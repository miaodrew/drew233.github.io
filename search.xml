<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>凌晨惊醒，一夜无眠</title>
      <link href="/2020/07/23/xswl/"/>
      <url>/2020/07/23/xswl/</url>
      
        <content type="html"><![CDATA[<div class="note warning"><p>本文可能不适合所有人群浏览。如果您患有心脏类疾病或胆子比较小，切勿点开</p></div><p>　　开始的时候是下着大雨，不知道我是在哪个地方，雨很大，我在一栋楼的往地下室走的楼梯上蹲着，窗户和门的声音也很大，亮度很低，仅能看到窗户附近的微弱的光，听到的是雨哗啦哗啦的声音。很害怕，挣扎着醒了过来，迷迷糊糊听到了还是在下雨，而且是很大的雨，以为是真的下雨了所以做了个噩梦，慢慢的清醒之后发现，只有梦里在下雨，这是个单纯的噩梦.</p><p>　　然而今夜的噩梦才刚刚开始。</p><p>　　雨停了，骑着我的电动车去了一个地方，类似于是驾校？遇到了一个女生，记不清楚是为什么了，说想跟我一起去玩。我就支开了自己所有朋友准备去跟她玩。然后发现她不是一个人，跟她一起的有四个左右的大汉。在之前闲聊的时候就听说，在这可能会有人把你骗到一个地方进行实验Or虐待，看到这几个大汉的时候我突然反应了过来，但是人很少，朋友们也在比较远的地方，直接跑肯定是不行的。还在我想着怎么自救的时候，四个大汉已经过来把我按在了地上。我一直在反抗，用尽剩余所有的力气往朋友在的那个方向喊道：“报警救我”。我敢确信他们是听到了的，因为喊完之后他们一同看向了我，但是面无表情。周围其他的人听到了我的呼救也毫无反应。终于，我还是被带走一个小黑屋里（是一个厕所），反正只有一个窗户，窗户外面是草地。他们开始虐待我，各种虐待。过程中我还一直很配合他们，甚至还觉得自己的小聪明给自己带来了很多机会。</p><p>　　等他们虐待完之后，我的所有衣服都被脱了下来，他们把我连带着我的衣服一同从窗户扔了下去。</p><p>　　当我再次醒来的时候，是赤裸的躺在一片草地里面。身下一摸是一件上衣，但不是我的。磕磕绊绊的我找到了我的上衣和内裤，唯独裤子怎么都找不到。突然周围的情况明朗了起来，我这是在我的高中的校园里面，现在正在进行高考，紧挨着窗户的那片草地拉上了隔离带。我想我的衣服可能在那里面吧。但是我进去找了找发现并没有。</p><p>　　这个时候我妈突然出现，我开始向她哭诉自己受了多少委屈，哭诉为什么我的朋友们连帮我报警都不愿意。然后继续找我的衣服，车钥匙，眼镜。可是无论怎么找都找不到了，我妈走过来跟我说，衣裳找不到就算了，回家换新的。我说还有眼镜和车钥匙没找到呢。我妈说，眼镜换个新的直接，车钥匙就在电车上插着呢。虽然我很纳闷为什么我的车钥匙竟然回到了车上，不过还是准备跟我妈走了。</p><p>　　这时候又开始下雨，我跟我妈打着伞往校门口走。但是一同走向了厕所，这个厕所里面男女厕所的认可像是迷宫一样，我上厕所的时候听到有人反锁厕所门的声音，吓得我准备跳窗户才发现这个厕所至少在三楼，没有办法回去发现是自己太害怕了，不会有人再抓我了。后来除了厕所还跟我妈说，完了，以后对厕所都有阴影了。</p><p>　　校门口的人很多，大家都在排队，这时候我妈对我说你手上怎么了。我看到自己手脖上挂着白天在驾校跟大家一起做的柳叶环，但是胳膊上手面上长满了植物，有花还有草。而且不是粘上去了，是扎根在里面了。我妈说没事，咱们直接去医院咋都给他看好。突然右边出来一个老奶奶，指着自己手上的草说，这是正常现象，不用慌。慢慢的我看到自己手上的植物都慢慢枯萎了，也就没那么害怕了。</p><p>　　我妈骑着电车带我回家，走着走着我发现这不是我回家的路啊，我赶紧跳下车，我妈停下来问我怎么了，我说这不是咱回家的路吧。她说，咱先去串个门，我不信，我说，你也不是俺妈吧？她笑了，我赶紧往回跑，路上人很多，她跑着追上来，慢慢的她快要追上我了，我一回头却没人了。<br>　　至此，惊醒。梦中的一切都是那么的不真实，但是现在仔细回想一下，逻辑又有点点严谨。</p><p>　　以上描述的为我今晚所做的噩梦大致意思，突然做了噩梦，还是这么恐怖的那种，描述出来可能没那么可怕，回想这个梦的时候我被吓哭了。不过这也只是个梦。<br>　　冷静下来想了想，为什么会做噩梦。应该是最近这段时间赶得太紧了吧。多校训练，协会大二训练，每周的组织一次积分赛，又报考了驾照，每天都很疲惫，一定要撑过去啊。</p><p>　　我一个队友今晚脱单，祝贺！（也就亿点点酸吧）</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Domjudge的安装与使用</title>
      <link href="/2020/07/05/domjudge/"/>
      <url>/2020/07/05/domjudge/</url>
      
        <content type="html"><![CDATA[<div class="note link green"><p>本文参考与：<a href="https://github.com/cn-xcpc-tools/cn-xcpc-docs" target="_blank" rel="noopener">https://github.com/cn-xcpc-tools/cn-xcpc-docs</a> <br> domjudge官网：<a href="https://www.domjudge.org/" target="_blank" rel="noopener">https://www.domjudge.org/</a></p></div><div class="note bug blue"><p>配置：<br> 1. Huawei cloud学生机 Ubuntu18.04<br> 2. domjudge v7.1.1</p></div><p>注：本篇文章的目的主要是记录自己的搭建过程（其实就是傻瓜式的跟着做的），在此同时帮助到可能能帮助到的小伙伴。并不是严格的教程向文章。</p><p>简单的使用domjudge需要安装两部分，一部分是Domserver，就是网页部分，另一部分是judgehost，即判题机。</p><h2 id="Domserver"><a href="#Domserver" class="headerlink" title="Domserver"></a>Domserver</h2><h3 id="安装依赖包和功能"><a href="#安装依赖包和功能" class="headerlink" title="安装依赖包和功能"></a>安装依赖包和功能</h3><p>远程连接到服务器后首先安装依赖包和功能,一步步执行，<br>安装时选择 <code>apache2</code></p><pre><code>sudo apt-get upgrade &amp;&amp; sudo apt-get updatesudo apt install gcc g++ make zip unzip mariadb-server \        apache2 php php-cli libapache2-mod-php php-zip \        php-gd php-curl php-mysql php-json php-xml php-intl php-mbstring \        acl bsdmainutils ntp phpmyadmin python-pygments \        libcgroup-dev linuxdoc-tools linuxdoc-tools-text \        groff texlive-latex-recommended texlive-latex-extra \        texlive-fonts-recommended texlive-lang-european composersudo apt install libcurl4-gnutls-dev libjsoncpp-dev libmagic-devsudo phpenmod json</code></pre><h3 id="编译domjudge"><a href="#编译domjudge" class="headerlink" title="编译domjudge"></a>编译domjudge</h3><pre><code>wget https://www.domjudge.org/releases/domjudge-7.1.1.tar.gz</code></pre><p>不知名原因导致下载速度感人，本地下载后通过ftp传到服务器里面，下载好之后解压配置编译安装即可。</p><pre><code>tar -zxvf domjudge-7.1.1.tar.gzcd domjudge-7.1.1./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1make domserver &amp;&amp; sudo make install-domservermake docs &amp;&amp; sudo make install-docs</code></pre><p><code>./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1</code>执行这一步时遇到权限问题，按照报错提示在后面添加指定内容成功解决。</p><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><pre><code>cd /opt/domjudge/domserversudo bin/dj_setup_database -u root install</code></pre><h3 id="配置-Web-服务器"><a href="#配置-Web-服务器" class="headerlink" title="配置 Web 服务器"></a>配置 Web 服务器</h3><pre><code>cd /opt/domjudge/domserversudo ln -s /opt/domjudge/domserver/etc/apache.conf /etc/apache2/conf-available/domjudge.confsudo a2enmod rewritesudo a2enconf domjudgesudo systemctl reload apache2sudo chown www-data:www-data -R /opt/domjudge/domserver/webapp/var/*</code></pre><p>到这一步的时候如果没有出错，那么已经可以通过服务器的公网ip（ip/domjudge）查看domjudge了。<br>默认用户名为<code>admin</code>，密码生成在<code>/opt/domjudge/domserver/etc/initial_admin_password.secret</code>中，以后可以修改</p><h3 id="配置-MySQL"><a href="#配置-MySQL" class="headerlink" title="配置 MySQL"></a>配置 MySQL</h3><p>编辑<code>/etc/mysql/conf.d/mysql.cnf</code>，在里面添加</p><pre><code>[mysqld]max_connections = 1000max_allowed_packet = 16MBinnodb_log_file_size = 48MB</code></pre><p>其中<code>max_allowed_packet</code>数值改成两倍于题目测试数据文件的大小，<code>innodb_log_file_size</code> 数值改成十倍于题目测试数据文件的大小。<br>若使用的是 mariadb，则 <code>/etc/mysql/mariadb.conf.d/50-server.cnf</code>中 <code>max_allowed_packet</code> 一项也需要修改。(但是我用的不是)</p><p>然后重启mysql</p><pre><code>sudo systemctl restart mysql</code></pre><h3 id="配置PHP"><a href="#配置PHP" class="headerlink" title="配置PHP"></a>配置PHP</h3><p>编辑 <code>/opt/domjudge/domserver/etc/apache.conf</code>，取消以下几行内容前的注释：(在vim中直接输入/+内容就可以查找)</p><pre><code>&lt;IfModule mod_php7.c&gt;php_value max_file_uploads      100php_value upload_max_filesize   128Mphp_value post_max_size         128Mphp_value memory_limit          512M&lt;/IfModule&gt;</code></pre><p>编辑 <code>/etc/php/7.2/apache2/php.ini</code>，搜索 <code>date.timezone</code> 关键字，取消其行前注释，并将其值设为 <code>Asia/Shanghai</code>。搜索 <code>max_execution_time</code> 关键字，将其值由30改为300，防止生成队伍密码时 PHP 执行超时。</p><p>然后重启PHP</p><pre><code>sudo systemctl restart apache2</code></pre><h3 id="配置-Apache"><a href="#配置-Apache" class="headerlink" title="配置 Apache"></a>配置 Apache</h3><p>编辑 <code>/etc/apache2/apache2.conf</code>，搜索 <code>KeepAlive</code> 关键字，将其值设为 <code>Off</code>，并在其后新增一行内容：</p><pre><code>MaxClients 1000</code></pre><p>然后重启Apache</p><pre><code>sudo systemctl restart apache2</code></pre><p>到这里，Domserver就设置完成了，关于domjudge的使用下面统一再说。接下来总结一下judgehost的搭建</p><h2 id="Judgehost"><a href="#Judgehost" class="headerlink" title="Judgehost"></a>Judgehost</h2><p>本着节约资源的理念（穷），domserver和judgeserver我都用在这个服务器上</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><pre><code>sudo apt install make sudo debootstrap libcgroup-dev lsof \        php-cli php-curl php-json php-xml php-zip procps \        gcc g++ openjdk-8-jre-headless \        openjdk-8-jdk ghc fp-compiler \        libcurl4-gnutls-dev libjsoncpp-dev libmagic-dev</code></pre><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><pre><code>cd domjudge-7.1.1./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1make judgehost &amp;&amp; sudo make install-judgehost</code></pre><p>配置的命令跟上面安装domserver的时候一样，按照报错信息操作即可。<br>这会将 judgehost 安装在 <code>/opt/domjudge/judgehost</code> 里。<br>(<code>make install-judgehost</code>会提示找不到 <code>etc/restapi.secret</code> ，可忽略，会在下面进行配置)</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code>useradd -d /nonexistent -U -M -s /bin/false domjudge-run</code></pre><p>我只添加了一个判题机。有更多的需求的可以去本文开头提到的GitHub库中查看相关操作。</p><h3 id="配置-sudoers"><a href="#配置-sudoers" class="headerlink" title="配置 sudoers"></a>配置 sudoers</h3><p>将 <code>/opt/domjudge/judgehost/etc/sudoers-domjudge</code> 复制到 <code>/etc/sudoers.d/</code> 目录下。</p><pre><code>sudo cp /opt/domjudge/judgehost/etc/sudoers-domjudge /etc/sudoers.d/</code></pre><h3 id="修改-rest-密码"><a href="#修改-rest-密码" class="headerlink" title="修改 rest 密码"></a>修改 rest 密码</h3><p>使用 vim 等文本编辑器编辑 <code>/opt/domjudge/judgehost</code> 目录下 <code>etc/restapi.secret</code> 这个文件。文件的格式为：</p><pre><code>default http://example.edu/domjudge/api/  judgehosts  MzfJYWF5agSlUfmiGEy5mgkfqU</code></pre><p>格式为 endpoint api_url username password ，endpoint 可以保持不变，api_url 根据 judgeserver 的地址进行修改，username 和 password 要与 judgeserver 上的 <code>etc/restapi.secret</code> 保持一致。<br>(这一步我没找到judgeserver，应该就是让看的domserver吧，写成一样的就行了)</p><h3 id="构建-chroot-环境"><a href="#构建-chroot-环境" class="headerlink" title="构建 chroot 环境"></a>构建 chroot 环境</h3><p>使用 vim 等文本编辑器编辑 ~/domjudge/judgehost/bin/dj_make_chroot 脚本，将 ubuntu 镜像改为国内源。（第 172 行）</p><pre><code># Ubuntu mirror, modify to match closest mirror[ -z &quot;$DEBMIRROR&quot; ] &amp;&amp; DEBMIRROR=&quot;http://mirrors.aliyun.com/ubuntu/&quot;</code></pre><p>修改之后保存并运行此脚本(bash 运行)。这一步会从源上下载必要的软件包，所以请耐心等待。</p><h3 id="设置cgroup"><a href="#设置cgroup" class="headerlink" title="设置cgroup"></a>设置cgroup</h3><p>使用 vim 等文本编辑器编辑 <code>/etc/default/grub</code> 这个文件，对其中的这一行做如下修改：</p><pre><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet cgroup_enable=memory swapaccount=1&quot;</code></pre><p>然后执行：<code>update-grub</code><br>之后重启服务器</p><h3 id="启动judgehost"><a href="#启动judgehost" class="headerlink" title="启动judgehost"></a>启动judgehost</h3><pre><code>bash /opt/domjudge/judgehost/bin/create_cgroups/opt/domjudge/judgehost/bin/judgedaemon</code></pre><p>即可启动。若提示 <code>error: Call to undefined function curl_init()</code>，则可以安装 php-curl 解决</p><p>如果没有问题，看到的会是这样的页面<br><a href="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1593959944188.png" data-fancybox="images" data-caption="1593959944188.png" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1593959944188.png" class="img-shadow img-margin"></center></a><br>大概意思就是，判题机已启动，队列中没有提交</p><p>到这里judgehost就安装好了</p><p>如果想要断开连接并且还可以正常使用判题机，这样来</p><pre><code>bash /opt/domjudge/judgehost/bin/create_cgroupsnohup /opt/domjudge/judgehost/bin/judgedaemon &amp;</code></pre><p>退出连接的时候记得用<code>exit</code>，不要直接关闭</p><p>到这里，domjudge就可以正常投入使用了。</p><h2 id="Domjudge的使用"><a href="#Domjudge的使用" class="headerlink" title="Domjudge的使用"></a>Domjudge的使用</h2><p>一切都还在摸索</p><p>Loading~~~</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domjudge </tag>
            
            <tag> training </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J - Factorial Products UCF Local Programming Contest 2014</title>
      <link href="/2020/06/01/UCF2014/"/>
      <url>/2020/06/01/UCF2014/</url>
      
        <content type="html"><![CDATA[<h1 id="Factorial-Products"><a href="#Factorial-Products" class="headerlink" title="Factorial Products"></a>Factorial Products</h1><div class="note link green"><p>Link: <a href="https://www.jisuanke.com/contest/10147/559071" target="_blank" rel="noopener">https://www.jisuanke.com/contest/10147/559071</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>Factorial is just a game of multiplications. Formally, it can be defined as a recurrence relation:</p><p>Fact (0) = 1 </p><p>Fact (n) = n * Fact(n-1), for all integers n &gt; 0</p><p>This problem is all about multiplications, more and more multiplications. It is a game of multiplications of factorials.</p><p>The Problem:<br>You will be given three lists of numbers: A, B and C. You have to take the factorials of all the numbers in each list and multiply them to get ProFact(A), ProFact(B), ProFact(C). Then report which product is the largest.</p><p>For example, consider the lists A = {2, 4, 7}, B = {0, 1, 9} and C = {2, 3, 5, 5}. Then,</p><p>ProFact(A) = 2! <em> 4! </em> 7! = 241, 920<br>ProFact(B) = 0! <em> 1! </em> 9! = 362, 880<br>ProFact(C) = 2! <em> 3! </em> 5! * 5! = 172,800</p><p>So, the largest product for this example is ProFact(B).</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>The first input line contains a positive integer, n, indicating the number of test cases. Each test case consists of four input lines. The first line consists of three positive integers providing, respectively, the size for the lists A, B and C. The last three lines contain, respectively, the elements (non-negative integers) in lists A, B and C.</p><p>All the values in the input file will be less than 2,501.</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>For each test case, output “Case #t: h” in a line, where t is the case number (starting with 1) and h is the list name with the highest product. If two or three lists are tied for the highest product, print “TIE”. Follow the format illustrated in Sample Output. Assume that, if the pairwise product values differ, then the relative difference of these products will differ by at least 0.01% of the largest product.</p><p>样例输入<br>3<br>3 3 4<br>2 4 7<br>0 1 9<br>2 3 5 5<br>2 2 2<br>2 3<br>3 2<br>2 2<br>3 3 3<br>1 3 5<br>2 4 6<br>1 4 7<br>样例输出<br>Case #1: B<br>Case #2: TIE<br>Case #3: C</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思很好理解，就是给你三组数，让你比较哪组数里面所有数的阶乘和最大。保证数据小于2500。<br>阶乘是一个很大的数，如果直接暴力计算肯定是存不下的。所以我们取一个对数，因为我们只需要比较大小，不需要进一步计算。<br>因为<script type="math/tex">\log (a \times b)=\log a+\log b</script>,并且数据最大也就2500，所以我们首先可以通过递推预处理出每一个值的阶乘所对应的对数。然后后面的相乘也直接对数相加即可。<br>因为精度问题，题目中也说到了，所以我们比较大小的时候不能直接用等于判断（WA死我了），看两个数是否相等我们只需要看他们的差和1e-6的大小关系即可~</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 3e3+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;const double ohuo = 1e-6;int d[4][2]={1,0,0,1,-1,0,0,-1};long double fac[maxn];int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    fac[1]=0;    for(int i=2;i&lt;=2510;i++){        fac[i]=fac[i-1]+log(i);        // cout&lt;&lt;fac[i]&lt;&lt;endl;    }//预处理    int t,a,b,c,mid;    cin&gt;&gt;t;    for(int ca=1;ca&lt;=t;ca++){        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        double x=0,y=0,z=0;        while(a--){            cin&gt;&gt;mid;            x+=fac[mid];        }        while(b--){            cin&gt;&gt;mid;            y+=fac[mid];        }        while(c--){            cin&gt;&gt;mid;            z+=fac[mid];        }        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;ca&lt;&lt;&quot;: &quot;;        if(x-y&gt;ohuo&amp;&amp;x-z&gt;ohuo){            cout&lt;&lt;&quot;A&quot;;        }        else if(y-x&gt;ohuo&amp;&amp;y-z&gt;ohuo){            cout&lt;&lt;&quot;B&quot;;        }        else if(z-y&gt;ohuo&amp;&amp;z-x&gt;ohuo){            cout&lt;&lt;&quot;C&quot;;        }        else{            cout&lt;&lt;&quot;TIE&quot;;        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于我的视线，谈谈我对现在网络环境的一些看法</title>
      <link href="/2020/05/17/licenses/"/>
      <url>/2020/05/17/licenses/</url>
      
        <content type="html"><![CDATA[<p>构思的时候想法很多，到了真正下手的时候却又不知道从何说起。本文仅代表个人观点，杠精勿扰。</p><p>从一开始维护自己的个人博客，到后来的各种转大佬博客。总能看到一些博客写的满满的版权声明，免责声明等等等等。甚至有的还会在博客一个地方写上自己引用的所有图片的出处。那时候什么都不懂，觉得挺高大上的，想给自己加上但是又不知道怎么写。现在不一样了，现在什么都还是不懂，但是已经不想加了。</p><div class="note warning"><p>我为什么不用CSDN或者博客园？</p></div><p>不得不说，在百度权重，收录这方面，CSDN和博客园做的是真棒，当然还有简书等，不再一一列举。下图为例<br><a href="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1589716643218.webp" data-fancybox="images" data-caption="1589716643218.webp" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1589716643218.webp" class="img-shadow img-margin"></center></a><br></p><p class="p center small">图为某次cf题解我被CSDN和博客园夹在中间</p><p></p><p>倒也不是说我写的文章质量比他们的都高很多，只不过是我不信只有我一个个人博客的用户写了这篇题解。而国内大部分用户还是用的百度，这就很🚗🥚了。</p><p>还有就是博客园和CSDN的“原创”，不是说所有原创都有问题，但是每当我搜一个东西，好，搜了一下，基本是这俩，点开排名第一的，嗯，说的不错，但是没解决我的问题，往下看看吧，第二个，这不跟第一个一样吗？往下看，大部分都是一个板子出来的，而且更有甚者直接是粘贴过来的，格式，链接，全都不变就过来了。还有某些采集站，点进去，代码都不全。</p><p>前段时间参加了腾讯粑粑的原创作者分享计划，一开始还没什么，后来三天内爬了我一百五十多篇文章，爬倒是挺好的，我们也是互惠。很神奇的是腾讯云那的文章不论是百度还是谷歌，排名碾压我（就算按先来后到也不是这样吧），不过毕竟是自己的文章，这也是好事。但是就这一爬，第二天我就看到了采集站上源自我博客的文章。我向腾讯云的技术人员询问，得到的答复是，腾讯云专栏的文章不会被爬走，除非采集站的人手动粘贴复制。哦，一个采集站的，还手动粘贴复制，我信。那个采集站，我找到了站长的联系方式，让他修改原出处，他回应的也不错，直接将文章删除了。</p><p>确实，我的博客下面写着<code>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</code>。我们看一下这个协议的内容<br></p><p class="p center">这是一份普通人可以理解的许可协议概要 (但不是替代) 。 免责声明.</p><p></p><p class="p center">您可以自由地：</p><p class="p center">共享 — 在任何媒介以任何形式复制、发行本作品</p><p class="p center">演绎 — 修改、转换或以本作品为基础进行创作</p><p class="p center">只要你遵守许可协议条款，许可人就无法收回你的这些权利。</p><p>对，这个协议我许可。但是那些个直接cv“转载”就放到网络上的，个人认为实在是污染环境。但是我没办法啊，我也改过一段时间，必须联系我获得许可才能转载，后来还是算了。毕竟有很多小伙伴的转载方式我很爱，而且也没哪个采集站会闲的没事爬我这个小站的文章。<br>你转载的时候加上自己的使用心得或者自己的看发，这才是允许转载的原意，而不是照搬。（某些类型除外，此处指小说等文章。</p><p>说完了博客，在说说开源这件事。<br>刚开始接触博客，就接触到了GitHub，GitHub 是一个面向开源及私有软件项目的托管平台。其上的开源软件，代码数不胜数。<br>就拿我的博客框架<code>Hexo</code>来说，这个框架真的没话说，好用。但是每个由他为框架的博客页脚会默认存在一个<code>Powered by Hexo</code>然后一个超链接到它的GitHub库/官网。<br>在我刚使用博客的时候，什么都不懂的时候，觉得这个很难看，费尽吃奶的劲也想给删掉它，如我所愿，网上的教程数不胜数。<br>后来，慢慢的，我接触的越多，换了个主题，将页脚的Hexo和主题字段都保留了下来，即使现在我已经学会了如何去删掉他们。<br>我专门看了一下Hexo的开源许可证，它采用的是<code>MIT</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1589718059881.webp" data-fancybox="images" data-caption="1589718059881.webp" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1589718059881.webp" class="img-shadow img-margin"></center></a><br>确实没有专门说关于这个标识，甚至hexo还是某些主题似乎还内置了配置项用来取消这个标识。确实，这些开源的代码都允许你随意修改使用，但是，作者尽心尽力的开发的东西，放个类似于logo的东西，你都不允许它的存在，引流是一方面。个人认为这也会减弱开发者的创作热情。<br>所以，我现在自豪的在页脚加上了<code>Powered by Hexo</code>和<code>Theme Sakura  by Mashiro&amp;Hojun</code></p><p>当然，这也不是大家必须做的。</p><div class="note quote"><p>开源软件（英语：open source software，缩写：OSS）又称开放源代码软件，是一种源代码可以任意获取的计算机软件，这种软件的著作权持有人在软件协议的规定之下保留一部分权利并允许用户学习、修改以及以任何目的向任何人分发该软件。</p></div><p>我只觉得，即使是开源软件，用着别人做的，不是非得要有感恩的心，那太扯了，但是起码有那么一点点的感谢或者是尊重，而不是说拿过来代码，人家的声明一删就自己用。</p><p>再次重申，以上仅为个人观点，不论对错。如果你不喜欢我说的话，且当我一人在胡言乱语吧。</p><p>反正我是不会很多的去使用csdn，博客园还挺好，csdn我真的没话说。我也不需要他们为我引流，就做个小站站长，有人需要了解什么只有我这有的东西让他能搜到我就行。安安静静的做个咸鱼，守住自己的这片“净土”。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lisense </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团结就是力量</title>
      <link href="/2020/05/14/nowcoder14411/"/>
      <url>/2020/05/14/nowcoder14411/</url>
      
        <content type="html"><![CDATA[<h1 id="团结就是力量"><a href="#团结就是力量" class="headerlink" title="团结就是力量"></a>团结就是力量</h1><div class="note link green"><p>Link: <a href="https://ac.nowcoder.com/acm/problem/14411" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/14411</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>从小老师就教育我们，一根筷子容易折断，而一捆筷子不容易折断。<br>因为要出战世界杯，我们需要考虑派一只队伍出战，而我们希望出战的队伍的团结力最大。<br>而一个队伍的团结力取决于每个人的性格，每个人都有一个性格基因【（由字符串表示），比如小明的性格基因为：abbcde】，性格基因的排列方式是可以通过一个人的后天培养而改变的，其改变方式就是类似于循环，【小明的性格基因为：abbcde，他可以变成：bbcdea，bcdeab，cdeabb，deabbc，eabbcd】 。<br>一个队伍中如果最多有x个人的性格基因可以完全相等的话，那么这个队伍的团结力就是x。<br>比如一个队伍有五个人：<br>小明：abbcde<br>小红：bbcdea<br>大明：cdeabb<br>大红：efg<br>小紫：fge<br>明显小明小红和大明的性格基因可以变成相等的，大红和小紫的性格基因可以变成相等的， 这个最多有3个人的性格基因可以完全相等的，所以这个五人队伍的团结力就是3；</p><p>现在已知可以出战的人数为n个，每个人都有一个性格基因字符串，而作为一只队伍出战的话，需要队伍中的每个人都互相达成共识。同时也已知m个信息，每个信息是：<br>a想要和b一起出战【注意，这里只是a的一厢情愿】，只有当a想要和b一起出战，并且b也想要和a一起出战的时候，两个人才能一起出战。想要一起出战是可以具有传递性的，比如a想要和b一起出战，b想要和c一起出战的话，那么a也可以想要和c一起出战。</p><p>我们肯定希望派出的队伍的团结力最大，请计算出这个最大团结力。  </p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>本题包含多组数据，第一行输入两个数字n，m，分别表示一共有n个人，以及m个出战信息 。<br>接下来n行，每行输入一个字符串，表示每个人的性格基因。<br>再接下来m行，每行两个编号x，y，表示x想要和y出战<br>数据范围：<br>5&lt;=n&lt;=100000<br>1&lt;=m&lt;=100000<br>1&lt;=x,y&lt;=n<br>每个数据的字符串长度和不超过100000</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>每组数据输出一行，表示最大团结力。</p><p>示例1<br>输入<br>5 5<br>abbcde<br>bbcdea<br>cdeabb<br>efg<br>fge<br>1 2<br>2 3<br>3 4<br>4 5<br>5 1<br>6 7<br>abbcde<br>bbcdea<br>cdeabb<br>efg<br>fge<br>gef<br>1 2<br>2 3<br>3 1<br>4 5<br>5 6<br>6 4<br>2 4<br>输出<br>3<br>3<br>说明<br>第一个样例题干中有所描述。这里1想和2出战，2想和3出战，3想和4出战，4想和5出战，5又想和1出战，那么就相当于每个人都想要互相一起出战，所以这就是一个队伍。<br>第二个样例中，123号三个人是一个队伍，456号是一个队伍，虽然2想和4一起出战，但是已知m条信息中，不能构成4想和2出战的信息出来，所以六个人不能变成一个队伍。</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思就是给你一些人，告诉你单向选择的结果，并且a选b，b选c，等于a选c。每个人都有一个字符串，可以以循环的方式随意变换。每组成员的团结力就是字符串相等的个数（任意变换后）。当且仅当两个人互相选了才可以成组。</p><p>首先解决分组的问题，直接用tarjan缩点就可以了。<br>然后就是团结力的问题了，我们可以给每个字符串设定一个规则，将每个字符串以里面字典序最小的元素做开头，作为变换的终点。然后统计相同组相同字符串的个数即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pair#define mem(name,val) memset(name,val,sizeof(name));const int maxn = 1e5+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int d[4][2]={1,0,0,1,-1,0,0,-1},n,m;string s[maxn];vector&lt;int&gt; g[maxn];vector&lt;string&gt; final[maxn];int dfn[maxn],color[maxn],low[maxn],cnt,top,sta[maxn],vis[maxn],scc;void init(){    for(int i=0;i&lt;=n;i++)   g[i].clear(),final[i].clear();    mem(dfn,0);mem(low,0);mem(sta,0);mem(vis,0);mem(color,0);    top=scc=0;    cnt=1;}void dfs(int u){    vis[u]=1;    low[u]=dfn[u]=cnt++;    sta[++top]=u;    for(auto v:g[u]){        if(vis[v]==0)   dfs(v);        if(vis[v]==1)   low[u]=min(low[u],low[v]);    }    if(dfn[u]==low[u]){        scc++;        do{            low[sta[top]]=scc;            color[sta[top]]=scc;            vis[sta[top]]=-1;        }        while(sta[top--]!=u);    }}int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    while(cin&gt;&gt;n&gt;&gt;m){        init();        for(int i=1;i&lt;=n;i++){            string ss;            cin&gt;&gt;ss;            int l=ss.size(),pos=0;char begin=ss[0];            for(int j=1;j&lt;l;j++){                if(ss[j]&lt;=begin){                    pos=j;                    begin=ss[j];                }            }            string mid=&quot;&quot;;            for(int j=pos,tot=0;tot&lt;l;j++,tot++){                mid+=ss[j%l];            }            ss=mid;            s[i]=mid;        }        for(int i=1,x,y;i&lt;=m;i++){            cin&gt;&gt;x&gt;&gt;y;            g[x].pb(y);        }        for(int i=1;i&lt;=n;i++){            if(!dfn[i]){                dfs(i);            }        }        for(int i=1;i&lt;=n;i++){            final[color[i]].pb(s[i]);        }        int ans=0;        for(int i=1;i&lt;=scc;i++){            map&lt;string,int&gt; ma;             for(auto j:final[i]){                ma[j]++;            }            for(auto ohuo:ma){                ans=max(ans,ohuo.second);            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nowcoder </tag>
            
            <tag> tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Picgo上传到GitHub莫名其妙的出错后，我选择自己实现上传功能</title>
      <link href="/2020/05/14/88picgo/"/>
      <url>/2020/05/14/88picgo/</url>
      
        <content type="html"><![CDATA[<div class="note guide blue"><p>使用GitHub做图床之后，上传是个比较麻烦的事。picgo是第一选择，但是最近不知道是什么原因，总是会莫名其妙的出错，在网上也搜不到任何解决方案，似乎官方给的回应就是GitHub的原因。那自然也是我无法干涉解决的了，所以还是自己来吧。自己动手丰衣足食</p></div><p>正好前两天在nb学长的帮助教育下用过GitHub上传文件的api，所以用起来也是轻车熟路了。<br>这不是教程，只是给出一个参考。另外，picgo很好用，就是我用不好。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>我引用了<code>jquery</code></p><pre><code class="lang-html">&lt;script src=&quot;https://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>首先要有一个可以上传文件的按钮（或者其他之类的）</p><pre><code class="lang-html">&lt;input type=&quot;file&quot; accept=&quot;image/png,image/gif,image/jpeg&quot;&gt;</code></pre><p>accept里面填入的就是选择文件的时候可选的格式，如果不填默认所有都可以</p><p>但是这个按钮的样式，不是怎么好看，所以可以改成这样</p><pre><code class="lang-html">&lt;div style=&quot;font-size: 30px;display: inline; cursor: pointer&quot; onclick=&quot;myimg.click()&quot;&gt;🚢&lt;/div&gt;&lt;input type=&quot;file&quot; id=&quot;myimg&quot; style=&quot;visibility: hidden;&quot; accept=&quot;image/png,image/gif,image/jpeg&quot;&gt;</code></pre><p>先把这个文件选择的按钮通过<code>visibility: hidden;</code>隐藏起来，然后通过另一个元素的<code>onclick</code>事件模拟点击了选择文件的按钮，这样就会很好看。🚢这个你可以随意更换为你想要的。</p><p>选择文件的弄好了，接着就是上传了。<br>GitHub的api说必须将文件转换成base64编码的格式才支持上传，所以我们首先要把选择的图片转换为base64编码的形式，然后直接调用api上传既可。<br>但是base64我们还得处理一下，因为转换出来的前面会带着data一些属性，用正则（nb学长帮我搞的）直接把前面的去掉，然后用substring获得图片本来的格式。<br>这里我是用时间戳重命名图片的，很随意，如果你要用别的也可以</p><pre><code class="lang-JavaScript">function uploadimg(file){      var timestamp=new Date().getTime();//获取时间戳      var nameofimg=timestamp+&quot;.&quot;+houzhui;//以事件戳重命名      var picurl=&quot;https://cdn.jsdelivr.net/gh/“GitHub用户名”/“GitHub存放图片的仓库名”/&quot;+nameofimg;    var settings = {    &quot;url&quot;: &quot;https://api.github.com/repos/“GitHub用户名”/“GitHub存放图片的仓库名”/contents/&quot;+nameofimg,    &quot;method&quot;: &quot;PUT&quot;,    &quot;timeout&quot;: 0,    &quot;headers&quot;: {        &quot;Authorization&quot;: &quot;Bearer “你的GitHub具有读写功能的token（怎么弄？百度去）”&quot;,        &quot;Content-Type&quot;: &quot;text/plain&quot;    },    &quot;data&quot;: &quot;{\r\n  \&quot;message\&quot;: \&quot;upload\&quot;,\r\n  \&quot;content\&quot;: \&quot;&quot;+ file +&quot;\&quot;\r\n}&quot;,    };    $.ajax(settings).done(function (response) {        imgurlmd=&quot;Markdown:![](&quot;+picurl+&quot;)&quot;;//markdown格式的链接        url=&quot;Imgurl:&quot;+picurl;//图片原链接        my=&quot;My:{% fb_img "+picurl+"  "+nameofimg+" %}&quot;;//自定义的格式，这里是我的自定义        var final=&quot;&lt;li&gt;&quot;+imgurlmd+&quot;&lt;/li&gt;&quot;+&quot;&lt;li&gt;&quot;+url+&quot;&lt;/li&gt;&quot;+&quot;&lt;li&gt;&quot;+my+&quot;&lt;/li&gt;&quot;;        document.getElementById(&quot;neirong&quot;).innerHTML=final;//写道html里面    });}function imgChange(img) {    const reader = new FileReader();    reader.onload = function (ev) {        var imgFile =ev.target.result;//imgFile就是图片的base64编码        base64url=imgFile.replace(/(.*)?,/,&#39;&#39;);//用正则消除前面的data之类的字符        // console.log(imgFile);        houzhui = imgFile.substring( imgFile.indexOf(&quot;/&quot;) + 1, imgFile.indexOf(&quot;;&quot;) );//获取图片原本的格式        uploadimg(base64url);//上传    }    reader.readAsDataURL(img.files[0]);}</code></pre><p>以上代码中用<code>“”</code>包含的都是你自己的信息</p><p>上传的代码有了，再将上传代码的函数和选择文件弄在一起，然后为返回的链接找一个位置就好了</p><pre><code class="lang-html">&lt;div style=&quot;font-size: 30px;display: inline; cursor: pointer&quot; onclick=&quot;myimg.click()&quot;&gt;🚢&lt;/div&gt;&lt;div id=&quot;neirong&quot;&gt;&lt;/div&gt;&lt;input type=&quot;file&quot; id=&quot;myimg&quot; onchange=&quot;imgChange(this)&quot; style=&quot;visibility: hidden;&quot; accept=&quot;image/png,image/gif,image/jpeg&quot;&gt;</code></pre><p>这样就可以了~关于html页面可以根据自己的需要进行美化</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="lang-html">&lt;script src=&quot;https://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;function uploadimg(file){      var timestamp=new Date().getTime();//获取时间戳      var nameofimg=timestamp+&quot;.&quot;+houzhui;//以事件戳重命名      var picurl=&quot;https://cdn.jsdelivr.net/gh/“GitHub用户名”/“GitHub存放图片的仓库名”/&quot;+nameofimg;    var settings = {    &quot;url&quot;: &quot;https://api.github.com/repos/“GitHub用户名”/“GitHub存放图片的仓库名”/contents/&quot;+nameofimg,    &quot;method&quot;: &quot;PUT&quot;,    &quot;timeout&quot;: 0,    &quot;headers&quot;: {        &quot;Authorization&quot;: &quot;Bearer “你的GitHub具有读写功能的token（怎么弄？百度去）”&quot;,        &quot;Content-Type&quot;: &quot;text/plain&quot;    },    &quot;data&quot;: &quot;{\r\n  \&quot;message\&quot;: \&quot;upload\&quot;,\r\n  \&quot;content\&quot;: \&quot;&quot;+ file +&quot;\&quot;\r\n}&quot;,    };    $.ajax(settings).done(function (response) {        imgurlmd=&quot;Markdown:![](&quot;+picurl+&quot;)&quot;;//markdown格式的链接        url=&quot;Imgurl:&quot;+picurl;//图片原链接        my=&quot;My:{% fb_img "+picurl+"  "+nameofimg+" %}&quot;;//自定义的格式，这里是我的自定义        var final=&quot;&lt;li&gt;&quot;+imgurlmd+&quot;&lt;/li&gt;&quot;+&quot;&lt;li&gt;&quot;+url+&quot;&lt;/li&gt;&quot;+&quot;&lt;li&gt;&quot;+my+&quot;&lt;/li&gt;&quot;;        document.getElementById(&quot;neirong&quot;).innerHTML=final;//写道html里面    });}function imgChange(img) {    const reader = new FileReader();    reader.onload = function (ev) {        var imgFile =ev.target.result;//imgFile就是图片的base64编码        base64url=imgFile.replace(/(.*)?,/,&#39;&#39;);//用正则消除前面的data之类的字符        // console.log(imgFile);        houzhui = imgFile.substring( imgFile.indexOf(&quot;/&quot;) + 1, imgFile.indexOf(&quot;;&quot;) );//获取图片原本的格式        uploadimg(base64url);//上传    }    reader.readAsDataURL(img.files[0]);}&lt;/script&gt;&lt;div style=&quot;font-size: 30px;display: inline; cursor: pointer&quot; onclick=&quot;myimg.click()&quot;&gt;🚢&lt;/div&gt;&lt;div id=&quot;neirong&quot;&gt;&lt;/div&gt;&lt;input type=&quot;file&quot; id=&quot;myimg&quot; onchange=&quot;imgChange(this)&quot; style=&quot;visibility: hidden;&quot; accept=&quot;image/png,image/gif,image/jpeg&quot;&gt;</code></pre><p>好了，这样就完成了自己写一个页面替代picgo的功能了。</p><h2 id="最后要说的话"><a href="#最后要说的话" class="headerlink" title="最后要说的话"></a>最后要说的话</h2><p>这个页面可以本地使用，并且推荐本地使用。<br>如果你想让别人跟你一起使用并且想要上传到GitHub pages的话，你需要将你的token换一种形式存在于代码中，比如说加密。然后再解密然后使用。即不能让你的token以明文形式存在，否则会被GitHub检测到然后删除你的这个token以至于上传api出现权限不足的报错。<br>本地自己用就没那么多事啦~</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> 图床 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COVID-19与我</title>
      <link href="/2020/05/14/COVID-19/"/>
      <url>/2020/05/14/COVID-19/</url>
      
        <content type="html"><![CDATA[<div class="note radiation red"><p>新型冠状病毒肺炎（Corona Virus Disease 2019，COVID-19），简称“新冠肺炎”，世界卫生组织命名为“2019冠状病毒病” ，是指2019新型冠状病毒感染导致的肺炎。2019年12月以来，湖北省武汉市部分医院陆续发现了多例有华南海鲜市场暴露史的不明原因肺炎病例，现已证实为2019新型冠状病毒感染引起的急性呼吸道传染病。—— 百度百科</p></div><p>就在疫情刚开始的那段时间，还没有很严重的时候还和我爸一起去我们这里新建的“古城”转悠了一圈（当然是戴着口罩的），那是年三十。</p><p>大年三十的晚上已过去，第二天就受到了各种通知，大概意思就是不让出去玩，不让走亲戚。只能在家呆着。这时疫情的严重性正在逐渐上升。那一段时间，街上基本都是空空的。然后就真的没有走亲戚，也没有出去玩。也忘了在家呆了有多久，到了该开学的时间，没有一个学校敢开学。不开学怎么办呢？在家上网课。</p><p>刚开始上网课的那段时间，一大堆的学习app占满了手机屏幕（直到现在还是。不过我现在也基本上没怎么上课，没怎么交作业。网课也太令人讨厌了。</p><p>其实说到COVID-19对我最大的影响之一，就是可能无法如期举行的ICPC，就如同一个赌徒，赌上了所有的钱，赌局失效了，庄家跑了那样子。亏得血本无归，是，搞算法也是为了充实自身，为以后打基础，但谁不想多拿几个奖？更何况对于我这种本来就没多少奖的蒟蒻玩家。在这里只能希望疫情早点结束，彻底地结束。现在很大的概率表面，我会被迫提前退役。</p><p>而且因为这个疫情，我们协会的下一届也受到了影响。无法面对面的讲课，无法知道每个同学的真实水平，很多很多的未知，不只是下一届，还有现在这一届，太多的不确定，导致管理方面极大的不易，其实也不能全怪疫情，也是我的管理能力太弱了。我可不想教练与学长苦苦经营了十多年的协会毁在我这一届，那就是千古罪人了啊。</p><p>这次<strong>寒假</strong>，放的时间应该是最长的了。二月十几号就该是开学的日子，直到今天开学还遥遥无期，每次都会有消息说下个月可能会开学，然后到了下个月就毫无消息，接着就是下一个下个月。毕竟学校同学密集，危险性是极高的。</p><p>呆在家的这段时间，随着爸妈的复工，我一个人在家的次数越来越多，他们忙没时间回来做饭，锻炼的我也会做饭了。这个必须夸自己一波。之前只会泡泡面，太磕碜了。</p><p class="p center">希望疫情早日过去，我们恢复正常生活</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> COVID-19 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加可实时发布的说说界面 | Artitalk.js</title>
      <link href="/2020/05/11/artitalk/"/>
      <url>/2020/05/11/artitalk/</url>
      
        <content type="html"><![CDATA[<div class="note quote"><p>Artitalk，前hexo-shuoshuo，重铸了一下，使用方法其实差不多，但是好多朋友都说看不太懂，所以再开（水）一篇文章介绍一下它的使用吧。注：本文只讲解简单使用。关于本js的详细介绍请移步文档：<a href="https://artitalk.js.org/" target="_blank" rel="noopener">https://artitalk.js.org/</a></p></div><h2 id="关于Leancloud"><a href="#关于Leancloud" class="headerlink" title="关于Leancloud"></a>关于Leancloud</h2><p>（这部分跟之前教程一样，如果你只是更新，直接跳到新建即可。<br>这里我们要求使用<a href="https://console.leancloud.app/login.html#/signup" target="_blank" rel="noopener">leancloud国际版</a>注册，因为国际版不需要绑定备案的域名<br>注册结束后首先找到账号设置，绑定邮箱和手机号。这一步是必须的，否则无法创建应用。邮箱和手机号都有临时的，所以也不难。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc1.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc1.webp" class="img-shadow img-margin"></center></a></p><p>绑定成功之后，点击创建应用，并将应用名字设置为<code>shuoshuo</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc2.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc2.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lcc2.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lcc2.webp" class="img-shadow img-margin"></center></a></p><p>创建之后点击应用跳转到控制台<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc3.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc3.webp" class="img-shadow img-margin"></center></a></p><p>在设置中找到应用keys中的<code>appId</code>和<code>appKey</code>记下来，或者页面一直开着。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc4.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc4.webp" class="img-shadow img-margin"></center></a></p><p>在<code>leancloud</code>的存储中添加<code>class</code>，命名为<code>shuoshuo</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc5.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc5.webp" class="img-shadow img-margin"></center></a></p><p>然后在你新建的应用中找到<code>结构化数据</code>下的<code>用户</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234538.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234538.webp" class="img-shadow img-margin"></center></a></p><p>然后点击<code>添加用户</code>，输入你想使用的<code>用户名</code>以及<code>密码</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234719.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234719.webp" class="img-shadow img-margin"></center></a></p><p>接着回到<code>结构化数据-&gt;shuoshuo-&gt;权限</code>，在<code>Class访问权限</code>中将<code>add_fields</code>以及<code>create</code>权限设置为指定用户，输入你刚才输入的用户名会自动匹配。为了安全起见，将<code>delete</code>和<code>update</code>也设置为跟它们一样的权限。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235209.webp" data-fancybox="images" data-caption="20200417235209" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235209.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235312.webp" data-fancybox="images" data-caption="20200417235312" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235312.webp" class="img-shadow img-margin"></center></a></p><p>最后将<code>_User</code>中的权限全部调为指定用户，或者数据创建者，为了保证不被篡改用户数据。</p><p>到这里<code>leancloud</code>的设置就告一段落了。</p><h2 id="新建说说界面"><a href="#新建说说界面" class="headerlink" title="新建说说界面"></a>新建说说界面</h2><ol><li>在<code>..\&#39;blogname&#39;\source</code>中新建一个文件夹，命名为<code>shuoshuo</code>（或者其它你想用的）</li><li>在刚才新建的文件夹中新建<code>index.md</code>，文件内容为</li></ol><pre><code class="lang-markdown">---title: 说说（或者其它你想用的）comments: false (如果你的博客中使用了valine作为评论系统，这一句一定要加上，否则会出错)---&lt;script src=&quot;https://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;body&gt;    &lt;script&gt;    var img=&quot;&quot;;    var appID=&quot;&quot;;    var appKEY=&quot;&quot;;    var per=&quot;&quot;;    var username=&quot;&quot;;    &lt;/script&gt;    &lt;div id=&quot;lazy&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;artitalk&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/artitalk&quot;&gt;&lt;/script&gt; //调用artitalk&lt;/body&gt;</code></pre><p>关于配置项的说明<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200511095805.png" data-fancybox="images" data-caption="20200511095805" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200511095805.png" class="img-shadow img-margin"></center></a></p><p>这样你再<code>hexo g</code>之后<strong>应该</strong>就可以了。对没错就是这样。多简单啊。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> javascript </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步步带你通过Ajax+Github提供的api 实现前端剪切板图片上传</title>
      <link href="/2020/05/08/artiimg/"/>
      <url>/2020/05/08/artiimg/</url>
      
        <content type="html"><![CDATA[<h2 id="通过api上传文件"><a href="#通过api上传文件" class="headerlink" title="通过api上传文件"></a>通过api上传文件</h2><div class="note warning"><p>这方面刚刚接触，只给出傻瓜式操作2333。强推Postman，调试api太好用了.如果不想跟着一起体验Postman的舒爽，可以直接跳到jquery代码</p></div><p><a href="https://www.postman.com/" target="_blank" rel="noopener">点我下载或在线使用Postman</a>，推荐下载后使用。</p><p>在GitHub的api中，有关于文件上传的接口<a href="https://developer.github.com/v3/repos/contents/" target="_blank" rel="noopener">Create or update a file</a></p><p>api的url格式</p><pre><code>PUT /repos/:owner/:repo/contents/:path</code></pre><p>在Postman里面我们新建一个请求<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508184058.webp" data-fancybox="images" data-caption="20200508184058" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508184058.webp" class="img-shadow img-margin"></center></a></p><p>首先改成PUT，然后输入url</p><pre><code>https://api.github.com/repos/:owner/:repo/contents/:path</code></pre><p>在body下使用raw添加信息(注意，GitHub的api强调必须把文件进行 base64 编码才能上传)</p><pre><code>//这是官网上的示例，我们只需要用message和content即可{  &quot;message&quot;: &quot;my commit message&quot;,  &quot;committer&quot;: {    &quot;name&quot;: &quot;Monalisa Octocat&quot;,    &quot;email&quot;: &quot;octocat@github.com&quot;  },  &quot;content&quot;: &quot;bXkgbmV3IGZpbGUgY29udGVudHM=&quot;}//可以拿下面这个做测试用{  &quot;message&quot;: &quot;test&quot;,  &quot;content&quot;: &quot;aGVsbG8gd29ybGQ=&quot;}</code></pre><p><code>aGVsbG8gd29ybGQ=</code>就是<code>Hello world</code>的base64编码后的形式<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508184709.webp" data-fancybox="images" data-caption="20200508184709" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508184709.webp" class="img-shadow img-margin"></center></a></p><p>我们还需要一步验证，GitHub可以采用token验证。<br><a href="https://github.com/settings/tokens" target="_blank" rel="noopener">点我生成GitHub的token</a>，我们这里只需要读写权限即可。不需要更多别的了，注意这个token只出现一次，确保已经粘贴好了再关闭这个页面。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185206.webp" data-fancybox="images" data-caption="20200508185206" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185206.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185341.webp" data-fancybox="images" data-caption="20200508185341" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185341.webp" class="img-shadow img-margin"></center></a></p><p>在Postman中的<code>Authorization</code>下的type选择<code>OAuth 2.0</code>，将你的token粘贴进去<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185446.webp" data-fancybox="images" data-caption="20200508185446" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185446.webp" class="img-shadow img-margin"></center></a></p><p>然后<code>send</code>,如果成功的话（跟着上面的来就不会出错（应该不会）），Postman中的body中会是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185718.webp" data-fancybox="images" data-caption="20200508185718" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185718.webp" class="img-shadow img-margin"></center></a></p><p>这个时候你在去你的上传的库中就可以看到你刚才上传的文件，比如说我这里是一个写着<code>Hello world</code>的readme.md<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/ajaxgithub.webp" data-fancybox="images" data-caption="ajaxgithub" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/ajaxgithub.webp" class="img-shadow img-margin"></center></a></p><p>这就说明你成功通过api向GitHub传了文件</p><h2 id="jquery代码"><a href="#jquery代码" class="headerlink" title="jquery代码"></a>jquery代码</h2><p>Postman支持自动生成访问api的代码。支持语言很多，这里我选择得时jquery的<br>如果你是上一步一起做过来的，直接生成代码就可自用。</p><pre><code class="lang-javascript">var settings = {  &quot;url&quot;: &quot;https://api.github.com/repos/Drew233/test/contents/test/readme.md&quot;,  &quot;method&quot;: &quot;PUT&quot;,  &quot;timeout&quot;: 0,  &quot;headers&quot;: {    &quot;Authorization&quot;: &quot;Bearer :Your token&quot;,    &quot;Content-Type&quot;: &quot;text/plain&quot;  },  &quot;data&quot;: &quot;{\r\n  \&quot;message\&quot;: \&quot;test\&quot;,\r\n  \&quot;content\&quot;: \&quot;aGVsbG8gd29ybGQ=\&quot;\r\n}&quot;,};$.ajax(settings).done(function (response) {  console.log(response);});</code></pre><p>通过观察我们不难发现</p><ul><li>url即上面我们访问的api的url</li><li>Authorization中的Bearer后面就是我们的token</li><li>data对应的就是官网中所给的发送api请求时候需要的信息</li></ul><h2 id="接听粘贴事件并将剪切板图片转换为base64编码后上传"><a href="#接听粘贴事件并将剪切板图片转换为base64编码后上传" class="headerlink" title="接听粘贴事件并将剪切板图片转换为base64编码后上传"></a>接听粘贴事件并将剪切板图片转换为base64编码后上传</h2><pre><code class="lang-javascript">function uploadimg(file){  var settings = {      &quot;url&quot;: &quot;&quot;,      &quot;method&quot;: &quot;PUT&quot;,      &quot;timeout&quot;: 0,      &quot;async&quot;: true,      &quot;headers&quot;: {        &quot;Authorization&quot;: ,        &quot;Content-Type&quot;: &quot;text/plain&quot;      },      &quot;data&quot;: &quot;{\r\n  \&quot;message\&quot;: \&quot;&quot; + window.location.host + &quot;\&quot;,\r\n  \&quot;content\&quot;: \&quot;&quot; + file + &quot;\&quot;\r\n}&quot;,    };    $.ajax(settings).done(function (response) {        console.log(response);//response即为上传后返回的message    });}document.addEventListener(&#39;paste&#39;, function (event) {//检测粘贴时间  var items = event.clipboardData &amp;&amp; event.clipboardData.items;  var file = null;  if (items &amp;&amp; items.length) {      // 检索剪切板items      for (var i = 0; i &lt; items.length; i++) {          if (items[i].type.indexOf(&#39;image&#39;) !== -1) {              file = items[i].getAsFile();              var reader = new FileReader();              reader.readAsDataURL(file);//将剪切板的图片文件转为base64编码              reader.onload = function(){                  base64url=reader.result.replace(/(.*)?,/,&#39;&#39;); //通过正则表达式删除转换为base64编码后前面的部分提示信息                  uploadimg(base64url);              };              break;          }      }  }});</code></pre><p>填上对应的值即可使用。</p><h2 id="起因-amp-amp-广告"><a href="#起因-amp-amp-广告" class="headerlink" title="起因 &amp;&amp; 广告"></a>起因 &amp;&amp; 广告</h2><p>为什么会接触到这个东西呢？因为最近弄的一个js（Artitalk）需要实现这个功能。<br>欢迎大家使用：<a href="https://artitalk.js.org" target="_blank" rel="noopener">Artitalk</a></p><h2 id="一些需要注意的事"><a href="#一些需要注意的事" class="headerlink" title="一些需要注意的事"></a>一些需要注意的事</h2><p>如果你要用这个功能并且把源码上传到GitHub pages，GitHub会自动检测到你的token然后将它删除（安全措施2333。<br>解决方法就是把token加密一下，然后调用的时候解密，亲测可行~</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript+Ajax+SMMS 实现前端剪切板图片上传</title>
      <link href="/2020/05/07/imgupload/"/>
      <url>/2020/05/07/imgupload/</url>
      
        <content type="html"><![CDATA[<div class="note danger"><p>本方法本地可使用，上传到网站后会出现跨域错误，最新解决方法已更新。</p></div><h2 id="需要先引入JQuery"><a href="#需要先引入JQuery" class="headerlink" title="需要先引入JQuery"></a>需要先引入JQuery</h2><pre><code class="lang-html">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="监听粘贴事件"><a href="#监听粘贴事件" class="headerlink" title="监听粘贴事件"></a>监听粘贴事件</h2><pre><code class="lang-javascript">document.addEventListener(&#39;paste&#39;, function (event) {    var items = event.clipboardData &amp;&amp; event.clipboardData.items;    var file = null;    if (items &amp;&amp; items.length) {        // 检索剪切板items        for (var i = 0; i &lt; items.length; i++) {            if (items[i].type.indexOf(&#39;image&#39;) !== -1) {                file = items[i].getAsFile();                break;            }        }    }</code></pre><p>如果你复制了图片，此时的file就是你复制的图片。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>这里调用了<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>提供的上传图片的api</p><pre><code class="lang-javascript">var formData = new FormData();    formData.append(&#39;smfile&#39;,file);    $.ajax({      url: &#39;https://sm.ms/api/v2/upload&#39;,      type: &#39;POST&#39;,      data:formData,      format: &#39;json&#39;,      success: function(smms){        var mid=eval(&#39;(&#39;+smms+&#39;)&#39;);        console.log(mid);        if(mid.code==&quot;image_repeated&quot;){          alert(mid.images);//图片已经存在了，直接返回url        }else if(mid.code==&quot;flood&quot;){          alert(&quot;上传过于频繁，等会再试试吧~&quot;);//api限制每小时最多上传20张        }        else{          alert(mid.data.url);//上传成功后返回url        }      },      error: function(smms){         var mid=eval(&#39;(&#39;+smms+&#39;)&#39;);        console.log(mid.data.url);      },      cache: false,      contentType: false,      processData: false  });});</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>新建一个html页面，代码放进去即可使用</p><pre><code class="lang-html">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;document.addEventListener(&#39;paste&#39;, function (event) {    var items = event.clipboardData &amp;&amp; event.clipboardData.items;    var file = null;    if (items &amp;&amp; items.length) {        // 检索剪切板items        for (var i = 0; i &lt; items.length; i++) {            if (items[i].type.indexOf(&#39;image&#39;) !== -1) {                file = items[i].getAsFile();                break;            }        }    }    // console.log(file); file即为剪切板中的图片    // 通过api接口上传到sm.ms    var formData = new FormData();    formData.append(&#39;smfile&#39;,file);    $.ajax({      url: &#39;https://sm.ms/api/v2/upload&#39;,      type: &#39;POST&#39;,      data:formData,      format: &#39;json&#39;,      success: function(smms){        var mid=eval(&#39;(&#39;+smms+&#39;)&#39;);        console.log(mid);        if(mid.code==&quot;image_repeated&quot;){          alert(mid.images);        }else if(mid.code==&quot;flood&quot;){          alert(&quot;上传过于频繁，等会再试试吧~&quot;);        }        else{          alert(mid.data.url);        }      },      error: function(smms){         var mid=eval(&#39;(&#39;+smms+&#39;)&#39;);        console.log(mid.data.url);      },      cache: false,      contentType: false,      processData: false  });});&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC Pacific Northwest Regional Contest 2019  B. Perfect Flush</title>
      <link href="/2020/05/05/PNRC2019B/"/>
      <url>/2020/05/05/PNRC2019B/</url>
      
        <content type="html"><![CDATA[<h1 id="B-Perfect-Flush"><a href="#B-Perfect-Flush" class="headerlink" title="B. Perfect Flush"></a>B. Perfect Flush</h1><div class="note link green"><p>Link: <a href="https://nanti.jisuanke.com/t/45345" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/45345</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>You are given a list of integers <script type="math/tex">x_{1}, x_{2}, \ldots, x_{n}</script> and a number <script type="math/tex">k</script>. It is guaranteed that each i from 1 to k appears in thelist at least once.Find the lexicographically smallest subsequence of x that contains each integer from 1 to k exactly once.</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>The first line will contain two integers <script type="math/tex">n</script> and <script type="math/tex">k</script>, with <script type="math/tex">1 \leq k \leq n \leq 200000</script>. The following n lines will each containan integer <script type="math/tex">x_{i}</script> with <script type="math/tex">1 \leq x_{i} \leq k</script>.</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>Write out on one line, separated by spaces, the lexicographically smallest subsequence of x that has each integer from 1 to k exactly once</p><p>样例输入1<br>6 3<br>3<br>2<br>1<br>3<br>1<br>3<br>样例输出1<br>2 1 3<br>样例输入2<br>10 5<br>5<br>4<br>3<br>2<br>1<br>4<br>1<br>1<br>5<br>5<br>样例输出2<br>3 2 1 4 5</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思是给我们<script type="math/tex">n</script>个数，保证<script type="math/tex">1-n</script>每个数都至少出现一次，让我们找到一个字典序最小的子序列包含<script type="math/tex">1-n</script>的每个数且智能出现一次。<br>暴力肯定是不行的，这道题的题解做法是，首先统计每个数最后出现的一个位置。<br>然后遍历这个序列，我们称现在遍历到的这个序列的数为<script type="math/tex">x_i</script>，做一下操作</p><ol><li>如果<script type="math/tex">x_i</script>还未出现在答案序列，并且答案序列不为空，就比较<script type="math/tex">x_i</script>和答案序列中最后一个数的大小。如果大于序列中的最后一个数，直接放到答案序列就行，如果小于，就看后面还是否会出现当前答案序列的最后一个数，用当前的位置和答案序列中最后一个数出现的最后一个位置作比较即可。如果后面不会再出现了，也直接加到答案序列。</li><li>如果<script type="math/tex">x_i</script>已经出现在答案序列，跳过。</li></ol><p>最后输出即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 2e5+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int d[4][2]={1,0,0,1,-1,0,0,-1};int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    int n,k;    cin&gt;&gt;n&gt;&gt;k;    vector&lt;int&gt; a(n+1),ans,vis(n+1),pos(n+1);    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;a[i];        pos[a[i]]=i;    }    for(int i=1;i&lt;=n;i++){        if(vis[a[i]])   continue;        while(ans.size()&gt;0&amp;&amp;a[i]&lt;ans.back()&amp;&amp;i&lt;pos[ans.back()]){            vis[ans.back()]=0;            ans.pop_back();        }        ans.pb(a[i]);        vis[a[i]]=1;    }    for(auto i :ans){        if(i!=ans.back())            cout&lt;&lt;i&lt;&lt;&quot; &quot;;        else            cout&lt;&lt;i&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder ABC 166 题解</title>
      <link href="/2020/05/03/abc166/"/>
      <url>/2020/05/03/abc166/</url>
      
        <content type="html"><![CDATA[<h2 id="A、-A-C"><a href="#A、-A-C" class="headerlink" title="A、    A?C"></a>A、    A?C</h2><p>直接判断输出即可。</p><h2 id="B、-Trick-or-Treat"><a href="#B、-Trick-or-Treat" class="headerlink" title="B、    Trick or Treat"></a>B、    Trick or Treat</h2><p>用一个数组统计出现过的，然后找没出现过的个数即可。</p><h2 id="C、-Peaks"><a href="#C、-Peaks" class="headerlink" title="C、    Peaks"></a>C、    Peaks</h2><p>存一下图，遍历即可。</p><h2 id="D、-I-hate-Factorization"><a href="#D、-I-hate-Factorization" class="headerlink" title="D、    I hate Factorization"></a>D、    I hate Factorization</h2><p>打表，-500-500的就够了    </p><h2 id="E、-This-Message-Will-Self-Destruct-in-5s"><a href="#E、-This-Message-Will-Self-Destruct-in-5s" class="headerlink" title="E、    This Message Will Self-Destruct in 5s"></a>E、    This Message Will Self-Destruct in 5s</h2><p>如果我们要找的两个数的下标位i,j。假设j&gt;i,可得<script type="math/tex">a_i+a_j=j-i</script><br>化简一下可得<script type="math/tex">a_i+i=j-a_j</script><br>所以我们统计每一个<script type="math/tex">j-a_j</script>出现的次数，遍历<script type="math/tex">a_i+i</script>累加即可。</p><h2 id="F、-Three-Variables-Game"><a href="#F、-Three-Variables-Game" class="headerlink" title="F、    Three Variables Game"></a>F、    Three Variables Game</h2><p>每次选小的加一，大的减一。如果相等的，看一下下一个操作来选择用哪个。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> atcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eight HDU - 1043</title>
      <link href="/2020/05/03/hdu1043/"/>
      <url>/2020/05/03/hdu1043/</url>
      
        <content type="html"><![CDATA[<h1 id="Eight"><a href="#Eight" class="headerlink" title="Eight"></a>Eight</h1><div class="note link green"><p>Link: <a href="https://vjudge.net/problem/HDU-1043" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1043</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>The 15-puzzle has been around for over 100 years; even if you don&#39;t know it by that name, you&#39;ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let&#39;s call the missing tile &#39;x&#39;; the object of the puzzle is to arrange the tiles so that they are ordered as:</p><p> 1  2  3  4<br> 5  6  7  8<br> 9 10 11 12<br>13 14 15  x</p><p>where the only legal operation is to exchange &#39;x&#39; with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle:</p><p> 1  2  3  4     1  2  3  4     1  2  3  4     1  2  3  4<br> 5  6  7  8     5  6  7  8     5  6  7  8     5  6  7  8<br> 9  x 10 12     9 10  x 12     9 10 11 12     9 10 11 12<br>13 14 11 15    13 14 11 15    13 14  x 15    13 14 15  x<br>            r-&gt;            d-&gt;            r-&gt;</p><p>The letters in the previous row indicate which neighbor of the &#39;x&#39; tile is swapped with the &#39;x&#39; tile at each step; legal values are &#39;r&#39;,&#39;l&#39;,&#39;u&#39; and &#39;d&#39;, for right, left, up, and down, respectively.</p><p>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing &#39;x&#39; tile, of course).</p><p>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement.</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus &#39;x&#39;. For example, this puzzle</p><p>1 2 3<br>x 4 6<br>7 5 8</p><p>is described by this list:</p><p>1 2 3 x 4 6 7 5 8</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>You will print to standard output either the word ``unsolvable&#39;&#39;, if the puzzle has no solution, or a string consisting entirely of the letters &#39;r&#39;, &#39;l&#39;, &#39;u&#39; and &#39;d&#39; that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases.<br>示例1<br>输入<br>2  3  4  1  5  x  7  6  8<br>输出<br>ullddrurdllurdruldr</p>              </div>            </details><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题有许多种解法。这里我用的是康拓展开。<br>康拓展开，将一个全排列跟一个整数对应起来。也就是哈希的思想。我们把这个3*3的图当成一个全排列看待即可。<br>因为最后我们要到达的状态是恒定的（12345678x），所以我们可以通过逆向bfs打一个表得到每种状态到达这个状态的路径。省了时间也省了空间。把x当成0看，就是0-8的全排列了。（其实没看题解之前想到了hash，但是不知道怎么来回转换，康拓展开nb</p><h2 id="康拓展开的模板"><a href="#康拓展开的模板" class="headerlink" title="康拓展开的模板"></a>康拓展开的模板</h2><pre><code class="lang-c++">int cantor(int *a){//获得hash值   int x=0;   for(int i=0;i&lt;9;i++){      int mi=0;      for(int j=i+1;j&lt;9;j++){         if(a[j]&lt;a[i])  mi++;      }      x+=FAC[9-i-1]*mi;   }   return x+1;}void decantor(int x,int *a){//通过hash值倒推回全排列   vector&lt;int&gt; v;   for(int i=0;i&lt;9;i++) v.pb(i);   for(int i=0;i&lt;9;i++){      int r=x%FAC[9-i-1];      int t=x/FAC[9-i-1];      x=r;      sort(v.begin(),v.end());      a[i]=v[t];      v.erase(v.begin()+t);   }}</code></pre><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 4e5+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int miday[9],dt[4][2]= {1,0,-1,0,0,1,0,-1},result=46234,vis[maxn];string path[maxn];char op[5]=&quot;udlr&quot;;int FAC[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}; struct node{   string path;   int val,pos;};node now,net;int cantor(int *a){   int x=0;   for(int i=0;i&lt;9;i++){      int mi=0;      for(int j=i+1;j&lt;9;j++){         if(a[j]&lt;a[i])  mi++;      }      x+=FAC[9-i-1]*mi;   }   return x+1;}void decantor(int x,int *a){   vector&lt;int&gt; v;   for(int i=0;i&lt;9;i++) v.pb(i);   for(int i=0;i&lt;9;i++){      int r=x%FAC[9-i-1];      int t=x/FAC[9-i-1];      x=r;      sort(v.begin(),v.end());      a[i]=v[t];      v.erase(v.begin()+t);   }}void bfs(){   queue&lt;node&gt; q;   for(int i=0;i&lt;8;i++) miday[i]=i+1;   miday[8]=0;   now.pos=8;now.val=result;now.path=&quot;&quot;;vis[result]=1;path[result]=&quot;&quot;;   q.push(now);   while(!q.empty()){      now=q.front();      q.pop();      for(int i=0;i&lt;4;i++){         int dx=(now.pos)/3+dt[i][0];         int dy=(now.pos)%3+dt[i][1];         if(dx&lt;0||dy&lt;0||dx&gt;2||dy&gt;2) continue;         net=now;net.pos=dx*3+dy;         decantor(now.val-1,miday);         swap(miday[now.pos],miday[net.pos]);         net.val=cantor(miday);         if(!vis[net.val]){            vis[net.val]=1;            net.path=op[i]+net.path;            q.push(net);            path[net.val]=net.path;         }      }   }   return ;}int main() {   ios::sync_with_stdio(0);   #ifdef Uncle_drew   freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);   freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);   #else   #endif   bfs();   char x;   while(cin&gt;&gt;x){      if(x==&#39;x&#39;){         now.pos=0;         miday[0]=0;      }else{         miday[0]=x-&#39;0&#39;;      }      for(int i=1;i&lt;9;i++){         cin&gt;&gt;x;         if(x==&#39;x&#39;){            now.pos=i;            miday[i]=0;         }else{            miday[i]=x-&#39;0&#39;;         }      }      now.val=cantor(miday);      if(!vis[now.val]){         cout&lt;&lt;&quot;unsolvable\n&quot;;      }else{         cout&lt;&lt;path[now.val]&lt;&lt;endl;      }   }   return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDU </tag>
            
            <tag> bfs </tag>
            
            <tag> hash </tag>
            
            <tag> 康拓展开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JLOI2011-飞行路线</title>
      <link href="/2020/04/26/jloi2011/"/>
      <url>/2020/04/26/jloi2011/</url>
      
        <content type="html"><![CDATA[<h1 id="JLOI2011-飞行路线"><a href="#JLOI2011-飞行路线" class="headerlink" title="[JLOI2011]飞行路线"></a>[JLOI2011]飞行路线</h1><div class="note link green"><p>Link: <a href="https://www.luogu.com.cn/problem/P4568" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4568</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在n个城市设有业务，设这些城市分别标记为0到n-1，一共有m种航线，每种航线连接两个城市，并且航线有一定的价格。<br>Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多k种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。<br>第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。(0 ≤ s,t &lt; n)<br>接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。(0 ≤ a,b &lt; n,a与b不相等，0 ≤ c ≤ 1000)</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>只有一行，包含一个整数，为最少花费。<br>示例1<br>输入<br>5 6 1<br>0 4<br>0 1 5<br>1 2 5<br>2 3 5<br>3 4 5<br>2 3 3<br>0 2 100<br>输出<br>8</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">\begin{aligned}&\text { 对于 } 100 \% \text { 的数据, } 2 \leq n \leq 10^{4}, 1 \leq m \leq 5 \times 10^{4}, 0 \leq k \leq 10,0 \leq s, t, a, b \leq n, a \neq b, 0 \leq\\&c \leq 10^{3}\end{aligned}</script>              </div>            </details><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你一个图，你有<script type="math/tex">k</script>次机会可以让你走的路零代价，给你起点和终点，问你最短距离。<br>~一开始想着贪心着写，贪着贪着发现，我还是不够贪心~</p><p>后来才知道这就是一道模板题——分层图最短路。<br>网上讲解挺多的，大致意思就是有两种方法。一种是dp，一种是建图的时候直接建分层图。但是后者容易被卡空间。<br>不过在这里显然不用担心。</p><p>具体思路，就是，建图的时候，建<script type="math/tex">k</script>层。每层图根原图是一样的。但是在每一层之间，如果这两个点是联通的就加上一条权值为0的边。然后我们跑一边最短路。答案就是从起点到每一层的终点对应的点的最短路的最小值。<br>这思路挺妙的，如果你某次使某条路代价为零就等价于，从这几层图的中间选择了一条路。</p><p>还有就是这种分法很占空间。我开了<script type="math/tex">3*10^6+10</script>才过。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 3e6+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int n,m,k,s,t,head[maxn],cnt=1,dis[maxn];struct node{    int to,next,val;}p[maxn];void add(int u,int v,int w){    p[cnt].to=v;    p[cnt].next=head[u];    p[cnt].val=w;    head[u]=cnt++;}void solve(int s){    memset(dis,INF,sizeof(dis));    dis[s]=0;    priority_queue&lt;pair&lt;int,int&gt; &gt; q;    q.push(mp(0,s));    while(!q.empty()){        int u=q.top().second;q.pop();        for(int i=head[u];i;i=p[i].next){            int v=p[i].to;            if(dis[v]&gt;dis[u]+p[i].val){                dis[v]=dis[u]+p[i].val;                q.push(mp(-dis[v],v));            }        }    }}int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;    for(int i=0,u,v,w;i&lt;m;i++){        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        for(int j=0;j&lt;=k;j++){            add(u+j*n,v+j*n,w);            add(v+j*n,u+j*n,w);            if(j&lt;k){                add(u+j*n,v+(j+1)*n,0);                add(v+j*n,u+(j+1)*n,0);            }        }    }//建图    solve(s);    int ans=INF;    for(int i=0;i&lt;=k;i++){        // cout&lt;&lt;dis[i*n+t]&lt;&lt;endl;        ans=min(ans,dis[i*n+t]);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
            <tag> Priority queue </tag>
            
            <tag> 分层图最短路 </tag>
            
            <tag> 链式前向星 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCOI2009 最长距离</title>
      <link href="/2020/04/22/SCOI2009/"/>
      <url>/2020/04/22/SCOI2009/</url>
      
        <content type="html"><![CDATA[<h1 id="SCOI2009-最长距离"><a href="#SCOI2009-最长距离" class="headerlink" title="[SCOI2009]最长距离"></a>[SCOI2009]最长距离</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>windy有一块矩形土地，被分为 NM 块 11 的小格子。 有的格子含有障碍物。 如果从格子A可以走到格子B，那么两个格子的距离就为两个格子中心的欧几里德距离。 如果从格子A不可以走到格子B，就没有距离。 如果格子X和格子Y有公共边，并且X和Y均不含有障碍物，就可以从X走到Y。 如果windy可以移走T块障碍物，求所有格子间的最大距离。 保证移走T块障碍物以后，至少有一个格子不含有障碍物。</p><p>输入格式<br>第一行包含三个整数，N M T。 接下来有N行，每行一个长度为M的字符串，&#39;0&#39;表示空格子，&#39;1&#39;表示该格子含有障碍物。</p><p>输出格式<br>包含一个浮点数，保留6位小数。</p><p>输入输出样例<br>输入 #1<br>3 3 0<br>001<br>001<br>110<br>输出 #1<br>1.414214</p><p>输入 #2<br>4 3 0<br>001<br>001<br>011<br>000<br>输出 #2<br>3.605551</p><p>输入 #3<br>3 3 1<br>001<br>001<br>001<br>输出 #3<br>2.828427<br>说明/提示<br>20%的数据，满足 1 &lt;= N,M &lt;= 30 ； 0 &lt;= T &lt;= 0 。</p><p>40%的数据，满足 1 &lt;= N,M &lt;= 30 ； 0 &lt;= T &lt;= 2 。</p><p>100%的数据，满足 1 &lt;= N,M &lt;= 30 ； 0 &lt;= T &lt;= 30 。</p>              </div>            </details><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是有一个<script type="math/tex">n*m</script>的图，某些点存在障碍，问你在移走最多<script type="math/tex">k</script>个障碍物之后，可以达到的最大的两点间距离，若两点有公共边且都没有障碍，两点可达。<br>我们可以发现，<span class="p red">问题的关键在于障碍物的处理</span>。因为我们只需要找两点之间的最大距离，所以这<script type="math/tex">k</script>个障碍物全都用来满足最大距离的情况就行了。<br>建图，把有障碍的地方距离建为<script type="math/tex">1</script>，其它可达的建为<script type="math/tex">0</script>。然后对于每个点，我们用<script type="math/tex">spfa</script>（或者<script type="math/tex">Dijkstra</script>）求出其他点到它的最短距离，如果最短距离小于等于<script type="math/tex">k</script>，说明我们可以通过移走障碍物把这两个点联通。然后更新一下最大值即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 35;const int  INF = 0x3f3f3f3f;#define mp make_pair#define pii pair&lt;int,int&gt;string s[N];int n,m,k,dis[N][N],vis[N][N],d[4][2]={1,0,0,1,-1,0,0,-1};void spfa(int x,int y){    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;m;j++){            dis[i][j]=INF;            vis[i][j]=0;        }    }    queue&lt;pii&gt; q;    q.push(mp(x,y));    vis[x][y]=1;dis[x][y]=(s[x][y]==&#39;1&#39;);    while(!q.empty()){        pii mid=q.front();q.pop();        x=mid.first,y=mid.second;        vis[x][y]=0;        for(int i=0;i&lt;4;i++){            int dx=x+d[i][0],dy=y+d[i][1];            if(dx&lt;0||dx&gt;=n||dy&lt;0||dy&gt;=m)    continue;            if(dis[dx][dy]&gt;dis[x][y]+(s[dx][dy]==&#39;1&#39;)){                dis[dx][dy]=dis[x][y]+(s[dx][dy]==&#39;1&#39;);                q.push(mp(dx,dy));                vis[dx][dy]=1;            }        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;s[i];    double ans=0;    for(int a=0;a&lt;n;a++){        for(int b=0;b&lt;m;b++){            spfa(a,b);            for(int c=0;c&lt;n;c++){                for(int d=0;d&lt;m;d++){                    if(dis[c][d]&lt;=k){                        ans=max(ans,sqrt((a-c)*(a-c)+(b-d)*(b-d)));                    }                }            }        }    }    printf(&quot;%.6lf\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
            <tag> spfa </tag>
            
            <tag> scoi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Markdown写作进阶——标签</title>
      <link href="/2020/04/18/mdjj/"/>
      <url>/2020/04/18/mdjj/</url>
      
        <content type="html"><![CDATA[<div class="note link green"><p>样式以及js代码参考于：<a href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener">https://volantis.js.org/tag-plugins/</a></p></div><blockquote><p>我只是将我需要的移植了过来，需要别的可以自行移植。所以我下面说到的都是关于我移植的部分标签。<br>移植于主题<strong><span class="p blue">volantis</span></strong>，这款主题很好看，大家可以去尝试一下。<br>移植起来也很简单，只要将对应的js和css添加到自己的引用中即可。</p></blockquote><h1 id="简单说一下移植以及使用"><a href="#简单说一下移植以及使用" class="headerlink" title="简单说一下移植以及使用"></a>简单说一下移植以及使用</h1><p class="p center cyan">移植简单，制作不易。支持原作者！</p><div class="note warning"><p>因为我也不是很清楚原理，所以给出傻瓜式操作</p></div><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p>将以下代码放进<code>../node_modules/hexo-generator-tag/index.js</code>中</p><pre><code class="lang-javascript">function postFolding(args, content) {  args = args.join(&#39; &#39;).split(&#39;,&#39;);  let style = &#39;&#39;  let title = &#39;&#39;  if (args.length &gt; 1) {    style = args[0].trim()    title = args[1].trim()  } else if (args.length &gt; 0) {    title = args[0].trim()  }  if (style != undefined) {    return `&lt;details ${style}&gt;&lt;summary&gt; ${hexo.render.renderSync({text: title, engine: &#39;markdown&#39;}).split(&#39;\n&#39;).join(&#39;&#39;)} &lt;/summary&gt;              &lt;div class=&#39;content&#39;&gt;              ${hexo.render.renderSync({text: content, engine: &#39;markdown&#39;}).split(&#39;\n&#39;).join(&#39;&#39;)}              &lt;/div&gt;            &lt;/details&gt;`;  } else {    return `&lt;details&gt;&lt;summary&gt; ${hexo.render.renderSync({text: title, engine: &#39;markdown&#39;}).split(&#39;\n&#39;).join(&#39;&#39;)} &lt;/summary&gt;              &lt;div class=&#39;content&#39;&gt;              ${hexo.render.renderSync({text: content, engine: &#39;markdown&#39;}).split(&#39;\n&#39;).join(&#39;&#39;)}              &lt;/div&gt;            &lt;/details&gt;`;  }}hexo.extend.tag.register(&#39;folding&#39;, postFolding, {ends: true});function postP(args) {  args = args.join(&#39; &#39;).split(&#39;,&#39;)  let p0 = args[0].trim()  let p1 = args[1].trim()  return `&lt;p class=&#39;p ${p0}&#39;&gt;${p1}&lt;/p&gt;`;}function postSpan(args) {  args = args.join(&#39; &#39;).split(&#39;,&#39;)  let p0 = args[0].trim()  let p1 = args[1].trim()  return `&lt;span class=&#39;p ${p0}&#39;&gt;${p1}&lt;/span&gt;`;}hexo.extend.tag.register(&#39;p&#39;, postP);hexo.extend.tag.register(&#39;span&#39;, postSpan);function postNote(args) {  args = args.join(&#39; &#39;).split(&#39;,&#39;)  if (args.length &gt; 1) {    let cls = args[0].trim()    let text = args[1].trim()    return `&lt;div class=&quot;note ${cls}&quot;&gt;${hexo.render.renderSync({text: text, engine: &#39;markdown&#39;}).split(&#39;\n&#39;).join(&#39;&#39;)}&lt;/div&gt;`;  } else if (args.length &gt; 0) {    let text = args[0].trim()    return `&lt;div class=&quot;note&quot;&gt;${hexo.render.renderSync({text: text, engine: &#39;markdown&#39;}).split(&#39;\n&#39;).join(&#39;&#39;)}&lt;/div&gt;`;  }}function postNoteBlock(args, content) {  return `&lt;div class=&quot;note ${args.join(&#39; &#39;)}&quot;&gt;            ${hexo.render.renderSync({text: content, engine: &#39;markdown&#39;}).split(&#39;\n&#39;).join(&#39;&#39;)}          &lt;/div&gt;`;}hexo.extend.tag.register(&#39;note&#39;, postNote);hexo.extend.tag.register(&#39;noteblock&#39;, postNoteBlock, {ends: true});</code></pre><p>如果你想移植自己想用的，将主题文件下载下来找到对应的js将其中的代码一起复制进来即可。</p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>下载这个css，放在本地调用：<a href="https://cdn.jsdelivr.net/gh/drew233/css/newtag.css" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/drew233/css/newtag.css</a> </p><p>如果你想移植自己想用的，在示例站的css中找到对应的代码一起复制进来即可。</p><p class="p center cyan">下面高能预警，非战斗人员撤退。</p><h1 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h1><p>方便以后自己使用，也给大家看一下效果。</p><h2 id="容器-folding"><a href="#容器-folding" class="headerlink" title="容器-folding"></a>容器-folding</h2><details green><summary> <p>点击查看markdown源代码</p> </summary>              <div class="content">              <p>{% folding, 图片测试 %}<br>{% fb_img <a href="https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp</a> %}<br>{% endfolding %}<br>{% folding cyan open, 查看默认打开的折叠框 %}</p><p>这是一个默认打开的折叠框。</p><p>{% endfolding %}<br>{% folding green, 查看代码测试 %}</p><p>{% endfolding %}<br>{% folding yellow, 查看列表测试 %}</p><ul><li>haha</li><li>hehe</li></ul><p>{% endfolding %}<br>{% folding red, 查看嵌套测试 %}</p><p>{% folding blue, 查看嵌套测试2 %}</p><p>{% folding 查看嵌套测试3 %}</p><p>hahaha </p><p>{% endfolding %}<br>{% endfolding %}<br>{% endfolding %}</p>              </div>            </details><details><summary> <p>图片测试</p> </summary>              <div class="content">              <p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp" data-fancybox="images" data-caption="主人没有描述我哦~" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp" class="img-shadow img-margin"></center></a></p>              </div>            </details><details cyan open><summary> <p>查看默认打开的折叠框</p> </summary>              <div class="content">              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details green><summary> <p>查看代码测试</p> </summary>              <div class="content">                            </div>            </details><details yellow><summary> <p>查看列表测试</p> </summary>              <div class="content">              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details red><summary> <p>查看嵌套测试</p> </summary>              <div class="content">              <details blue><summary> <p>查看嵌套测试2</p> </summary>              <div class="content">              <details><summary> <p>查看嵌套测试3</p> </summary>              <div class="content">              <p>hahaha </p>              </div>            </details>              </div>            </details>              </div>            </details><h2 id="标签-note"><a href="#标签-note" class="headerlink" title="标签-note"></a>标签-note</h2><details green><summary> <p>点击查看markdown源代码</p> </summary>              <div class="content">              <div class="note done red"><p>支持使用颜色参数：clear，light，gray，red，yellow，green，cyan，blue</p></div><p>{% note red, 为简单的一句话提供的简便写法。 %}</p><p>{% note quote, 为简单的一句话提供的简便写法。 %}</p><p>{% note info, 为简单的一句话提供的简便写法。 %}</p><p>{% note warning, 为简单的一句话提供的简便写法。 %}</p><p>{% note done, 支持同样丰富的参数。 %}</p><p>{% note success, 支持同样丰富的参数。 %}</p><p>{% note danger, 支持同样丰富的参数。 %}</p><p>{% note error, 支持同样丰富的参数。 %}</p><p>{% note radiation, 支持同样丰富的参数。 %}</p><p>{% note bug, 支持同样丰富的参数。 %}</p><p>{% note idea, 支持同样丰富的参数。 %}</p><p>{% note link, 支持同样丰富的参数。 %}</p><p>{% note todo, 支持同样丰富的参数。 %}</p><p>{% note msg, 支持同样丰富的参数。 %}</p><p>{% note guide, 支持同样丰富的参数。 %}</p><p>{% note up, 支持同样丰富的参数。 %}</p><p>{% note undo, 支持同样丰富的参数。 %}</p><p>{% note paperclip, 支持同样丰富的参数。 %}</p>              </div>            </details><div class="note red"><p>为简单的一句话提供的简便写法。</p></div><div class="note quote"><p>为简单的一句话提供的简便写法。</p></div><div class="note info"><p>为简单的一句话提供的简便写法。</p></div><div class="note warning"><p>为简单的一句话提供的简便写法。</p></div><div class="note done"><p>支持同样丰富的参数。</p></div><div class="note success"><p>支持同样丰富的参数。</p></div><div class="note danger"><p>支持同样丰富的参数。</p></div><div class="note error"><p>支持同样丰富的参数。</p></div><div class="note radiation"><p>支持同样丰富的参数。</p></div><div class="note bug"><p>支持同样丰富的参数。</p></div><div class="note idea"><p>支持同样丰富的参数。</p></div><div class="note link"><p>支持同样丰富的参数。</p></div><div class="note todo"><p>支持同样丰富的参数。</p></div><div class="note msg"><p>支持同样丰富的参数。</p></div><div class="note guide"><p>支持同样丰富的参数。</p></div><div class="note up"><p>支持同样丰富的参数。</p></div><div class="note undo"><p>支持同样丰富的参数。</p></div><div class="note paperclip"><p>支持同样丰富的参数。</p></div><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><details green><summary> <p>点击查看markdown源代码</p> </summary>              <div class="content">              <p>{% span red, 红色 %}、{% span yellow, 黄色 %}、{% span green, 绿色 %}、{% span cyan, 青色 %}、{% span blue, 蓝色 %}、{% span gray, 灰色 %}。</p><p>{% span small, Test %}<br>{% span large, Test %}<br>{% span huge, Test %}<br>{% span ultra, Test %}<br>{% span ultra logo red,  Test %}</p><p>{% p center logo large, Uncle_drew %}<br>{% p center small, Hand down,man down %}</p>              </div>            </details><span class="p red">红色</span>、<span class="p yellow">黄色</span>、<span class="p green">绿色</span>、<span class="p cyan">青色</span>、<span class="p blue">蓝色</span>、<span class="p gray">灰色</span>。<span class="p small">Test</span><span class="p large">Test</span><span class="p huge">Test</span><span class="p ultra">Test</span><span class="p ultra logo red">Test</span><p class="p center logo large">Uncle_drew</p><p class="p center small">Hand down</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> javascript </tag>
            
            <tag> Hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为你的hexo博客添加动态的（可直接发布说说的）说说页面</title>
      <link href="/2020/04/10/hexo-shuoshuo/"/>
      <url>/2020/04/10/hexo-shuoshuo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：我美化的没那么好看，如果不喜欢的话，你可以在css中根据自己的需要调整。本页面用到的所有css均在一个文件。持续更新到我不知道更新什么为止。2.0版本已解决验证问题。</p></blockquote><p>项目初期版本迭代更新较快，请着重参考文档中的介绍。<br>活前往查看最新教程：<a href="https://cndrew.cn/2020/05/11/artitalk/" target="_blank" rel="noopener">https://cndrew.cn/2020/05/11/artitalk/</a></p><p>文档地址：<a href="https://artitalk.js.org/" target="_blank" rel="noopener">https://artitalk.js.org/</a><br>如果有问题或者建议，欢迎进群交流，群号：1104585229</p><p><img border="0" src="//pub.idqqimg.com/wpa/images/group.png" alt="Artitalk交流群" title="Artitalk交流群"></p><h1 id="一开始我想说的话"><a href="#一开始我想说的话" class="headerlink" title="一开始我想说的话"></a>一开始我想说的话</h1><p>本文可能不会实时更新，推荐前往GitHub。<br>本篇文章中涉及到的js和css都已上传到GitHub: <a href="https://github.com/Drew233/hexo-shuoshuo" target="_blank" rel="noopener">Hexo-shuoshuo</a><br>之前弄了一个简单的说说页面，没想到效果挺好。挺多小伙伴都表示了很有用，最近突然意识到既然评论数据可以存储在<code>leancloud</code>然后展示出来，那说说肯定也可以啊！说干就干。<br>之前那篇文章的链接: <a href="https://cndrew.cn/2019/09/11/shuoshuo/" target="_blank" rel="noopener">为你的hexo博客添加说说页面</a><br>视频教程：<a href="https://www.bilibili.com/video/BV16A411b7UF" target="_blank" rel="noopener">Hexo-shuoshuo bilibili</a><br>目前最新版本：<code>V2.1.1</code></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性:"></a>特性:</h2><ul><li>在<code>Hexo</code>中显示一个说说页面，并且支持站长实时发布，可移步<code>leancloud</code>后台进行修改。</li><li>可直接使用<code>html</code>语法插入歌曲或者图片视频等。理论上支持除了<code>&lt;li&gt;</code>和<code>&lt;ui&gt;</code>的其他任何<code>html</code>语法。</li><li>通过leancloud的用户直接调用保证仅站长可以发布说说，且被破解的概率理论上为0.</li></ul><p>Demo: <a href="https://cndrew.cn/shuoshuo/" target="_blank" rel="noopener">Hexo-说说</a></p><h1 id="具体食用方法"><a href="#具体食用方法" class="headerlink" title="具体食用方法"></a>具体食用方法</h1><h2 id="关于Leancloud"><a href="#关于Leancloud" class="headerlink" title="关于Leancloud"></a>关于Leancloud</h2><p>这里我们要求使用<a href="https://console.leancloud.app/login.html#/signup" target="_blank" rel="noopener">leancloud国际版</a>注册，因为国际版不需要绑定备案的域名<br>注册结束后首先找到账号设置，绑定邮箱和手机号。这一步是必须的，否则无法创建应用。邮箱和手机号都有临时的，所以也不难。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc1.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc1.webp" class="img-shadow img-margin"></center></a></p><p>绑定成功之后，点击创建应用，并将应用名字设置为<code>shuoshuo</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc2.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc2.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lcc2.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lcc2.webp" class="img-shadow img-margin"></center></a></p><p>创建之后点击应用跳转到控制台<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc3.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc3.webp" class="img-shadow img-margin"></center></a></p><p>在设置中找到应用keys中的<code>appId</code>和<code>appKey</code>记下来，或者页面一直开着。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc4.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc4.webp" class="img-shadow img-margin"></center></a></p><p>在<code>leancloud</code>的存储中添加<code>class</code>，命名为<code>shuoshuo</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc5.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc5.webp" class="img-shadow img-margin"></center></a></p><p>然后在你新建的应用中找到<code>结构化数据</code>下的<code>用户</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234538.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234538.webp" class="img-shadow img-margin"></center></a></p><p>然后点击<code>添加用户</code>，输入你想使用的<code>用户名</code>以及<code>密码</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234719.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234719.webp" class="img-shadow img-margin"></center></a></p><p>接着回到<code>结构化数据-&gt;shuoshuo-&gt;权限</code>，在<code>Class访问权限</code>中将<code>add_fields</code>以及<code>create</code>权限设置为指定用户，输入你刚才输入的用户名会自动匹配。为了安全起见，将<code>delete</code>和<code>update</code>也设置为跟它们一样的权限。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235209.webp" data-fancybox="images" data-caption="20200417235209" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235209.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235312.webp" data-fancybox="images" data-caption="20200417235312" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235312.webp" class="img-shadow img-margin"></center></a></p><p>最后将<code>_User</code>中的权限全部调为指定用户，或者数据创建者，为了保证不被篡改用户数据。</p><p>到这里<code>leancloud</code>的设置就告一段落了。</p><h2 id="关于js和css"><a href="#关于js和css" class="headerlink" title="关于js和css"></a>关于js和css</h2><p>去<code>GitHub</code>下载：<a href="https://github.com/Drew233/hexo-shuoshuo" target="_blank" rel="noopener">Hexo-shuoshuo</a><br>引用<code>jquery</code></p><pre><code class="lang-html">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 如果之前引用过就不需要重复引用了 --&gt;</code></pre><p>然后在根目录的<code>source</code>文件夹下新建一个<code>shuoshuo</code>文件夹，并在文件夹中新建<code>index.md</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/index.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/index.webp" class="img-shadow img-margin"></center></a></p><p>在<code>index.md</code>中除了<code>font-matter</code>之外写上以下内容</p><pre><code class="lang-html">&lt;script&gt;var img=&quot;&quot;;var appID=&quot;&quot;;var appKEY=&quot;&quot;;var per=&quot;&quot;;var username=&quot;&quot;;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/src/shuoshuov1.1.css&quot; media=&quot;all&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/leancloud-storage@4.5.3/dist/av-min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/src/os.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/src/shuoshuov2.1.1.js&quot;&gt;&lt;/script&gt;&lt;body&gt;  &lt;div id=&quot;lazy&quot;&gt;    &lt;div class=&quot;preloader&quot; style=&quot;opacity: 1; &quot;&gt;  &lt;svg version=&quot;1.1&quot; id=&quot;sun&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;10px&quot; height=&quot;10px&quot; viewBox=&quot;0 0 10 10&quot; enable-background=&quot;new 0 0 10 10&quot; xml:space=&quot;preserve&quot; style=&quot;opacity: 1; margin-left: 0px; margin-top: 0px;&quot;&gt;    &lt;g&gt;      &lt;path fill=&quot;none&quot; d=&quot;M6.942,3.876c-0.4-0.692-1.146-1.123-1.946-1.123c-0.392,0-0.779,0.104-1.121,0.301c-1.072,0.619-1.44,1.994-0.821,3.067C3.454,6.815,4.2,7.245,5,7.245c0.392,0,0.779-0.104,1.121-0.301C6.64,6.644,7.013,6.159,7.167,5.581C7.321,5,7.243,4.396,6.942,3.876z M6.88,5.505C6.745,6.007,6.423,6.427,5.973,6.688C5.676,6.858,5.34,6.948,5,6.948c-0.695,0-1.343-0.373-1.69-0.975C2.774,5.043,3.093,3.849,4.024,3.312C4.32,3.14,4.656,3.05,4.996,3.05c0.695,0,1.342,0.374,1.69,0.975C6.946,4.476,7.015,5,6.88,5.505z&quot;&gt;&lt;/path&gt;      &lt;path fill=&quot;none&quot; d=&quot;M8.759,2.828C8.718,2.757,8.626,2.732,8.556,2.774L7.345,3.473c-0.07,0.041-0.094,0.132-0.053,0.202C7.319,3.723,7.368,3.75,7.419,3.75c0.025,0,0.053-0.007,0.074-0.02l1.211-0.699C8.774,2.989,8.8,2.899,8.759,2.828z&quot;&gt;&lt;/path&gt;      &lt;path fill=&quot;none&quot; d=&quot;M1.238,7.171c0.027,0.047,0.077,0.074,0.128,0.074c0.025,0,0.051-0.008,0.074-0.02l1.211-0.699c0.071-0.041,0.095-0.133,0.054-0.203S2.574,6.228,2.503,6.269l-1.21,0.699C1.221,7.009,1.197,7.101,1.238,7.171z&quot;&gt;&lt;/path&gt;      &lt;path fill=&quot;none&quot; d=&quot;M6.396,2.726c0.052,0,0.102-0.026,0.13-0.075l0.349-0.605C6.915,1.976,6.89,1.885,6.819,1.844c-0.07-0.042-0.162-0.017-0.202,0.054L6.269,2.503C6.228,2.574,6.251,2.666,6.322,2.706C6.346,2.719,6.371,2.726,6.396,2.726z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M3.472,7.347L3.123,7.952c-0.041,0.07-0.017,0.162,0.054,0.203C3.2,8.169,3.226,8.175,3.25,8.175c0.052,0,0.102-0.027,0.129-0.074l0.349-0.605c0.041-0.07,0.017-0.16-0.054-0.203C3.603,7.251,3.513,7.276,3.472,7.347z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M3.601,2.726c0.025,0,0.051-0.007,0.074-0.02C3.746,2.666,3.77,2.574,3.729,2.503l-0.35-0.604C3.338,1.828,3.248,1.804,3.177,1.844C3.106,1.886,3.082,1.976,3.123,2.047l0.35,0.604C3.5,2.7,3.549,2.726,3.601,2.726z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M6.321,7.292c-0.07,0.043-0.094,0.133-0.054,0.203l0.351,0.605c0.026,0.047,0.076,0.074,0.127,0.074c0.025,0,0.051-0.006,0.074-0.02c0.072-0.041,0.096-0.133,0.055-0.203l-0.35-0.605C6.483,7.276,6.393,7.253,6.321,7.292z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M2.202,5.146c0.082,0,0.149-0.065,0.149-0.147S2.284,4.851,2.202,4.851H1.503c-0.082,0-0.148,0.066-0.148,0.148s0.066,0.147,0.148,0.147H2.202z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M8.493,4.851H7.794c-0.082,0-0.148,0.066-0.148,0.148s0.066,0.147,0.148,0.147l0,0h0.699c0.082,0,0.148-0.065,0.148-0.147S8.575,4.851,8.493,4.851L8.493,4.851z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M5.146,2.203V0.805c0-0.082-0.066-0.148-0.148-0.148c-0.082,0-0.148,0.066-0.148,0.148v1.398c0,0.082,0.066,0.149,0.148,0.149C5.08,2.352,5.146,2.285,5.146,2.203z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M4.85,7.796v1.396c0,0.082,0.066,0.15,0.148,0.15c0.082,0,0.148-0.068,0.148-0.15V7.796c0-0.082-0.066-0.148-0.148-0.148C4.917,7.647,4.85,7.714,4.85,7.796z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M2.651,3.473L1.44,2.774C1.369,2.732,1.279,2.757,1.238,2.828C1.197,2.899,1.221,2.989,1.292,3.031l1.21,0.699c0.023,0.013,0.049,0.02,0.074,0.02c0.051,0,0.101-0.026,0.129-0.075C2.747,3.604,2.722,3.514,2.651,3.473z&quot;&gt;&lt;/path&gt;          &lt;path fill=&quot;none&quot; d=&quot;M8.704,6.968L7.493,6.269c-0.07-0.041-0.162-0.016-0.201,0.055c-0.041,0.07-0.018,0.162,0.053,0.203l1.211,0.699c0.023,0.012,0.049,0.02,0.074,0.02c0.051,0,0.102-0.027,0.129-0.074C8.8,7.101,8.776,7.009,8.704,6.968z&quot;&gt;&lt;/path&gt;      &lt;/g&gt;  &lt;/svg&gt;  &lt;svg version=&quot;1.1&quot; id=&quot;cloud&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;10px&quot; height=&quot;10px&quot; viewBox=&quot;0 0 10 10&quot; enable-background=&quot;new 0 0 10 10&quot; xml:space=&quot;preserve&quot;&gt;    &lt;path fill=&quot;none&quot; d=&quot;M8.528,5.624H8.247c-0.085,0-0.156-0.068-0.156-0.154c0-0.694-0.563-1.257-1.257-1.257c-0.098,0-0.197,0.013-0.3,0.038C6.493,4.259,6.45,4.252,6.415,4.229C6.38,4.208,6.356,4.172,6.348,4.131C6.117,3.032,5.135,2.235,4.01,2.235c-1.252,0-2.297,0.979-2.379,2.23c-0.004,0.056-0.039,0.108-0.093,0.13C1.076,4.793,0.776,5.249,0.776,5.752c0,0.693,0.564,1.257,1.257,1.257h6.495c0.383,0,0.695-0.31,0.695-0.692S8.911,5.624,8.528,5.624z&quot;&gt;&lt;/path&gt;  &lt;/svg&gt;  &lt;div class=&quot;rain&quot;&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;drop&quot;&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;div class=&quot;text&quot;&gt;    LOOKING OUTSIDE FOR YOU... ONE SEC  &lt;/div&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;div id=&quot;primary&quot; class=&quot;content-area&quot; style=&quot;&quot;&gt;    &lt;main id=&quot;main&quot; class=&quot;site-main&quot; role=&quot;main&quot;&gt;        &lt;div id=&quot;shuoshuo_content&quot;&gt;            &lt;div id=&quot;ccontent&quot;&gt;        &lt;/div&gt;&lt;div id=&quot;sa&quot;&gt;&lt;/div&gt;&lt;div id=&quot;saa&quot;&gt;&lt;/div&gt;&lt;textarea id=&quot;neirong&quot; placeholder=&quot;本页面仅支持站长发表说说，由于特殊原因关闭本页面评论功能&quot; style=&quot;width:100%;height:150px;background-image: url(https://cdn.jsdelivr.net/gh/drew233/cdn/20200409110727.webp);background-size: contain;background-repeat: no-repeat;background-position: right;&quot;&gt;&lt;/textarea&gt;&lt;button onclick=&quot;savecontent()&quot; style=&quot;float :right;&quot;&gt;biu~&lt;/button&gt;&lt;button onclick=&quot;preview()&quot; style=&quot;float :right;&quot;&gt;预览&lt;/button&gt;&lt;input type=&quot;password&quot; id=&quot;key&quot; value=&quot;&quot; class=&quot;mytxt&quot; placeholder=&quot;是时候验证你的身份了！&quot; autocomplete=&quot;off&quot;/&gt;&lt;div id=&quot;preview&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><ul><li>变量含义及作用</li><li><code>img</code>: 头像url链接</li><li><code>appID</code>: leancloud的应用appId</li><li><code>appKEY</code>: leancloud的应用appKey</li><li><code>per</code>: 每一部分想展示的说说数以及每次点击查看更多的时候显示的说说数</li><li><code>username</code>: 你在leancloud中添加的作为可发布说说的用户的用户名</li><li>每个参数均必须填写(若未自己修改js)</li></ul><p>至此就添加完毕了。访问<code>yoursite.com/shuoshuo</code>就能看到你的动态说说界面了。<br>每次发说说填上你在leancloud中设置的密码，再也不会有人可能冒充你发说说了呢。<br>效果图<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc6.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc6.webp" class="img-shadow img-margin"></center></a></p><h2 id="与valine的一些冲突"><a href="#与valine的一些冲突" class="headerlink" title="与valine的一些冲突"></a>与valine的一些冲突</h2><p>说说页面无法开启<code>valine</code>评论<br>如果不可以，请联系我或者在<code>GitHub</code>提交<code>issues</code></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本教程使用<code>hexo</code>默认主题做的示范，理论上任何主题均支持。<br>我只是一个小白，大家轻喷。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>valine添加自定义表情</title>
      <link href="/2020/04/09/valinebq/"/>
      <url>/2020/04/09/valinebq/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我使用的valine评论系统真的是棒，唯一我个人觉得不太舒服的就是表情说实话有点少。那怎么添加自定义表情呢？</p></blockquote><div class="note link green"><p>Valine最新版本已经支持自定义表情：<a href="https://valine.js.org/emoji.html" target="_blank" rel="noopener">https://valine.js.org/emoji.html</a></p></div><h2 id="下载js到本地"><a href="#下载js到本地" class="headerlink" title="下载js到本地"></a>下载js到本地</h2><p>点击下载：<a href="https://unpkg.com/valine@1.3.10/dist/Valine.min.js" target="_blank" rel="noopener">valine.min.js</a></p><h2 id="修改js中的表情部分"><a href="#修改js中的表情部分" class="headerlink" title="修改js中的表情部分"></a>修改js中的表情部分</h2><p>在这个js里面找到属于表情的部分，很好区分，因为原装的valine中的emoji表情是彩色的。在js中很好区分。<br><code>1.4+</code>之后的版本中作者对表情进行了处理。但是大致的逻辑并无改变。照葫芦画瓢即可。</p><p>表情部分大概是这样子的</p><pre><code class="lang-javascript">function(e,t){    e.exports={        grinning:&quot;😀&quot;,smiley:&quot;😃&quot;,smile:&quot;😄&quot;,grin:&quot;😁&quot;,laughing:&quot;😆&quot;,sweat_smile:&quot;😅&quot;,joy:&quot;😂&quot;,blush:&quot;😊&quot;,        innocent:&quot;😇&quot;,wink:&quot;😉&quot;,relieved:&quot;😌&quot;,heart_eyes:&quot;😍&quot;,kissing_heart:&quot;😘&quot;,kissing:&quot;😗&quot;,        kissing_smiling_eyes:&quot;😙&quot;,kissing_closed_eyes:&quot;😚&quot;,yum:&quot;😋&quot;,stuck_out_tongue_winking_eye:&quot;😜&quot;,              stuck_out_tongue_closed_eyes:&quot;😝&quot;,stuck_out_tongue:&quot;😛&quot;,sunglasses:&quot;😎&quot;,smirk:&quot;😏&quot;,unamused:&quot;😒&quot;,              disappointed:&quot;😞&quot;,pensive:&quot;😔&quot;,worried:&quot;😟&quot;,confused:&quot;😕&quot;,persevere:&quot;😣&quot;,confounded:&quot;😖&quot;,tired_face:&quot;😫&quot;,               weary:&quot;😩&quot;,angry:&quot;😠&quot;,rage:&quot;😡&quot;,no_mouth:&quot;😶&quot;,neutral_face:&quot;😐&quot;,expressionless:&quot;😑&quot;,hushed:&quot;😯&quot;,                frowning:&quot;😦&quot;,anguished:&quot;😧&quot;,open_mouth:&quot;😮&quot;,astonished:&quot;😲&quot;,dizzy_face:&quot;😵&quot;,flushed:&quot;😳&quot;,scream:&quot;😱&quot;,               fearful:&quot;😨&quot;,cold_sweat:&quot;😰&quot;,cry:&quot;😢&quot;,disappointed_relieved:&quot;😥&quot;,sob:&quot;😭&quot;,sweat:&quot;😓&quot;,sleepy:&quot;😪&quot;,               sleeping:&quot;😴&quot;,mask:&quot;😷&quot;,smiling_imp:&quot;😈&quot;,smiley_cat:&quot;😺&quot;,smile_cat:&quot;😸&quot;,joy_cat:&quot;😹&quot;,heart_eyes_cat:&quot;😻&quot;,               smirk_cat:&quot;😼&quot;,kissing_cat:&quot;😽&quot;,scream_cat:&quot;🙀&quot;,crying_cat_face:&quot;😿&quot;,pouting_cat:&quot;😾&quot;,cat:&quot;🐱&quot;,               mouse:&quot;🐭&quot;,cow:&quot;🐮&quot;,monkey_face:&quot;🐵&quot;,hand:&quot;✋&quot;,fist:&quot;✊&quot;,v:&quot;✌️&quot;,point_up:&quot;👆&quot;,point_down:&quot;👇&quot;,         point_left:&quot;👈&quot;,point_right:&quot;👉&quot;,facepunch:&quot;👊&quot;,wave:&quot;👋&quot;,clap:&quot;👏&quot;,open_hands:&quot;👐&quot;,&quot;+1&quot;:&quot;👍&quot;,&quot;-1&quot;:&quot;👎&quot;,        ok_hand:&quot;👌&quot;,pray:&quot;🙏&quot;,ear:&quot;👂&quot;,eyes:&quot;👀&quot;,nose:&quot;👃&quot;,lips:&quot;👄&quot;,tongue:&quot;👅&quot;,heart:&quot;❤️&quot;,cupid:&quot;💘&quot;,        sparkling_heart:&quot;💖&quot;,star:&quot;⭐️&quot;,sparkles:&quot;✨&quot;,zap:&quot;⚡️&quot;,sunny:&quot;☀️&quot;,cloud:&quot;☁️&quot;,snowflake:&quot;❄️&quot;,umbrella:&quot;☔️&quot;,        coffee:&quot;☕️&quot;,airplane:&quot;✈️&quot;,anchor:&quot;⚓️&quot;,watch:&quot;⌚️&quot;,phone:&quot;☎️&quot;,hourglass:&quot;⌛️&quot;,email:&quot;✉️&quot;,scissors:&quot;✂️&quot;,        black_nib:&quot;✒️&quot;,pencil2:&quot;✏️&quot;,x:&quot;❌&quot;,recycle:&quot;♻️&quot;,white_check_mark:&quot;✅&quot;,negative_squared_cross_mark:&quot;❎&quot;,        m:&quot;Ⓜ️&quot;,i:&quot;ℹ️&quot;,tm:&quot;™️&quot;,copyright:&quot;©️&quot;,registered:&quot;®️&quot;    }},</code></pre><p>虽然我看不懂这个，但是照葫芦画瓢还是可以的。<br>在这里面添加你想要的表情即可。注意如果是图片格式的，<code>img</code>标签中的链接的双引号一定要加上转义字符<code>\</code>。<br>这里放出来我添加后的一部分，仅供参考</p><pre><code class="lang-javascript">function(e,t){    e.exports={        傲娇:&quot;&lt;img src=\&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/20200409103906.webp\&quot; height=\&quot;15px\&quot;         width=\&quot;25px\&quot;&gt;&quot;,开心:&quot;&lt;img src=\&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/20200409104757.webp\&quot; /&gt;&quot;,扣手        手:&quot;&lt;img src=\&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/20200409130304.webp\&quot; /&gt;&quot;,仙女下凡:&quot;&lt;img         src=\&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/20200409130301.webp\&quot; /&gt;&quot;,得瑟:&quot;&lt;img src=\&quot;https://cdn.        jsdelivr.net/gh/drew233/cdn/20200409130258.webp\&quot; /&gt;&quot;,揉左脸:&quot;&lt;img src=\&quot;https://cdn.jsdelivr.net/gh/        drew233/cdn/20200409130254.webp\&quot; /&gt;&quot;,揉右脸:&quot;&lt;img src=\&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/        20200409130249.webp\&quot; /&gt;&quot;,滑稽:&quot;&lt;img src=\&quot;https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.9/img/Sakura/images/        smilies/icon_huaji.gif\&quot; width=\&quot;30px\&quot;/&gt;&quot;,grinning:&quot;😀&quot;,smiley:&quot;😃&quot;,smile:&quot;😄&quot;,grin:&quot;😁&quot;,.......,        negative_squared_cross_mark:&quot;❎&quot;,m:&quot;Ⓜ️&quot;,i:&quot;ℹ️&quot;,tm:&quot;™️&quot;,copyright:&quot;©️&quot;,registered:&quot;®️&quot;    }},</code></pre><h2 id="调用修改过的js"><a href="#调用修改过的js" class="headerlink" title="调用修改过的js"></a>调用修改过的js</h2><p>修改完成之后，本地调用或者cdn调用即可。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/nanshoua.webp" data-fancybox="images" data-caption="demo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/nanshoua.webp" class="img-shadow img-margin"></center></a><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200409210725.webp" data-fancybox="images" data-caption="20200409210725" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200409210725.webp" class="img-shadow img-margin"></center></a><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>最近也是加了valine的交流群，跟作者提了一下相关需求。作者已经做了出来（期待发布<br>毕竟我这种小白弄得那也确实不好看。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 632 (Div. 2) D. Challenges in school №41</title>
      <link href="/2020/04/09/cf1333D/"/>
      <url>/2020/04/09/cf1333D/</url>
      
        <content type="html"><![CDATA[<h1 id="Challenges-in-school-№41"><a href="#Challenges-in-school-№41" class="headerlink" title="Challenges in school №41"></a>Challenges in school №41</h1><p>Link: <a href="https://codeforces.com/contest/1333/problem/D" target="_blank" rel="noopener">Challenges in school №41</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There are n children, who study at the school №41. It is well-known that they are good mathematicians. Once at a break, they arranged a challenge for themselves. All children arranged in a row and turned heads either to the left or to the right.</p><p>Children can do the following: in one second several pairs of neighboring children who are looking at each other can simultaneously turn the head in the opposite direction. For instance, the one who was looking at the right neighbor turns left and vice versa for the second child. Moreover, every second at least one pair of neighboring children performs such action. They are going to finish when there is no pair of neighboring children who are looking at each other.</p><p>You are given the number n, the initial arrangement of children and the number k. You have to find a way for the children to act if they want to finish the process in exactly k seconds. More formally, for each of the k moves, you need to output the numbers of the children who turn left during this move.</p><p>For instance, for the configuration shown below and k=2 children can do the following steps:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200409171429.webp" data-fancybox="images" data-caption="20200409171429" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200409171429.webp" class="img-shadow img-margin"></center></a></p><p>At the beginning, two pairs make move: (1,2) and (3,4). After that, we receive the following configuration:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200409171448.webp" data-fancybox="images" data-caption="20200409171448" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200409171448.webp" class="img-shadow img-margin"></center></a></p><p>At the second move pair (2,3) makes the move. The final configuration is reached. Good job.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200409171459.webp" data-fancybox="images" data-caption="20200409171459" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200409171459.webp" class="img-shadow img-margin"></center></a></p><p>It is guaranteed that if the solution exists, it takes not more than <script type="math/tex">n^2</script> &quot;headturns&quot;.</p><p>Input<br>The first line of input contains two integers n and k (<script type="math/tex">2 \le n \le 3000</script>, <script type="math/tex">1 \le k \le 3000000</script>)  — the number of children and required number of moves.</p><p>The next line contains a string of length n and consists only of characters L and R, where L means that the child looks to the left and R means that the child looks to the right.</p><p>Output<br>If there is no solution, print a single line with number −1.</p><p>Otherwise, output k lines. Each line has to start with a number <script type="math/tex">n_i</script> (<script type="math/tex">1\le n_i \le \frac{n}{2}</script>)  — the number of pairs of children, who turn at this move. After that print <script type="math/tex">n_i</script> distinct integers  — the numbers of the children who will turn left during this move.</p><p>After performing all &quot;headturns&quot;, there can&#39;t be a pair of two neighboring children looking at each other.</p><p>If there are many solutions, print any of them.</p><p>Examples</p><blockquote><p>input<br>2 1<br>RL<br>output<br>1 1<br>input<br>2 1<br>LR<br>output<br>-1<br>input<br>4 2<br>RLRL<br>output<br>2 1 3<br>1 2</p></blockquote><p>Note<br>The first sample contains a pair of children who look at each other. After one move, they can finish the process.</p><p>In the second sample, children can&#39;t make any move. As a result, they can&#39;t end in k&gt;0 moves.</p><p>The third configuration is described in the statement.</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思是有n个小朋友，初始的时候每个小朋友朝向的方向都会给出来。每一秒，你可以选择任意对且至少一对对着看的小朋友让他们看到反方向，即<code>RL-&gt;LR</code>。<br>问你在能否正好在k秒后，使得所有小朋友中不存在对着看的。不能的话输出<code>-1</code>。</p><p>因为将一对小朋友操作之后，可能会产生另一对对着看的小朋友，所以我们可以发现，总操作次数会有一个最大值和最小值。</p><ul><li>当你每一次操作都选出当前所有对着看的小朋友并让他们看向反方向的时候，这是最小值。</li><li>当你每一次操作只选择一对小朋友让他们看向反方向的时候，这是最大值。</li></ul><p>所以如果k在这个范围内，一定存在可行解。因为我们可以通过贪心调整每一次选择的小朋友的对数来达到k。<br>反之，输出<code>-1</code>。</p><p>所以我们可以首先求出最小值和最大值，然后构建答案。<br>构建的时候，先一个一个的放，当剩下的时间（k）与剩下的需要操作的最小次数相等时，按照最小的操作次数来进行输出。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_backconst int maxn = 3e3+10;vector&lt;int&gt; v[maxn];char s[maxn];int main(){    int n,k,minn=0,maxx=0;    scanf(&quot;%d%d%s&quot;,&amp;n,&amp;k,s+1);    while(1){        minn++;        int flag=0;        for(int i=1;i&lt;n;i++){            if(s[i]==&#39;R&#39;&amp;&amp;s[i+1]==&#39;L&#39;){                flag=1;                v[minn].pb(i);            }        }        if(!flag)   break;//如果已经没有可以操作的小朋友，退出循环        for(auto pos:v[minn]){            swap(s[pos],s[pos+1]);        }        maxx+=v[minn].size();    }//minn最小值，maxn最大值    if(k&lt;minn-1||k&gt;maxx){        puts(&quot;-1&quot;);        return 0;    }    for(int i=1;i&lt;minn;i++){        while(!v[i].empty()&amp;&amp;k&gt;minn-i){            printf(&quot;%d %d\n&quot;, 1, v[i].back());            v[i].pop_back();            k--;        }//先一个一个放        if(!v[i].empty()){            printf(&quot;%d&quot;, v[i].size());            for (auto it : v[i])                printf(&quot; %d&quot;, it);            puts(&quot;&quot;);            k--;        }//然后按照最小的操作次数输出    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 632 (Div. 2) F. Kate and imperfection</title>
      <link href="/2020/04/09/cf1333F/"/>
      <url>/2020/04/09/cf1333F/</url>
      
        <content type="html"><![CDATA[<h1 id="Kate-and-imperfection"><a href="#Kate-and-imperfection" class="headerlink" title="Kate and imperfection"></a>Kate and imperfection</h1><p>Link: <a href="https://codeforces.com/contest/1333/problem/F" target="_blank" rel="noopener">Kate and imperfection</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Kate has a set S of n integers <script type="math/tex">\{1, \dots, n\}</script>.</p><p>She thinks that imperfection of a subset <script type="math/tex">M \subseteq S</script> is equal to the maximum of <script type="math/tex">gcd(a,b)</script> over all pairs <script type="math/tex">(a,b)</script> such that both a and b are in M and <script type="math/tex">a \neq b</script>.</p><p>Kate is a very neat girl and for each <script type="math/tex">k \in \{2, \dots, n\}</script> she wants to find a subset that has the smallest imperfection among all subsets in S of size k. There can be more than one subset with the smallest imperfection and the same size, but you don&#39;t need to worry about it. Kate wants to find all the subsets herself, but she needs your help to find the smallest possible imperfection for each size k, will name it <script type="math/tex">I_k</script>.</p><p>Please, help Kate to find <script type="math/tex">I_2</script>, <script type="math/tex">I_3</script>, ..., <script type="math/tex">I_n</script>.</p><p>Input<br>The first and only line in the input consists of only one integer n (<script type="math/tex">2\le n \le 5 \cdot 10^5</script>)  — the size of the given set S.</p><p>Output<br>Output contains only one line that includes n−1 integers: <script type="math/tex">I_2</script>, <script type="math/tex">I_3</script>, ..., <script type="math/tex">I_n</script>.</p><p>Examples</p><blockquote><p>input<br>2<br>output<br>1<br>input<br>3<br>output<br>1 1 </p></blockquote><p>Note<br>First sample: answer is 1, because <script type="math/tex">gcd(1, 2) = 1</script>.</p><p>Second sample: there are subsets of S with sizes 2,3 with imperfection equal to 1. For example, <script type="math/tex">\{2,3\}</script> and <script type="math/tex">\{1, 2, 3\}</script>.</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你一个数n，让你分别找出<script type="math/tex">1-n</script>这个序列的长度为<script type="math/tex">2-n</script>的子序列，使得子序列中两两间的<script type="math/tex">gcd</script>的最大值最小。输出这个最小值。</p><p>如果有质数，我们一定是往里面放质数。当质数用完的时候，我们怎么办呢？<br>因为我们要求的是两两间的<script type="math/tex">gcd</script>的最大值的最小。所以我们可以先放与当前序列中质数的<script type="math/tex">gcd</script>为2的数，然后是3，直到放完<br>放完之后，放入的每一个数的每一个因子在序列中都存在了，所以此时能产生的最大的<script type="math/tex">gcd</script>就是它的最大的因子。</p><p>然后我们用一个数组维护某一个数的最大因子，然后排序输出即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5+10;int p[maxn];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)   p[i]=1;    for(int i=2;i&lt;=n;i++){        for(int j=i+i;j&lt;=n;j+=i){            p[j]=i;        }    }    sort(p+1,p+1+n);    for(int i=2;i&lt;=n;i++)   cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo使用hexo-generator-search添加local-search</title>
      <link href="/2020/04/07/local-search/"/>
      <url>/2020/04/07/local-search/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客中的搜索功能我也是用过不少了。速度是很关键的一个问题。今天突然想起来之前next主题的搜索速度很理想。所以移植一下。next主题的一键就可以了，绕道吧。</p></blockquote><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>在博客根目录下运行</p><pre><code class="lang-git">npm install hexo-generator-search --save</code></pre><p>然后在博客根目录下添加以下语句</p><pre><code class="lang-yml">search:  path: search.xml  field: post  content: true</code></pre><h1 id="引用js和css"><a href="#引用js和css" class="headerlink" title="引用js和css"></a>引用js和css</h1><p>因为和next的框架不同，所以js和css我做了以下调整。可以直接调用我的链接（不保证稳定性），也可以下载后放入自己调用的地方。</p><pre><code>js: https://cdn.jsdelivr.net/gh/drew233/css/fsearch.min.jscss: https://cdn.jsdelivr.net/gh/drew233/css/rfsearch.min.css</code></pre><p>你也可以根据你的实际情况，调整css（我的css没调太好，牵扯太多，懒</p><h1 id="设置弹出搜索框元素"><a href="#设置弹出搜索框元素" class="headerlink" title="设置弹出搜索框元素"></a>设置弹出搜索框元素</h1><p>在你主题下的对应模板文件中<br>如Sakura主题中的<code>layout.ejs</code>中添加</p><pre><code class="lang-html">&lt;div class=&quot;site-search&quot;&gt;      &lt;div class=&quot;popup search-popup&quot; style=&quot;display: none;&quot;&gt;      &lt;div class=&quot;search-header&quot;&gt;    &lt;span class=&quot;search-icon&quot;&gt;      &lt;i class=&quot;fa fa-search&quot;&gt;&lt;/i&gt;    &lt;/span&gt;    &lt;div class=&quot;search-input-container&quot;&gt;      &lt;input autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;none&quot; placeholder=&quot;输入关键词搜索&quot; spellcheck=&quot;false&quot; type=&quot;text&quot; id=&quot;search-input&quot;&gt;    &lt;/div&gt;    &lt;span class=&quot;popup-btn-close&quot;&gt;      &lt;i class=&quot;fa fa-times-circle&quot;&gt;&lt;/i&gt;    &lt;/span&gt;    &lt;/div&gt;    &lt;div id=&quot;search-result&quot;&gt;      &lt;div id=&quot;no-result&quot;&gt;&lt;i class=&quot;fa fa-frown-o fa-5x&quot;&gt;&lt;/i&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;search-pop-overlay&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h1 id="添加搜索"><a href="#添加搜索" class="headerlink" title="添加搜索"></a>添加搜索</h1><p>此时你已经可以使用本地搜索了，只需要在你觉得合适的模板文件添加一下代码即可</p><pre><code class="lang-html">&lt;a role=&quot;button&quot; class=&quot;popup-trigger&quot;&gt;“这里的内容可以自己随意调整”&lt;/a&gt;</code></pre><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><a role="button" class="popup-trigger">Demo(点此查看效果)</a></p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200407230541.webp" data-fancybox="images" data-caption="20200407230541" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200407230541.webp" class="img-shadow img-margin"></center></a><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实我现在才知道这种搜索方式之所以速度不会卡太久，是因为只有你点击了搜索，才会加载本地的用来检索的文件。这样想来，确实也没什么可以说的了，不是主题自带的搜索不好用，是我不会用，菜是原罪。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU-1074  Doing Homework</title>
      <link href="/2020/04/06/hdu1074/"/>
      <url>/2020/04/06/hdu1074/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1074-Doing-Homework"><a href="#HDU-1074-Doing-Homework" class="headerlink" title="HDU-1074  Doing Homework"></a>HDU-1074  Doing Homework</h1><p>Link: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1074" target="_blank" rel="noopener">HDU-1074  Doing Homework</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Ignatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test, 1 day for 1 point. And as you know, doing homework always takes a long time. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.</p><p>Input<br>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case start with a positive integer N(1&lt;=N&lt;=15) which indicate the number of homework. Then N lines follow. Each line contains a string S(the subject&#39;s name, each string will at most has 100 characters) and two integers D(the deadline of the subject), C(how many days will it take Ignatius to finish this subject&#39;s homework).</p><p>Note: All the subject names are given in the alphabet increasing order. So you may process the problem much easier.</p><p>Output<br>For each test case, you should output the smallest total reduced score, then give out the order of the subjects, one subject in a line. If there are more than one orders, you should output the alphabet smallest one.</p><p>Sample Input</p><blockquote><p>2<br>3<br>Computer 3 3<br>English 20 1<br>Math 3 2<br>3<br>Computer 3 3<br>English 6 3<br>Math 6 3</p></blockquote><p>Sample Output</p><blockquote><p>2<br>Computer<br>Math<br>English<br>3<br>Computer<br>English<br>Math</p></blockquote><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就你在做家庭作业。每种作业都有一个需要花费的时间以及截至时间，如果你完成这个作业的时间超过了截止时间，就会被罚超过时间的分数。超过1就罚一分。让你输出所有作业完成之后的最少扣多少分，以及完成作业的顺序。</p><p>注意到这里的作业数总共最多就15种。如果暴力枚举所有情况，那是<script type="math/tex">O(n!)</script>的复杂度，肯定会超时。这时候就用到了状压dp（状态压缩）。<br>为什么叫状态压缩呢，我们用一个长度为15的二进制串中的每一位的<script type="math/tex">0/1</script>代表每一个作业的完成情况。这样的话复杂度就会很低，<script type="math/tex">O(2^{15})</script>。</p><blockquote><p>例如</p><p><script type="math/tex">0</script>： <script type="math/tex">000</script>  就代表都未完成</p><p><script type="math/tex">5</script>： <script type="math/tex">101</script>  就代表第一个和第三个作业完成，第二个未完成</p><p><script type="math/tex">7</script>： <script type="math/tex">111</script>  就代表都完成</p></blockquote><p>状态转移，即假设对于作业<script type="math/tex">k</script>，在状态<script type="math/tex">i</script>中，<script type="math/tex">k</script>已完成，可以由另一个与状态<script type="math/tex">i</script>基本一样，只有<script type="math/tex">k</script>未完成的状态<script type="math/tex">j</script>转移得到。</p><blockquote><p>例如</p><p><script type="math/tex">1101</script>  可由    <script type="math/tex">1001</script>得到</p><p><script type="math/tex">1101</script>  不可由  <script type="math/tex">0001</script>得到</p></blockquote><p>所以我们从<script type="math/tex">1-2^{n}</script>遍历每一种状态，再根据状态转移确定每一种状态到达的时候所会扣的最少的分。</p><p>用<script type="math/tex">dp_i</script>表示到达状态<script type="math/tex">i</script>会扣的最少的分，那么显然最后作业全部完成后扣的最少的分为<script type="math/tex">dp_{2^{n}-1}</script>，关于作业完成顺序，我们添加一个辅助数组记录每次转移的状态的上一个状态，递归输出即可。</p><p>一个与状态<script type="math/tex">i</script>基本一样，只有<script type="math/tex">k</script>未完成的状态<script type="math/tex">j</script>如何得到呢？</p><blockquote><p>例如<br> 状态<script type="math/tex">i</script>为<script type="math/tex">11011</script>，<script type="math/tex">k</script>为作业2，<script type="math/tex">i-(1<<k)</script>就是<script type="math/tex">j</script>，<script type="math/tex">j</script>为<script type="math/tex">11001</script></p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">const int maxn = 20;int dp[1&lt;&lt;maxn],fa[1&lt;&lt;maxn],cost[1&lt;&lt;maxn],d[maxn],c[maxn];string s[maxn];void print(int x){    if(!x)  return ;    print(x-(1&lt;&lt;fa[x]));    cout&lt;&lt;s[fa[x]]&lt;&lt;endl;}int main(){    int t,n;    cin&gt;&gt;t;    while(t--){        cin&gt;&gt;n;        for(int i=0;i&lt;n;i++)    cin&gt;&gt;s[i]&gt;&gt;d[i]&gt;&gt;c[i];        for(int i=1;i&lt;(1&lt;&lt;n);i++){            dp[i]=0x3f3f3f3f;            for(int j=n-1;j&gt;=0;j--){                int mid=(1&lt;&lt;j);                if(!(i&amp;mid))    continue;                int val=max(0,cost[i-mid]+c[j]-d[j]);                if(dp[i]&gt;dp[i-mid]+val){                    dp[i]=dp[i-mid]+val;                    cost[i]=cost[i-mid]+c[j];                    fa[i]=j;                }            }        }        cout&lt;&lt;dp[(1&lt;&lt;n)-1]&lt;&lt;endl;        print((1&lt;&lt;n)-1);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript实现Hexo中给时间久远的文章增加友好的提示</title>
      <link href="/2020/04/04/date/"/>
      <url>/2020/04/04/date/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在逛各种大佬博客的时候发现了有一款typecho的主题handsome中在时间久远的文章首部会有个相关的提示，第一眼就爱上了。就想着在我的hexo中实现一下，效果还不错拿出来分享一下。</p></blockquote><h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>每次搜个什么解决方案，对着做了好久突然报错，才发现是古董级别的文章。说实话是有点想爆粗口的。正好我的博客文章逐渐过多，对于时间久远的文章增添一个提示还是很有必要的。（会少很多人在我这爆粗口吧🙃</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>hexo文章会有date的属性，可以得到每篇文章的发布时间以及最近一次更新时间。再使用js计算时间差即可。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h2><p>这部分你可以新建一个js文件再引用，但是由于一些特殊原因，写进js文件引用需要操作，所以推荐直接像我一样放在<code>common-article.ejs</code>（文章模板）中。想自己引入的话可以自己钻研一下。</p><pre><code class="lang-javascript">function intervalTime(startTime,endTime){        var date1 = new Date(startTime);        var date2 = new Date(endTime);          var date3 = date2.getTime() - date1.getTime();         var days = Math.floor(date3 / (24 * 3600 * 1000));        return days;}function format(Date){  var Y = Date.getFullYear();  var M = Date.getMonth() + 1;    M = M &lt; 10 ? &#39;0&#39; + M : M;  var D = Date.getDate();    D = D &lt; 10 ? &#39;0&#39; + D : D;  var H = Date.getHours();    H = H &lt; 10 ? &#39;0&#39; + H : H;  var Mi = Date.getMinutes();    Mi = Mi &lt; 10 ? &#39;0&#39; + Mi : Mi;  var S = Date.getSeconds();    S = S &lt; 10 ? &#39;0&#39; + S : S;    return Y + &#39;-&#39; + M + &#39;-&#39; + D + &#39; &#39; + H + &#39;:&#39; + Mi + &#39;:&#39; + S;}var pdate = new Date(&quot;&lt;%- post.date %&gt;&quot;);var update = new Date(&quot;&lt;%- post.updated %&gt;&quot;);var now = new Date();now=format(now);pdate=format(pdate);update=format(update);var days=intervalTime(pdate,now),udays=intervalTime(update,now);var mid=parseInt(days,10);var mi=parseInt(&quot;30&quot;,10);if(mid &gt; mi){  document.getElementById(&quot;point&quot;).innerHTML=&quot;&lt;div class=\&quot;tip share\&quot;&gt;请注意，本文编写于&quot;+days+&quot;天前，最后修改于&quot;+udays+&quot;天前，其中某些信息可能已经过时。&lt;img src=\&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/kawayi.webp\&quot;&gt;&lt;\img&gt; &lt;/div&gt;&quot;;}</code></pre><p>这里我们要找到放置提示的合理位置，并在模板文件中对应的位置添加</p><pre><code class="lang-html">&lt;div id=&quot;point&quot;&gt;&lt;/div&gt;</code></pre><p>注意，无论你是写了一个js引用，还是直接把js写入了模板文件中，一定要在<code>&lt;div id=&quot;point&gt;&lt;/div&gt;</code>的后面引用js。</p><p>为了加强效果，放出来我的模板文件的这部分，仅供参考</p><pre><code class="lang-html">&lt;div id=&quot;content&quot; class=&quot;site-content&quot;&gt;  &lt;div id=&quot;primary&quot; class=&quot;content-area&quot;&gt;    &lt;main id=&quot;main&quot; class=&quot;site-main&quot; role=&quot;main&quot;&gt;      &lt;div id=&quot;point&quot;&gt;&lt;/div&gt;        &lt;script&gt;          function intervalTime(startTime,endTime){              var date1 = new Date(startTime);              var date2 = new Date(endTime);                var date3 = date2.getTime() - date1.getTime();               var days = Math.floor(date3 / (24 * 3600 * 1000));              return days;          }          function format(Date){            var Y = Date.getFullYear();            var M = Date.getMonth() + 1;              M = M &lt; 10 ? &#39;0&#39; + M : M;            var D = Date.getDate();              D = D &lt; 10 ? &#39;0&#39; + D : D;            var H = Date.getHours();              H = H &lt; 10 ? &#39;0&#39; + H : H;            var Mi = Date.getMinutes();              Mi = Mi &lt; 10 ? &#39;0&#39; + Mi : Mi;            var S = Date.getSeconds();              S = S &lt; 10 ? &#39;0&#39; + S : S;              return Y + &#39;-&#39; + M + &#39;-&#39; + D + &#39; &#39; + H + &#39;:&#39; + Mi + &#39;:&#39; + S;          }          var pdate = new Date(&quot;&lt;%- post.date %&gt;&quot;);          var update = new Date(&quot;&lt;%- post.updated %&gt;&quot;);          var now = new Date();          now=format(now);          pdate=format(pdate);          update=format(update);          var days=intervalTime(pdate,now),udays=intervalTime(update,now);          var mid=parseInt(days,10);          var mi=parseInt(&quot;30&quot;,10);          if(mid &gt; mi){            document.getElementById(&quot;point&quot;).innerHTML=&quot;&lt;div class=\&quot;tip share\&quot;&gt;请注意，本文编写于&quot;+days+&quot;天前，最后修改于&quot;+udays+&quot;天前，其中某些信息可能已经过时。&lt;img src=\&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/kawayi.webp\&quot;&gt;&lt;\img&gt; &lt;/div&gt;&quot;;          }        &lt;/script&gt;      &lt;article id=&quot;post-1&quot; class=&quot;post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized&quot;&gt;        &lt;div class=&quot;toc&quot;&gt;&lt;/div&gt;        &lt;!--&lt;div class=&quot;toc-entry-content&quot;&gt;&lt;!-- 套嵌目录使用（主要为了支援评论）--&gt;        &lt;% if (!post.photos[0]){ %&gt;          &lt;header class=&quot;entry-header&quot;&gt;            &lt;h1 class=&quot;entry-title&quot;&gt;&lt;%- post.title %&gt;&lt;/h1&gt;            &lt;p class=&quot;entry-census&quot;&gt;&lt;%- post.author %&gt;&amp;nbsp;·&amp;nbsp;&lt;%= date(post.date, &#39;YYYY-M-D&#39;) %&gt;&amp;nbsp;·&amp;nbsp;&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&lt;/p&gt;&lt;/p&gt;            &lt;hr&gt;          &lt;/header&gt;        &lt;% } %&gt;</code></pre><h2 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h2><p>这部分主要还是参考原版主题中的css，但是我自己也大概改了一下。你可以通过<code>F12</code>调整到适合自己博客的样式。<br>我的css</p><pre><code class="lang-css">.tip.share {    border-left-color: rgb(238, 5, 5);    background: #fff;}.tip {    display:block;    background: #fff;    padding: 8px 20px;    position: relative;    margin: 0 0 20px;    font-family: Georgia, serif;    font-size: 16px;    line-height: 1.2;    color: #666;    text-align: justify;    border-left: 5px solid      #3CB371;    /*盒子阴影 - (选项)*/    -moz-box-shadow: 2px 2px 15px #ccc;    -webkit-box-shadow: 2px 2px 15px #ccc;    box-shadow: 2px 2px 15px #ccc;}.tip.share:before {    background: #ddd;    content: &quot;🐷&quot;;}.tip:before {    background: #38a3fd;    border-radius: 50%;    color: #fff;    content: &quot;i&quot;;    font-family: Dosis,&quot;Source Sans Pro&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif;    font-size: 16px;    height: 21px;    line-height: 21px;    margin-left: -32px;    margin-top: 8px;    position: absolute;    text-align: center;    width: 21px;}</code></pre><h1 id="一个已知的小bug"><a href="#一个已知的小bug" class="headerlink" title="一个已知的小bug"></a>一个已知的小bug</h1><p>因为直接修改了模板文件，所以每一篇文章的最近一次更新时间都会变成你修改模板的那个时间。这个莫得办法解决了。不是很影响（个人认为。</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200404235405.webp" data-fancybox="images" data-caption="20200404235405" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200404235405.webp" class="img-shadow img-margin"></center></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从七牛到又拍，最后我选择了jsDelivr</title>
      <link href="/2020/04/02/jsdelivr/"/>
      <url>/2020/04/02/jsdelivr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对于图床的探索，真的是一波INF折。前排声明，又拍和七牛很好用，只不过不适合我，类似于我这种的个人博客站点吐血推荐使用jsDelivr</p></blockquote><p>在博客最初的成立阶段，我使用的大部分是网上的免费图床。例如</p><ul><li><a href="https://imgchr.com/" target="_blank" rel="noopener">路过图床</a></li><li><a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a></li></ul><p>等等。但是随着时间推移，发现这些图床的速度不是很理想（也许是我的原因。但他们确实已经不能满足我的需要了。</p><p>于是我跟着网友的引导使用了七牛云的存储作为图床使用，刚用到七牛云的时候，那速度，是真的爽。没爽几天，所有链接全部失效。原来是七牛分配的测试域名到期。需要用自己的域名绑定，域名？我有啊。满心欢喜的填上之后，才发现，需要备案域名。那对不起，再见，我（laozi）再也不回来了。</p><p>走的时候很潇洒，继续找合适的图床的时候就很狼狈。最后我意识到一个问题，既然js和css都是直接引用的<code>GitHub</code>上面的，那为什么不直接放在<code>GitHub</code>上呢。所以我把我的图片全放在了博客目录下去调用。咳咳，有点常识的小伙伴应该已经知道了这之后发生了什么。具体我就不再细说了，就是最后我又踏上了寻找合适的图床之路。<br>（其实这时我已经听说<code>jsDelivr</code>了，但是我想着再怎么加速，也是<code>GitHub</code>上面的东西，快不到哪去，就没尝试去用</p><p>兜兜转转，在学长的帮助下，搞了一个备案的域名，我又回来使用七牛了。（真香。不得不说七牛用起来确实舒服，上年暑假我入手了自己的学生机。备案了自己的域名。但随着博文越来越多，我还贼喜欢图片。图片也越来越多。七牛免费的流量渐渐不够用，那时候七牛我还不舍得用<code>https</code>，贵啊。后来每月的流量基本能花五块钱左右。扣我钱？那对不起，再见，我（laozi）再也不回来了。</p><p>我抱着我备过案的域名又是一波找寻，在网友的帮助下我了解到了又拍云。又拍云有一个连萌，你每年能获得大约70人民币左右的代金券。如果流量（此处指的不是浏览量）少，自然是够用的。可是我博客中的图片很多，每次<code>hexo s</code>我感觉都在烧我的代金券。前不久我看我的代金券怎么算都不够一年用的，还买了个流量包，<code>20人民币，100G流量，三个月有效期</code>。对没错，我花钱了。因为那时我觉得我已经上了贼船，下不去了。</p><p>随着图片越来越多，每天的花费越来越大。可能就有些人会想说了，你一个小站，事儿咋这么多？<br>嗯，我确实是小站，但是我也会拿出十二分的认真对待。因为在我看来，这不止是一个小站，还是我心里的一方净土。我喜欢我的博客。</p><p>最后在我咨询了许多人关于<code>jsDelivr</code>的速度之后，得到的都是肯定答复。我决定弃用又拍，改用<code>jsDelivr</code>。<br>换了之后才发现，<code>jsDelivr</code>是真的香。速度快，不限流量，而且基本上讲道理不会崩。（听说因为都是大厂，所以跑路可能性为0</p><p>使用<code>jsDelivr</code>CDN加速的教程很多，我就不再写了（主要是我也说不清，放几个我参考的链接出来吧</p><ul><li><a href="https://yremp.live/jsdeliver/" target="_blank" rel="noopener">使用jsDelivr+github搭建免费的cdn ——流年</a></li><li><a href="https://www.itrhx.com/2019/02/10/A18-free-cdn/" target="_blank" rel="noopener">免费CDN：jsDelivr + Github ——TRHX&#39;S BLOG</a></li></ul><p>当然你也可以配合picgo使用，更方便</p><ul><li><a href="https://www.itrhx.com/2019/08/01/A27-image-hosting/" target="_blank" rel="noopener">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床 ——TRHX&#39;S BLOG</a></li></ul><p>使用了<code>jsDelivr</code>之后，我在<code>Google PageSpeed Insights</code>的评分<strong>高达97</strong>分。之前用又拍的时候还没上过五十。完虐啊，爱了爱了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200402091103.webp" data-fancybox="images" data-caption="20200402091103" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200402091103.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
            <tag> jsdelivr </tag>
            
            <tag> speed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客一周年纪念暨INFO-CF正式发布</title>
      <link href="/2020/03/26/oneyear/"/>
      <url>/2020/03/26/oneyear/</url>
      
        <content type="html"><![CDATA[<h1 id="博客一周年"><a href="#博客一周年" class="headerlink" title="博客一周年"></a>博客一周年</h1><h2 id="想说的话"><a href="#想说的话" class="headerlink" title="想说的话"></a>想说的话</h2><p>在今天到来之前一直想着一周年的时候一定要写一篇长文表达一下自己的情感（水一篇文章，但到了这个时候还真有种不知道说什么的感觉。总之就是只要我有这个能力，我的博客就不会停。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="Google-search-console-amp-Google-Analytics数据"><a href="#Google-search-console-amp-Google-Analytics数据" class="headerlink" title="Google search console &amp; Google Analytics数据"></a>Google search console &amp; Google Analytics数据</h3><p>本站于<strong>2019.4.23</strong>日更换域名并接入<strong>Google search console</strong>，至今数据总览<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326094947.webp" data-fancybox="images" data-caption="20200326094947" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326094947.webp" class="img-shadow img-margin"></center></a></p><p>本站于<strong>2020.1.23</strong>日接入<strong>Google Analytics</strong><br>每日的用户数在<strong>50</strong>左右浮动，用户数数据总览。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326100759.webp" data-fancybox="images" data-caption="20200326100759" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326100759.webp" class="img-shadow img-margin"></center></a></p><p>流量渠道总览<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326101015.webp" data-fancybox="images" data-caption="20200326101015" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326101015.webp" class="img-shadow img-margin"></center></a></p><p>页面价值Top10总览<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326101118.webp" data-fancybox="images" data-caption="20200326101118" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326101118.webp" class="img-shadow img-margin"></center></a></p><p>从这个榜单可以看的出来我是有多失败，只有第九和第十是题解。排名第二的是一个绑鞋带的教程（TAT</p><p>这里得提一下<br>大部分的浏览量源自我跟我的小伙伴(<a href="http://sqdxwz.com/" target="_blank" rel="noopener">Rongsheng Wang</a> &amp;  <a href="https://angelni.github.io/" target="_blank" rel="noopener">Hui Ning</a>)翻译的<strong>Chevereto中文文档</strong>。<br>感谢当时小伙伴愿意帮我一起翻译，现在看起来效果还是很好的。</p><h3 id="百度资源平台数据"><a href="#百度资源平台数据" class="headerlink" title="百度资源平台数据"></a>百度资源平台数据</h3><p>索引量：站点中有多少页面可以作为搜索候选结果，就是一个网站的索引量。<br>本站于<strong>2019.5.20</strong>接入百度资源平台（百度站长工具），至今索引量已达<strong>300+</strong><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326101738.webp" data-fancybox="images" data-caption="20200326101738" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326101738.webp" class="img-shadow img-margin"></center></a></p><p>百度中的流量与关键词总览<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326102003.webp" data-fancybox="images" data-caption="20200326102003" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326102003.webp" class="img-shadow img-margin"></center></a></p><h3 id="收录情况"><a href="#收录情况" class="headerlink" title="收录情况"></a>收录情况</h3><h4 id="网页收录情况"><a href="#网页收录情况" class="headerlink" title="网页收录情况"></a>网页收录情况</h4><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326105429.webp" data-fancybox="images" data-caption="20200326105429" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326105429.webp" class="img-shadow img-margin"></center></a><h4 id="关键词优化"><a href="#关键词优化" class="headerlink" title="关键词优化"></a>关键词优化</h4><p>（其实并没有优化过，只是放出来搜索Uncle_drew的结果）<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326105512.webp" data-fancybox="images" data-caption="20200326105512" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326105512.webp" class="img-shadow img-margin"></center></a></p><h3 id="文章统计"><a href="#文章统计" class="headerlink" title="文章统计"></a>文章统计</h3><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326110225.webp" data-fancybox="images" data-caption="20200326110225" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200326110225.webp" class="img-shadow img-margin"></center></a><p>由此可见，我更新（水）博客的速度还是很可观的。</p><h2 id="最后想说的话"><a href="#最后想说的话" class="headerlink" title="最后想说的话"></a>最后想说的话</h2><p>博客的情况还是挺满足我心里的预期情况的。我喜欢我的博客，就这样。<br>前一段时间我就在想只说一个周年纪念显得太过空洞且矫情。正好也想试一下api怎么使用。所以做了一个站，就在昨天想要实现的功能基本实现了，借着一周年的喜庆发布出来。</p><h1 id="INFO-CF发布"><a href="#INFO-CF发布" class="headerlink" title="INFO-CF发布"></a>INFO-CF发布</h1><p>本站主要针对<strong>CodeForces</strong>集成了以下功能</p><ul><li>CF站个人信息<ul><li>注册时间及上次在线时间</li><li>Rating及Rating变化</li><li>参与比赛及结果</li></ul></li><li>CF竞赛信息<ul><li>近期比赛</li><li>已结束比赛</li></ul></li><li>CFhelper-本站最令我自豪的一个功能<ul><li>比赛中题目的通过人数情况</li><li>朋友榜单（Friends Standing）</li><li>翻译功能</li></ul></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>国内高速传送门：<a href="https://codeforces.site/" target="_blank" rel="noopener">INFO-CF</a></li><li>传送门：<a href="https://world.codeforces.site/" target="_blank" rel="noopener">INFO-CF | World</a></li><li>本站GitHub地址：<a href="https://github.com/Drew233/drew233.github.io" target="_blank" rel="noopener">INFO-CF | Github</a></li></ul><h2 id="收录情况-1"><a href="#收录情况-1" class="headerlink" title="收录情况"></a>收录情况</h2><p>本站已于<strong>2020.3.26</strong>提交至谷歌及百度收录，从今日起推广宣传。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces获取Personal apiKey&amp;secret</title>
      <link href="/2020/03/25/cfapi/"/>
      <url>/2020/03/25/cfapi/</url>
      
        <content type="html"><![CDATA[<h1 id="首先登录CF，点击右上角的用户名进入个人信息界面"><a href="#首先登录CF，点击右上角的用户名进入个人信息界面" class="headerlink" title="首先登录CF，点击右上角的用户名进入个人信息界面"></a>首先登录CF，点击右上角的用户名进入个人信息界面</h1><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114631.webp" data-fancybox="images" data-caption="20200325114631" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114631.webp" class="img-shadow img-margin"></center></a><h1 id="点击setting进入设置界面"><a href="#点击setting进入设置界面" class="headerlink" title="点击setting进入设置界面"></a>点击setting进入设置界面</h1><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114712.webp" data-fancybox="images" data-caption="20200325114712" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114712.webp" class="img-shadow img-margin"></center></a><h1 id="此时的菜单栏会出现变化，点击API进入API页面"><a href="#此时的菜单栏会出现变化，点击API进入API页面" class="headerlink" title="此时的菜单栏会出现变化，点击API进入API页面"></a>此时的菜单栏会出现变化，点击API进入API页面</h1><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114747.webp" data-fancybox="images" data-caption="20200325114747" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114747.webp" class="img-shadow img-margin"></center></a><h1 id="点击Add-API-key添加，然后会让你输入你的用户名及密码。"><a href="#点击Add-API-key添加，然后会让你输入你的用户名及密码。" class="headerlink" title="点击Add API key添加，然后会让你输入你的用户名及密码。"></a>点击<code>Add API key</code>添加，然后会让你输入你的用户名及密码。</h1><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114853.webp" data-fancybox="images" data-caption="20200325114853" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114853.webp" class="img-shadow img-margin"></center></a><h1 id="至此你的API-apiKey-amp-secret已经生成好了。你可以直接在上面复制使用，以后进来这个页面的时候上面不会显示，点击箭头指的地方就可以看到复制的地方。"><a href="#至此你的API-apiKey-amp-secret已经生成好了。你可以直接在上面复制使用，以后进来这个页面的时候上面不会显示，点击箭头指的地方就可以看到复制的地方。" class="headerlink" title="至此你的API apiKey&amp;secret已经生成好了。你可以直接在上面复制使用，以后进来这个页面的时候上面不会显示，点击箭头指的地方就可以看到复制的地方。"></a>至此你的API apiKey&amp;secret已经生成好了。你可以直接在上面复制使用，以后进来这个页面的时候上面不会显示，点击箭头指的地方就可以看到复制的地方。</h1><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114924.webp" data-fancybox="images" data-caption="20200325114924" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200325114924.webp" class="img-shadow img-margin"></center></a>]]></content>
      
      
      <categories>
          
          <category> INFO-cf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
            <tag> Tutorial </tag>
            
            <tag> 建站 </tag>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 84 (Rated for Div. 2) E. Count The Blocks</title>
      <link href="/2020/03/24/cf1327E/"/>
      <url>/2020/03/24/cf1327E/</url>
      
        <content type="html"><![CDATA[<h1 id="E-Count-The-Blocks"><a href="#E-Count-The-Blocks" class="headerlink" title="E. Count The Blocks"></a>E. Count The Blocks</h1><p>Link: <a href="https://codeforces.com/contest/1327/problem/E" target="_blank" rel="noopener">E. Count The Blocks</a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You wrote down all integers from 0 to <script type="math/tex">10^n - 1</script>, padding them with leading zeroes so their lengths are exactly n. For example, if <script type="math/tex">n=3</script> then you wrote out 000, 001, ..., 998, 999.</p><p>A block in an integer x is a consecutive segment of equal digits that cannot be extended to the left or to the right.</p><p>For example, in the integer <script type="math/tex">00027734000</script> there are three blocks of length <script type="math/tex">1</script>, one block of length <script type="math/tex">2</script> and two blocks of length <script type="math/tex">3</script>.</p><p>For all integers <script type="math/tex">i</script> from <script type="math/tex">1</script> to <script type="math/tex">n</script> count the number of blocks of length <script type="math/tex">i</script> among the written down integers.</p><p>Since these integers may be too large, print them modulo <script type="math/tex">998244353</script>.</p><p>Input<br>The only line contains one integer <script type="math/tex">n</script> (<script type="math/tex">1 \le n \le 2 \cdot 10^5</script>).</p><p>Output<br>In the only line print <script type="math/tex">n</script> integers. The <script type="math/tex">i</script>-th integer is equal to the number of blocks of length <script type="math/tex">i</script>.</p><p>Since these integers may be too large, print them modulo <script type="math/tex">998244353</script>.</p><p>Examples<br>input<br>1<br>output<br>10<br>input<br>2<br>output<br>180 10</p><h1 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h1><p>这道题的意思就是给你一个数<script type="math/tex">n</script>，让你往这n位上面随意放置<script type="math/tex">0-9</script>这<script type="math/tex">10</script>个数字。问你所有摆放情况中，每种长度个相邻且相等的子串的个数。（<script type="math/tex">123000</script>中有<script type="math/tex">3</script>个长度为<script type="math/tex">1</script>的(<script type="math/tex">1,2,3</script>)，<script type="math/tex">1</script>个长度为<script type="math/tex">3</script>的(<script type="math/tex">000</script>)）<br>排列组合的问题，我们分情况考虑一下。假设现在求得是长度为<script type="math/tex">i</script>的子串个数</p><ol><li>这个串在最左边或者最右边。此时这个长度为<script type="math/tex">i</script>的子串有<script type="math/tex">10</script>种情况（<script type="math/tex">0-9</script>），与这个子串相邻的下（上）一位不能和它相等，若相等长度就是<script type="math/tex">i+1</script>了。所以只有<script type="math/tex">9</script>种情况。剩下的<script type="math/tex">n-i-1</script>位这<script type="math/tex">10</script>个数可以随便填。所以这种情况下的长度为<script type="math/tex">i</script>的字串个数<script type="math/tex">=10*2*9*10^{n-i-1}</script>，乘<script type="math/tex">2</script>是因为可以在左右两边。</li><li>这个串处于中间。此时这个长度为<script type="math/tex">i</script>的子串也是有<script type="math/tex">10</script>种情况（<script type="math/tex">0-9</script>），与它相邻的两位，都只有<script type="math/tex">9</script>种情况。剩下的<script type="math/tex">n-i-2</script>位可以随便填。在长度为<script type="math/tex">n</script>的串中长度为<script type="math/tex">i</script>的子串个数为<script type="math/tex">n-i+1</script>，但是左右两边的不是这种情况讨论的，所以还剩下<script type="math/tex">n-i-1</script>种。所以这种情况下的长度为<script type="math/tex">i</script>的子串个数<script type="math/tex">=10*9*9*10^{n-i-2}*(n-i+1)</script>。</li></ol><p>将两种情况得到的答案加起来即可。长度为<script type="math/tex">n</script>的情况比较特殊我们直接输出就好了。</p><p>可能是我高中数学或者概率论没有学好吧，这种题（一言难尽）</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 2e5 + 10;const int mod = 998244353;ll ten[maxn];int main() {    ios::sync_with_stdio(0);    ten[0]=1;    for(int i=1;i&lt;maxn;i++) ten[i]=ten[i-1]*10%mod;    ll n;    cin&gt;&gt;n;    for(int i=1;i&lt;n;i++){        ll ans=(2ll*9ll*ten[n-i]%mod+9ll*9ll*ten[n-i-1]*(n-i-1)%mod)%mod;        cout&lt;&lt;ans&lt;&lt;&quot; &quot;;    }    cout&lt;&lt;10&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ - 2528   Mayor&#39;s posters</title>
      <link href="/2020/03/23/poj2528/"/>
      <url>/2020/03/23/poj2528/</url>
      
        <content type="html"><![CDATA[<h1 id="Mayor-39-s-posters"><a href="#Mayor-39-s-posters" class="headerlink" title="Mayor&#39;s posters"></a>Mayor&#39;s posters</h1><p>Link: <a href="http://poj.org/problem?id=2528" target="_blank" rel="noopener">Mayor&#39;s posters</a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:</p><ul><li>Every candidate can place exactly one poster on the wall.</li><li>All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown).</li><li>The wall is divided into segments and the width of each segment is one byte.</li><li>Each poster must completely cover a contiguous number of wall segments.</li></ul><p>They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.<br>Your task is to find the number of visible posters when all the posters are placed given the information about posters&#39; size, their place and order of placement on the electoral wall.<br>Input</p><p>The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers li and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= li &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered li, li+1 ,... , ri.<br>Output</p><p>For each input data set print the number of visible posters after all the posters are placed.</p><p>The picture below illustrates the case of the sample input.</p><p>Sample Input</p><p>1<br>5<br>1 4<br>2 6<br>8 10<br>3 4<br>7 10<br>Sample Output</p><p>4</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200323201142.webp" data-fancybox="images" data-caption="20200323201142" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200323201142.webp" class="img-shadow img-margin"></center></a><h1 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h1><p>这道题的意思就是有一个广告板，现在你按照顺序往广告板上贴广告。每个广告都处于一个区间<script type="math/tex">[l_i,r_i]</script>，问你最后能看到几个广告。题意看图很容易就明白了。<br>暴力写肯定是会TLE的。这是一道线段树的题。关键就是怎么用。我们可以发现，越靠后贴上的广告才可能是最后看得到的。所以我们可以倒着看，初始的时候每个点的值都设为<script type="math/tex">1</script>，然后装上一个广告牌，将广告牌所在区间的值都改为<script type="math/tex">0</script>,表示这个地方已经有广告牌了。所以我们可以这样用线段树，每次遇到一个位于<script type="math/tex">[l_i,r_i]</script>的广告牌先查询这个区间的和，如果大于0，说明有的地方还没有广告，答案加一，然后将这个区间所有的值修改为0.这样就解决了本题。<br>但是还有一个问题就是，这样做的话我们需要按照广告板的长度去建树，而这个长度最长会是<script type="math/tex">10^7</script>，会MLE。但是总共最多也就<script type="math/tex">1000</script>个广告，最多也就<script type="math/tex">2000</script>个点，所以我们需要对每个广告的左右区间离散化处理一下。这样就可以了。<br>还有个问题就是懒标记，因为模板中的pushdown都是<code>if(lazy[rt])</code>，所以我卡了好久。因为这里的<code>lazy[rt]</code>会是<script type="math/tex">0</script>，所以我们把lazy数组直接初始化为<script type="math/tex">-1</script>即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="lang-c++">#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 2e4 + 5;const int mod = 1e9+7;ll tree[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],a[maxn],cnt;ll read(){    char c;    ll ans=0,flag=1;    while(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;){        if(c==&#39;-&#39;)  flag=-1;        c=getchar();    }    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){        ans=ans*10+c-&#39;0&#39;;        c=getchar();    }    return ans*flag;}struct node{    ll l,r;}p[maxn];void build(int l,int r,int rt){    if(l==r){        tree[rt]=1;        return ;    }    int mid=(l+r)&gt;&gt;1;    build(l,mid,rt&lt;&lt;1);    build(mid+1,r,rt&lt;&lt;1|1);    tree[rt]=tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];}void pushdown(int rt,int ln,int rn){    if(lazy[rt]==0){        lazy[rt&lt;&lt;1]=lazy[rt];        lazy[rt&lt;&lt;1|1]=lazy[rt];        tree[rt&lt;&lt;1]=lazy[rt]*ln;        tree[rt&lt;&lt;1|1]=lazy[rt]*rn;        lazy[rt]=0;    }}void update(int l,int r,int x,int y,int rt,int z){    if(l&gt;=x&amp;&amp;r&lt;=y){        tree[rt]=(r-l+1)*z;        lazy[rt]=z;        return ;    }    int mid=(l+r)&gt;&gt;1;    pushdown(rt,mid-l+1,r-mid);    if(x&lt;=mid)  update(l,mid,x,y,rt&lt;&lt;1,z);    if(y&gt;mid)   update(mid+1,r,x,y,rt&lt;&lt;1|1,z);    tree[rt]=tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];}ll query(ll l,ll r,ll x,ll y,ll rt){    // cout&lt;&lt;&quot;query&quot;&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;    if(l&gt;=x&amp;&amp;r&lt;=y){        return tree[rt];    }    ll mid=(l+r)&gt;&gt;1;    pushdown(rt,mid-l+1,r-mid);    ll ans=0;    if(x&lt;=mid)  ans+=query(l,mid,x,y,rt&lt;&lt;1);    if(y&gt;mid)   ans+=query(mid+1,r,x,y,rt&lt;&lt;1|1);    return ans;}int main() {    ll t;    t=read();    while(t--){        ll n,ans=0;cnt=0;        scanf(&quot;%lld&quot;,&amp;n);        for(ll i=1;i&lt;=n;i++)   p[i].l=read(),p[i].r=read(),a[cnt++]=p[i].l,a[cnt++]=p[i].r;        sort(a,a+cnt);        cnt=unique(a,a+cnt)-a;        for(int  i=1;i&lt;=(cnt&lt;&lt;2);i++)   lazy[i]=-1;        build(1,cnt,1);        for(ll i=n;i&gt;=1;i--){            ll L=lower_bound(a,a+cnt,p[i].l) - a+1;            ll R=lower_bound(a,a+cnt,p[i].r) - a+1;            // cout&lt;&lt;L&lt;&lt;&quot; &quot;&lt;&lt;R&lt;&lt;endl;            ll mid=query(1,cnt,L,R,1);            // cout&lt;&lt;mid&lt;&lt;endl;            if(mid&gt;0)  ans++;            update(1,cnt,L,R,1,0);        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 628 (Div. 2) E. Ehab&#39;s REAL Number Theory Problem</title>
      <link href="/2020/03/20/cf1325E/"/>
      <url>/2020/03/20/cf1325E/</url>
      
        <content type="html"><![CDATA[<h1 id="E-Ehab-39-s-REAL-Number-Theory-Problem"><a href="#E-Ehab-39-s-REAL-Number-Theory-Problem" class="headerlink" title="E. Ehab&#39;s REAL Number Theory Problem"></a>E. Ehab&#39;s REAL Number Theory Problem</h1><p>Link: <a href="https://codeforces.com/contest/1325/problem/E" target="_blank" rel="noopener">E. Ehab&#39;s REAL Number Theory Problem</a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are given an array a of length n that has a special condition: every element in this array has at most 7 divisors. Find the length of the shortest non-empty subsequence of this array product of whose elements is a perfect square.</p><p>A sequence a is a subsequence of an array b if a can be obtained from b by deletion of several (possibly, zero or all) elements.</p><p>Input<br>The first line contains an integer n (<script type="math/tex">1 \le n \le 10^5</script>) — the length of a.</p><p>The second line contains n integers <script type="math/tex">a_1,a_2,\dots,a_n</script> (<script type="math/tex">1 \le a_i \le 10^6</script>) — the elements of the array a.</p><p>Output<br>Output the length of the shortest non-empty subsequence of a product of whose elements is a perfect square. If there are several shortest subsequences, you can find any of them. If there&#39;s no such subsequence, print &quot;-1&quot;.</p><p>Examples<br>input<br>3<br>1 4 6<br>output<br>1<br>input<br>4<br>2 3 6 6<br>output<br>2<br>input<br>3<br>6 15 10<br>output<br>3<br>input<br>4<br>2 3 5 7<br>output<br>-1<br>Note<br>In the first sample, you can choose a subsequence <script type="math/tex">[1]</script>.</p><p>In the second sample, you can choose a subsequence <script type="math/tex">[6,6]</script>.</p><p>In the third sample, you can choose a subsequence <script type="math/tex">[6,15,10]</script>.</p><p>In the fourth sample, there is no such subsequence.</p><h1 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h1><p>这道题的意思就是给你一组数，让你尽可能少的选择数，使得这些数的乘积为完全平方数。<br><code>every element in this array has at most 7 divisors</code>，题目中的这句话很关键，说的是序列中的数最多有7个因子。<br>根据约数定理可得，如果一个数有三个质因子，那这个数最少有<script type="math/tex">(1+1)^3=8</script>个因子。所以这句话的意思就是每个数最多有两个质因子.<br>并且我们可以发现，如果一个数对某个完全平方数取模为0，那么让这个数除以这个完全平方数对最后的答案没有影响。所以我们可以对所有数进行质因子分解，并且将质因子的幂对<script type="math/tex">2</script>取模，这样就实现了除以某个完全平方数。<br>上面处理完之后，每个数只有三种情况<script type="math/tex">1,p,p*q</script></p><p><script type="math/tex">p,q</script>均为质数。如果出现了为<script type="math/tex">1</script>的情况，那直接输出<script type="math/tex">1</script>即可。因为你可以只选择这一个数。<br>接下来就是这个题最妙的地方。如果一个数处理完变成了<script type="math/tex">p*q</script>，就把这两个数当成节点连接起来，如果处理完变成了<script type="math/tex">p</script>，就把<script type="math/tex">p</script>和<script type="math/tex">1</script>连接起来。<br>这样会得到一个无向图，我们可以发现，如果有一个环存在，那么这个环中存在的那几个质因子相乘肯定是完全平方数。<br>所以这道题就变成了求无向图中的最小环。<br>直接暴力是肯定不行的，所以我们可以用<script type="math/tex">bfs</script>求最小换，有两种方法可以优化。<br>一种是对质因子离散化，一种是遍历bfs的起点，从<script type="math/tex">1</script>到<script type="math/tex">\sqrt{max_{a_i}}</script>。离散化就不用多说了。<br>这个<script type="math/tex">\sqrt{max_{a_i}}</script>为上界是因为如果起点的质因子大于<script type="math/tex">\sqrt{max_{a_i}}</script>，是不可能找到环的。因为<script type="math/tex">\sqrt{max_{a_i}}^2</script>肯定是大于<script type="math/tex">a_i</script>的。</p><p><script type="math/tex">bfs</script>来找最小环，只要下一个点是被之前访问过的，更新<script type="math/tex">ans</script>的最小值即可,<script type="math/tex">ans=\min\{ans,dep_{to}+dep_x+1\}</script>。<script type="math/tex">dep_{to}</script>和<script type="math/tex">dep_x</script>代表的是从当前的起点到<script type="math/tex">to</script>和<script type="math/tex">x</script>的距离，最后加的<script type="math/tex">1</script>就是将<script type="math/tex">to</script>和<script type="math/tex">x</script>中间的那个距离。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+10;const int inf =  0x3f3f3f3f;vector&lt;ll&gt; V[maxn];int dis[maxn],f[maxn];int ans=inf; #define pb push_backvoid bfs(int u) {    memset(dis, inf, sizeof(dis));    dis[u] = 0;    queue&lt;int&gt; q;    q.push(u);    while (!q.empty()) {        int u = q.front();        q.pop();        for (int i = 0; i &lt; V[u].size(); i++) {            int v = V[u][i];            if (v != f[u]) {                if (dis[v] != inf) ans = min(ans, (dis[u] + dis[v] + 1));                else f[v] = u, dis[v] = dis[u] + 1, q.push(v);;            }        }    }}int main(){    ios::sync_with_stdio(0);    int n,x;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;x;        int flag=0;        for(int i=2;i&lt;=sqrt(x);i++){            while(x%(i*i)==0)    x/=i*i;        }        if(x==1){            cout&lt;&lt;&quot;1\n&quot;;            return 0;        }        for(int i=2;i&lt;=sqrt(x);i++){            if(x%i==0){                V[i].pb(x/i);                V[x/i].pb(i);                flag=1;            }        }        if(!flag){            V[1].pb(x);            V[x].pb(1);        }    }    for(int i=1;i&lt;=sqrt(maxn);i++)    bfs(i);    if(ans!=inf)    cout&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
            <tag> bfs </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Global Round 7  D. Prefix-Suffix Palindrome</title>
      <link href="/2020/03/20/cf1326D/"/>
      <url>/2020/03/20/cf1326D/</url>
      
        <content type="html"><![CDATA[<h1 id="Prefix-Suffix-Palindrome"><a href="#Prefix-Suffix-Palindrome" class="headerlink" title="Prefix-Suffix Palindrome"></a>Prefix-Suffix Palindrome</h1><p>Link: <a href="https://codeforces.com/contest/1326" target="_blank" rel="noopener">Prefix-Suffix Palindrome</a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are given a string s, consisting of lowercase English letters. Find the longest string, t, which satisfies the following conditions:</p><ul><li>The length of t does not exceed the length of s.</li><li>t is a palindrome.</li><li>There exists two strings a and b (possibly empty), such that t=a+b ( &quot;+&quot; represents concatenation), and a is prefix of s while b is suffix of s.</li></ul><p>Input<br>The input consists of multiple test cases. The first line contains a single integer t (<script type="math/tex">1 \leq t \leq 10^5</script>), the number of test cases. The next t lines each describe a test case.</p><p>Each test case is a non-empty string s, consisting of lowercase English letters.</p><p>It is guaranteed that the sum of lengths of strings over all test cases does not exceed <script type="math/tex">10^6</script>.</p><p>Output<br>For each test case, print the longest string which satisfies the conditions described above. If there exists multiple possible solutions, print any of them.</p><p>Example<br>input<br>5<br>a<br>abcdfdcecba<br>abbaxyzyx<br>codeforces<br>acbba<br>output<br>a<br>abcdfdcba<br>xyzyx<br>c<br>abba<br>Note<br>In the first test, the string s=&quot;a&quot; satisfies all conditions.</p><p>In the second test, the string &quot;abcdfdcba&quot; satisfies all conditions, because:</p><ul><li>Its length is 9, which does not exceed the length of the string s, which equals 11.</li><li>It is a palindrome.</li><li>&quot;abcdfdcba&quot; = &quot;abcdfdc&quot; + &quot;ba&quot;, and &quot;abcdfdc&quot; is a prefix of s while &quot;ba&quot; is a suffix of s.<br>It can be proven that there does not exist a longer string which satisfies the conditions.</li></ul><p>In the fourth test, the string &quot;c&quot; is correct, because &quot;c&quot; = &quot;c&quot; + &quot;&quot; and a or b can be empty. The other possible solution for this test is &quot;s&quot;.</p><h1 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h1><p>这道题的意思就是给你一个字符串,你可以选择一个字符串的前缀子串和一个后缀子串,使得两个字串合起来是回文串.并且另回文串尽可能地长.换句话说就是你可以删去一个子串,使得字符串剩下的部分为回文串.求最长的可以剩下的回文串.</p><p>首先我们可以求出字符串两边可以构造出的回文串,假设字符串的<script type="math/tex">1\dots n</script>,我们比较<script type="math/tex">i</script>和<script type="math/tex">n-i+1</script>,如果相等就继续比较否则退出循环.剩下的最长的回文子串一定包含两边可以构造出来的回文串.因为你要选的是前缀,后缀合起来.<br>这个统计完之后,把已经构成了回文串的字符不再考虑,我们考虑剩下的子串中前缀和后缀中的最长回文子串,选长的那个,加上上一步我们得到的回文串.就是最后的答案.求最长回文子串可以用马拉车,这里我用了哈希.<br>不过哈希里面的<script type="math/tex">base</script>和<script type="math/tex">mod</script>一定要选好.这里挺好用的一组就是<script type="math/tex">base=233,mod=10^9+7</script>.单哈希不行就双哈希,爱了爱了,复杂度为<script type="math/tex">O(N)</script></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll base = 233;const int maxn = 1e6+10;const int mod = 1e9+7;ll p[maxn],l[maxn],r[maxn];bool check(ll L,ll R){    ll x,y;    x=(l[R]-l[L-1]*p[R-L+1]%mod+mod)%mod;    y=(r[L]-r[R+1]*p[R-L+1]%mod+mod)%mod;//求子串的哈希值,模板    return x==y;//如果前缀和后缀哈希值相等,说明这个子串是回文串}int main(){    ios::sync_with_stdio(0);    p[0]=1;    ll t;    cin&gt;&gt;t;    while(t--)    {            string s;        cin&gt;&gt;s;        ll n=s.size();        s=&quot; &quot;+s;//把字符串中的字符下标置为1-n,方便处理        for(ll i=1;i&lt;=n;i++)    l[i]=l[i-1]*base%mod+s[i],p[i]=p[i-1]*base,l[i]%=mod,p[i]%=mod;//计算前缀哈希值,p[i]为base的i次方,优化时间        for(ll i=n;i&gt;=1;i--)    r[i]=r[i+1]*base%mod+s[i],r[i]%=mod;//计算后缀哈希值        ll pos=0;        for(ll i=1;i&lt;=n/2;i++){            if(s[i]==s[n+1-i]){                pos=i;            }            else    break;        }//找到原字符串前后可以构建出的最长回文子串        ll flag=0,maxx=0;        for(ll i=pos+1;i&lt;=n-pos;i++){            if(check(pos+1,i)&amp;&amp;i-pos&gt;maxx){                flag=1;                maxx=i-pos;            }        }//求剩下的字符串前缀最长回文子串        for(ll i=n-pos;i&gt;=pos+1;i--){            if(check(i,n-pos)&amp;&amp;n-pos-i+1&gt;maxx){                flag=2;                maxx=n-pos-i+1;            }        }//求剩下的字符串后缀最长回文子串        /*然后输出即可*/        for(ll i=1;i&lt;=pos;i++)    cout&lt;&lt;s[i];        if(flag==1){            for(ll i=pos+1;i&lt;=pos+maxx;i++)    cout&lt;&lt;s[i];        }else if(flag==2){            for(ll i=n-pos-maxx+1;i&lt;=n-pos;i++)    cout&lt;&lt;s[i];        }        for(ll i=n-pos+1;i&lt;=n;i++)    cout&lt;&lt;s[i];        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> hash </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ - 2886  Who Gets the Most Candies?</title>
      <link href="/2020/03/19/poj2886/"/>
      <url>/2020/03/19/poj2886/</url>
      
        <content type="html"><![CDATA[<h1 id="Who-Gets-the-Most-Candies"><a href="#Who-Gets-the-Most-Candies" class="headerlink" title="Who Gets the Most Candies?"></a>Who Gets the Most Candies?</h1><p>Link: <a href="http://poj.org/problem?id=2886" target="_blank" rel="noopener">Who Gets the Most Candies?</a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>N children are sitting in a circle to play a game.</p><p>The children are numbered from 1 to N in clockwise order. Each of them has a card with a non-zero integer on it in his/her hand. The game starts from the K-th child, who tells all the others the integer on his card and jumps out of the circle. The integer on his card tells the next child to jump out. Let A denote the integer. If A is positive, the next child will be the A-th child to the left. If A is negative, the next child will be the (−A)-th child to the right.</p><p>The game lasts until all children have jumped out of the circle. During the game, the p-th child jumping out will get F(p) candies where F(p) is the number of positive integers that perfectly divide p. Who gets the most candies?</p><p>Input</p><p>There are several test cases in the input. Each test case starts with two integers N (0 &lt; N ≤ 500,000) and K (1 ≤ K ≤ N) on the first line. The next N lines contains the names of the children (consisting of at most 10 letters) and the integers (non-zero with magnitudes within <script type="math/tex">10^8</script>) on their cards in increasing order of the children’s numbers, a name and an integer separated by a single space in a line with no leading or trailing spaces.<br>Output</p><p>Output one line for each test case containing the name of the luckiest child and the number of candies he/she gets. If ties occur, always choose the child who jumps out of the circle first.</p><p>Sample Input</p><p>4 2<br>Tom 2<br>Jack 4<br>Mary -1<br>Sam 1<br>Sample Output</p><p>Sam 3</p><h1 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h1><p>这道题的意思是有一圈孩子围成一个圈坐着，每个孩子都有一个value，从第k个孩子开始，将这个孩子删除，然后将这个孩子的的value所指的孩子也删除。直到删除完所有孩子。求第几个被删除的孩子的<script type="math/tex">f(x)</script>最大，x是孩子被删的次序，<script type="math/tex">f(x)</script>代表的是x的因子数。<br>这个问题我们可以分成两部分考虑<br>一：因为删除孩子的次序一定是<script type="math/tex">1-n</script>，所以我们可以先找出来这个范围里面因子个数最多的那个数。似乎暴力会TLE，所以这里会用到一个关于素数的概念。高合成数（有人也叫做？反素数），因为每个数都可以进行质因子分解，所以我们根据质因子的不同搭配可以求出用因子个数递增的一个序列。高合成数的意思就是对于一个高合成数x，比它小的任何数的因子数都小于等于它。所以我们只要找到最接近n的那个高合成数即可。高合成数我们可以打表得到。以上是网上的版本。下面是我自己的理解因为每个数都可以质因子分解为<script type="math/tex">x=2^{i} \cdot 3^{i} \cdot 5^{i} \cdot 7^{i} \ddots</script>，所以相当于对于每个高合成数，小于它的数的因子数一定小于他，大于它小于第一个比它大的高合成数区间内的数因子数也小于它。<br>二：找到高合成数x——因子数最多的数，就是我们要删除x次，这就成了约瑟夫环问题的变形了。但是直接模拟会TLE。我们可以用线段树实现，这个思路就不再多说了，跟<a href="/2020/03/18/poj2828/">POJ - 2828 Buy Tickets</a>基本一样。关于下一个孩子的指向可以参考这篇博客说的十分清晰：<a href="https://blog.csdn.net/wyxeainn/article/details/76095860" target="_blank" rel="noopener">https://blog.csdn.net/wyxeainn/article/details/76095860</a></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>对于poj的G++和C++的区别真的是无力吐槽了（应该还是怪我太菜、</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int maxn = 5e5+10;int hn[] = {1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400};int pn[] = {1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,60,64,72,80,84,90,96,100,108,120,128,144,160,168,180,192,200,216};struct node{    int val;    char name[20];}p[maxn];int tree[maxn&lt;&lt;2];void build(int l,int r,int rt){    if(l==r){        tree[rt]=1;        return ;    }    int mid=(l+r)&gt;&gt;1;    build(l,mid,rt&lt;&lt;1);    build(mid+1,r,rt&lt;&lt;1|1);    tree[rt]=tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];}int query(int l,int r,int val,int rt){    if(l==r){        tree[rt]=0;        return l;    }    int mid=(l+r)&gt;&gt;1,ans;    if(val&lt;=tree[rt&lt;&lt;1])    ans=query(l,mid,val,rt&lt;&lt;1);    else ans=query(mid+1,r,val-tree[rt&lt;&lt;1],rt&lt;&lt;1|1);    tree[rt]=tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];    return ans;        }int main(){    ios::sync_with_stdio(0);    int n,k;    while(cin&gt;&gt;n&gt;&gt;k){        for(int i=1;i&lt;=n;i++){            cin&gt;&gt;p[i].name&gt;&gt;p[i].val;        }        build(1,n,1);        int pos=0,ans;        while(hn[pos]&lt;=n)    pos++;        pos--;        int mid=hn[pos];        for(int i=0;i&lt;mid;i++){            ans=query(1,n,k,1);            if(!tree[1])    break;            if(p[ans].val&gt;0) k = ((k-1+p[ans].val)%tree[1]+tree[1]-1)%tree[1]+1;            else k = ((k-1+p[ans].val)%tree[1]+tree[1])%tree[1]+1;        }            cout&lt;&lt;p[ans].name&lt;&lt;&quot; &quot;&lt;&lt;pn[pos]&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ - 2828   Buy Tickets</title>
      <link href="/2020/03/18/poj2828/"/>
      <url>/2020/03/18/poj2828/</url>
      
        <content type="html"><![CDATA[<h1 id="Buy-Tickets"><a href="#Buy-Tickets" class="headerlink" title="Buy Tickets"></a>Buy Tickets</h1><p>Link: <a href="http://poj.org/problem?id=2828" target="_blank" rel="noopener">Buy Tickets</a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Railway tickets were difficult to buy around the Lunar New Year in China, so we must get up early and join a long queue…</p><p>The Lunar New Year was approaching, but unluckily the Little Cat still had schedules going here and there. Now, he had to travel by train to Mianyang, Sichuan Province for the winter camp selection of the national team of Olympiad in Informatics.</p><p>It was one o’clock a.m. and dark outside. Chill wind from the northwest did not scare off the people in the queue. The cold night gave the Little Cat a shiver. Why not find a problem to think about? That was none the less better than freezing to death!</p><p>People kept jumping the queue. Since it was too dark around, such moves would not be discovered even by the people adjacent to the queue-jumpers. “If every person in the queue is assigned an integral value and all the information about those who have jumped the queue and where they stand after queue-jumping is given, can I find out the final order of people in the queue?” Thought the Little Cat.</p><p>Input<br>There will be several test cases in the input. Each test case consists of N + 1 lines where N (1 ≤ N ≤ 200,000) is given in the first line of the test case. The next N lines contain the pairs of values Posi and Vali in the increasing order of i (1 ≤ i ≤ N). For each i, the ranges and meanings of Posi and Vali are as follows:</p><ul><li><script type="math/tex">Pos_i</script> ∈ [0, i − 1] — The i-th person came to the queue and stood right behind the Posi-th person in the queue. The booking office was considered the 0th person and the person at the front of the queue was considered the first person in the queue.</li><li><script type="math/tex">Val_i</script> ∈ [0, 32767] — The i-th person was assigned the value Vali.</li><li>There no blank lines between test cases. Proceed to the end of input.</li></ul><p>Output<br>For each test cases, output a single line of space-separated integers which are the values of people in the order they stand in the queue.</p><p>Sample Input<br>4<br>0 77<br>1 51<br>1 33<br>2 69<br>4<br>0 20523<br>1 19243<br>1 3890<br>0 31492<br>Sample Output<br>77 33 69 51<br>31492 20523 3890 19243<br>Hint<br>The figure below shows how the Little Cat found out the final order of people in the queue described in the first test case of the sample input.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200318134240.webp" data-fancybox="images" data-caption="20200318134240" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200318134240.webp" class="img-shadow img-margin"></center></a></p><h1 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h1><p>题意很好理解，就是一堆人在排队，但是有人插队。问你最后的排队情况。<br>一开始我是想直接用vector的insert试一下的。无情TLE之后意识到，insert着写是<script type="math/tex">O(n^2)</script>的复杂度233<br>其实这道题是可以用线段树写的，我们让线段树每个节点的值代表这个区间所剩的空位的个数。然后按照倒序处理。因为倒着来的话有些位置是确定的。并且每次插入一个人的value，它前面的空位数是确定的。就是他插入的位置。因此线段树单点更新即可。复杂度<script type="math/tex">O(nlogn)</script></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="lang-c++">#include&lt;iostream&gt;using namespace std;const int maxn = 2e5+10;int tree[maxn&lt;&lt;2],n,ans[maxn];struct node{    int pos,val;}p[maxn];void build(int l,int r,int rt){    if(l==r){            tree[rt]=1;//叶子节点都是只有一个空位        return ;    }    int mid=(l+r)&gt;&gt;1;    build(l,mid,rt&lt;&lt;1);    build(mid+1,r,rt&lt;&lt;1|1);    tree[rt]=tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];}//建树void add(int pos,int l,int r,int rt,int val){    if(l==r){        ans[l]=val;//储存答案方便输出        tree[rt]=0;//如果用过了，就没有空位了        return ;    }    int mid=(l+r)&gt;&gt;1;    if(pos&lt;=tree[rt&lt;&lt;1])    add(pos,l,mid,rt&lt;&lt;1,val);//如果需要的空位数小于等于左子节点的空位数，向左子树查询即可    else  add(pos-tree[rt&lt;&lt;1],mid+1,r,rt&lt;&lt;1|1,val);//反之查询右子树，注意此时左子树节点的空位数相当于也放在这个点的前面了，所以现在需要的空位数是pos-tree[rt&lt;&lt;1]    tree[rt]=tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];}int main(){    while(~scanf(&quot;%d&quot;,&amp;n)){        build(1,n,1);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d %d&quot;,&amp;p[i].pos,&amp;p[i].val);        }        for(int i=n;i&gt;0;i--){            add(p[i].pos+1,1,n,1,p[i].val);        }        for(int i=1;i&lt;=n;i++){            printf(&quot;%d &quot;,ans[i]);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站弃用pjax</title>
      <link href="/2020/03/15/pjax/"/>
      <url>/2020/03/15/pjax/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pjax是一个jQuery插件，它使用ajax和pushState通过真正的永久链接，页面标题和后退按钮提供快速浏览体验。</p></blockquote><p>自从我用了mathjax渲染之后，发现一个很严重的问题就是，文章中如果有mathjax的公式，必须得刷新一下才能显示。刚开始傻傻的我还以为是浏览器缓存什么的原因，特意加了提示框。但是最近无聊决定深究这种现象出现的原因。<br>经过各种搜索之后我意识到，是我主题自带的pjax在搞鬼。<br>于是我又各种搜索pjax，了解到pjax是一个jQuery插件，它使用ajax和pushState通过真正的永久链接，页面标题和后退按钮提供快速浏览体验。虽然速度是提升了，但是js不会重新记载就正好导致我的mathjax无法正常显示。痛苦万分，虽然有大佬告诉我可以重新pjax的刷新规则，但是我是真的不会。随意简单粗暴的——弃用。<br>也不是说pjax不好用，只不过正好在错的时间遇到了错的我。</p><p>最后说一下，在我百度<code>如何关闭pjax</code>得时候，看到了<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn//20200315115046.webp" data-fancybox="images" data-caption="20200315115046" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn//20200315115046.webp" class="img-shadow img-margin"></center></a></p><p>pjax很好用的，只不过是我莫得能力重写刷新规则所以用不来而已。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> pjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 628 (Div. 2) D. Ehab the Xorcist</title>
      <link href="/2020/03/15/cf1325D/"/>
      <url>/2020/03/15/cf1325D/</url>
      
        <content type="html"><![CDATA[<h1 id="D-Ehab-the-Xorcist"><a href="#D-Ehab-the-Xorcist" class="headerlink" title="D. Ehab the Xorcist"></a>D. Ehab the Xorcist</h1><p>Link: <a href="https://codeforces.com/contest/1325/problem/D" target="_blank" rel="noopener">D. Ehab the Xorcist</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given <script type="math/tex">2</script> integers <script type="math/tex">u</script> and <script type="math/tex">v</script>, find the shortest array such that bitwise-xor of its elements is <script type="math/tex">u</script>, and the sum of its elements is <script type="math/tex">v</script>.</p><p>Input<br>The only line contains <script type="math/tex">2</script> integers <script type="math/tex">u</script> and <script type="math/tex">v</script> (<script type="math/tex">(0 \le u,v \le 10^{18})</script>).</p><p>Output<br>If there&#39;s no array that satisfies the condition, print &quot;<script type="math/tex">-1</script>&quot;. Otherwise:</p><p>The first line should contain one integer, <script type="math/tex">n</script>, representing the length of the desired array. The next line should contain n positive integers, the array itself. If there are multiple possible answers, print any.</p><p>Examples<br>input<br>2 4<br>output<br>2<br>3 1<br>input<br>1 3<br>output<br>3<br>1 1 1<br>input<br>8 5<br>output<br>-1<br>input<br>0 0<br>output<br>0<br>Note<br>In the first sample, <script type="math/tex">3\oplus 1 = 2</script> and <script type="math/tex">3+1=4</script>. There is no valid array of smaller length.</p><p>Notice that in the fourth sample the array is empty.</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你两个数<script type="math/tex">u</script>,<script type="math/tex">v</script>,让你求一个最短的序列，满足序列中所有元素的异或和为<script type="math/tex">u</script>,所有的元素和为<script type="math/tex">v</script>,如果系列不存在就输出<script type="math/tex">-1</script><br>分情况讨论</p><ul><li>首先我们可以发现，如果<script type="math/tex">v < u</script>,答案不存在。我们按照二进制位来看，如果异或和中的某高位为<script type="math/tex">1</script>但是数值和小于<script type="math/tex">u</script>，也就是说肯定没有一个属可以让异或和的那个高位上为<script type="math/tex">1</script>，所以此时答案不存在</li><li>然后我们知道，如果<script type="math/tex">uv</script>的奇偶性各不相同，答案不存在。因为奇偶性只看最后一位，这时和异或正好是同步的。</li><li>然后我们考虑<script type="math/tex">u = v</script>的情况，如果此时<script type="math/tex">u=0</script>，那么输出<script type="math/tex">0</script>，否则，答案就是<script type="math/tex">[u]</script>。因为<script type="math/tex">uv</script>相等，序列中只有一个数，数值和与异或和均为它本身。所以与v也相等。</li><li>如果<script type="math/tex">u\neq v</script>,我们让<script type="math/tex">x=\frac{v-u}{2}</script>,那么此时的答案序列就是<script type="math/tex">[u,x,x]</script>,因为相等的数异或为<script type="math/tex">0</script>，<script type="math/tex">0</script>根任何数异或都为<script type="math/tex">0</script>，所以异或和为u，数值和为<script type="math/tex">u+2*x=u+2*\frac{v-u}{2}=v</script>。所以答案序列的长度最长为<script type="math/tex">3</script>。</li><li>我们考虑序列长度为2的时候，设序列为<script type="math/tex">[a,b]</script>,则<script type="math/tex">a \oplus b=u</script>且<script type="math/tex">a+b=v</script>，此时<script type="math/tex">a+b=a \oplus b+2*(a</script>&amp;<script type="math/tex">b)</script>。所以我们发现上面我们定义的<script type="math/tex">x</script>正好等于<script type="math/tex">a</script>&amp;<script type="math/tex">b</script>。如果<script type="math/tex">x</script>的某一位为<script type="math/tex">1</script>，那么<script type="math/tex">ab</script>的这一位一定也是<script type="math/tex">1</script>，那此时<script type="math/tex">u</script>的这一位为0，所以如果<script type="math/tex">u</script>这一位为<script type="math/tex">1</script>得时候，序列长度为2得时候显然不可以。（判断的话直接判断<script type="math/tex">x</script>&amp;<script type="math/tex">u</script>是否为<script type="math/tex">1</script>即可）。如果<script type="math/tex">x</script>&amp;<script type="math/tex">u=0</script>,那么我们可以得到<script type="math/tex">x \oplus u=x+u</script>，所以答案序列可以写成长度为2的<script type="math/tex">[u+x,x]</script>。</li></ul><p>看了题解勉强可以看懂，但是自己想真的是想不起来2333。菜是原罪。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ios::sync_with_stdio(0);    ll u,v;    cin&gt;&gt;u&gt;&gt;v;    if(u&gt;v||(u&amp;1)!=(v&amp;1)){        puts(&quot;-1&quot;);        return 0;    }    if(u==v){        if(u==0){            cout&lt;&lt;&quot;0\n&quot;;        }else{            cout&lt;&lt;&quot;1\n&quot;&lt;&lt;u&lt;&lt;endl;        }        return 0;    }    ll x=(v-u)/2;    if(x&amp;u){        cout&lt;&lt;&quot;3\n&quot;&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;x;    }else{        cout&lt;&lt;&quot;2\n&quot;&lt;&lt;(u^x)&lt;&lt;&quot; &quot;&lt;&lt;x;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
            <tag> codeforces </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>竞赛清单页面的搭建 | INFO-cf搭建历程</title>
      <link href="/2020/03/10/INFO-cf-contest/"/>
      <url>/2020/03/10/INFO-cf-contest/</url>
      
        <content type="html"><![CDATA[<blockquote><p>思路：通过cf提供的user.rating的api，加上json动态创建表格来实现。</p></blockquote><h1 id="竞赛清单页面链接"><a href="#竞赛清单页面链接" class="headerlink" title="竞赛清单页面链接"></a>竞赛清单页面链接</h1><h1 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h1><p>关于api的调用，通过之前的搭建经验，已经可以了。直接通过ajax实现即可。</p><h1 id="json动态表格实现"><a href="#json动态表格实现" class="headerlink" title="json动态表格实现"></a>json动态表格实现</h1><pre><code class="lang-html">&lt;html&gt;  &lt;head&gt;  &lt;title&gt;&lt;/title&gt;  &lt;script type=&quot;text/javascript&quot;&gt;                 var jsonArray = [{&quot;编号&quot;:&quot;001&quot;,&quot;名称&quot;:&quot;小苹果&quot;,&quot;描述&quot;:&quot;现代神曲，大妈的最爱&quot;},{&quot;编号&quot;:&quot;002&quot;,&quot;名称&quot;:&quot;mou宝&quot;,&quot;描述&quot;:&quot;想怎么玩就怎么完&quot;}];            var headArray = [];            function parseHead(oneRow) {                          for ( var i in oneRow) {                                  headArray[headArray.length] = i;                           }              }              function appendTable() {                            parseHead(jsonArray[0]);                            var div = document.getElementById(&quot;div1&quot;);                             var table = document.createElement(&quot;table&quot;);                            var thead = document.createElement(&quot;tr&quot;);                            for ( var count = 0; count &lt; headArray.length; count++) {                                      var td = document.createElement(&quot;th&quot;);                                      td.innerHTML = headArray[count];                                      thead.appendChild(td);                             }                             table.appendChild(thead);                            for ( var tableRowNo = 0; tableRowNo &lt; jsonArray.length; tableRowNo++) {                                      var tr = document.createElement(&quot;tr&quot;);                                      for ( var headCount = 0; headCount &lt; headArray.length; headCount++) {                                              var cell = document.createElement(&quot;td&quot;);                                              cell.innerHTML = jsonArray[tableRowNo][headArray[headCount]];                                              tr.appendChild(cell);                                      }                                      table.appendChild(tr);                           }                            div.appendChild(table);          }                         &lt;/script&gt;      &lt;style&gt;          table {              width: 600px;              padding: 0 ;              margin: 100 auto;              border-collapse: collapse;          }          td,th {              border: 1px solid #ddd;              padding: 6px 6px 6px 12px;              color: #4f6b72;              text-align: center;          }          th {              background: #d3d3d3;          }      &lt;/style&gt;  &lt;/head&gt;  &lt;body onload=&quot;appendTable(jsonArray);&quot;&gt;      &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;  &lt;/body&gt;  &lt;/html&gt;</code></pre><p>源码转载于：<a href="https://www.cnblogs.com/jpfss/p/9104686.html" target="_blank" rel="noopener">https://www.cnblogs.com/jpfss/p/9104686.html</a></p><p>这个源码需要一个json文件作为根本来创建表格。</p><h1 id="json文件的获取"><a href="#json文件的获取" class="headerlink" title="json文件的获取"></a>json文件的获取</h1><p>这一步卡了我将近五个小时。<br>因为ajax或者是getjson他们获取的json文件都是在回调函数内部。而我找到的这个动态表格的模板需要的是一个json数组。又因为api返回的json格式各不相同，可难为死我这个小白了。索性最后还是解决了。<br>这里我的解决方案是定义一个字符串，按照json的格式，每次把json中的元素以字符串的形式加进去。最后将整个字符串通过<code>eval</code>函数转化为json格式的变量。用此调用动态创建表格的函数。（当然这个思路并不是一开始就有的，而是摸索了近五个小时得到的解决办法。<br>思路确定了，接下来实现就方便了。但是还有一些细节需要解决。</p><h2 id="json的数据不可以直接当成字符串相加"><a href="#json的数据不可以直接当成字符串相加" class="headerlink" title="json的数据不可以直接当成字符串相加"></a>json的数据不可以直接当成字符串相加</h2><p>如果我们直接加，会出现<code>[object]</code>。这时候需要用到一个函数，<code>JSON.stringify()</code>，可以将json转化为字符串的格式供我们相加</p><h2 id="ajax中全局变量赋值无效"><a href="#ajax中全局变量赋值无效" class="headerlink" title="ajax中全局变量赋值无效"></a>ajax中全局变量赋值无效</h2><p>Ajax是异步操作，也就是说在赋值的时候数据还没提取出来，所以只要改成同步操作就行<br>调用ajax的时候直接在里面加上<code>async : false,</code>即可。</p><p>这里附上我实现这部分的代码，供有相同问题的小伙伴参考</p><pre><code class="lang-javascript">var mid = &quot;[&quot;;$.ajax({ url: curl, dataType: &#39;json&#39;,  async : false, success: function( end ) {   for(var i=0;i&lt;end.result.length;i++){             mid+=JSON.stringify(end.result[i])+&#39;,&#39;;        } }, error: function( end ) {   mid=&quot;&quot;; }});mid+=&#39;]&#39;;var jsonArray=eval(&#39;(&#39; + mid + &#39;)&#39;);</code></pre><p>至此，这个页面的搭建基本就完成了，在美化一下即可。</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p><code>var jsonArray=eval(&#39;(&#39; + mid + &#39;)&#39;);</code>  讲字符串类型的mid转换为json格式</p>]]></content>
      
      
      <categories>
          
          <category> INFO-cf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
            <tag> Tutorial </tag>
            
            <tag> 建站 </tag>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序章 | INFO-cf搭建历程</title>
      <link href="/2020/03/10/INFO-cf/"/>
      <url>/2020/03/10/INFO-cf/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>产生这样的想法是因为总是看到各种各样的地方写着api，但是又不知道是什么干什么的。又看到了CodeForces提供的api，所以拿来练手，发现挺有意义的，所以准备做下去，慢慢完善功能的同时提升自己能力。<br>PS：博主前端纯小白，过程的艰辛自己体会233.</p><p>本站源码已上传至GitHub: <a href="https://github.com/Drew233/INFO-CF" target="_blank" rel="noopener">https://github.com/Drew233/INFO-CF</a><br>欢迎大家提issues，反馈bug或跟我一起完善本站功能</p><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><p>主页模板源自：<a href="https://html5up.net/" target="_blank" rel="noopener">https://html5up.net/</a></p><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>已优化</p><h2 id="比赛信息"><a href="#比赛信息" class="headerlink" title="比赛信息"></a>比赛信息</h2><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="已实现"><a href="#已实现" class="headerlink" title="已实现"></a>已实现</h2><h3 id="通过user-info的调用实现简单的竞赛数据显示"><a href="#通过user-info的调用实现简单的竞赛数据显示" class="headerlink" title="通过user.info的调用实现简单的竞赛数据显示"></a>通过user.info的调用实现简单的竞赛数据显示</h3><p>主要代码</p><pre><code class="lang-js">&lt;script src=&quot;https://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;  $(document).ready(function (){      $(&quot;#btn382&quot;).click(function(){      var str=&quot;&quot;;      var x=  document.getElementById(&quot;input&quot;);      var curl=&quot;https://codeforces.com/api/user.rating?handle=&quot;+x.value;      var buttonstyle=&quot;&quot;;      jQuery.support.cors = true;      $.ajax({         url: curl,         dataType: &#39;json&#39;,         success: function( end ) {           var mid = end.result;           var link=&quot;https://codeforces.com/contest/&quot;;           for(var i=0;i&lt;mid.length;i++){                 str+=&quot;&lt;a href=&quot;+link+mid[i].contestId+&quot; class=&quot;+buttonstyle+&quot;&gt;&quot;+(mid[i].contestId+&quot;&lt;/a&gt;&quot;+&quot;\n&quot;);           }           document.getElementById(&quot;div381&quot;).innerHTML=&quot;&quot;;           document.getElementById(&quot;main&quot;).innerHTML=&quot;比赛清单&quot;+str;           document.getElementById(&quot;num&quot;).innerHTML=&quot;至今你以参加&quot;+mid.length+&quot;场比赛&quot;;         },         error: function( end ) {           alert( &quot;ERROR:  &quot; + &quot;输入用户名错误，请重新输入&quot; );         }       });        });    });  &lt;/script&gt;</code></pre><p>通过ajax调用api，返回json数据，然后通过document.getElementById(&quot;&quot;).innerHTML=&quot;&quot;;在html中相应位置添加对应元素。</p><h3 id="待实现"><a href="#待实现" class="headerlink" title="待实现"></a>待实现</h3><h4 id="Rating相关"><a href="#Rating相关" class="headerlink" title="Rating相关"></a>Rating相关</h4><h4 id="赛事相关（如近期赛事）"><a href="#赛事相关（如近期赛事）" class="headerlink" title="赛事相关（如近期赛事）"></a>赛事相关（如近期赛事）</h4><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="上传文件至已有文件的GitHub仓库"><a href="#上传文件至已有文件的GitHub仓库" class="headerlink" title="上传文件至已有文件的GitHub仓库"></a>上传文件至已有文件的GitHub仓库</h2><ol><li>git add .</li><li>git commit -m &quot;提交注释&quot;</li><li>git pull origin master</li><li>git push -u origin master</li></ol><h2 id="关于移动端的适配"><a href="#关于移动端的适配" class="headerlink" title="关于移动端的适配"></a>关于移动端的适配</h2><p><code>width</code>和<code>height</code>属性可以通过相对大小来适应屏幕大小<br>或者直接使用<code>auto</code></p><h2 id="调用api中的json"><a href="#调用api中的json" class="headerlink" title="调用api中的json"></a>调用api中的json</h2><p>可以使用getjson或者ajax，getjson更简单快捷，ajax麻烦一点但是功能更详细。</p>]]></content>
      
      
      <categories>
          
          <category> INFO-cf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
            <tag> Tutorial </tag>
            
            <tag> 建站 </tag>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 83 (Rated for Div. 2) D. Count the Arrays</title>
      <link href="/2020/03/10/cf1312D/"/>
      <url>/2020/03/10/cf1312D/</url>
      
        <content type="html"><![CDATA[<h1 id="D-Count-the-Arrays"><a href="#D-Count-the-Arrays" class="headerlink" title="D. Count the Arrays"></a>D. Count the Arrays</h1><p>Link: <a href="https://codeforces.com/contest/1312/problem/D" target="_blank" rel="noopener">D. Count the Arrays</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Your task is to calculate the number of arrays such that:</p><ul><li>each array contains n elements;</li><li>each element is an integer from 1 to m;</li><li>for each array, there is exactly one pair of equal elements;</li><li>for each array a, there exists an index i such that the array is strictly ascending before the i-th element and strictly descending after it (formally, it means that <script type="math/tex">a_j < a_{j + 1}</script>, if <script type="math/tex">j<i</script>, and <script type="math/tex">a_j > a_{j + 1}</script>, if <script type="math/tex">j \ge i</script>).</li></ul><p>Input<br>The first line contains two integers n and m (<script type="math/tex">2 \le n \le m \le 2 \cdot 10^5</script>).</p><p>Output<br>Print one integer — the number of arrays that meet all of the aforementioned conditions, taken modulo 998244353.</p><p>Examples<br>input<br>3 4<br>output<br>6<br>input<br>3 5<br>output<br>10<br>input<br>42 1337<br>output<br>806066790<br>input<br>100000 200000<br>output<br>707899035<br>Note<br>The arrays in the first example are:</p><ul><li><script type="math/tex">[1,2,1]</script>;</li><li><script type="math/tex">[1,3,1]</script>;</li><li><script type="math/tex">[1,4,1]</script>;</li><li><script type="math/tex">[2,3,2]</script>;</li><li><script type="math/tex">[2,4,2]</script>;</li><li><script type="math/tex">[3,4,3]</script>.</li></ul><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思是给你两个数<script type="math/tex">n</script>和<script type="math/tex">m</script>，让你求有多少个长度为<script type="math/tex">n</script>的序列满足，序列中最大值的左边严格单调递增，最大值的右边严格单调递减。并且序列中有且仅有一对相等的数，序列中的数的范围是<script type="math/tex">1-m</script>。</p><p>首先你要知道，有一对相等的数。那么这两个数一定是一个在最大值的左边一个在最大值的右边，因为题目要求中的单调性都是严格单调。<br>我们考虑，将最大值右边的数全部移动到最大值左边，所以此时除了最大值，我们还需要放<script type="math/tex">n-2</script>个数（因为总共n个数，有一个数是出现两次的）。然后我们考虑排列组合，假设最大值为<script type="math/tex">i</script>，那么这<script type="math/tex">n-2</script>个数的取值就有<script type="math/tex">i-1</script>个可能，因为每个数都不相同，所以此时的总方案数为<script type="math/tex">C_{i-1}^{n-2}</script>。<br>但是我们这是移动过之后放置的方案数，每个数的原来的位置是可以在最大值左边也可以在最大值右边的。所以总方案数应该再乘上<script type="math/tex">2^{n-3}</script>，为什么是<script type="math/tex">n-3</script>次方呢，因为这<script type="math/tex">n-2</script>个数中有一个数是重复出现的，因此它的位置是固定的，即最大值左边一个最大值右边一个，所以只有<script type="math/tex">n-3</script>个数是即可以放在左边也可以放在右边的，并且因为这<script type="math/tex">n-2</script>个数中每个数都有可能是那个重复的数，所以总方案数应该再乘上<script type="math/tex">n-2</script>，这时的方案数即为最大值为<script type="math/tex">i</script>时的最终答案。<br>然后我们枚举i可能的取值，累加计算答案即可。因为<script type="math/tex">i</script>前面至少要放<script type="math/tex">n-2</script>个数，所以i的枚举范围为<script type="math/tex">[n-1,m]</script><br>注意，<script type="math/tex">n=2</script>的时候是无解的。<br>即：</p><script type="math/tex; mode=display">\operatorname{ans}=\left\{\begin{array}{ll}0 & n=2 \\\sum_{i=n-1}^{m} C_{i-1}^{n-2} \cdot 2^{n-3} \cdot(n-2) & n>2\end{array}\right.</script><p>答案我们列出来了，但是还需要一些细节的处理。因为需要计算组合数，如果你只是暴力计算组合数，那你肯定会T死。不难发现，我们需要的组合数都是<script type="math/tex">C_{x}^{n-2}</script>。并且求和的时候第一项如果有一定是<script type="math/tex">C_{n-2}^{n-2}</script>，然后依次是<script type="math/tex">C_{n-1}^{n-2}</script> , <script type="math/tex">C_{n}^{n-2}</script>。不难发现，后面的每一项都可以由前面的那一项递推得来，以达到优化时间复杂度的效果。</p><p>我们观察可得</p><script type="math/tex; mode=display">\begin{aligned}&C_{n+1}^{n-2}=\frac{(n+1) !}{(n-2) ! \cdot 3 !}=\frac{n !}{(n-2) ! 2 !} \cdot \frac{n+1}{3}\=C_{n}^{n-2} \cdot \frac{n+1}{n+1-(n-2)}\end{aligned}</script><p>并且每相邻两项都满足这样的规律。<br>因此我们如果知道最大值为<script type="math/tex">pre</script>得时候的组合数<script type="math/tex">mid</script>，就可以最大值为<script type="math/tex">next=pre+1</script>时的组合数为<script type="math/tex">mid \cdot \frac{i-1}{i-n+1}</script><br>因为数据范围很大，所以这里的除法需要用到逆元。</p><p>具体操作请看代码注释</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 2e5+10;const ll mod = 998244353;ll a[maxn];ll poww(ll x,ll y){    ll ans=1;    while(y){        if(y&amp;1)    ans=(ans*x)%mod;        x=(x*x)%mod;        y&gt;&gt;=1;    }    return ans;}//快速幂ll inv(ll x){    return poww(x,mod-2);}//逆元int main(){    ll n,m;    cin&gt;&gt;n&gt;&gt;m;    if(n==2){        cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;        return 0;    }//如果n为2，此时无解    ll ans=0,mid,er=poww(2,n-3);//ans为答案，mid记录每一次组合数的值    mid=1;ans=er*(n-2)%mod;//我们以i=n-1的值为初始情况，将mid和ans初始化    for(ll i=n;i&lt;=m;i++)        mid=(i-1)*mid%mod*inv(i-n+1)%mod,ans=(ans+mid*er%mod*(n-2))%mod;//每次更新mid（即组合数）和ans，注意这里三个数相乘可能会爆long long，总之能取模就多去几次就行了。这里对应的就是上面的分析    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> thinking </tag>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 626 (Div. 2, based on Moscow Open Olympiad in Informatics) D. Present</title>
      <link href="/2020/03/08/cf1323D/"/>
      <url>/2020/03/08/cf1323D/</url>
      
        <content type="html"><![CDATA[<h1 id="D-Present"><a href="#D-Present" class="headerlink" title="D. Present"></a>D. Present</h1><p>Link: <a href="https://codeforces.com/contest/1323/problem/D" target="_blank" rel="noopener">D. Present</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Catherine received an array of integers as a gift for March 8. Eventually she grew bored with it, and she started calculated various useless characteristics for it. She succeeded to do it for each one she came up with. But when she came up with another one — xor of all pairwise sums of elements in the array, she realized that she couldn&#39;t compute it for a very large array, thus she asked for your help. Can you do it? Formally, you need to compute</p><script type="math/tex; mode=display">(a_1 + a_2) \oplus (a_1 + a_3) \oplus \ldots \oplus (a_1 + a_n) \\ \oplus (a_2 + a_3) \oplus \ldots \oplus (a_2 + a_n) \\ \ldots \\ \oplus (a_{n-1} + a_n) \\</script><p>Here <script type="math/tex">x \oplus y</script> is a bitwise XOR operation (i.e. x ^ y in many modern programming languages). You can read about it in Wikipedia: <a href="https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation</a>.</p><p>Input<br>The first line contains a single integer n (<script type="math/tex">2 \leq n \leq 400\,000</script>) — the number of integers in the array.</p><p>The second line contains integers <script type="math/tex">a_1, a_2, \ldots, a_n</script> (<script type="math/tex">1 \leq a_i \leq 10^7</script>).</p><p>Output<br>Print a single integer — xor of all pairwise sums of integers in the given array.</p><p>Examples<br>input<br>2<br>1 2<br>output<br>3<br>input<br>3<br>1 2 3<br>output<br>2<br>Note<br>In the first sample case there is only one sum 1+2=3.</p><p>In the second sample case there are three sums: 1+2=3, 1+3=4, 2+3=5. In binary they are represented as <script type="math/tex">011_2 \oplus 100_2 \oplus 101_2 = 010_2</script>, thus the answer is 2.</p><p>(<script type="math/tex">\oplus</script>)is the bitwise xor operation. To define <script type="math/tex">x \oplus y</script>, consider binary representations of integers x and y. We put the i-th bit of the result to be 1 when exactly one of the i-th bits of x and y is 1. Otherwise, the i-th bit of the result is put to be 0.For example, <script type="math/tex">0101_2 \, \oplus \, 0011_2 = 0110_2</script></p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思是给你一个序列，让你求序列中每个数两两之和的异或和。暴力是肯定不行的。<br>看到异或，我们首先就应该往按位运算的方向想。假设我们现在想知道答案中二进制位第k位的值。我们可以发现，对这一位有影响的就是原序列中每个数的二进制位中的第0位到第k位。所以我们可以将序列中的每个数对<script type="math/tex">2^{k+1}</script>取模。这样取模之后，假设任意两数之和为m，那么当m处于<script type="math/tex">[2^k; 2^{k+1}-1]</script>或者<script type="math/tex">[2^{k+1} + 2^k; 2^{k+2} - 2]</script>时，第k位为1。所以我们可以统计出来两个数的和第k位为1的对数。因为他们是异或，所以如果对数是奇数，那么答案中的第k位就是1，否则就是0.统计对数的时候我们可以二分查找，这样时间复杂度是<script type="math/tex">O(n \log n \log n)</script></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4e5+10;int a[maxn],b[maxn];typedef long long ll;int main(){    ios::sync_with_stdio(0);    int n;ll ans=0;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    cin&gt;&gt;a[i];    for(int k=0;k&lt;30;k++){//因为最大也就是2e6，所以30位二进制位是足够的        int mod=1&lt;&lt;(k+1);        for(int i=1;i&lt;=n;i++)    b[i]=a[i]%mod;        sort(b+1,b+n+1);        ll mid=0;        for(int i=1;i&lt;=n;i++){            mid+=upper_bound(b+i+1,b+n+1,(1&lt;&lt;(k+1))-1-b[i])-lower_bound(b+i+1,b+n+1,(1&lt;&lt;k)-b[i]);//为了避免重复的对数，每次从第i位往后找            mid+=upper_bound(b+i+1,b+n+1,(1&lt;&lt;(k+2))-b[i])-lower_bound(b+i+1,b+n+1,(1&lt;&lt;k)+(1&lt;&lt;(k+1))-b[i]);//注意upper和lower的使用        }        if(mid&amp;1)    ans+=(1&lt;&lt;k);//如果第k位是1的对数有奇数个，那么答案中的第k位就是1，即(1&lt;&lt;k)($$2^k$$)    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
            <tag> codeforces </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeCraft-20 (Div. 2) C. Primitive Primes</title>
      <link href="/2020/03/05/cf1316C/"/>
      <url>/2020/03/05/cf1316C/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Primitive-Primes"><a href="#C-Primitive-Primes" class="headerlink" title="C. Primitive Primes"></a>C. Primitive Primes</h1><p>Link: <a href="https://codeforces.com/contest/1316/problem/C" target="_blank" rel="noopener">C. Primitive Primes</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>It is Professor R&#39;s last class of his teaching career. Every time Professor R taught a class, he gave a special problem for the students to solve. You being his favourite student, put your heart into solving it one last time.</p><p>You are given two polynomials <script type="math/tex">f(x) = a_0 + a_1x + \dots + a_{n-1}x^{n-1}</script> and <script type="math/tex">g(x) = b_0 + b_1x + \dots + b_{m-1}x^{m-1}</script>, with positive integral coefficients. It is guaranteed that the cumulative GCD of the coefficients is equal to 1 for both the given polynomials. In other words, <script type="math/tex">gcd(a_0, a_1, \dots, a_{n-1}) = gcd(b_0, b_1, \dots, b_{m-1}) = 1</script>. Let <script type="math/tex">h(x) = f(x)\cdot g(x)</script>. Suppose that <script type="math/tex">h(x) = c_0 + c_1x + \dots + c_{n+m-2}x^{n+m-2}</script>.</p><p>You are also given a prime number p. Professor R challenges you to find any t such that <script type="math/tex">c_t</script> isn&#39;t divisible by p. He guarantees you that under these conditions such t always exists. If there are several such t, output any of them.</p><p><strong>As the input is quite large, please use fast input reading methods.</strong></p><p>Input<br>The first line of the input contains three integers, n, m and p (<script type="math/tex">1 \leq n, m \leq 10^6, 2 \leq p \leq 10^9</script>),  — n and m are the number of terms in <script type="math/tex">f(x)</script> and <script type="math/tex">g(x)</script> respectively (one more than the degrees of the respective polynomials) and p is the given prime number.</p><p>It is guaranteed that p is prime.</p><p>The second line contains n integers <script type="math/tex">a_0, a_1, \dots, a_{n-1}</script>(<script type="math/tex">1 \leq a_{i} \leq 10^{9}</script>) — <script type="math/tex">a_i</script> is the coefficient of <script type="math/tex">x^{i}</script> in <script type="math/tex">f(x)</script>.</p><p>The third line contains m integers <script type="math/tex">b_0, b_1, \dots, b_{m-1}</script> (<script type="math/tex">1 \leq b_{i} \leq 10^{9}</script>)  — <script type="math/tex">b_i</script> is the coefficient of <script type="math/tex">x^{i}</script> in <script type="math/tex">g(x)</script>.</p><p>Output<br>Print a single integer t (<script type="math/tex">0\le t \le n+m-2</script>)  — the appropriate power of x in <script type="math/tex">h(x)</script> whose coefficient isn&#39;t divisible by the given prime p. If there are multiple powers of x that satisfy the condition, print any.</p><p>Examples<br>input<br>3 2 2<br>1 1 2<br>2 1<br>output<br>1<br>input<br>2 2 999999937<br>2 1<br>3 1<br>output<br>2<br>Note<br>In the first test case, <script type="math/tex">f(x)</script> is <script type="math/tex">2x^2 + x + 1</script> and <script type="math/tex">g(x)</script> is <script type="math/tex">x+2</script>, their product <script type="math/tex">h(x)</script> being <script type="math/tex">2x^3 + 5x^2 + 3x + 2</script>, so the answer can be 1 or 2 as both 3 and 5 aren&#39;t divisible by 2.</p><p>In the second test case, <script type="math/tex">f(x)</script> is <script type="math/tex">x+2</script> and <script type="math/tex">g(x)</script> is <script type="math/tex">x+3</script>, their product <script type="math/tex">h(x)</script> being <script type="math/tex">x^2 + 5x + 6</script>, so the answer can be any of the powers as no coefficient is divisible by the given prime.</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你两个多项式，让你找到他们的乘积多项式中对p取模不为0的一个系数。<br>首先我们知道，一个数x，若想对p取模不为0，那么x一定满足<script type="math/tex">x=y \cdot p+z</script>，其中的z满足<script type="math/tex">z<p</script>.<br>那么我们现在去找这两个多项式的系数当中第一个对p取模不为0的系数，这两个系数的和就是答案，即这两个系数相乘之后在c中的系数。<br><strong>可是为什么呢？</strong><br>假设我们找到的这两个系数分别为x,y,因为我们找的是对p取模不为0的一个系数。换句话说就是在x，y前面的系数对p取模都为0.<br>我们再看x，y相乘在c中得到的项是<script type="math/tex">c^{x+y}</script>,假设这一项的系数是t，那么t就等于</p><script type="math/tex; mode=display">t=a_0b_{x+y}+a_1b_{x+y-1}+a_2b{x+y-2}+\cdots+a_xb_y+\cdots+a_{x+y-2}b_2+a{x+y-1}b_1+a_{x+y}b_0</script><p>我们不难发现，在t中除了<script type="math/tex">a_xb_y</script>这一项，其他项对p取模均为0。<br>因为其他每一项中都有一个<script type="math/tex">a_{i} \quad i \in(0, x)</script>或者<script type="math/tex">b_{i} \quad i \in(0, y)</script>，这两个项我们上面已经说过了对p取模为0，所以他们乘上一个数之后对p取模仍然为0。所以我们的t就可以变成<script type="math/tex">t=y \cdot p+z</script>的形式，<script type="math/tex">z=a_x \cdot b_y</script>。<br>所以我们只要分别找到两个多项式中第一个对p取模不为0的项数即可。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n, m, p, a;    scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;p);    ll x = -1, y = -1;    for (int i = 0; i &lt; n; i++) {        scanf(&quot;%lld&quot;, &amp;a); if (a % p &amp;&amp; x &lt; 0) x = i;    }    for (int i = 0; i &lt; m; i++) {        scanf(&quot;%lld&quot;, &amp;a); if (a % p &amp;&amp; y &lt; 0) y = i;    }    printf(&quot;%lld\n&quot;, x + y);}</code></pre><h2 id="FFT模板"><a href="#FFT模板" class="headerlink" title="FFT模板"></a>FFT模板</h2><pre><code class="lang-c++">#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 410000;const double pi=acos(-1);struct E{    double x,y;    E(){x=y=0;}    E(double a,double b){x=a;y=b;}}a[maxn],b[maxn],c[maxn],w[maxn];int id[maxn],an,bn,cn,n,ln;E operator +(E x,E y){return E(x.x+y.x,x.y+y.y);}E operator -(E x,E y){return E(x.x-y.x,x.y-y.y);}E operator *(E x,E y){return E(x.x*y.x-x.y*y.y,x.x*y.y+x.y*y.x);}void fft(E *s,int sig){    for(int i=0;i&lt;n;i++)if(i&lt;id[i])swap(s[i],s[id[i]]);    for(int m=2;m&lt;=n;m&lt;&lt;=1)    {        int t=m&gt;&gt;1,tt=n/m;        for(int i=0;i&lt;t;i++)        {            E wn=sig==1?w[i*tt]:w[n-i*tt];            for(int j=i;j&lt;n;j+=m)            {                E tx=s[j],ty=s[j+t]*wn;                s[j]=tx+ty;                s[j+t]=tx-ty;            }        }    }    if(sig==-1)for(int i=0;i&lt;n;i++)s[i].x/=(double)n;}int main(){    scanf(&quot;%d%d&quot;,&amp;an,&amp;bn);an++;bn++;    for(int i=0;i&lt;an;i++) scanf(&quot;%lf&quot;,&amp;a[i].x);    for(int i=0;i&lt;bn;i++) scanf(&quot;%lf&quot;,&amp;b[i].x);    n=1;ln=0;while(n&lt;(an+bn))ln++,n&lt;&lt;=1;    for(int i=0;i&lt;n;i++) id[i]=id[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(ln-1));    for(int m=2;m&lt;=n;m&lt;&lt;=1)    {        int t=m&gt;&gt;1,tt=n/m;        for(int i=0;i&lt;t;i++)        {            w[i*tt]=E(cos(i*2*pi/m),sin(i*2*pi/m));            w[n-i*tt]=E(cos(i*2*pi/m),sin(-i*2*pi/m));        }    }    fft(a,1);fft(b,1);    for(int i=0;i&lt;n;i++) c[i]=a[i]*b[i];    fft(c,-1);    printf(&quot;%d&quot;,int(c[0].x+0.5));    for(int i=1;i&lt;an+bn-1;i++)printf(&quot; %d&quot;,int(c[i].x+0.5));    printf(&quot;\n&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ozon Tech Challenge 2020 (Div.1 + Div.2, Rated, T-shirts + prizes!) D. Kuroni and the Celebration</title>
      <link href="/2020/03/04/cf1305D/"/>
      <url>/2020/03/04/cf1305D/</url>
      
        <content type="html"><![CDATA[<h1 id="D-Kuroni-and-the-Celebration"><a href="#D-Kuroni-and-the-Celebration" class="headerlink" title="D. Kuroni and the Celebration"></a>D. Kuroni and the Celebration</h1><p>Link: <a href="https://codeforces.com/contest/1305/problem/D" target="_blank" rel="noopener">D. Kuroni and the Celebration</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>This is an interactive problem.</p><p>After getting AC after 13 Time Limit Exceeded verdicts on a geometry problem, Kuroni went to an Italian restaurant to celebrate this holy achievement. Unfortunately, the excess sauce disoriented him, and he&#39;s now lost!</p><p>The United States of America can be modeled as a tree (why though) with n vertices. The tree is rooted at vertex r, wherein lies Kuroni&#39;s hotel.</p><p>Kuroni has a phone app designed to help him in such emergency cases. To use the app, he has to input two vertices u and v, and it&#39;ll return a vertex w, which is the lowest common ancestor of those two vertices.</p><p>However, since the phone&#39;s battery has been almost drained out from live-streaming Kuroni&#39;s celebration party, he could only use the app at most <script type="math/tex">\lfloor \frac{n}{2} \rfloor</script> times. After that, the phone would die and there will be nothing left to help our dear friend! :(</p><p>As the night is cold and dark, Kuroni needs to get back, so that he can reunite with his comfy bed and pillow(s). Can you help him figure out his hotel&#39;s location?</p><p>Interaction<br>The interaction starts with reading a single integer n (<script type="math/tex">2 \le n \le 1000</script>), the number of vertices of the tree.</p><p>Then you will read n−1 lines, the i-th of them has two integers xi and yi <script type="math/tex">\left(1 \leq x_{i}, y_{i} \leq n, x_{i} \neq y_{i}\right)</script>, denoting there is an edge connecting vertices xi and yi. It is guaranteed that the edges will form a tree.</p><p>Then you can make queries of type &quot;? u v&quot; (<script type="math/tex">1 \le u, v \le n</script>) to find the lowest common ancestor of vertex u and v.</p><p>After the query, read the result w as an integer.</p><p>In case your query is invalid or you asked more than <script type="math/tex">\lfloor \frac{n}{2} \rfloor</script> queries, the program will print −1 and will finish interaction. You will receive a Wrong answer verdict. Make sure to exit immediately to avoid getting other verdicts.</p><p>When you find out the vertex r, print &quot;! r&quot; and quit after that. This query does not count towards the <script type="math/tex">\lfloor \frac{n}{2} \rfloor</script> limit.</p><p>Note that the tree is fixed beforehand and will not change during the queries, i.e. the interactor is not adaptive.</p><p>After printing any query do not forget to print end of line and flush the output. Otherwise, you might get Idleness limit exceeded. To do this, use:</p><ul><li>fflush(stdout) or cout.flush() in C++;</li><li>System.out.flush() in Java;</li><li>flush(output) in Pascal;</li><li>stdout.flush() in Python;</li><li>see the documentation for other languages.</li></ul><p>Hacks</p><p>To hack, use the following format:</p><p>The first line should contain two integers n and r <script type="math/tex">(2 \leq n \leq 1000,1 \leq r \leq n)</script>, denoting the number of vertices and the vertex with Kuroni&#39;s hotel.</p><p>The i-th of the next n−1 lines should contain two integers <script type="math/tex">x_{i}</script> and <script type="math/tex">y_{i}</script> (<script type="math/tex">1 \le x_i, y_i \le n</script>) — denoting there is an edge connecting vertex <script type="math/tex">x_{i}</script>and <script type="math/tex">y_{i}</script>.</p><p>The edges presented should form a tree.</p><p>Example<br>input<br>6<br>1 4<br>4 2<br>5 3<br>6 3<br>2 3</p><p>3</p><p>4</p><p>4</p><p>output</p><p>? 5 6</p><p>? 3 1</p><p>? 1 2</p><p>! 4<br>Note<br>Note that the example interaction contains extra empty lines so that it&#39;s easier to read. The real interaction doesn&#39;t contain any empty lines and you shouldn&#39;t print any extra empty lines as well.</p><p>The image below demonstrates the tree in the sample test:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200304103159.webp" data-fancybox="images" data-caption="20200304103159" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200304103159.webp" class="img-shadow img-margin"></center></a></p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你一棵树，让你去找他的根。n为树的节点数，查询次数不能超过<script type="math/tex">\lfloor \frac{n}{2} \rfloor</script> 。每次你可以给出两个点，系统会将这两个点的LCA返回给你，也就是充当下一个输入。这就是交互式的意思。<br>比如说样例，输入完树之后，你查询了5，6，他们的lca是3，所以你的下一个输入就是3.<br>假设我们每次都查询两个叶子结点的lca，会有两种情况</p><ol><li>lca与两个点中的某一个相等，这时这个lca就是我们要找的根节点。</li><li>lca与这两个点都不相同，这时我们把这两个点删去。</li></ol><p>所以我们如果没有找到根节点，那么每次也都可以删除两个点，所以删除<script type="math/tex">\lfloor \frac{n}{2} \rfloor</script> 次之后一定可以找到根节点。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;#define pb push_backconst int maxn = 1e3 + 10;vector&lt;int&gt; V[maxn], mid;int d[maxn], c;int main(){    int t, n;    cin &gt;&gt; n;    for (int i = 1, u, v; i &lt; n; i++) {        cin &gt;&gt; u &gt;&gt; v;        V[u].pb(v); V[v].pb(u);        d[v]++, d[u]++; //统计度数用来寻找叶子节点    }    t = n &gt;&gt; 1;             //最多n/2次查询    while (t--) {        mid.clear();        for (int i = 1; i &lt;= n; i++) if (d[i] == 1) mid.pb(i);        int a = mid[0], b = mid[1];        cout &lt;&lt; &quot;? &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;        cout.flush();        cin &gt;&gt; c;        if (c == a || c == b) {            cout &lt;&lt; &quot;! &quot; &lt;&lt; c &lt;&lt; endl;            return 0;        }        for (auto i:V[a]) d[i]--;        for (auto i:V[b]) d[i]--;       //与我们将要删除的两个点相连的点的度数全部减一        d[a] = d[b] = 0;                //要删除的点的度数置为0，就不会再考虑了。    }    cout &lt;&lt; &quot;! &quot; &lt;&lt; c &lt;&lt; endl;              //如果查询了n/2次之后还没有遇到lca与叶节点相等的情况，那么此时的lca一定是根节点    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花里胡哨的Hexo | 给你的hexo博客加上文章分析</title>
      <link href="/2020/03/03/post-charts/"/>
      <url>/2020/03/03/post-charts/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文将使用傻瓜式介绍，使用我所用的主题Sakura为例。其他主题灵活运用即可。</p></blockquote><p>前排感谢matery<br>matery的GitHub：<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery</a></p><p>我的文章分析：<a href="http://cndrew.cn/analytics/" target="_blank" rel="noopener">http://cndrew.cn/analytics/</a></p><p>Attention：如果你很清楚的知道下面的步骤都是在做什么，各种文件你想放那随便放，但是如果你是小白，就跟着教程一步一步走。</p><p>首先在<code>X:\nblog\source</code>中新建一个文件夹<code>analytics</code>，用来生成文章分析的页面<br>在文件夹中新建一个文件<code>index.md</code>，文件内容为</p><pre><code class="lang-markdown">---title: analyticsdate:layout: analytics---</code></pre><p>然后下载<code>echarts.min.js</code>.这里给出下载链接：<a href="https://pan.miaodrew.workers.dev/Drew/web/js/echarts.min.js?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">点我下载</a></p><p>然后在<code>X:\nblog\themes\Sakura\layout</code>中新建<code>analytics.ejs</code><br>文件内容为</p><pre><code class="lang-ejs">&lt;div class=&quot;pattern-center-blank&quot;&gt;&lt;/div&gt;&lt;div class=&quot;pattern-center &quot;&gt;  &lt;div class=&quot;pattern-attachment-img&quot;&gt;    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/20200303155335.webp&quot; data-src=&quot;&lt;%= page.photos %&gt;&quot; class=&quot;lazyload&quot; onerror=&quot;imgError(this,3)&quot; style=&quot;width: 100%; height: 100%; object-fit: cover; pointer-events: none;&quot;&gt;  &lt;/div&gt;        &lt;style type=&quot;text/css&quot;&gt;                #contentss {                    position: relative;                    width: 800px;                    height: 900px;                    max-height: 1200px;                    margin-bottom: 15px;                    margin-top: 15px;                    text-align: center;                    border: 0;                    border-radius: 10px;                    color: rgba(0, 0, 0, .87);                    background: #fff 50%;                    background-size: cover;                    box-shadow: 0 15px 35px rgba(50, 50, 93, .1), 0 5px 15px rgba(0, 0, 0, .07);                    margin:0 auto;                }            &lt;/style&gt;  &lt;header class=&quot;pattern-header &quot;&gt;    &lt;h1 class=&quot;entry-title&quot;&gt;    文章数据统计&lt;/h1&gt;  &lt;/header&gt;&lt;/div&gt;&lt;div id=&quot;contentss&quot;&gt;&lt;%- partial(&#39;_widget/post-charts&#39;) %&gt;&lt;/div&gt;</code></pre><p>说一下，这个ejs文件中最关键的是<code>&lt;%- partial(&#39;_widget/post-charts&#39;) %&gt;</code>，其他的都是为了迎合我的主题以及美化而已。</p><p>然后在<code>X:\nblog\themes\Sakura\layout\_widget\</code>中新建<code>post-charts.ejs</code><br>文件内容为</p><pre><code class="lang-ejs">&lt;style type=&quot;text/css&quot;&gt;    #posts-chart,    #categories-chart,    #tags-chart {        width: 100%;        height: 300px;        margin: 0.5rem auto;        padding: 0.5rem;    }&lt;/style&gt;&lt;div id=&quot;postCharts&quot; class=&quot;post-charts&quot;&gt;    &lt;div class=&quot;title center-align&quot; data-aos=&quot;zoom-in-up&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;chart col s12 m6 l4&quot; data-aos=&quot;zoom-in-up&quot;&gt;            &lt;div id=&quot;posts-chart&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;chart col s12 m6 l4&quot; data-aos=&quot;zoom-in-up&quot;&gt;            &lt;div id=&quot;categories-chart&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;chart col s12 m6 l4&quot; data-aos=&quot;zoom-in-up&quot;&gt;            &lt;div id=&quot;tags-chart&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let postsChart = echarts.init(document.getElementById(&#39;posts-chart&#39;));    let categoriesChart = echarts.init(document.getElementById(&#39;categories-chart&#39;));    let tagsChart = echarts.init(document.getElementById(&#39;tags-chart&#39;));    &lt;%    /* calculate postsOption data. */    var startDate = moment().subtract(1, &#39;years&#39;).startOf(&#39;month&#39;);    var endDate = moment().endOf(&#39;month&#39;);    var monthMap = new Map();    var dayTime = 3600 * 24 * 1000;    for (var time = startDate; time &lt;= endDate; time += dayTime) {        var month = moment(time).format(&#39;YYYY-MM&#39;);        if (!monthMap.has(month)) {            monthMap.set(month, 0);        }    }    // post and count map.    site.posts.forEach(function (post) {        var month = post.date.format(&#39;YYYY-MM&#39;);        if (monthMap.has(month)) {            monthMap.set(month, monthMap.get(month) + 1);        }    });    // xAxis data and yAxis data.    var monthArr = JSON.stringify([...monthMap.keys()]);    var monthValueArr = JSON.stringify([...monthMap.values()]);    %&gt;    let postsOption = {        title: {            text: &#39;文章发布统计图&#39;,            top: 0,            x: &#39;center&#39;        },        tooltip: {            trigger: &#39;axis&#39;        },        xAxis: {            type: &#39;category&#39;,            data: &lt;%- monthArr %&gt;        },        yAxis: {            type: &#39;value&#39;,        },        series: [            {                name: &#39;&lt;%- __(&quot;postsNumberName&quot;)  %&gt;&#39;,                type: &#39;line&#39;,                color: [&#39;#6772e5&#39;],                data: &lt;%- monthValueArr %&gt;,                markPoint: {                    symbolSize: 45,                    color: [&#39;#fa755a&#39;,&#39;#3ecf8e&#39;,&#39;#82d3f4&#39;],                    data: [{                        type: &#39;max&#39;,                        itemStyle: {color: [&#39;#3ecf8e&#39;]},                        name: &#39;&lt;%- __(&quot;maximum&quot;)  %&gt;&#39;                    }, {                        type: &#39;min&#39;,                        itemStyle: {color: [&#39;#fa755a&#39;]},                        name: &#39;&lt;%- __(&quot;minimum&quot;)  %&gt;&#39;                    }]                },                markLine: {                    itemStyle: {color: [&#39;#ab47bc&#39;]},                    data: [                        {type: &#39;average&#39;, name: &#39;&lt;%- __(&quot;average&quot;)  %&gt;&#39;}                    ]                }            }        ]    };    &lt;%    /* calculate categoriesOption data. */    var categoryArr = [];    site.categories.map(function(category) {        categoryArr.push({&#39;name&#39;: category.name, &#39;value&#39;: category.length})    });    var categoryArrJson = JSON.stringify(categoryArr);    %&gt;    let categoriesOption = {        title: {            text: &#39;文章分类统计图&#39;,            top: 1,            x: &#39;center&#39;        },        tooltip: {            trigger: &#39;item&#39;,            formatter: &quot;{a} &lt;br/&gt;{b} : {c} ({d}%)&quot;        },        series: [            {                name: &#39;&lt;%- __(&quot;categories&quot;)  %&gt;&#39;,                type: &#39;pie&#39;,                radius: &#39;50%&#39;,                color: [&#39;#6772e5&#39;, &#39;#ff9e0f&#39;, &#39;#fa755a&#39;, &#39;#3ecf8e&#39;, &#39;#82d3f4&#39;, &#39;#ab47bc&#39;, &#39;#525f7f&#39;, &#39;#f51c47&#39;, &#39;#26A69A&#39;],                data: &lt;%- categoryArrJson %&gt;,                itemStyle: {                    emphasis: {                        shadowBlur: 10,                        shadowOffsetX: 0,                        shadowColor: &#39;rgba(0, 0, 0, 0.5)&#39;                    }                }            }        ]    };    &lt;%    /* calculate tagsOption data. */    // get all tags name and count,then order by length desc.    var tagArr = [];    site.tags.map(function(tag) {        tagArr.push({&#39;name&#39;: tag.name, &#39;value&#39;: tag.length});    });    tagArr.sort((a, b) =&gt; {return b.value - a.value});    // get Top 10 tags name and count.    var tagNameArr = [];    var tagCountArr = [];    for (var i = 0, len = Math.min(tagArr.length, 10); i &lt; len; i++) {        tagNameArr.push(tagArr[i].name);        tagCountArr.push(tagArr[i].value);    }    var tagNameArrJson = JSON.stringify(tagNameArr);    var tagCountArrJson = JSON.stringify(tagCountArr);    %&gt;    let tagsOption = {        title: {            text: &#39;Top10标签统计图 &#39;,            top: 2,            x: &#39;center&#39;        },        tooltip: {},        xAxis: [            {                type: &#39;category&#39;,                data: &lt;%- tagNameArrJson %&gt;            }        ],        yAxis: [            {                type: &#39;value&#39;            }        ],        series: [            {                type: &#39;bar&#39;,                color: [&#39;#82d3f4&#39;],                barWidth : 18,                data: &lt;%- tagCountArrJson %&gt;,                markPoint: {                    symbolSize: 45,                    data: [{                        type: &#39;max&#39;,                        itemStyle: {color: [&#39;#3ecf8e&#39;]},                        name: &#39;&lt;%- __(&quot;maximum&quot;)  %&gt;&#39;                    }, {                        type: &#39;min&#39;,                        itemStyle: {color: [&#39;#fa755a&#39;]},                        name: &#39;&lt;%- __(&quot;minimum&quot;)  %&gt;&#39;                    }],                },                markLine: {                    itemStyle: {color: [&#39;#ab47bc&#39;]},                    data: [                        {type: &#39;average&#39;, name: &#39;&lt;%- __(&quot;average&quot;)  %&gt;&#39;}                    ]                }            }        ]    };    // render the charts    postsChart.setOption(postsOption);    categoriesChart.setOption(categoriesOption);    tagsChart.setOption(tagsOption);&lt;/script&gt;</code></pre><p>最后在主题的<code>_config.yml</code>文件中添加菜单栏中的analytics</p><pre><code class="lang-yml">统计: {path: /analytics/ , fa: fa-line-chart }</code></pre><p>然后就可以了，效果如图:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200303161857.webp" data-fancybox="images" data-caption="20200303161857" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200303161857.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> 建站 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花里胡哨的Hexo | 给你的hexo博客加上仿GIthub文章日历以及分类雷达图</title>
      <link href="/2020/03/03/calender/"/>
      <url>/2020/03/03/calender/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了方便，这里就直接以我的博客主题Sakura为例进行教程。其他主题使用起来灵活变通即可。</p></blockquote><p>前排感谢matery<br>matery的GitHub：<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery</a></p><p>我的文章日历：<a href="https://cndrew.cn/archives/" target="_blank" rel="noopener">https://cndrew.cn/archives/</a><br>分类雷达图：<a href="https://cndrew.cn/category/" target="_blank" rel="noopener">https://cndrew.cn/category/</a></p><p>Attention：如果你很清楚的知道下面的步骤都是在做什么，各种文件你想放那随便放，但是如果你是小白，就跟着教程一步一步走。</p><h1 id="文章日历"><a href="#文章日历" class="headerlink" title="文章日历"></a>文章日历</h1><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200303145638.webp" data-fancybox="images" data-caption="20200303145638" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200303145638.webp" class="img-shadow img-margin"></center></a><h2 id="准备js"><a href="#准备js" class="headerlink" title="准备js"></a>准备js</h2><p>在<a href="https://pan.miaodrew.workers.dev/Drew/web/js/echarts.min.js?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">这里</a>下载<code>echarts.min.js</code>然后放到<code>.\nblog\themes\Sakura\source\js</code>中</p><h2 id="准备css"><a href="#准备css" class="headerlink" title="准备css"></a>准备css</h2><p>在<a href="https://pan.miaodrew.workers.dev/Drew/web/css/matery.css?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">这里</a>下载<code>matery.css</code>然后放到<code>.\nblog\themes\Sakura\source\css</code>中<br>然后找到主题中对应的head渲染模板中，比如说我的就是<code>.\nblog\themes\Sakura\layout\_partial\head.ejs</code><br>在head标记中添加一行</p><pre><code class="lang-html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/matery.css&quot;&gt;</code></pre><h2 id="准备模板"><a href="#准备模板" class="headerlink" title="准备模板"></a>准备模板</h2><p>在<a href="https://pan.miaodrew.workers.dev/Drew/web/ejs-hexo/post-calendar.ejs?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">这里</a>下载<code>post-calendar.ejs</code>然后放到<code>.\nblog\themes\Sakura\layout\_widget</code>中</p><h2 id="选择位置"><a href="#选择位置" class="headerlink" title="选择位置"></a>选择位置</h2><p>这一步就是自己选择了。找到hexo模板中你想放文章日历的位置，在相应位置添加</p><pre><code class="lang-ejs">&lt;%- partial(&#39;_widget/post-calendar&#39;) %&gt;</code></pre><p>比如说我准备把日历放在我的归档界面。就找到<code>.\nblog\themes\Sakura\layout\archive.ejs</code>,找到合适的位置加上。</p><p>然后，你的文章日历就有了！</p><h1 id="分类雷达图"><a href="#分类雷达图" class="headerlink" title="分类雷达图"></a>分类雷达图</h1><p>这一步需要的js和css跟上一步的一样，如果上一个你添加了，这里直接跳到第三步即可。</p><h2 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h2><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200303145626.webp" data-fancybox="images" data-caption="20200303145626" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200303145626.webp" class="img-shadow img-margin"></center></a><h2 id="准备js-1"><a href="#准备js-1" class="headerlink" title="准备js"></a>准备js</h2><p>在<a href="https://pan.miaodrew.workers.dev/Drew/web/js/echarts.min.js?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">这里</a>下载<code>echarts.min.js</code>然后放到<code>.\nblog\themes\Sakura\source\js</code>中</p><h2 id="准备css-1"><a href="#准备css-1" class="headerlink" title="准备css"></a>准备css</h2><p>在<a href="https://pan.miaodrew.workers.dev/Drew/web/css/matery.css?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">这里</a>下载<code>matery.css</code>然后放到<code>.\nblog\themes\Sakura\source\css</code>中</p><h2 id="准备模板-1"><a href="#准备模板-1" class="headerlink" title="准备模板"></a>准备模板</h2><p>在<a href="https://pan.miaodrew.workers.dev/Drew/web/ejs-hexo/category-radar.ejs?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">这里</a>下载<code>category-radar.ejs</code>然后放到<code>.\nblog\themes\Sakura\layout\_widget</code>中</p><h2 id="选择位置-1"><a href="#选择位置-1" class="headerlink" title="选择位置"></a>选择位置</h2><p>这一步就是自己选择了。找到hexo模板中你想放文章日历的位置，在相应位置添加</p><pre><code class="lang-ejs">&lt;%- partial(&#39;_widget/category-radar&#39;) %&gt;</code></pre><p>然后，你的分类雷达图就有了！</p><h1 id="一些小美化"><a href="#一些小美化" class="headerlink" title="一些小美化"></a>一些小美化</h1><p>我只是一个html小白，有错的话对我善良点谢谢。<br>因为我们添加的这两个样式并不是自带的，所以肯定会跟主题显得有些？冲突或者看着不太舒服之类的。<br>（反正我是这样<br>所以我们可以给他们添加一个边框，添加了边框之后就是跟我上面的效果图一样的效果，不加的话，你可以自己试试效果。</p><p>首先找到你刚才放了<code>&lt;%- partial(&#39;_widget/category-radar&#39;) %&gt;&lt;/div&gt;</code>或者<code>&lt;%- partial(&#39;_widget/post-calendar&#39;) %&gt;</code>的模板文件中，在最上面添加</p><pre><code class="lang-css">&lt;style type=&quot;text/css&quot;&gt;        #contentss {        position: relative;        width: 800px;        height: 1200px;        max-height: 1200px;        margin-bottom: 15px;        margin-top: 15px;        text-align: center;        border: 0;        border-radius: 10px;        color: rgba(0, 0, 0, .87);        background: #fff 50%;        background-size: cover;        box-shadow: 0 15px 35px rgba(50, 50, 93, .1), 0 5px 15px rgba(0, 0, 0, .07);        margin:0 auto;        }    &lt;/style&gt;</code></pre><p>当然你也可以根据自己的喜好适配你自己的样式。<br>然后把<code>&lt;%- partial(&#39;_widget/category-radar&#39;) %&gt;</code>或者<code>&lt;%- partial(&#39;_widget/post-calendar&#39;) %&gt;</code><br>变成</p><pre><code class="lang-ejs">&lt;div id=&quot;contentss&quot;&gt;&lt;%- partial(&#39;_widget/category-radar&#39;) %&gt;&lt;/div&gt;`或者`&lt;%- partial(&#39;_widget/post-calendar&#39;) %&gt;&lt;/div&gt;</code></pre><p>即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就这样，我是挺喜欢这两个的，很帅很骚气。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> 建站 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BalticOI 2014 Day 1」三个朋友</title>
      <link href="/2020/03/02/loj2823/"/>
      <url>/2020/03/02/loj2823/</url>
      
        <content type="html"><![CDATA[<h1 id="「BalticOI-2014-Day-1」三个朋友"><a href="#「BalticOI-2014-Day-1」三个朋友" class="headerlink" title="「BalticOI 2014 Day 1」三个朋友"></a>「BalticOI 2014 Day 1」三个朋友</h1><p>Link: <a href="https://loj.ac/problem/2823" target="_blank" rel="noopener">「BalticOI 2014 Day 1」三个朋友</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个字符串S，先将字符串S复制一次（变成双倍快乐），得到字符串T，然后在T中插入一个字符，得到字符串U。<br>给出字符串U，重新构造出字符串S。<br>所有字符串只包含大写英文字母。<br>输入格式<br>第一行一个整数N，表示字符串U的长度。(<script type="math/tex">2 \leq N \leq 2000001</script>)<br>第二行一个长度为N的字符串，表示字符串U。<br>输出格式<br>一行一个字符串，表示字符串S。<br>特别地：</p><ul><li>如果字符串无法按照上述方法构造出来，输出 NOT POSSIBLE；</li><li>如果字符串S不唯一，输出 NOT UNIQUE。</li></ul><p>样例<br>样例输入 1<br>7<br>ABXCABC<br>样例输出 1<br>ABC<br>样例输入 2<br>6<br>ABCDEF<br>样例输出 2<br>NOT POSSIBLE<br>样例输入 3<br>9<br>ABABABABA<br>样例输出 3<br>NOT UNIQUE</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思题面已经描述的很清楚了。清楚了题意之后，显然可以用哈希写。因为输入的字符串的长度是S的二倍加一，所以如果长度是偶数，直接输出NOT POSSIBLE即可。而且显然我们可以知道满足题意得S最多就两种。然后我们可以遍历整个字符串，遍历到第i位时便认为这一位即新加的，因为我们要求的字符串的长度是固定的的，所以只要我们确定了最后一步加上的是哪一位，我们求出删去这一位之后字符串的前一半的哈希值和后一半的哈希值作比较就可以得到要求的字符串。<br>因为可能满足条件的字符串有多个，所以我们需要特殊处理一下。详见代码及注释。<br>我们刚好有求区间的哈希值以及区间中删去任一位置之后的哈希值的板子，直接套板子即可。<br>（在网上找到的题解写的代码，我真的是看着头疼，自我感觉写的还是很清楚的</p><p>关于用到的板子：<a href="https://ac.nowcoder.com/discuss/178326?type=101&amp;order=4&amp;pos=12&amp;page=1" target="_blank" rel="noopener">https://ac.nowcoder.com/discuss/178326?type=101&amp;order=4&amp;pos=12&amp;page=1</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6 + 10;typedef unsigned long long ull;#define base 233ull h[maxn], p[maxn];ull get_hash(int l, int r){    return h[r] - h[l - 1] * p[r - l + 1];}ull get_s(int l, int r, int x){    return get_hash(l, x - 1) * p[r - x] + get_hash(x + 1, r);}//板子int main(){    int n, mid; string s;    cin &gt;&gt; n &gt;&gt; s;    if (!(n &amp; 1)) {        cout &lt;&lt; &quot;NOT POSSIBLE\n&quot;; return 0;    }    p[0] = 1;    for (int i = 1; i &lt;= maxn; i++) p[i] = p[i - 1] * base;    s = &quot; &quot; + s;//因为我们求get_s的时候会遇到x-1，所以下标如果从0开始会RE，因此我们给s的第一位变成空格    h[1] = s[1];    for (int i = 2; i &lt;= n; i++)        h[i] = h[i - 1] * base + s[i];    mid = n / 2 + 1;    ull a, b, ans = 0; b = get_hash(mid + 1, n);    //这里我是分开处理了，前一半和后一半分开    //因为如果你假设的是前一半中删去一个，那么后半部分字符串就是我们要求的，它的哈希值是固定的，这样只用算一次    string Ans, ANS1, ANS2;    for (int i = mid + 1; i &lt;= n; i++) Ans += s[i];//把字符串后半部分存储起来    for (int i = 1; i &lt; mid; i++) {        a = get_s(1, mid, i);        // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;        if (a == b) {            ans++, ANS1 = Ans; break;//如果哈希值相等，说明Ans是答案之一        }    }    Ans = &quot;&quot;;    for (int i = 1; i &lt;= mid - 1; i++) Ans += s[i];    b = get_hash(1, mid - 1);    for (int i = mid; i &lt;= n; i++) {        a = get_s(mid, n, i);        // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;        if (a == b) {            ans++, ANS2 = Ans; break;        }    }//这一部分是从后一半中删去一个字符，跟上面那种情况同样的做法    if (ans == 0) cout &lt;&lt; &quot;NOT POSSIBLE\n&quot;;//如果ans还是0，说明没有出现满足条件的    else if (ans == 1 || ANS1 == ANS2) cout &lt;&lt; (ANS1 == &quot;&quot; ? ANS2 : ANS1) &lt;&lt; endl;//如果只有1种情况，输出那一种。但是还有一种情况就是，分开的两种都有结果但是结果相同，所以我们也输出一个。    else cout &lt;&lt; &quot;NOT UNIQUE\n&quot;;//否则就是有两个解}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Hash </tag>
            
            <tag> loj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 625 (Div. 2, based on Technocup 2020 Final Round) D. Navigation System</title>
      <link href="/2020/03/02/cf1321D/"/>
      <url>/2020/03/02/cf1321D/</url>
      
        <content type="html"><![CDATA[<h1 id="D-Navigation-System"><a href="#D-Navigation-System" class="headerlink" title="D. Navigation System"></a>D. Navigation System</h1><p>Link：<a href="https://codeforces.com/contest/1321/problem/D" target="_blank" rel="noopener">D. Navigation System</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The map of Bertown can be represented as a set of n intersections, numbered from 1 to n and connected by m one-way roads. It is possible to move along the roads from any intersection to any other intersection. The length of some path from one intersection to another is the number of roads that one has to traverse along the path. The shortest path from one intersection v to another intersection u is the path that starts in v, ends in u and has the minimum length among all such paths.</p><p>Polycarp lives near the intersection s and works in a building near the intersection t. Every day he gets from s to t by car. Today he has chosen the following path to his workplace: <script type="math/tex">p_1</script>, <script type="math/tex">p_2</script>, ..., <script type="math/tex">p_k</script>, where <script type="math/tex">p_1 = s</script>, <script type="math/tex">p_k = t</script>, and all other elements of this sequence are the intermediate intersections, listed in the order Polycarp arrived at them. Polycarp never arrived at the same intersection twice, so all elements of this sequence are pairwise distinct. Note that you know Polycarp&#39;s path beforehand (it is fixed), and it is not necessarily one of the shortest paths from s to t.</p><p>Polycarp&#39;s car has a complex navigation system installed in it. Let&#39;s describe how it works. When Polycarp starts his journey at the intersection s, the system chooses some shortest path from s to t and shows it to Polycarp. Let&#39;s denote the next intersection in the chosen path as v. If Polycarp chooses to drive along the road from s to v, then the navigator shows him the same shortest path (obviously, starting from v as soon as he arrives at this intersection). However, if Polycarp chooses to drive to another intersection w instead, the navigator rebuilds the path: as soon as Polycarp arrives at w, the navigation system chooses some shortest path from w to t and shows it to Polycarp. The same process continues until Polycarp arrives at t: if Polycarp moves along the road recommended by the system, it maintains the shortest path it has already built; but if Polycarp chooses some other path, the system rebuilds the path by the same rules.</p><p>Here is an example. Suppose the map of Bertown looks as follows, and Polycarp drives along the path [1, 2, 3, 4] (s=1, t=4):</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200302131845.webp" data-fancybox="images" data-caption="20200302131845" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200302131845.webp" class="img-shadow img-margin"></center></a><ol><li>When Polycarp starts at 1, the system chooses some shortest path from 1 to 4. There is only one such path, it is [1,5,4];</li><li>Polycarp chooses to drive to 2, which is not along the path chosen by the system. When Polycarp arrives at 2, the navigator rebuilds the path by choosing some shortest path from 2 to 4, for example, [2,6,4] (note that it could choose [2,3,4]);</li><li>Polycarp chooses to drive to 3, which is not along the path chosen by the system. When Polycarp arrives at 3, the navigator rebuilds the path by choosing the only shortest path from 3 to 4, which is [3,4];</li><li>Polycarp arrives at 4 along the road chosen by the navigator, so the system does not have to rebuild anything.</li></ol><p>Overall, we get 2 rebuilds in this scenario. Note that if the system chose [2,3,4] instead of [2,6,4] during the second step, there would be only 1 rebuild (since Polycarp goes along the path, so the system maintains the path [3,4] during the third step).</p><p>The example shows us that the number of rebuilds can differ even if the map of Bertown and the path chosen by Polycarp stays the same. Given this information (the map and Polycarp&#39;s path), can you determine the minimum and the maximum number of rebuilds that could have happened during the journey?</p><p>Input<br>The first line contains two integers n and m (<script type="math/tex">2 \le n \le m \le 2 \cdot 10^5</script>) — the number of intersections and one-way roads in Bertown, respectively.<br>Then m lines follow, each describing a road. Each line contains two integers u and v <script type="math/tex">(1 \leq u, v \leq n, u \neq v)</script><br> denoting a road from intersection u to intersection v. All roads in Bertown are pairwise distinct, which means that each ordered pair (u,v) appears at most once in these m lines (but if there is a road (u,v), the road (v,u) can also appear).</p><p>The following line contains one integer k (<script type="math/tex">2 \le k \le n</script>) — the number of intersections in Polycarp&#39;s path from home to his workplace.</p><p>The last line contains k integers <script type="math/tex">p_1</script>, <script type="math/tex">p_2</script>, ..., <script type="math/tex">p_k</script>(<script type="math/tex">1 \le p_i \le n</script>, all these integers are pairwise distinct) — the intersections along Polycarp&#39;s path in the order he arrived at them. p1 is the intersection where Polycarp lives (<script type="math/tex">s = p_1</script>), and pk is the intersection where Polycarp&#39;s workplace is situated (<script type="math/tex">t = p_k</script>). It is guaranteed that for every <script type="math/tex">i \in [1, k - 1]</script> the road from <script type="math/tex">p_i</script> to <script type="math/tex">p_{i + 1}</script> exists, so the path goes along the roads of Bertown.</p><p>Output<br>Print two integers: the minimum and the maximum number of rebuilds that could have happened during the journey.</p><p>Examples<br>input<br>6 9<br>1 5<br>5 4<br>1 2<br>2 3<br>3 4<br>4 1<br>2 6<br>6 4<br>4 2<br>4<br>1 2 3 4<br>output<br>1 2<br>input<br>7 7<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>6 7<br>7 1<br>7<br>1 2 3 4 5 6 7<br>output<br>0 0<br>input<br>8 13<br>8 7<br>8 6<br>7 5<br>7 4<br>6 5<br>6 4<br>5 3<br>5 2<br>4 3<br>4 2<br>3 1<br>2 1<br>1 8<br>5<br>8 7 5 2 1<br>output<br>0 3</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>刚开始看到这道题的时候一点都不想看，因为太长了。仔细看了一下，这道题的意思就是给你一个有向图，现在有一个系统会自动给出你所在的位置到达终点的最短路的路径，如果你下一步走的不是系统给出的最短路的路径，系统会重新规划一次，起点为你现在的位置，现在给出你走的路径，问系统最多最少重新规划几次。<br>首先我们要知道当你走的路不是系统规划的最短路的时候就会重新规划。因为最短路并不是唯一的，所以会存在不一样的规划次数。<br>最小的规划次数就是每次你走的都是规划的最短路。<br>最大的规划次数就是每次走只要存在可以重新规划的下一步就重新规划。<br>因为每次系统规划的都是到达终点的最短路，所以我们需要从终点开始倒着bfs。统计出来每个点到终点的最短距离。并且我们走的路径是固定的，所以从起点开始每次比较当前点和下一个走到的点到终点的距离。再根据上面两个条件计算min和max即可。具体细节详见代码注释。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;#define pb push_backtypedef long long ll;vector&lt;int&gt; v1[maxn], v2[maxn];int a[maxn], dis[maxn], vis[maxn];void bfs(int x){    queue&lt;int&gt; que;    que.push(x); vis[x] = 1;    while (!que.empty()) {        int mid = que.front();        que.pop();        for (int i = 0; i &lt; v2[mid].size(); i++) {            int p = v2[mid][i];            if (vis[p]) continue;            vis[p] = 1;            dis[p] = dis[mid] + 1;            que.push(p);        }    }}int main(){    ios::sync_with_stdio(0);    int n, m, k;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0, u, v; i &lt; m; i++) {        cin &gt;&gt; u &gt;&gt; v;        v1[u].pb(v); v2[v].pb(u);//有向图存的时候存单向边即可。v2存反边，为下面求每个点到终点的最短路做准备    }    cin &gt;&gt; k;    for (int i = 1; i &lt;= k; i++)        cin &gt;&gt; a[i];    bfs(a[k]);//求出其他点到终点的最短路    // for (int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dis[i] &lt;&lt; endl;    int minn = 0, maxx = 0;    for (int i = 1; i &lt; k; i++)        if (dis[a[i]] - 1 != dis[a[i + 1]]) minn++;//最少重新规划次数的情况，只要每走一步接近终点一步，就不需要重新规划，否则重新规划，这是必须的，因为规划的最短路中不会出现距离终点距离一样的。    for (int i = 1; i &lt; k; i++) {        int flag = 0, mid = a[i];        for (int j = 0; j &lt; v1[mid].size(); j++) {            int mi = v1[mid][j];            if (mi != a[i + 1] &amp;&amp; dis[mi] + 1 == dis[mid]) flag = 1;            if (mi == a[i + 1] &amp;&amp; dis[mi] + 1 != dis[mid]) flag = 1;            /*            最多规划次数的情况，遍历跟这个点相连的所有点，我们假设这个点为mi点，如果mi点不是我们要走的路径中的下一个点            并且&quot;dis[mi]+1==dis[mid]&quot;，那我们就可以假设之前规划的最短路是经过这个点的，            但是走到下一个点并不是规划的这个点，需要重新规划一次。或者mi点就是我们要走的路径中的下一个点，            并且这个点跟上一个点到终点的距离相等，那么我们也需要重新规划一次，这个在最少的情况种已经解释过了。            */        }        if (flag) maxx++;    }    cout &lt;&lt; minn &lt;&lt; &quot; &quot; &lt;&lt; maxx &lt;&lt; endl;}</code></pre><h1 id="News"><a href="#News" class="headerlink" title="News"></a>News</h1><p>经历了不知道多久的py以及py，我的cf1700分了！！！虽然有水分，但是还是吹自己一波2333<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200302132004.webp" data-fancybox="images" data-caption="20200302132004" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200302132004.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> BFS </tag>
            
            <tag> codeforces </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ - 3321   Apple Tree</title>
      <link href="/2020/02/27/poj3321/"/>
      <url>/2020/02/27/poj3321/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DFS序就是将树形结构转化为线性结构，用dfs遍历一遍这棵树，进入到x节点有一个in时间戳，递归退出时有一个out时间戳</p></blockquote><p>说人话就是dfs序可以让一个树形结构上面的动态修改转化为线性结构的操作。方便使用线段树或树状数组。</p><h1 id="Apple-Tree"><a href="#Apple-Tree" class="headerlink" title="Apple Tree"></a>Apple Tree</h1><p>Link:<a href="http://poj.org/problem?id=3321" target="_blank" rel="noopener">Apple Tree</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There is an apple tree outside of kaka&#39;s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree.</p><p>The tree has N forks which are connected by branches. Kaka numbers the forks by 1 to N and the root is always numbered by 1. Apples will grow on the forks and two apple won&#39;t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree.</p><p>The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka?</p> <a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200227171514.webp" data-fancybox="images" data-caption="20200227171514" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200227171514.webp" class="img-shadow img-margin"></center></a><p>Input</p><p>The first line contains an integer N (N ≤ 100,000) , which is the number of the forks in the tree.<br>The following N - 1 lines each contain two integers u and v, which means fork u and fork v are connected by a branch.<br>The next line contains an integer M (M ≤ 100,000).<br>The following M lines each contain a message which is either<br>&quot;C x&quot; which means the existence of the apple on fork x has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.<br>or<br>&quot;Q x&quot; which means an inquiry for the number of apples in the sub-tree above the fork x, including the apple (if exists) on the fork x<br>Note the tree is full of apples at the beginning</p><p>Output</p><p>For every inquiry, output the correspond answer per line.<br>Sample Input</p><p>3<br>1 2<br>1 3<br>3<br>Q 1<br>C 2<br>Q 1<br>Sample Output</p><p>3<br>2</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving:"></a>Problem solving:</h2><p>这道题的意思就是给你一颗树，初始时树上每个节点的权值都为1。然后查询，每次查询可能有两种操作，一种是找到一个节点修改它的值，1变0，0变1。还有一种就是查询以当前点为根的子树的权值和。</p><p>因为是动态修改查询的。所以这里我们先用dfs序转化为线性，再用树状数组维护就可以了。</p><p>用dfs遍历一遍这棵树，进入到x节点有一个in时间戳，递归退出时有一个out时间戳，易知，每个结点的in和out之间的dfs到的节点就是以x为根的子树中的节点们。所以dfs序得到的两个数组就是代表这个点“控制”的区间。我们再用树状数组维护一下前缀和，查询的时候直接减就好了。具体操作可看代码注释。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e5 + 10;#define lowbit(x) (x &amp; (-x))int n, q, t;struct node {    int to, nxt;} v[maxn &lt;&lt; 1];int head[maxn], cnt;int tree[maxn];                 //存储树状数组int vis[maxn];                  //存储每个结点的值int in[maxn], out[maxn], tim;   //dfs序void addv(int from, int to){    v[cnt].to = to;    v[cnt].nxt = head[from];    head[from] = cnt++;}//链式前向星存图void dfs(int x, int fa){    in[x] = ++tim;    for (int i = head[x]; i != -1; i = v[i].nxt) {        int mid = v[i].to;        if (mid == fa) continue;        dfs(mid, x);    }    out[x] = tim;}//计算dfs序void add(int x, int val){    for (; x &lt;= n; x += lowbit(x)) tree[x] += val;}//树状数组单点修改int query(int x){    int ans = 0;    for (; x; x -= lowbit(x)) ans += tree[x];    return ans;}//树状数组查询int main(){    ios::sync_with_stdio(0);    while (cin &gt;&gt; n) {        memset(head, -1, sizeof(head));        memset(vis, 1, sizeof(vis));        memset(tree, 0, sizeof(tree));        cnt = tim = 0;//初始化        for (int i = 1, u, v; i &lt; n; i++) {            cin &gt;&gt; u &gt;&gt; v; addv(u, v); addv(v, u);        }        dfs(1, -1);        for (int i = 1; i &lt;= n; i++) add(i, 1); //初始化树状数组        char op; int q, t;        cin &gt;&gt; q;        while (q--) {            cin &gt;&gt; op &gt;&gt; t;            if (op == &#39;C&#39;) {                if (vis[t]) {                    add(in[t], -1);//in[t]就是t在树状数组所用的序列中的位置                    vis[t] = 0;                } else {                    add(in[t], 1);                    vis[t] = 1;                }            } else {                cout &lt;&lt; query(out[t]) - query(in[t] - 1) &lt;&lt; endl;            }        }    }}</code></pre><h2 id="dfs序模板"><a href="#dfs序模板" class="headerlink" title="dfs序模板"></a>dfs序模板</h2><pre><code class="lang-c++">void dfs(int x, int fa){    in[x] = ++tim;    for (int i = head[x]; i != -1; i = v[i].nxt) {        int mid = v[i].to;        if (mid == fa) continue;        dfs(mid, x);    }    out[x] = tim;}//计算dfs序</code></pre><p>很骚而且挺实用的一种操作。明天把那个lca+dfs序的写一下！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> DFS序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为你的博客添加swiftype搜索——图文教程</title>
      <link href="/2020/02/25/swiftype/"/>
      <url>/2020/02/25/swiftype/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我用的主题Sakura是自带搜索的。但是自带的搜索是依赖于插件<code>hexo-generator-json</code>自动生成的<code>content.json</code>实现的。讲道理这个<code>content.json</code>才1MB左右的大小，加载时间往往在10s左右。然后我就下定决心弃用这个插件。所以搜索功能自然也得换了。</p></blockquote><p>这里你首先需要一个swiftype账号，我是直接用google账号注册了，据说注册swiftype账号会有些问题，所以推荐直接用google账号注册吧。<br>首先进入登陆界面点击<code>sign up</code>：<a href="https://app.swiftype.com/login" target="_blank" rel="noopener">swiftype</a><br> <a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135622.webp" data-fancybox="images" data-caption="20200225135622" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135622.webp" class="img-shadow img-margin"></center></a></p><p>然后点击<code>Sign up with Google</code>，选择你的google账号注册</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135650.webp" data-fancybox="images" data-caption="20200225135650" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135650.webp" class="img-shadow img-margin"></center></a><p>然后就会<code>Welcome to Swiftype!</code><br>选择<code>Start your Site Search trial</code></p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135711.webp" data-fancybox="images" data-caption="20200225135711" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135711.webp" class="img-shadow img-margin"></center></a><p>然后根据提示输入自己网站的链接，</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135751.webp" data-fancybox="images" data-caption="20200225135751" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135751.webp" class="img-shadow img-margin"></center></a><p>Swiftype测试成功后会让你命名以及选择语言，这些随便选就好。</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135804.webp" data-fancybox="images" data-caption="20200225135804" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135804.webp" class="img-shadow img-margin"></center></a><p>然后点击<code>complete setup</code>。</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135911.webp" data-fancybox="images" data-caption="20200225135911" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135911.webp" class="img-shadow img-margin"></center></a><p>接着Swiftype就会开始抓取你博客的数据来用作搜索索引，这个过程可能时间会有点久，我用了一天（因为我的内容比较多？）你可以在Content中看到抓取的搜索索引数据。<br>等它抓取完之后，如果你只是跟我一样只想用默认的外观的话，直接点击<code>Install Search</code>，</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135838.webp" data-fancybox="images" data-caption="20200225135838" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200225135838.webp" class="img-shadow img-margin"></center></a><p>把这个<code>Your install code:</code>中的代码粘贴到你的主题文件中的footer渲染文件中，例如我的就是<code>footer.ejs</code><br>然后找到合适的位置加上<code>&lt;a href=&quot;#&quot; title=&quot;搜索博客&quot; class=&quot;st-search-show-outputs&quot;&gt;搜索&lt;/a&gt;</code>就可了。<br>总的来说还是挺简单的。搜索框的样式可以自定义，有兴趣的话可以在上面摸索一下。我确实挺喜欢这个默认的弹出式搜索，所以就不更换了。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> Tutorial </tag>
            
            <tag> Useful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 620 (Div. 2)  E. 1-Trees and Queries</title>
      <link href="/2020/02/24/cf1304E/"/>
      <url>/2020/02/24/cf1304E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>　　LCA,即在图论和计算机科学中，最近公共祖先（英語：lowest common ancestor）是指在一个树或者有向无环图中同时拥有v和w作为后代的最深的节点。在这里，我们定义一个节点也是其自己的后代，因此如果v是w的后代，那么w就是v和w的最近公共祖先。　　——wikipedia</p></blockquote><h1 id="E-1-Trees-and-Queries"><a href="#E-1-Trees-and-Queries" class="headerlink" title="E. 1-Trees and Queries"></a>E. 1-Trees and Queries</h1><p>Link: <a href="https://codeforces.com/contest/1304/problem/E" target="_blank" rel="noopener">E. 1-Trees and Queries</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Gildong was hiking a mountain, walking by millions of trees. Inspired by them, he suddenly came up with an interesting idea for trees in data structures: What if we add another edge in a tree?</p><p>Then he found that such tree-like graphs are called 1-trees. Since Gildong was bored of solving too many tree problems, he wanted to see if similar techniques in trees can be used in 1-trees as well. Instead of solving it by himself, he&#39;s going to test you by providing queries on 1-trees.</p><p>First, he&#39;ll provide you a tree (not 1-tree) with n vertices, then he will ask you q queries. Each query contains 5 integers: x, y, a, b, and k. This means you&#39;re asked to determine if there exists a path from vertex a to b that contains exactly k edges after adding a bidirectional edge between vertices x and y. A path can contain the same vertices and same edges multiple times. All queries are independent of each other; i.e. the added edge in a query is removed in the next query.</p><p>Input<br>The first line contains an integer n (<script type="math/tex">3 \le n \le 10^5</script>), the number of vertices of the tree.</p><p>Next n−1 lines contain two integers u and v (<script type="math/tex">1 \leq u, v \leq n, u \neq v</script>) each, which means there is an edge between vertex u and v. All edges are bidirectional and distinct.</p><p>Next line contains an integer q (<script type="math/tex">1 \le q \le 10^5</script>), the number of queries Gildong wants to ask.</p><p>Next q lines contain five integers x, y, a, b, and k each (<script type="math/tex">1 \leq x, y, a, b \leq n, x \neq y, 1 \leq k \leq 10^{9}</script>) – the integers explained in the description. It is guaranteed that the edge between x and y does not exist in the original tree.</p><p>Output<br>For each query, print &quot;YES&quot; if there exists a path that contains exactly k edges from vertex a to b after adding an edge between vertices x and y. Otherwise, print &quot;NO&quot;.</p><p>You can print each letter in any case (upper or lower).</p><p>Example</p><p>input<br>5<br>1 2<br>2 3<br>3 4<br>4 5<br>5<br>1 3 1 2 2<br>1 4 1 3 2<br>1 4 1 3 3<br>4 2 3 3 9<br>5 2 3 3 9<br>output<br>YES<br>YES<br>NO<br>YES<br>NO<br>Note<br>The image below describes the tree (circles and solid lines) and the added edges for each query (dotted lines).<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200224171430.webp" data-fancybox="images" data-caption="20200224171430" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200224171430.webp" class="img-shadow img-margin"></center></a></p><p>Possible paths for the queries with &quot;YES&quot; answers are:</p><ul><li>1-st query: 1 – 3 – 2</li><li>2-nd query: 1 – 2 – 3</li><li>4-th query: 3 – 4 – 2 – 3 – 4 – 2 – 3 – 4 – 2 – 3</li></ul><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道的意思就是给你一颗树，然后q次查询，每次查询输入五个数，x,y,a,b,k，问你x和y中间连接起来之后从a到b有没有路径长度为k的路。每次查询独立。如果有就输出“YES”，否则输出“NO”。并且本题中的路径可以经过一条边或一个点无数次。<br>所以我们可以发现，从a到b的最短距离是可以算出来的，我们只需要比较最短距离和k的奇偶性是否相同即可。因为假设这条最短路径为a,i,j,...,k,b，路径长度为x，走到b之后我们再从b走向k，然后再走向b。这样的话路径长度就变为了x+2i，i为任意正整数。所以只要x和k的奇偶性相同即可。当然，如果从a到b的最短距离已经大于k，那么肯定是不会有长度为k的路径的。<br>因此我们现在只需要考虑计算从a到b的最短距离。因为每次查询都会将一对xy连接起来。所以从a到b的最短路径有三种情况</p><ol><li>a-&gt;b</li><li>a-&gt;x-&gt;y-&gt;b</li><li>a-&gt;y-&gt;x-&gt;b</li></ol><p>树上的两个点的最短距离可以用lca计算，树上两点ab的最短距离为<code>dep[a]+dep[b]-dep[lca(a,b)]*2</code><br>所以我们可以据此求出上面列出来的三条路径的最短路长度跟k的奇偶性作比较，只要有一个满足奇偶性相同，就表明存在一条长度为k的路。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;struct node {    int to, nxt;} v[maxn &lt;&lt; 1];int head[maxn], cnt = 1, n, k, q, lg[maxn], dep[maxn], f[maxn][25];void add(int from, int to){    v[cnt].to = to;    v[cnt].nxt = head[from];    head[from] = cnt++;}void dfs(int x, int fa){    f[x][0] = fa;    dep[x] = dep[fa] + 1;    for (int i = 1; i &lt;= lg[dep[x]]; i++) f[x][i] = f[f[x][i - 1]][i - 1];    for (int i = head[x]; i; i = v[i].nxt)        if (v[i].to != fa) dfs(v[i].to, x);}int lca(int x, int y){    if (dep[x] &lt; dep[y]) swap(x, y);    while (dep[x] &gt; dep[y]) x = f[x][lg[dep[x] - dep[y]] - 1];    if (x == y) return x;    for (int i = lg[dep[x]] - 1; i &gt;= 0; i--)        if (f[x][i] != f[y][i])            x = f[x][i], y = f[y][i];    return f[x][0];}int dis(int x, int y){    return dep[x] + dep[y] - dep[lca(x, y)] * 2;}bool check(int x){    if (x &lt;= k &amp;&amp; ((x &amp; 1) == (k &amp; 1))) return 1;    return 0;}int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n;    for (int i = 1, u, v; i &lt; n; i++) {        cin &gt;&gt; u &gt;&gt; v;        add(u, v); add(v, u);    }    for (int i = 1; i &lt;= n; i++)        lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);    dfs(1, 0);    cin &gt;&gt; q;    while (q--) {        int a, b, x, y;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b &gt;&gt; k;        if (check(dis(a, b)) || check(dis(a, x) + dis(y, b) + 1) || check(dis(a, y) + dis(x, b) + 1)) cout &lt;&lt; &quot;YES\n&quot;;        else cout &lt;&lt; &quot;NO\n&quot;;    }    return 0;}</code></pre><h2 id="LCA模板"><a href="#LCA模板" class="headerlink" title="LCA模板"></a>LCA模板</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5 + 10;int n, m, s;struct node {    int to, next;} v[maxn &lt;&lt; 1];int head[maxn], cnt = 1, dep[maxn], fa[maxn][30], lg[maxn];void add(int from, int to){    v[cnt].to = to;    v[cnt].next = head[from];    head[from] = cnt++;}void dfs(int x, int f){    fa[x][0] = f; dep[x] = dep[f] + 1;    for (int i = 1; i &lt;= lg[dep[x]]; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];    for (int i = head[x]; i; i = v[i].next) if (v[i].to != f) dfs(v[i].to, x);}int lca(int x, int y){    if (dep[x] &lt; dep[y]) swap(x, y);    while (dep[x] &gt; dep[y])        x = fa[x][lg[dep[x] - dep[y]] - 1];    if (x == y) return x;    for (int i = lg[dep[x]] - 1; i &gt;= 0; i--)        if (fa[x][i] != fa[y][i])            x = fa[x][i], y = fa[y][i];    return fa[x][0];}int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    for (int x, y, i = 1; i &lt;= n - 1; i++) {        cin &gt;&gt; x &gt;&gt; y;        add(x, y); add(y, x);    }    for (int i = 1; i &lt;= n; i++) lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);    dfs(s, 0);    for (int i = 1, x, y; i &lt;= m; i++) {        cin &gt;&gt; x &gt;&gt; y;        cout &lt;&lt; lca(x, y) &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> LCA </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 622 (Div. 2)  C. Skyscrapers</title>
      <link href="/2020/02/23/cf1313C/"/>
      <url>/2020/02/23/cf1313C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单调栈是指一个栈内部的元素具有严格单调性的一种数据结构，分为单调递增栈和单调递减栈。</p></blockquote><h1 id="Codeforces-Round-622-Div-2-C-Skyscrapers"><a href="#Codeforces-Round-622-Div-2-C-Skyscrapers" class="headerlink" title="Codeforces Round 622 (Div. 2)  C. Skyscrapers"></a>Codeforces Round 622 (Div. 2)  C. Skyscrapers</h1><p>Link:<a href="https://codeforces.com/contest/1313/problem/C2" target="_blank" rel="noopener">Codeforces Round 622 (Div. 2)  C. Skyscrapers</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The outskirts of the capital are being actively built up in Berland. The company &quot;Kernel Panic&quot; manages the construction of a residential complex of skyscrapers in New Berlskva. All skyscrapers are built along the highway. It is known that the company has already bought n plots along the highway and is preparing to build n skyscrapers, one skyscraper per plot.</p><p>Architects must consider several requirements when planning a skyscraper. Firstly, since the land on each plot has different properties, each skyscraper has a limit on the largest number of floors it can have. Secondly, according to the design code of the city, it is unacceptable for a skyscraper to simultaneously have higher skyscrapers both to the left and to the right of it.</p><p>Formally, let&#39;s number the plots from 1 to n. Then if the skyscraper on the i-th plot has <script type="math/tex">a_i</script> floors, it must hold that <script type="math/tex">a_i</script> is at most <script type="math/tex">m_i</script> (<script type="math/tex">1 \le a_i \le m_i</script>). Also there mustn&#39;t be integers j and k such that <script type="math/tex">j < i < k</script> and <script type="math/tex">a_j > a_i < a_k</script>. Plots j and k are not required to be adjacent to i.</p><p>The company wants the total number of floors in the built skyscrapers to be as large as possible. Help it to choose the number of floors for each skyscraper in an optimal way, i.e. in such a way that all requirements are fulfilled, and among all such construction plans choose any plan with the maximum possible total number of floors.</p><p>Input<br>The first line contains a single integer n (<script type="math/tex">1 \leq n \leq 500\,000</script>) — the number of plots.</p><p>The second line contains the integers <script type="math/tex">m_1, m_2, \ldots, m_n</script>(<script type="math/tex">1 \leq m_i \leq 10^9</script>) — the limit on the number of floors for every possible number of floors for a skyscraper on each plot.</p><p>Output<br>Print n integers <script type="math/tex">a_i</script> — the number of floors in the plan for each skyscraper, such that all requirements are met, and the total number of floors in all skyscrapers is the maximum possible.</p><p>If there are multiple answers possible, print any of them.</p><p>Examples<br>input<br>5<br>1 2 3 2 1<br>output<br>1 2 3 2 1<br>input<br>3<br>10 6 8<br>output<br>10 6 6<br>Note<br>In the first example, you can build all skyscrapers with the highest possible height.</p><p>In the second test example, you cannot give the maximum height to all skyscrapers as this violates the design code restriction. The answer [10,6,6] is optimal. Note that the answer of [6,6,8] also satisfies all restrictions, but is not optimal.</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你一个序列，序列中每个值的初始值代表的就是这个数能达到的最大值，现在让你随意修改这些数（只要不超过最大值）。问你修改成什么样的情况可以使每个数的两边都没有大于它的数，并且序列和是最大的。<br>由题意我们可以知道最终的答案序列要么是单调递增的，要么是单调递减的，要么就是先单调递增，再单调递减。也就是说一定会存在一个极大值。我们只需要枚举极大值的位置，就可以得到答案了。<br>在c1里面，n只有1000，所以我们可以直接暴力枚举，计算当第i位看为是极大值时，此时达到的最大的序列和，更新使序列和最大的极大值的位置，最后输出即可，时间复杂度<script type="math/tex">O(n^2)</script>。<br>但是c2里面，我们显然是不可以暴力计算的。当然我们仍然可以采用c1的思路去写，不过当第i位看为最大值时，此时的序列和我们需要使用单调栈处理。<br>我们定义四个数组，pre和nxt分别代表第i位左右两边第一个小于它的数的位置。spre和snxt分别代表第i为看为最大值时，1-i和i-n的和。<br>所以现在只要我们计算出spre和snxt数组的值，就可以很快的按照c1的思路进行处理。<br>在计算spre得时候，我们遍历这个序列，每次使用单调栈得到左边第一个小于他的数，假如当前遍历到i，则<code>spre[i]=spre[pre[i]]+(i-pre[i])*a[i]</code>,意思就是以第i位为极大值的时候左边的和，等于比i小的第一个数为极大值时左边的和加上从第一个比i小的数到i都变成a[i]之后的和。这里有中前缀和的感觉。<br>在计算snxt得时候，跟spre是差不多的就不说了。<br>至此我们就计算出了spre和snxt，所以这道题也就可以了。<br>单调栈挺好用的，下次一定会。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 5e5 + 10;ll a[maxn], ans[maxn], pre[maxn], nxt[maxn], spre[maxn], snxt[maxn];int main(){    ios::sync_with_stdio(0);    int n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];    stack&lt;ll&gt; sta;    spre[1] = a[1];    sta.push(1);    for (int i = 2; i &lt;= n; i++) {        while (!sta.empty() &amp;&amp; a[sta.top()] &gt;= a[i]) sta.pop();        if (!sta.empty()) pre[i] = sta.top();//单调栈找出左边第一个小于a[i]的位置        spre[i] = spre[pre[i]] + (i - pre[i]) * a[i];//计算spre        sta.push(i);    }    while (!sta.empty()) sta.pop();    for (int i = 1; i &lt;= n; i++) nxt[i] = n + 1;//初始化nxt数组，上面因为pre数组初值本就是0所以不需要初始化。    sta.push(n);    snxt[n] = a[n];    for (int i = n - 1; i &gt;= 1; i--) {        while (!sta.empty() &amp;&amp; a[sta.top()] &gt;= a[i]) sta.pop();        if (!sta.empty()) nxt[i] = sta.top();//单调栈找出右边第一个小于a[i]的位置        snxt[i] = snxt[nxt[i]] + (nxt[i] - i) * a[i];//计算snxt，类似于spre        sta.push(i);    }    ll pos = 1, maxx = 0;    for (int i = 1; i &lt;= n; i++) {        if (spre[i] + snxt[i] - a[i] &gt; maxx) {            maxx = spre[i] + snxt[i] - a[i];            pos = i;//找到以pos为极值点的时候序列和最大        }    }    ll cur = a[pos]; ans[pos] = a[pos];    for (int i = pos + 1; i &lt;= n; i++) {        cur = min(cur, a[i]);        ans[i] = cur;    }    cur = a[pos];    for (int i = pos - 1; i &gt;= 1; i--) {        cur = min(cur, a[i]);        ans[i] = cur;    }//通过a[pos]为极值点，左右两边确定每个数的取值    for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> codeforces </tag>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量转换jpg/png/gif为webp为网站提速</title>
      <link href="/2020/02/19/webp/"/>
      <url>/2020/02/19/webp/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>WebP（发音：weppy）是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，派生自影像编码格式VP8，被认为是WebM多媒体格式的姊妹项目，是由Google在购买On2 Technologies后发展出来，以BSD授权条款发布。</p><div style="text-align: right"> ——百度百科</div></blockquote><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>随着我博客内容原来越多，加上我对博客插图质量的近乎变态的要求高清，加载速度越来越慢。然后了解到了webp这个格式在网上搜了好久，也是得到了不错的解决方法。</p><h1 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h1><h2 id="准备好需要转换的图片"><a href="#准备好需要转换的图片" class="headerlink" title="准备好需要转换的图片"></a>准备好需要转换的图片</h2><p>首先，如果你本来的图片在自己电脑上存有，直接用就可以。<br>但是如果你本来的图片是存储在七牛云或者又拍云的话，我们都知道上面不能批量下载。所以你需要一些软件。</p><h3 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h3><p>在GitHub上面有一个又拍云资源管理器。可以很方便的批量下载。这里给出链接自行下载。<br><a href="https://github.com/layerssss/manager-for-upyun" class="LinkCard" target="_blank" rel="noopener">又拍云资源管理器</a></p><p>下载安装完是这个样子的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219111811.webp" data-fancybox="images" data-caption="20200219111811" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219111811.webp" class="img-shadow img-margin"></center></a><br>我解释一下这些参数怎么填</p><ul><li>操作员用户名：就是你在你的又拍云存储空间中的存储管理中设置的操作员</li><li>操作员密码：操作员密码在你设置操作员的时候会自动生成</li><li>空间名：就是你储存图片的存储空间的名字</li><li>公开URL：存储空间中的加速域名</li></ul><p>登陆完成之后是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219112437.webp" data-fancybox="images" data-caption="20200219112437" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219112437.webp" class="img-shadow img-margin"></center></a><br>找到你存储图片的目录直接点击下载当前目录即可。<br>至此又拍云的批量下载就结束了。</p><h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><p>在GitHub上面有一个官方的七牛云批量下载器-qshell，这里给出链接自行下载。<br><a href="https://github.com/qiniu/qshell" class="LinkCard" target="_blank" rel="noopener">qshell</a><br>下载完qshell之后，在同路径下新建一个文件，文件名为<code>runker.conf</code><br>文件内容为</p><pre><code>{&quot;dest_dir&quot; : &quot;/qn&quot;,&quot;bucket&quot; : &quot;blog&quot;,&quot;domain&quot; : &quot;http://qn.cndrew.cn&quot;,&quot;access_key&quot; : &quot;&quot;,&quot;secret_key&quot; : &quot;&quot;,&quot;is_private&quot; : false,&quot;prefix&quot; : &quot;&quot;,&quot;suffix&quot; : &quot;&quot;}</code></pre><p>解释一下参数</p><ul><li>dest_dir：本地存储路径，下载到的图片的存储位置</li><li>bucket：在七牛云上的存储空间名称</li><li>domain：空间绑定的域名</li><li>access_key：七牛云账号的access_key</li><li>secret_key：七牛云账号的secret_key</li><li>is_private：是否为私有空间，true/false</li><li>prefix：文件的前缀，默认为空</li><li>suffix：文件的后缀，默认为空</li></ul><p>access_key和secret_key在登陆七牛云之后，找到密钥管理之后，复制粘贴即可。如图<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219114016.webp" data-fancybox="images" data-caption="20200219114016" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219114016.webp" class="img-shadow img-margin"></center></a></p><p>这些参数填对的情况下，打开cmd，转到qshell所在的路径输入指令</p><pre><code class="lang-cmd">qshell qdownload 10 runker.conf</code></pre><p>qshell qdownload是命令；10为下载的并发协程数量，从1~10 可以理解为下载速度<br>至此七牛云的批量下载就结束了。</p><p>至此图片准备就完成了。</p><h2 id="开始转换"><a href="#开始转换" class="headerlink" title="开始转换"></a>开始转换</h2><p>这里我在网上找到一个软件，这个软件就是把谷歌的图片转换webp的工具整合了起来，很适合我这种啥都不知道的小白使用。<br><a href="https://cloud.cndrew.cn/index.php?share/file&user=1&sid=EAC3chqG " class="LinkCard" target="_blank" rel="noopener">下载链接</a><br>密码：cndrew</p><p>下载完成解压之后，可以看到一个文件夹和两个.exe可执行文件<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219115459.webp" data-fancybox="images" data-caption="20200219115459" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219115459.webp" class="img-shadow img-margin"></center></a><br>文件夹中放的就是基础的转换工具，不需要管它。<br><code>Any2WebpTool.exe</code>是把任意图片格式转换为webp的<br><code>Webp2AnyTool.exe</code>是把webp转换为jpg/png的<br>这里我们打开<code>Any2WebpTool.exe</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219115513.webp" data-fancybox="images" data-caption="20200219115513" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219115513.webp" class="img-shadow img-margin"></center></a><br>然后选择源文件夹，源文件夹即你存放图片的文件夹。选择完成之后输出文件夹会自动填入，不需要更改的话直接跳过就行。<br>压缩配置可以自己选择<br>然后点击开始转换，然后转换出来的webp格式的图片就在刚才的输出文件夹中了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219115528.webp" data-fancybox="images" data-caption="20200219115528" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200219115528.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round621 (Div. 1 + Div. 2) D. Cow and Fields</title>
      <link href="/2020/02/18/cf1307/"/>
      <url>/2020/02/18/cf1307/</url>
      
        <content type="html"><![CDATA[<h1 id="D-Cow-and-Fields"><a href="#D-Cow-and-Fields" class="headerlink" title="D. Cow and Fields"></a>D. Cow and Fields</h1><p><a href="https://codeforces.com/contest/1307/problem/D" class="LinkCard" target="_blank" rel="noopener">Codeforces Round621 (Div. 1 + Div. 2) D. Cow and Fields</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Bessie is out grazing on the farm, which consists of n fields connected by m bidirectional roads. She is currently at field 1, and will return to her home at field n at the end of the day.</p><p>The Cowfederation of Barns has ordered Farmer John to install one extra bidirectional road. The farm has k special fields and he has decided to install the road between two different special fields. He may add the road between two special fields that already had a road directly connecting them.</p><p>After the road is added, Bessie will return home on the shortest path from field 1 to field n. Since Bessie needs more exercise, Farmer John must maximize the length of this shortest path. Help him!</p><p>Input<br>The first line contains integers n, m, and k (<script type="math/tex">2 \leq n \leq 2 \cdot 10^{5}, n-1 \leq m \leq 2 \cdot 10^{5}, 2 \leq k \leq n</script>)  — the number of fields on the farm, the number of roads, and the number of special fields.</p><p>The second line contains k integers <script type="math/tex">a_1, a_2, \ldots, a_k</script> (<script type="math/tex">1 \le a_i \le n</script>)  — the special fields. All ai are distinct.</p><p>The i-th of the following m lines contains integers xi and yi (<script type="math/tex">1 \leq x_{i}, y_{i} \leq n, x_{i} \neq y_{i}</script>), representing a bidirectional road between fields xi and yi.</p><p>It is guaranteed that one can reach any field from every other field. It is also guaranteed that for any pair of fields there is at most one road connecting them.</p><p>Output<br>Output one integer, the maximum possible length of the shortest path from field 1 to n after Farmer John installs one road optimally.</p><p>Examples<br>input<br>5 5 3<br>1 3 5<br>1 2<br>2 3<br>3 4<br>3 5<br>2 4<br>output<br>3<br>input<br>5 4 2<br>2 4<br>1 2<br>2 3<br>3 4<br>4 5<br>output<br>3<br>Note<br>The graph for the first example is shown below. The special fields are denoted by red. It is optimal for Farmer John to add a road between fields 3 and 5, and the resulting shortest path from 1 to 5 is length 3.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200218103051.webp" data-fancybox="images" data-caption="20200218103051" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200218103051.webp" class="img-shadow img-margin"></center></a><p>The graph for the second example is shown below. Farmer John must add a road between fields 2 and 4, and the resulting shortest path from 1 to 5 is length 3.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200218103106.webp" data-fancybox="images" data-caption="20200218103106" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200218103106.webp" class="img-shadow img-margin"></center></a></p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你一个图，让你在指定的点中找两个点连起来使得，连接之后的图中的最短路最小。<br>首先我们通过bfs计算出1和n到其他每个点的最短路长度，分别用数组a和数组b存储。连接xy两条边之后，路径1-&gt;x-&gt;y-&gt;n的长度即为<script type="math/tex">min(x_a+y_b,y_a+x_b)+1</script>。连接xy之后路径长度产生变化的路径也只有这条路，即1-&gt;x-&gt;y-&gt;n。连接之后可能这条路会变成最短路，所以我们看这条路能达到的最长的路即可.即<script type="math/tex">min(x_a+y_b,y_a+x_b)</script>的最大值。暴力查找的话n^2肯定会超时。<br>所以现在我们假设<script type="math/tex">x_a+y_b \le y_a+x_b</script>，要求<script type="math/tex">x_a+y_b</script>的最大值并且满足<script type="math/tex">x_a-y_a \le x_b-y_b</script>。因此我们对那些特殊点根据<script type="math/tex">x_i-y_i</script>进行排序。<br>然后遍历一下。用一个变量储存特殊点到1的最短距离。每次更新路径能达到的最大值。最后输出最大值和加边之前的最短路中的最小值即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pair#define pb push_back#define fa(i, x, y)       for (int i = x; i &lt;= y; i++)#define fs(i, x, y)       for (int i = x; i &gt;= y; i--)const int maxn = 2e5 + 10;const int mod = 1e9 + 10;const int inf = 0x3f3f3f3f;int n, m, k, u, v, a[maxn], q[maxn], d1[maxn], vis[maxn], dn[maxn];vector&lt;int&gt; V[maxn];void bfs(int s, int *d){    fa(i, 1, n)       vis[i] = 0, d[i] = n + 1;    int mid = 0;    vis[s] = 1; d[s] = 0;    q[mid++] = s;    fa(i, 0, mid){        int miu = q[i];        for (auto miv:V[miu]) {            if (d[miv] &gt; d[miu] + 1) {                d[miv] = d[miu] + 1;                q[mid++] = miv;            }        }    }}int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    fa(i, 1, k)       cin &gt;&gt; a[i];    fa(i, 1, m){        cin &gt;&gt; u &gt;&gt; v;        V[u].pb(v); V[v].pb(u);    }    bfs(1, d1), bfs(n, dn);    sort(a + 1, a + k + 1, [&amp;](int a, int b){        return d1[a] - dn[a] &lt; d1[b] - dn[b];    });//新学到的黑科技，虽然不太懂原理但是作用就是根据xi-yi进行排序。    int ans = 0, m4a1 = d1[a[1]];//m4a1记录1到x的最短路径中的最大值    fa(i, 2, k){        ans = max(ans, m4a1 + dn[a[i]] + 1);//每次更新连接xy之后的最长路径        m4a1 = max(m4a1, d1[a[i]]);    }    ans = min(ans, d1[n]);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>需要对一个函数调用多次并且记录的话，可以在函数中用指针形式传数组</li><li>sort那个黑科技</li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> bfs </tag>
            
            <tag> greedy </tag>
            
            <tag> codeforces </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用链式前向星进行存图以及搜索(模板)</title>
      <link href="/2020/02/17/lsqxx/"/>
      <url>/2020/02/17/lsqxx/</url>
      
        <content type="html"><![CDATA[<p>参考的博客：<br><a href="https://blog.csdn.net/Q_M_X_D_D_/article/details/90019352" class="LinkCard" target="_blank" rel="noopener">链式前向星（加快图的搜索）</a><br>链式前向星,它是一种在时间和空间上最优的存图结构。无论是建图还是遍历图效率最高的存图的方式。<br>链式前向星的结构定义如下：</p><pre><code class="lang-c++">struct node{    int to,next;}edge[maxn];</code></pre><p>链式前向星以边为单位进行储存。其中，成员to表示这条边的终点，而next就比较重要了，表示跟本条边的起点相同的前一条边，在edge数组中的下标，如果这条边的起点是第一次出现的，则置为0。也就是说，链式前向星的next属性，像链表一样，将图中起点相同的边连在了一起。例如下面这个图：</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20131123160056593.webp" data-fancybox="images" data-caption="20131123160056593" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20131123160056593.webp" class="img-shadow img-margin"></center></a><p>我们输入边的顺序为：<br>1 2<br>2 3<br>3 4<br>4 5<br>1 3<br>1 5<br>4 1</p><p>那么我们得到的edge数组为：<br> <a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200217232705.webp" data-fancybox="images" data-caption="20200217232705" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200217232705.webp" class="img-shadow img-margin"></center></a></p><p>当我们想要得到一条边的终点时，就调用edge[i].to，当我们想得到这个起点连接的其他边时，就可以调用edge[i].next。那么现在的问题就是如何快速求next属性。</p><p>解决方法就是再定义一个数组head，head[i]表示最近一次输入的以i为起点的边在edge数组中的下标。</p><p>用链式前向星建图的整个过程并不复杂，下面来看建图的函数：</p><pre><code class="lang-c++">struct node{    int to;    int next;}edge[maxn];int head[maxn];int cnt=1;//表示edge数组的下标，也可以表示已经存入的边数void add(int from,int t){    edge[cnt].to=t;    edge[cnt].next=head[from];    head[from]=cnt++;}</code></pre><p>链式前向星遍历图的核心代码是：</p><pre><code class="lang-c++">for(int i=head[x];i!=0;i=edge[i].next)</code></pre><p>在对某一点所连接的所有边的遍历过程中，调用edge[i].next，就像链表一样，将所有起点相同的边都串在了一起。而且，最先输入的边会最晚遍历到，这是由next的属性所造成的。</p><p>最开始觉得链式前向星很难，就是因为那个next和head太绕了。这里列出来一次存储的过程还是很舒服得。</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用iziToast给自己的博客加上消息提示框</title>
      <link href="/2020/02/17/iziToast/"/>
      <url>/2020/02/17/iziToast/</url>
      
        <content type="html"><![CDATA[<p>首先奉上官网<br><a href="https://izitoast.marcelodolza.com/" class="LinkCard" target="_blank" rel="noopener">iziToast</a></p><p>这里我以我的Hexo博客为例（其实都基本是一样的。<br>其实iziToast的使用还是很方便的，你只需要引入一个js和一个css，然后按照格式编辑你想要的提示框样式即可。<br>js和css官网可下载<br>因为源码是放在github上面的，可能由于一些特殊原因国内下载速度会比较慢，所以我给大家提供一下下载。<br><a href="https://cloud.cndrew.cn/index.php?share/file&user=1&sid=kjqFvCtg" class="LinkCard" target="_blank" rel="noopener">Uncle_drew的网盘</a><br>用我的下载可能也没很快（学生机），但肯定比上面那个快（手动滑稽<br>无论是用我的还是用官网的下载，你都可以在下载得到的文件中找到<code>iziToast.min.js</code>和<code>iziToast.min.css</code><br>js在body中引用，css在head中引用。比如说在我的博客中，js在<code>layout.ejs</code>中引用，css在<code>head.ejs</code>中引用。</p><p>然后按照格式编辑即可。<a href="https://izitoast.marcelodolza.com/" target="_blank" rel="noopener">官网</a>上都介绍得很清楚。<br>这里把我的格式亮出来仅供大家参考</p><pre><code class="lang-javascript">&lt;script&gt;iziToast.success({    image: &#39;https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp&#39;,    title: &#39;Welcome&#39;,    message: &#39;因为浏览器缓存问题，请您至少刷新一次以获得最佳的阅读体验，&#39;,    position: &#39;center&#39;,    transitionIn: &#39;bounceInLeft&#39;,    layout:2,    imageWidth: 70,});&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 620 (Div. 2)  D. Shortest and Longest LIS</title>
      <link href="/2020/02/16/cf1304D/"/>
      <url>/2020/02/16/cf1304D/</url>
      
        <content type="html"><![CDATA[<h1 id="D-Shortest-and-Longest-LIS"><a href="#D-Shortest-and-Longest-LIS" class="headerlink" title="D. Shortest and Longest LIS"></a>D. Shortest and Longest LIS</h1><p><a href="https://codeforces.com/contest/1304/problem/D" class="LinkCard" target="_blank" rel="noopener">Codeforces Round 620 (Div. 2)  D. Shortest and Longest LIS</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Gildong recently learned how to find the <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank" rel="noopener">longest increasing subsequence</a> (LIS) in <script type="math/tex">O(n\log{n})</script> time for a sequence of length n. He wants to test himself if he can implement it correctly, but he couldn&#39;t find any online judges that would do it (even though there are actually many of them). So instead he&#39;s going to make a quiz for you about making permutations of n distinct integers between 1 and n, inclusive, to test his code with your output.</p><p>The quiz is as follows.</p><p>Gildong provides a string of length n−1, consisting of characters &#39;&lt;&#39; and &#39;&gt;&#39; only. The i-th (1-indexed) character is the comparison result between the i-th element and the i+1-st element of the sequence. If the i-th character of the string is &#39;&lt;&#39;, then the i-th element of the sequence is less than the i+1-st element. If the i-th character of the string is &#39;&gt;&#39;, then the i-th element of the sequence is greater than the i+1-st element.</p><p>He wants you to find two possible sequences (not necessarily distinct) consisting of n distinct integers between 1 and n, inclusive, each satisfying the comparison results, where the length of the LIS of the first sequence is minimum possible, and the length of the LIS of the second sequence is maximum possible.</p><p>Input<br>Each test contains one or more test cases. The first line contains the number of test cases t (<script type="math/tex">1 \le t \le 10^4</script>).</p><p>Each test case contains exactly one line, consisting of an integer and a string consisting of characters &#39;&lt;&#39; and &#39;&gt;&#39; only. The integer is n (<script type="math/tex">2 \le n \le 2 \cdot 10^5</script>), the length of the permutation you need to find. The string is the comparison results explained in the description. The length of the string is n−1.</p><p>It is guaranteed that the sum of all n in all test cases doesn&#39;t exceed <script type="math/tex">2 \cdot 10^5</script>.</p><p>Output<br>For each test case, print two lines with n integers each. The first line is the sequence with the minimum length of the LIS, and the second line is the sequence with the maximum length of the LIS. If there are multiple answers, print any one of them. Each sequence should contain all integers between 1 and n, inclusive, and should satisfy the comparison results.</p><p>It can be shown that at least one answer always exists.</p><p>Example</p><p>input<br>3<br>3 &lt;&lt;<br>7 &gt;&gt;&lt;&gt;&gt;&lt;<br>5 &gt;&gt;&gt;&lt;<br>output<br>1 2 3<br>1 2 3<br>5 4 3 7 2 1 6<br>4 3 1 7 5 2 6<br>4 3 2 1 5<br>5 4 2 1 3<br>Note<br>In the first case, 1 2 3 is the only possible answer.</p><p>In the second case, the shortest length of the LIS is 2, and the longest length of the LIS is 3. In the example of the maximum LIS sequence, 4 &#39;3&#39; 1 7 &#39;5&#39; 2 &#39;6&#39; can be one of the possible LIS.</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你一个数n代表序列长度，然后给你一个字符串，字符串的长度为n-1，字符串由大于号和小于号组成，字符串的第i位代表着序列中第i个数和第i+1个数的大小关系。现在让你找到两个序列，满足其中的最长公共子序列最长（最短）。<br>我们首先考虑最短的情况，上升子序列，也就是说字符串中出现一个&quot;&gt;&quot;就意味着一个上升子序列的终点，换句话说，我们可以通过&quot;&gt;&quot;将字符串分成若干个部分，例如第一个部分，我们把这一部分的最后一个数置为n，每往前移动一位，n减一。直到这一部分服指完毕。就接着寻找下一部分。这里说这还是很简单的。不懂得话可以等下看代码注释。<br>然后我们考虑最长的情况。这次我们从出现&quot;&lt;&quot;的地方进行划分，出现&quot;&lt;&quot;之前肯定都是&quot;&gt;&quot;(因为我们就是这样统计的)，所以这一部分一定不满足是一个上升的子序列，所以我们需要把每个划分中的最后一位做出贡献组成上升子序列即可。换句话说，每一部分开始赋值的时候都选择最小的开始。跟上部分代码很相似，不理解的话可以看代码注释。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;int a[maxn], b[maxn];//用a记录最短,b记录最长int main(){    ios::sync_with_stdio(0);    int t;    cin &gt;&gt; t;    while (t--) {        int n; string s;        cin &gt;&gt; n &gt;&gt; s;        int num, last;        /*我们首先处理最短的，把num的初始值赋为n（即当前能达到的最大值），last记录的是新的划分开始的位置，用当前位置i减去last即为这一个划分的元素个数*/        num = n, last = 0;        for (int i = 0; i &lt; n; i++) {            if (i == n - 1 || s[i] == &#39;&gt;&#39;) {//根据s[i]=&#39;&gt;&#39;进行划分，同时因为可能出现最后一位是&lt;的情况，我们也需要考虑遍历到最后一位时直接进行赋值                for (int j = i; j &gt;= last; j--)//从当前能达到的最大值进行赋值，i到last（即当前的一个划分）                    a[j] = num--;//因为根据&quot;&gt;&quot;划分，所以每一个划分里面的元素都是递增的，所以我们需要倒着赋值，每次取当前能取到的最大值(即num--)                last = i + 1;//每次last更新新划分的开始            }        }        /*然后我们处理最长的，代码，变量含义作用跟上面基本一样，不同的是，num我们要从当前能达到的最小的开始赋值*/        num = 1, last = 0;        for (int i = 0; i &lt; n; i++) {            if (i == n - 1 || s[i] == &#39;&lt;&#39;) {                for (int j = i; j &gt;= last; j--)                    b[j] = num++;//因为根据&quot;&lt;&quot;划分，所以每一个划分里面的元素都是递减的，所以我们需要倒着赋值，每次取当前能取到的最小值(即num++)                last = i + 1;            }        }        for (int i = 0; i &lt; n; i++)            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;        for (int i = 0; i &lt; n; i++)            cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> greedy </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 618 (Div. 2)  E. Water Balance</title>
      <link href="/2020/02/10/cf1300E/"/>
      <url>/2020/02/10/cf1300E/</url>
      
        <content type="html"><![CDATA[<h1 id="E-Water-Balance"><a href="#E-Water-Balance" class="headerlink" title="E. Water Balance"></a>E. Water Balance</h1><p><a href="https://codeforces.com/contest/1300/problem/E" class="LinkCard" target="_blank" rel="noopener">Codeforces Round 618 (Div. 2)  E. Water Balance</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There are n water tanks in a row, i-th of them contains ai liters of water. The tanks are numbered from 1 to n from left to right.</p><p>You can perform the following operation: choose some subsegment [l,r] (<script type="math/tex">1\le l \le r \le n</script>), and redistribute water in tanks <script type="math/tex">l, l+1, \dots, r</script> evenly. In other words, replace each of <script type="math/tex">a_l, a_{l+1}, \dots, a_r</script> by <script type="math/tex">\frac{a_l + a_{l+1} + \dots + a_r}{r-l+1}</script>. For example, if for volumes <script type="math/tex">[1, 3, 6, 7]</script> you choose l=2,r=3, new volumes of water will be <script type="math/tex">[1,4.5,4.5,7]</script>. You can perform this operation any number of times.</p><p>What is the lexicographically smallest sequence of volumes of water that you can achieve?</p><p>As a reminder:</p><p>A sequence a is lexicographically smaller than a sequence b of the same length if and only if the following holds: in the first (leftmost) position where a and b differ, the sequence a has a smaller element than the corresponding element in b.</p><p>Input<br>The first line contains an integer n (<script type="math/tex">1 \le n \le 10^6</script>) — the number of water tanks.</p><p>The second line contains n integers a1,a2,…,an (<script type="math/tex">1 \le a_i \le 10^6</script>) — initial volumes of water in the water tanks, in liters.</p><p>Because of large input, reading input as doubles is not recommended.</p><p>Output<br>Print the lexicographically smallest sequence you can get. In the i-th line print the final volume of water in the i-th tank.</p><p>Your answer is considered correct if the absolute or relative error of each ai does not exceed <script type="math/tex">10^{-9}</script>.</p><p>Formally, let your answer be a1,a2,…,an, and the jury&#39;s answer be b1,b2,…,bn. Your answer is accepted if and only if <script type="math/tex">\frac{|a_i - b_i|}{\max{(1, |b_i|)}} \le 10^{-9}</script> for each i.</p><p>Examples<br>input<br>4<br>7 5 5 7<br>output<br>5.666666667<br>5.666666667<br>5.666666667<br>7.000000000<br>input<br>5<br>7 8 8 10 12<br>output<br>7.000000000<br>8.000000000<br>8.000000000<br>10.000000000<br>12.000000000<br>input<br>10<br>3 9 5 5 1 7 5 3 8 7<br>output<br>3.000000000<br>5.000000000<br>5.000000000<br>5.000000000<br>5.000000000<br>5.000000000<br>5.000000000<br>5.000000000<br>7.500000000<br>7.500000000<br>Note<br>In the first sample, you can get the sequence by applying the operation for subsegment [1,3].</p><p>In the second sample, you can&#39;t get any lexicographically smaller sequence.</p><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你一个序列，你可以选择无数次任意区间[l,r]进行操作，就是把这个区间中的所有数变成这个区间的平均数。问你你能通过这个操作能达到的最小字典序的序列是什么。<br>要求字典序最小，所以越往前的越小，直接就想到了贪心。我写的时候，只是考虑了新加一个数的时候对他前面那一个数的影响，所以WA了。显然新加入一个数，可能对他前面所有的数造成影响。所以我们需要考虑的更多一些。</p><p>我们定义两个数组，p[i]第i组中数的和，q[i]代表第i组中数的个数。<br>每次考虑一个新的数，用while计算它能让本来的值变小的数的个数，期间还需要维护前i个数的和。<br>最后按照组输出即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 10;typedef long long ll;inline ll read(){    ll   flag = 1, ans = 0;    char c = getchar();    while (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)    {        if (c == &#39;-&#39;)            flag = 1;        c = getchar();    }    while (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)    {        ans = ans * 10 + c - &#39;0&#39;;        c   = getchar();    }    return ans * flag;}//cin的通过代码是2324 ms，我加了快读是1325 ms，scanf/printf是1248 msll a[maxn], p[maxn], q[maxn];int main(){    ll n, x = 0, y = 0, pos = 0;    scanf(&quot;%lld&quot;,&amp;n);    for (ll i = 1; i &lt;= n; i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    for (ll i = 1; i &lt;= n; i++)    {        x = a[i], y = 1;        while (pos &amp;&amp; p[pos] * y &gt;= x * q[pos])//p[pos] * y &gt;= x * q[pos]这一句是用来计算新考虑的这个数对前面是否有影响，如果小于，说明加上这个数会使前面的数都减小，所以加上            x += p[pos], y += q[pos--];        p[++pos] = x, q[pos] = y;    }//计算出来总共pos组数，每组数有q[i]个    for (ll i = 1; i &lt;= pos; i++)        for (ll j = 1; j &lt;= q[i]; j++)            printf(&quot;%.9lf\n&quot;, p[i] * 1.0 / q[i]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> greedy </tag>
            
            <tag> codeforces </tag>
            
            <tag> geometry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 618 (Div. 2)  D. Aerodynamic</title>
      <link href="/2020/02/10/cf1300D/"/>
      <url>/2020/02/10/cf1300D/</url>
      
        <content type="html"><![CDATA[<h1 id="D-Aerodynamic"><a href="#D-Aerodynamic" class="headerlink" title="D. Aerodynamic"></a>D. Aerodynamic</h1><p><a href="https://codeforces.com/contest/1300/problem/D" class="LinkCard" target="_blank" rel="noopener">Codeforces Round 618 (Div. 2)  D. Aerodynamic</a><br>Guy-Manuel and Thomas are going to build a polygon spaceship.<br>You&#39;re given a strictly convex (i. e. no three points are collinear) polygon P which is defined by coordinates of its vertices. Define P(x,y) as a polygon obtained by translating P by vector <script type="math/tex">\overrightarrow {(x,y)}</script>. The picture below depicts an example of the translation:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200210084553.webp" data-fancybox="images" data-caption="描述" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200210084553.webp" class="img-shadow img-margin"></center></a><br>Define T as a set of points which is the union of all P(x,y) such that the origin (0,0) lies in P(x,y) (both strictly inside and on the boundary). There is also an equivalent definition: a point (x,y) lies in T only if there are two points A,B in P such that <script type="math/tex">\overrightarrow {AB} = \overrightarrow {(x,y)}</script>. One can prove T is a polygon too. For example, if P is a regular triangle then T is a regular hexagon. At the picture below P is drawn in black and some P(x,y) which contain the origin are drawn in colored:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200210084659.webp" data-fancybox="images" data-caption="描述" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200210084659.webp" class="img-shadow img-margin"></center></a><br>The spaceship has the best aerodynamic performance if P and T are similar. Your task is to check whether the polygons P and T are similar(相似).<br>Input<br>The first line of input will contain a single integer n (<script type="math/tex">3 \le n \le 10^5</script>) — the number of points.</p><p>The i-th of the next n lines contains two integers <script type="math/tex">x_i, y_i</script> (<script type="math/tex">|x_i|, |y_i| \le 10^9</script>), denoting the coordinates of the i-th vertex.</p><p>It is guaranteed that these points are listed in counterclockwise order and these points form a strictly convex polygon.</p><p>Output<br>Output &quot;YES&quot; in a separate line, if P and T are similar. Otherwise, output &quot;NO&quot; in a separate line. You can print each letter in any case (upper or lower).</p><p>Examples<br>input<br>4<br>1 0<br>4 1<br>3 4<br>0 3<br>output<br>YES<br>input<br>3<br>100 86<br>50 0<br>150 0<br>output<br>nO<br>input<br>8<br>0 0<br>1 0<br>2 1<br>3 3<br>4 6<br>3 6<br>2 5<br>1 3<br>output<br>YES<br>Note<br>The following image shows the first sample: both P and T are squares. The second sample was shown in the statements.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200210084847.webp" data-fancybox="images" data-caption="描述" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200210084847.webp" class="img-shadow img-margin"></center></a></p><p>Problem solving:<br>这道题的意思就是给你一个n边形，这个n边形可以在坐标轴上任意移动。问你当这个n变形的某一个顶点移动到原点时，剩下的可以得到2*n个点，问你这个n边形与2*n个点组成的多边形是否相似。<br>因为2*n边形的边肯定是偶数，所以如果n是奇数的话直接就是不可以的。<br>当n为偶数时，如果这个n边形是中心对称图形，才会满足相似。这些顶点还是按照逆时针顺序给出的，所以我们只需要根据n/2条由顶点连接起来的线的中点是否相同即可。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;ll        a[maxn], b[maxn];int main(){    ios::sync_with_stdio(0);    ll n;    cin &gt;&gt; n;    for (ll i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i] &gt;&gt; b[i];    if (n &amp; 1)    {        cout &lt;&lt; &quot;NO\n&quot;;    }    else    {        ll mmp = a[1] + a[n / 2 + 1], mmmp = b[1] + b[n / 2 + 1], flag = 0;        for (ll i = 2; i &lt;= n / 2; i++)        {            ll m = a[i] + a[i + n / 2], mp = b[i] + b[i + n / 2];            if (m != mmp)                flag = 1;            if (mp != mmmp)                flag = 1;        }        if (flag)            cout &lt;&lt; &quot;NO\n&quot;;        else            cout &lt;&lt; &quot;YES\n&quot;;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
            <tag> codeforces </tag>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元宵节快乐！一起来猜字谜啊</title>
      <link href="/2020/02/08/2020yx/"/>
      <url>/2020/02/08/2020yx/</url>
      
        <content type="html"><![CDATA[<p>闹元宵 （中国民俗）<br>闹元宵是中国节日民俗活动，起源于汉代。正月是农历的元月，古人称夜为“宵”，所以称正月十五为元宵节。正月十五日是一年中第一个月圆之夜，也是一元复始，大地回春的夜晚，人们对此加以庆祝，也是庆贺新春的延续。元宵节又称为“上元节”。（原自百度百科）<br>我还是很喜欢吃元宵的。<br>为了迎接这个元宵节，我特地去GitHub搜了一下，摸到了一个猜灯谜的小游戏的源码，<br><a href="https://github.com/Silence-girl/riddle" class="LinkCard" target="_blank" rel="noopener">元宵节猜灯谜-Github源码</a></p><p>然后放在了我服务器上面，欢迎大家一起来猜字谜鸭。(由于并无任何访问量，本站已删除)<br><a href="https://holf.cndrew.cn/" class="LinkCard" target="_blank" rel="noopener">（已失效）Happiness of the Lantern Festival</a><br>这个源码貌似是针对移动设备的所以电脑上面效果似乎不会太好，推荐大家使用手机浏览。</p><p>就这样。最后祝大家万事如意，健健康康。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020牛客寒假算法基础集训营1</title>
      <link href="/2020/02/04/nowcoder3002/"/>
      <url>/2020/02/04/nowcoder3002/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3002/" class="LinkCard" target="_blank" rel="noopener">2020牛客寒假算法基础集训营1 </a></p><h1 id="A-honoka和格点三角形"><a href="#A-honoka和格点三角形" class="headerlink" title="A    honoka和格点三角形"></a>A    honoka和格点三角形</h1><p>Description：<br>honoka最近在研究三角形计数问题。<br>她认为，满足以下三个条件的三角形是“好三角形”。<br>1.三角形的三个顶点均为格点，即横坐标和纵坐标均为整数。<br>2.三角形的面积为 。<br>3.三角形至少有一条边和 轴或 轴平行。<br>honoka想知道，在平面中选取一个大小为 <script type="math/tex">n*m</script> 的矩形格点阵，可以找到多少个不同的“好三角形”？由于答案可能过大，请对<script type="math/tex">1000000007</script>取模。<br>输入描述:<br>两个正整数<script type="math/tex">n</script>和<script type="math/tex">m</script> <script type="math/tex">\left(2 \leq n, m \leq 10^{9}\right)</script><br>输出描述:<br>面积为1的格点三角形的数量，对<script type="math/tex">10^{9}+7</script>取模的结果。<br>示例1<br>输入<br>2 3<br>输出<br>6<br>说明<br>格点如下：</p><pre><code>*  *  **  *  *</code></pre><p>不妨设左下角坐标为(1,1)，右上角坐标为到(3,2)。<br>那么三点坐标可选：<br>（1，1）（1，2）（3，1）<br>（1，1）（1，2）（3，2）<br>（1，1）（2，2）（3，1）<br>（1，1）（3，1）（3，2）<br>（1，2）（2，1）（3，2）<br>（1，2）（3，1）（3，2）<br>所以共有6个。<br>示例2<br>输入<br>100 100<br>输出<br>7683984<br>说明<br>这里太小写不下啦。</p><p>Problem solving:<br>这道题的意思就是给你一个n*m的矩形，让你在里面找面积为1并且三角形顶点都处于端点的三角形的个数。<br>分情况考虑：</p><ul><li>两条边都与坐标轴平行<br>一个<script type="math/tex">1*2</script>的矩形中有<script type="math/tex">4</script>个这样的好三角形，所以我们只需要统计这样的矩形有多少即可。即<script type="math/tex">4 *((n-2) *(m-1)+(m-2) *(n-1))</script></li><li>只有一条边与坐标轴平行<br>底边为<script type="math/tex">2</script>高为<script type="math/tex">1</script>时<br>底边与x轴平行时，每一条与x轴平行的边有<script type="math/tex">(n-2)</script>种情况满足底边为2，并且它对应的满足条件的三角形的顶点会有<script type="math/tex">2*(n-2)</script>或<script type="math/tex">(n-2)</script>种,如果这条边在中间，那么它可以组成的三角形个数就是<script type="math/tex">2*(n-2)</script>，如果是上下底边就是<script type="math/tex">(n-2)</script>种。这个挺好理解的，因为中间的边顶点可以在上面也可以在下面。所以总数是<script type="math/tex">2*(m-1)*(n-2)(n-2)</script><br>底边与y轴平行时，跟与x轴的情况是一样的，我们换一下nm即可，就是<script type="math/tex">2*(n-1)*(m-2)*(m-2)</script><br>底边为<script type="math/tex">1</script>高为<script type="math/tex">2</script>时<br>底边与x轴平行时，每一条与x轴平行的边有<script type="math/tex">n-1</script>种情况满足底边为1，并且它对应的满足条件的三角形的顶点会有<script type="math/tex">(n-2)*2</script>或<script type="math/tex">(n-2)</script>种，如果这两边是上下底边或者紧挨上下底边的四条边之一，顶点数是<script type="math/tex">(n-2)</script>，否则就是<script type="math/tex">(n-2)*2</script>。所以总数就是<script type="math/tex">(n-1)*(n-2)*4+(n-1)*(n-2)*(m-4)*2</script><br>底边与y轴平行时，跟与x轴的情况是一样的，我们换一下nm即可，就是<script type="math/tex">(m-1)*(m-2)*4+(m-1)*(m-2)*(n-4)*2</script></li></ul><p>将上面三种情况加在一起化简后变成<script type="math/tex">(2*m+2*n-4)*((n-2)*(m-1)+(n-1)*(m-2))</script></p><p>直接计算即可。注意取模</p><p>Code：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;&gt;using namespace std;typedef long long ll;const int mod = 1e9+7;int main(){    ll m,n;    cin&gt;&gt;m&gt;&gt;n;    ll ans=(2*(m+n-2)%mod*((n-2)%mod*(m-1)%mod+(m-2)%mod*(n-1)%mod))%mod;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="B-kotori和bangdream"><a href="#B-kotori和bangdream" class="headerlink" title="B    kotori和bangdream"></a>B    kotori和bangdream</h1><p>Description:<br>有一天，kotori发现了一个和lovelive相似的游戏：bangdream。令她惊讶的是，这个游戏和lovelive居然是同一个公司出的！<br>kotori经过一段时间的练习后已经变得非常触，每个音符 <script type="math/tex">x \%</script> 的概率perfect，获得<script type="math/tex">a</script>分， <script type="math/tex">(100 -x)\%</script> 概率great，获得<script type="math/tex">b</script>分。<br>已知一首歌有<script type="math/tex">n</script>个音符。kotori想知道，不考虑连击加成的话，一首歌得分的期望是多少？</p><p>输入描述:<br>一行<script type="math/tex">4</script>个整数，用空格隔开。分别是<script type="math/tex">n,x,a,b</script>。</p><script type="math/tex; mode=display">(0 \leq x \leq 100, \quad 1 \leq n, a, b \leq 1000)</script><p>输出描述:<br>一首歌得分的期望，保留两位小数。<br>示例1<br>输入<br>100 50 500 400<br>输出<br>45000.00<br>说明<br>如果全perfect是50000分，全great是40000分。由于它们的概率都是50%，即perfect和great五五开，所以期望是45000分。</p><p>Problem solving:<br>这道题的意思就是会有两种情况的得分，每种情况的得分数和概率都给出来了。直接相乘就行了，注意精度</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    double n,x,a,b;    cin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;    double ans=a*n*x/100+b*(100-x)*n/100;    printf(&quot;%.2lf\n&quot;,ans);}</code></pre><h1 id="C-umi和弓道"><a href="#C-umi和弓道" class="headerlink" title="C    umi和弓道"></a>C    umi和弓道</h1><p>Description:<br>umi对弓道非常痴迷。<br>有一天，她在研究一个射箭问题：<br>在一个无限大的平面中，她站在<script type="math/tex">\left(x_{0}, y_{0}\right)</script>这个坐标。<br>有<script type="math/tex">n</script>个靶子，第<script type="math/tex">i</script>个靶子的坐标是 <script type="math/tex">\left(x_{i}, y_{i}\right)</script><br>umi准备在<script type="math/tex">x</script>轴或<script type="math/tex">y</script>轴上放置一块挡板来挡住弓箭的轨迹，使得她可以射中的靶子数量不超过<script type="math/tex">k</script>个。<br>她想知道挡板的最短长度是多少？<br>注：假定弓箭的轨迹是起点为umi坐标、长度无穷大的射线。umi和靶子的体积可以无视。挡板的边缘碰到弓箭轨迹也可视为挡住弓箭。<br>注2：挡板不能弯折，起始和终点必须在同一坐标轴上。<br>输入描述:<br>第一行两个整数<script type="math/tex">x_{0},y_{0}</script>,代表umi的坐标。<br>第二行两个正整数<script type="math/tex">n</script>和<script type="math/tex">k</script>，分别代表靶子的总数量、放置挡板后可射中靶子的最大值。<br>接下来的<script type="math/tex">n</script>行，每行两个整数<script type="math/tex">x_{i}</script>和<script type="math/tex">y_{i}</script> 。代表每个靶子的坐标。<br>保证没有任何一个点在坐标轴上（无论umi还是靶子），保证没有任何两点重合。</p><script type="math/tex; mode=display">\left(1 \leq n \leq 100000, \quad 0 \leq k \leq n-2, \quad-2 * 10^{9} \leq x i, y i \leq 2 * 10^{9}\right)</script><p>输出描述:<br>若无论如何无法保证可以射中的靶子数量不超过<script type="math/tex">k</script>个，则输出<script type="math/tex">-1</script>。<br>否则输出挡板的最小长度。如果你和正确答案的误差不超过<script type="math/tex">10^{-6}</script>，则视为答案正确。<br>示例1<br>输入<br>1 1<br>2 0<br>-1 2<br>-2 1<br>输出<br>0.50000000<br>说明<br>umi要保证能射中的靶子不超过0个，即全部挡住。在y轴上选区间[1,1.5]放置一个长度为0.5的挡板即可。</p><p>Problem solving:<br>这道题比赛的时候没看。发现还是挺简单的一道题。<br>这道题的就是给你一个坐标作为起点，然后会有n个点的坐标。问你能否通过挡住x轴或者y轴上的某一部分使得，从起点的射线所能到达的点的个数不超过<script type="math/tex">k</script>个。首先如果在一个象限内是肯定挡不住的，然后我们把每个点（除了与起点同象限的点）和起点的连线与x轴，y轴的交点记录下来。记录完之后排序，然后每隔k个做差统计最小值即可。</p><p>注意下标</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int    maxn = 1e5 + 10;const double INF = 0x3f3f3f3f3f3f3f3f;double       xx[maxn], yy[maxn];int main(){    double x, y;    int    n, k, pos1 = 0, pos2 = 0;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; n &gt;&gt; k;    k = n - k;    for (int i = 0, a, b; i &lt; n; i++)    {        cin &gt;&gt; a &gt;&gt; b;        if (a * x &lt; 0)            xx[pos1++] = y - x * (b - y) / (a - x);        if (b * y &lt; 0)            yy[pos2++] = x - y * (a - x) / (b - y);    }    sort(xx, xx + pos1); sort(yy, yy + pos2);    double ans = INF;    for (int i = 0; i &lt; pos1; i++)    {        if (i + k &gt; pos1)            break;        ans = min(ans, xx[i + k - 1] - xx[i]);    }    for (int i = 0; i &lt; pos2; i++)    {        if (i + k &gt; pos2)            break;        ans = min(ans, yy[i + k - 1] - yy[i]);    }    if (ans == INF)        cout &lt;&lt; &quot;-1\n&quot;;    else        printf(&quot;%.6lf\n&quot;,ans);    return 0;}</code></pre><h1 id="D-hanayo和米饭"><a href="#D-hanayo和米饭" class="headerlink" title="D    hanayo和米饭"></a>D    hanayo和米饭</h1><p>Description:<br>hanayo很喜欢吃米饭。<br>有一天，她拿出了<script type="math/tex">n</script>个碗，第一个碗装了<script type="math/tex">1</script>粒米饭，第二个碗装了<script type="math/tex">2</script>粒米饭，以此类推，第<script type="math/tex">n</script>个碗装了<script type="math/tex">n</script>粒米饭。<br>然而，爱搞恶作剧的rin把所有的碗的顺序打乱，并拿走了一个碗。hanayo想知道，rin拿走的碗里有多少粒米饭？<br>输入描述:<br>第一行输入一个正整数<script type="math/tex">n</script>。代表原始的总碗数。<br>第二行输入<script type="math/tex">n-1</script>正整数<script type="math/tex">a_{i}</script>代表目前每碗里米饭数量。<br>保证输入合法。</p><script type="math/tex; mode=display">\left(2 \leq n \leq 100000, \quad 1 \leq a_{i} \leq n\right)</script><p>输出描述:<br>输出一个正整数，代表rin拿走的碗里米饭数量。<br>示例1<br>输入<br>5<br>2 5 1 3<br>输出<br>4<br>说明<br>开始共有5个碗，每个碗内分别有1、2、3、4、5粒米饭。rin拿走的是第四碗。这么简单的样例连tairitsu都看得懂好伐~</p><p>Problem solving:<br>这道题没什么好说的，签到</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    long long n,a,b,sum=0;    cin&gt;&gt;n;    a=(n+1)*n/2;    for(int i=1;i&lt;n;i++)    cin&gt;&gt;b,sum+=b;    cout&lt;&lt;a-sum&lt;&lt;endl;}</code></pre><h1 id="E-rin和快速迭代"><a href="#E-rin和快速迭代" class="headerlink" title="E    rin和快速迭代"></a>E    rin和快速迭代</h1><p>Description:<br>rin最近喜欢上了数论。<br>然而数论实在太复杂了，她只能研究一些简单的问题。<br>这天，她在研究正整数因子个数的时候，想到了一个“快速迭代”算法。设<script type="math/tex">f(x)</script>为<script type="math/tex">x</script>的因子个数，将<script type="math/tex">f</script>迭代下去，rin猜想任意正整数最终都会变成<script type="math/tex">2</script>。<br>例如：<script type="math/tex">f(12)=6, \quad f(6)=4, \quad f(4)=3, \quad f(3)=2</script>。<br>她希望你帮她验证一下。她会给你一个正整数<script type="math/tex">n</script>，让你输出它在迭代过程中，第一次迭代成<script type="math/tex">2</script>的迭代次数。<br>输入描述:<br>一个正整数  <script type="math/tex">n\left(3 \leq n \leq 10^{12}\right)</script><br>输出描述:<br>一个正整数，为<script type="math/tex">n</script>迭代至<script type="math/tex">2</script>的次数。<br>示例1<br>输入<br>12<br>输出<br>4<br>说明<br>12的因子：1，2，3，4，6，12。共6个。<br>6的因子：1，2，3，6。共4个。<br>4的因子：1，2，4。共3个。<br>3的因子：1，3。共2个。<br>12 → 6 → 4 → 3 → 2 ， 故迭代了4次。</p><p>Problem solving:<br>这道题直接跟着题目的描述模拟暴力写即可。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n, ans = 0, mid = 0;    cin &gt;&gt; n;    for (ll i = 1; i * i &lt; n; i++)        if (n % i == 0)            mid += 2;    if ((ll) sqrt(n) * (ll) sqrt(n) == n)        mid++;    if (mid == 2)    {        cout &lt;&lt; &quot;1\n&quot;; return 0;    }    else        ans = 1;    while (mid != 2)    {        ll mm = 0;        ans++;        for (ll i = 1; i * i &lt; mid; i++)            if (mid % i == 0)                mm += 2;        if ((ll) sqrt(mid) * (ll) sqrt(mid) == mid)            mm++;        mid = mm;    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h1 id="F-maki和tree"><a href="#F-maki和tree" class="headerlink" title="F    maki和tree"></a>F    maki和tree</h1><p>Description:<br>有一天，maki拿到了一颗树。所谓树，即没有自环、重边和回路的无向连通图。<br>这个树有<script type="math/tex">n</script>个顶点，<script type="math/tex">n-1</script>条边。每个顶点被染成了白色或者黑色。<br>maki想知道，取两个不同的点，它们的简单路径上有且仅有一个黑色点的取法有多少？<br>注：</p><ol><li>树上两点简单路径指连接两点的最短路。</li><li><script type="math/tex"><p, q></script>和<script type="math/tex"><q, p></script>的取法视为同一种。</li></ol><p>输入描述:<br>第一行一个正整数<script type="math/tex">n</script>。代表顶点数量。<br>第二行是一个仅由字符&#39;B&#39;和&#39;W&#39;组成的字符串。第<script type="math/tex">i</script>个字符是B代表第<script type="math/tex">i</script>个点是黑色，W代表第<script type="math/tex">i</script>个点是白色。<br>接下来的<script type="math/tex">n-1</script>行，每行两个正整数 <script type="math/tex">x</script>，<script type="math/tex">y</script>，代表<script type="math/tex">x</script>点和<script type="math/tex">y</script>点有一条边相连</p><script type="math/tex; mode=display">(1 \leq x, y \leq n)</script><p>输出描述:<br>一个正整数，表示只经过一个黑色点的路径数量。<br>示例1<br>输入</p><p>3<br>WBW<br>1 2<br>2 3<br>输出</p><p>3<br>说明<br>树表示如下：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200209135752.webp" data-fancybox="images" data-caption="图" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200209135752.webp" class="img-shadow img-margin"></center></a><br>其中只有2号是黑色点。</p><p><1,2>、<2,3>、<1,3>三种取法都只经过一个黑色点。</1,3></2,3></1,2></p><p>Problem solving:<br>这道题就是给了你一棵树，每个节点都有颜色，黑色或者白色。问你有多少条路径经过黑色节点。<br>我们可以把白点当成连通块处理，并且把这一块百点中的任意一个百点的值赋为连通块中节点的数量。<br>然后每遇到一个黑点计算一次。对与黑点相连的点，如果是白色，答案加上这个白色的所处连通块的节点数量。但是有可能存在一个黑点连接好几个白点的情况，这个时候同时也得计算两个端点都是白色节点的路径数，统计一下之前相连的所有白色节点的个数相乘即可。</p><p>注意会爆int</p><p>这道题也可以用带权并查集，bfs写，但是dfs会简洁一点。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb    push_backconst ll  maxn = 1e5 + 10;ll        n, ans, p[maxn]; char s[maxn];bool        vis[maxn];vector&lt;int&gt; V[maxn];vector&lt;int&gt; mid;void dfs(ll x){    mid.pb(x), vis[x] = 1;    for (ll i = 0; i &lt; V[x].size(); i++)    {        if (s[V[x][i]] == &#39;W&#39; &amp;&amp; !vis[V[x][i]])            dfs(V[x][i]);    }}int main(){    cin &gt;&gt; n;    scanf(&quot;%s&quot;, s + 1);    for (ll i = 1, u, v; i &lt; n; i++)    {        cin &gt;&gt; u &gt;&gt; v;        V[u].pb(v); V[v].pb(u);    }    for (ll i = 1; i &lt;= n; i++)    {        if (vis[i] || s[i] == &#39;B&#39;)            continue;        mid.clear(); dfs(i);        ll mi = mid.size();        for (ll i = 0; i &lt; mi; i++)            p[mid[i]] = mi;    }    for (ll i = 1; i &lt;= n; i++)    {        ll m = 0;        if (s[i] == &#39;B&#39;)        {            for (ll j = 0; j &lt; V[i].size(); j++)            {                if (s[V[i][j]] == &#39;W&#39;)                {                    ans += m * p[V[i][j]] + p[V[i][j]];                    m   += p[V[i][j]];                }            }        }    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h1 id="G-eli和字符串"><a href="#G-eli和字符串" class="headerlink" title="G    eli和字符串"></a>G    eli和字符串</h1><p>Description:<br>eli拿到了一个仅由小写字母组成的字符串。<br>她想截取一段连续子串，这个子串包含至少<script type="math/tex">k</script>个相同的某个字母。<br>她想知道，子串的长度最小值是多少？<br>注：所谓连续子串，指字符串删除头部和尾部的部分字符（也可以不删除）剩下的字符串。例如：对于字符串“arcaea”而言，“arc”、“rcae”都是其子串。而“car”、“aa”则不是它的子串。<br>输入描述:<br>第一行输入两个正整数<script type="math/tex">n</script>和<script type="math/tex">k</script>   <script type="math/tex">(1 \leq k \leq n \leq 200000)</script><br>输入仅有一行，为一个长度为<script type="math/tex">n</script>的、仅由小写字母组成的字符串。<br>输出描述:<br>如果无论怎么取都无法满足条件，输出<script type="math/tex">-1</script>。<br>否则输出一个正整数，为满足条件的子串长度最小值。<br>示例1<br>输入<br>5 2<br>abeba<br>输出<br>3<br>说明<br>选择“beb”子串，长度为3，其中包含相同的两个&#39;b&#39;</p><p>Problem solving:<br>这道题的意思是给你一个字符串，让你找一个最短的子串里面包含k个相同字母。<br>因为保证只有小写字母，所以我们统计每个字母出现的位置，然后每次计算k个相邻字母的距离，直接位置相减即可。并且每次更新最小值。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int   maxn = 2e5 + 10;vector&lt;int&gt; V[30];int main(){    int n, k, ans = 1e9; string s;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;    if (k == 1)    {        cout &lt;&lt; &quot;1\n&quot;; return 0;    }    for (int i = 0; i &lt; n; i++)        V[s[i] - &#39;a&#39;].push_back(i);    for (int i = 0; i &lt; 26; i++)    {        int l = V[i].size();        if (l &lt; k)            continue;        for (int j = 0; j &lt; l; j ++)        {            if (j + k - 1 &gt;= l)                break;            ans = min(V[i][j + k - 1] - V[i][j] + 1, ans);        }    }    if (ans == 1e9)        ans = -1;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h1 id="H-nozomi和字符串"><a href="#H-nozomi和字符串" class="headerlink" title="H    nozomi和字符串"></a>H    nozomi和字符串</h1><p>Description:<br>nozomi看到eli在字符串的“花园”里迷路了，决定也去研究字符串问题。<br>她想到了这样一个问题：<br>对于一个 “01”串而言，每次操作可以把 <script type="math/tex">0</script> 字符改为 <script type="math/tex">1</script> 字符，或者把 <script type="math/tex">1</script> 字符改为 <script type="math/tex">0</script> 字符。所谓“01”串，即只含字符 <script type="math/tex">0</script> 和字符 <script type="math/tex">1</script> 的字符串。<br>nozomi有最多<script type="math/tex">k</script>次操作的机会。她想在操作之后找出一个尽可能长的连续子串，这个子串上的所有字符都相同。<br>nozomi想问问聪明的你，这个子串的长度最大值是多少？<br>注：<script type="math/tex">k</script>次操作机会可以不全部用完。<br>如果想知道连续子串的说明，可以去问问eli，nozomi不想再讲一遍。<br>输入描述:<br>第一行输入两个正整数<script type="math/tex">n</script>和<script type="math/tex">k</script> <script type="math/tex">(1 \leq k \leq n \leq 200000)</script><br>输入仅有一行，为一个长度为 <script type="math/tex">n</script> 的、仅由字符 <script type="math/tex">0</script> 和 <script type="math/tex">1</script> 组成的字符串。<br>输出描述:<br>一个正整数，为满足条件的子串长度最大值。<br>示例1<br>输入<br>5 1<br>10101<br>输出<br>3<br>说明<br>只有<script type="math/tex">1</script>次操作机会。<br>将第二个位置的 <script type="math/tex">0</script> 改成 <script type="math/tex">1</script> ，字符串变成 <script type="math/tex">11101</script>，可以选出 “111”子串，长度为<script type="math/tex">3</script>。<br>如果修改第三个或者第四个位置的字符也可以选出长度为<script type="math/tex">3</script>的子串。</p><p>Problem solving:<br>这道题跟上一道题很像，这道题的意思是给你一个只有01组成的字符串，你有k次机会可以把0变成1，或者把1变成0.问你可以找到的最大的子串长度，要求子串中的每一个元素都相等，即都是1或者都是0<br>我们仍然统计0和1的出现位置，现在假如我们考虑把1换成0，那我们只需要看1的位置中，中间有k个1的两个1之间的距离就是此时可以达到的最大子串长度。<br>把0换成1也是一样的。每次更新最大值即可</p><p>注意有一些细节需要处理，具体可以看代码去理解。<br>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 10;typedef long long ll;#define pb    push_backvector&lt;ll&gt; v[5];int main(){    ll x = 0, y = 0, n, k, ans = 1; string s;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;    for (int i = 0; i &lt; n; i++)        v[s[i] - &#39;0&#39;].pb(i);    v[0].pb(n),v[1].pb(n);    x = v[0].size(), y = v[1].size();    if (k &gt;= x-1 || k &gt;= y-1)    {        cout &lt;&lt; n &lt;&lt; endl;        return 0;    }    for (int i = 0; i &lt; x; i++)    {        if (i + k &gt;= x)            break;        ans = max(ans, v[0][i + k+1] - v[0][i] -1);    }    for (int i = 0; i &lt; y; i++)    {        if (i + k &gt;= y)            break;        ans = max(ans, v[1][i + k+1 ] - v[1][i] -1);    }    cout &lt;&lt; ans &lt;&lt; endl;}</code></pre><h1 id="I-nico和niconiconi"><a href="#I-nico和niconiconi" class="headerlink" title="I    nico和niconiconi"></a>I    nico和niconiconi</h1><p>Description:<br>nico平时最喜欢说的口头禅是niconiconi~。<br>有一天nico在逛著名弹幕网站&quot;niconico&quot;的时候惊异的发现，n站上居然有很多她的鬼畜视频。其中有一个名为《让nico为你洗脑》的视频吸引了她的注意。<br>她点进去一看，就被洗脑了:<code>&quot;niconicoh0niconico*^vvniconicoG(vniconiconiconiconiconicoG(vniconico......&quot;</code><br>弹幕中刚开始有很多“nico<em>1 nico</em>2”等计数菌，但到后面基本上都是“计数菌阵亡”的弹幕了。<br>nico也想当一回计数菌。她认为：&quot;nico&quot; 计<script type="math/tex">a</script>分，&quot;niconi&quot; 计<script type="math/tex">b</script>分，&quot;niconiconi&quot; 计<script type="math/tex">c</script>分。<br>她拿到了一个长度为 <script type="math/tex">n</script>的字符串，请帮她算出最大计数分数。<br>注：已被计数过的字符不能重复计数！如&quot;niconico&quot;要么当作&quot;nico&quot;+&quot;nico&quot;计<script type="math/tex">2a</script>分，要么当作&quot;niconi&quot;+&quot;co&quot;计<script type="math/tex">b</script>分。<br>输入描述:<br>第一行四个正整数 <script type="math/tex">n, a, b, c , \quad\left(1 \leq n \leq 300000, \quad 1 \leq a, b, c \leq 10^{9}\right)</script>.<br>第二行是一个长度为<script type="math/tex">n</script>的字符串。<br>输出描述:<br>一个整数，代表最大的计数分数。<br>示例1<br>输入<br>19 1 2 5<br>niconiconiconiconi~<br>输出<br>7<br>说明<br>&quot;niconi&quot;co&quot;niconiconi&quot;~<br>故为2+5=7分</p><p>Problem solving:<br>这道题的意思就是给你一个字符串，不同的子串可以有不同的分数，问你最多可以得多少分。<br>就是一个dp，找到状态转移方程就可以了。</p><p>状态转移方程：</p><script type="math/tex; mode=display">\begin{aligned}&\text { if }(\text { substring }(i-3, i)==\text { nico }) \text { then } d p[i]=\max (d p[i], d p[i-4]+a)\\&\text { if }(\text {substring}(i-5, i)==\text {niconi}) \text {then } d p[i]=\max (d p[i], d p[i-6]+b)\\&\text { if }(\text { substring }(i-9, i)==\text { niconiconi }) \text { then } d p[i]=\max (d p[i], d p[i-10]+c)\end{aligned}</script><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 3e5 + 10;ll       dp[maxn];int main(){    string s; ll n, a, b, c;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; s;    for (ll i = 0; i &lt; n; i++)    {        if (i &gt; 0)            dp[i] = dp[i - 1];        if (i &gt;= 3 &amp;&amp; s.substr(i - 3, 4) == &quot;nico&quot;)            dp[i] = max(dp[i], dp[i - 3] + a);        if (i &gt;= 5 &amp;&amp; s.substr(i - 5, 6) == &quot;niconi&quot;)            dp[i] = max(dp[i], dp[i - 5] + b);        if (i &gt;= 9 &amp;&amp; s.substr(i - 9, 10) == &quot;niconiconi&quot;)            dp[i] = max(dp[i], dp[i - 9] + c);    }    cout &lt;&lt; dp[n - 1] &lt;&lt; endl;    return 0;}</code></pre><h1 id="J-u-39-s的影响力"><a href="#J-u-39-s的影响力" class="headerlink" title="J    u&#39;s的影响力"></a>J    u&#39;s的影响力</h1><p>μ&#39;s在九人齐心协力下，影响力越来越大了！<br>已知第一天影响力为<script type="math/tex">x</script>  ，第二天影响力为<script type="math/tex">y</script> ，从第三天开始，每一天的影响力为前两天影响力的乘积再乘以<script type="math/tex">a</script> 的<script type="math/tex">b</script> 次方。 用数学语言描述是：<br>设第<script type="math/tex">i</script> 天的影响力为<script type="math/tex">f(i)</script> ，那么<script type="math/tex">f(1)=x</script> ，<script type="math/tex">f(2)=y</script> ，对于<script type="math/tex">i>2</script>  ，<script type="math/tex">f(i)=f(i-1) * f(i-2) * a^{b}</script><br>她们想知道第<script type="math/tex">n</script>天影响力是多少？<br>由于这个数可能非常大，只需要输出其对<script type="math/tex">1000000007</script>取模的值就可以了。<br>输入描述:<br>一行五个正整数:<script type="math/tex">n,x,y,a,b</script>。</p><script type="math/tex; mode=display">\left(1 \leq n, x, y, a, b \leq 10^{12}\right)</script><p>输出描述:<br>第<script type="math/tex">n</script>天的影响力对<script type="math/tex">1000000007</script>取模的值。<br>示例1<br>输入<br>4 2 3 2 1<br>输出<br>72<br>说明<br>f(1)=2，f(2)=3，f(3)=f(1)<em>f(2)</em>2=12，f(4)=f(2)<em>f(3)</em>2=72<br>备注:<br>1000000007是素数。</p><p>Problem solving:<br>题意挺明确的，就是一个递推式，让你求第n项，但是这第n项求起来就很难。<br>待补</p><p><a href="https://ac.nowcoder.com/discuss/364600?type=101&order=0&pos=4&page=3" class="LinkCard" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为hexo添加Latex渲染</title>
      <link href="/2020/01/22/test/"/>
      <url>/2020/01/22/test/</url>
      
        <content type="html"><![CDATA[<p>最开始用hexo用的是Next主题。里面自带的有Latex渲染的支持。现在换了Sakura之后，不自带了还是很不舒服的。所以在网上找了一下教程，搞好之后自己来试试。<br><a href="https://cps.ninja/2019/03/16/hexo-with-latex/" class="LinkCard" target="_blank" rel="noopener">参考教程-让 Hexo 搭建的博客支持 LaTeX</a></p><p>首先进入博客根目录<code>../blog</code><br>右键<code>git bash here</code><br>依次输入以下指令</p><pre><code>npm install hexo-math --savenpm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save</code></pre><p>以上命令执行完以后，我们还需要修改 kramed 配置，解决语义冲突，因为由于 LaTeX 与 Markdown 语法存在冲突（例如在 markdown 中，斜体可以用<code>*</code>或者<code>_</code>表示，而 LaTeX 也会用到 <code>_</code> ），所以我们要对 kramed 默认的语法规则进行修改，否则之后会出现很多奇怪的排版样式。</p><p>在<code>../blog/node_modules\kramed\lib\rules\inline.js</code>中<br>把第 <code>11</code> 行的 <code>escape</code>变量的值修改为：</p><pre><code>escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</code></pre><p>同时把第 <code>20</code>行的 <code>em</code> 变量修改为：</p><pre><code>em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</code></pre><p>然后再<code>../blog/_config.yml</code>中添加</p><pre><code class="lang-yml"># MathJaxmath:  engine: &#39;mathjax&#39;  mathjax:    src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML</code></pre><p>这样就可以啦。愉快的使用Latex吧</p><pre><code class="lang-LaTeX">$$A = \begin{bmatrix}        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\\        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\    \end{bmatrix} , b = \begin{bmatrix}        b_{1}  \\        b_{2}  \\        b_{3}  \\        \vdots \\        b_{n}  \\    \end{bmatrix}$$</code></pre><p>效果</p><script type="math/tex; mode=display">A = \begin{bmatrix}        a_{11}    & a_{12}    & ...    & a_{1n}\\        a_{21}    & a_{22}    & ...    & a_{2n}\\        a_{31}    & a_{22}    & ...    & a_{3n}\\        \vdots    & \vdots    & \ddots & \vdots\\        a_{n1}    & a_{n2}    & ... & a_{nn}\\    \end{bmatrix} , b = \begin{bmatrix}        b_{1}  \\        b_{2}  \\        b_{3}  \\        \vdots \\        b_{n}  \\    \end{bmatrix}</script>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathpix更新收费之后我选择了阿里云企业邮箱</title>
      <link href="/2020/01/20/mathpix/"/>
      <url>/2020/01/20/mathpix/</url>
      
        <content type="html"><![CDATA[<p>对于Latex选手，数学公式永远是最头疼的东西。各种各样的语法（反正我是懒得记。<br>近年出现一个贼nb的软件<a href="https://mathpix.com/" target="_blank" rel="noopener">mathpix</a>可以通过图片把数学公式转换成Latex语法的表示。关键是它还免费，用的也是很顺心的很不错的。<br>但是正在我今天舒舒服服快快乐乐的用着的时候，它提示我本月<code>50</code>次免费转换机会用完了？怎么突然收费了，我内心是快（meng）乐（bi）的。<br>在网上各种找各种解决方法都没有成功。所以我选择了阿里云免费企业邮箱。（手动滑稽）真的没有在做广告，这个真的不错，关键是还免费。白嫖就完事了啊。你只需要一个域名。而域名甚至也可以找到免费的。</p><p>购买之后各种绑定各种解析之后，我获得了<code>50</code>个邮箱。<br>我没有在针对mathpix，只不过是它让我意识到我的邮箱太少了。<br>这里也不是跟大家说关于mathpix付费之后的破解办法，当然不是，绝对不是，肯定不是。我拿张三的人格发誓。<br>只是安利一下阿里云的免费企业邮箱。</p><p>最后给大家表演一下我的数学能力<br><code>50*50=2500</code><br>仅仅是表演，不要想多，没有别的意思</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 614 (Div. 2)  D. Aroma&#39;s Search</title>
      <link href="/2020/01/20/cf613D/"/>
      <url>/2020/01/20/cf613D/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1293/problem/D" target="_blank" rel="noopener">Aroma&#39;s Search</a></p><p><center>D. Aroma's Search</center><br>Description:<br>With a new body, our idol Aroma White (or should we call her Kaori Minamiya?) begins to uncover her lost past through the OS space.</p><p>The space can be considered a 2D plane, with an infinite number of data nodes, indexed from 0, with their coordinates defined as follows:</p><p>The coordinates of the 0-th node is (x0,y0)<br>For i&gt;0, the coordinates of i-th node is (ax⋅xi−1+bx,ay⋅yi−1+by)<br>Initially Aroma stands at the point (xs,ys). She can stay in OS space for at most t seconds, because after this time she has to warp back to the real world. She doesn&#39;t need to return to the entry point (xs,ys) to warp home.</p><p>While within the OS space, Aroma can do the following actions:</p><p>From the point (x,y), Aroma can move to one of the following points: (x−1,y), (x+1,y), (x,y−1) or (x,y+1). This action requires 1 second.<br>If there is a data node at where Aroma is staying, she can collect it. We can assume this action costs 0 seconds. Of course, each data node can be collected at most once.<br>Aroma wants to collect as many data as possible before warping back. Can you help her in calculating the maximum number of data nodes she could collect within t seconds?</p><p>Input<br>The first line contains integers x0, y0, ax, ay, bx, by (1≤x0,y0≤1e16, 2≤ax,ay≤100, 0≤bx,by≤1e16), which define the coordinates of the data nodes.</p><p>The second line contains integers xs, ys, t (1≤xs,ys,t≤1e16) – the initial Aroma&#39;s coordinates and the amount of time available.</p><p>Output<br>Print a single integer — the maximum number of data nodes Aroma can collect within t seconds.</p><p>Examples<br>input<br>1 1 2 3 1 0<br>2 4 20<br>output<br>3<br>input<br>1 1 2 3 1 0<br>15 27 26<br>output<br>2<br>input<br>1 1 2 3 1 0<br>2 2 1<br>output<br>0<br>Note<br>In all three examples, the coordinates of the first 5 data nodes are (1,1), (3,3), (7,9), (15,27) and (31,81) (remember that nodes are numbered from 0).</p><p>In the first example, the optimal route to collect 3 nodes is as follows:</p><p>Go to the coordinates (3,3) and collect the 1-st node. This takes |3−2|+|3−4|=2 seconds.<br>Go to the coordinates (1,1) and collect the 0-th node. This takes |1−3|+|1−3|=4 seconds.<br>Go to the coordinates (7,9) and collect the 2-nd node. This takes |7−1|+|9−1|=14 seconds.<br>In the second example, the optimal route to collect 2 nodes is as follows:</p><p>Collect the 3-rd node. This requires no seconds.<br>Go to the coordinates (7,9) and collect the 2-th node. This takes |15−7|+|27−9|=26 seconds.<br>In the third example, Aroma can&#39;t collect any nodes. She should have taken proper rest instead of rushing into the OS space like that.</p><p>Problem solving:<br>这道题的意思就是在一个无限大的二维平面内。有一个人位于起点xs,ys。每秒可以走一格，相邻的格子。现在告诉你有一种格子中存在着金币（就看成是金币吧），问你这个人在规定的时间t内最多可以取到多少金币。</p><p>从一个位置走到另一个位置花费的时间其实就是横纵坐标差的绝对值之和。有金币的格子坐标没有给我们，只是给了一个递推式xi=ax⋅x(i−1)+bx,yi=ay⋅y(i−1)+by，我们知道，累乘是很大的，并且题目中说最大不会超过1e16，所以其实有金币的格子是很少的。并且我们还可以知道，当你选择了第一个取得金币之后，如果你还想保证在有限时间内取到的金币最多的话那么接下来取金币的顺序就定了，因为金币之间的距离是按比值增加的。因我们就可以暴力枚举第一次取得的金币的所有可能，然后每次更新最大值即可。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;ll        x[maxn], y[maxn];int main(){    ll s, ax, ay, bx, by, xs, ys, t, ans = 0;    cin &gt;&gt; x[0] &gt;&gt; y[0] &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by &gt;&gt; xs &gt;&gt; ys &gt;&gt; t;    for (int i = 1;; i++)    {        x[i] = ax * x[i - 1] + bx;        y[i] = ay * y[i - 1] + by;        if (x[i] &gt;= xs + t || y[i] &gt;= ys + t)        {            s = i;            break;        }    }    for (int i = 0; i &lt; s; i++)    {        for (int j = 0; j &lt; s; j++)        {            ll d = abs(x[i] - xs) + abs(y[i] - ys) + abs(x[j] - x[i]) + abs(y[j] - y[i]);            if (d &lt;= t)                ans = max(ans, abs(j - i) + (ll) 1);        }    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><p>跟oi爷成功的一次py(希望FST善良一点)<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119233557.webp" data-fancybox="images" data-caption="Rank" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119233557.webp" class="img-shadow img-margin"></center></a></p><p>少考虑一种情况WA了(果然FST不会善良)<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200120102532.webp" data-fancybox="images" data-caption="Rank" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200120102532.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> thinking </tag>
            
            <tag> codedforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次给valine添加评论回复功能</title>
      <link href="/2020/01/19/smtp/"/>
      <url>/2020/01/19/smtp/</url>
      
        <content type="html"><![CDATA[<p>博客里面的评论系统是很有必要的，是博主和访客一个稳定的交流方式。目前使用hexo作为博客框架的大部分评论系统应该都是采用的valine。基本的valine是没有评论回复的功能的。往往看到很久之前别人的回复就很尴尬。所以评论回复的功能还是很有必要的。<br>这里我们默认你已经配置好了基本的valine。<br>接下来我们打开LeanCloud的控制台中的你的评论系统<br>找到云引擎-&gt;设置，在代码库中填入</p><pre><code class="lang-txt">https://github.com/zhaojun1998/Valine-Admin</code></pre><p>后，点击保存<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119154429.webp" data-fancybox="images" data-caption="代码库" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119154429.webp" class="img-shadow img-margin"></center></a></p><p>接下来，找到菜单栏中的部署，点进去之后在源码部署中的分支或版本号填上<code>master</code>之后点击部署。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119154913.webp" data-fancybox="images" data-caption="代码库" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119154913.webp" class="img-shadow img-margin"></center></a></p><p>然后回到设置中，找到自定义环境变量，进行添加。（这里我用的是qq的邮箱，别的都差不多，端口ip什么的百度都可以有）<br>我们需要添加的变量有</p><ol><li>SITE_NAME : 网站名称。</li><li>SITE_URL : 网站地址, 最后不要加 / 。</li><li>SMTP_USER : SMTP 服务用户名，一般为邮箱地址。</li><li>SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式</li><li>SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、&quot;Yahoo&quot;、...... ，全部支持请参考 : <a href="https://nodemailer.com/smtp/well-known/#supported-services" target="_blank" rel="noopener">Nodemailer Supported services</a>。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器</li><li>SENDER_NAME : 寄件人名称。</li><li>SMTP_HOST : 邮件服务提供商 SMTP 地址，如 qq : smtp.qq.com，此项需要自行查询或询问其服务商。</li><li>SMTP_PORT : 邮件服务提供商 SMTP 端口, 此项需要自行查询或询问其服务商。</li><li>SMTP_SECURE : 是否启用加密, 默认为 true，一般不需要设置，如有特殊请自行配置。 此项需要自行查询或询问其服务商。</li><li>（可选）TEMPLATE_NAME：设置提醒邮件的主题，目前内置了两款主题，分别为 default 与 rainbow。默认为 default 。<br>填完之后大概是这鸭子的<a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155413.webp" data-fancybox="images" data-caption="环境变量" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155413.webp" class="img-shadow img-margin"></center></a></li></ol><p>这里顺便说一下QQ的SMTP授权码的获取<br>登陆进去之后找到设置<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155515.webp" data-fancybox="images" data-caption="设置" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155515.webp" class="img-shadow img-margin"></center></a><br>在常规中往下滑找到<code>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155606.webp" data-fancybox="images" data-caption="设置" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155606.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155619.webp" data-fancybox="images" data-caption="设置" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155619.webp" class="img-shadow img-margin"></center></a><br><code>POP3/SMTP服务</code>如果没开启就开启，然后点击下面的生成授权码，跟着他的要求发一遍就好了。这就不往下说了，我之前弄过了不重复弄了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155752.webp" data-fancybox="images" data-caption="授权码" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200119155752.webp" class="img-shadow img-margin"></center></a><br>注意发的是<code>配置邮件客户端</code>，我总把邮件写成邮箱</p><p>这些全部都填好之后，把自己评论系统中的实例重启一下就可以了。不出意外的话，评论提醒已经有了。</p><p>但是还会有一个问题就是免费版的话每天会有6个小时的强制休眠时间，并且如果应用最近一段时间（半小时）没有任何外部请求，则休眠。<br>但是这并不能阻止我们白嫖，我们可以在linux服务器中添加一个定时任务，每二十分钟提醒一次就可以保证不会休眠了。因为是有六个小时的强制休眠，网上大部分都是选的7:00-23:00<br>crontab代码为</p><pre><code class="lang-crontab">*/20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn</code></pre><p>如果你们没有服务器或者不会添加可以给我留言，我加到我的服务器上面。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 80 (Rated for Div. 2) E. Messenger Simulator</title>
      <link href="/2020/01/17/cfedu80E/"/>
      <url>/2020/01/17/cfedu80E/</url>
      
        <content type="html"><![CDATA[<p>Link:<a href="https://codeforces.com/contest/1288/problem/E" target="_blank" rel="noopener">E. Messenger Simulator</a></p><p><center>E. Messenger Simulator</center><br>Description:<br>Polycarp is a frequent user of the very popular messenger. He&#39;s chatting with his friends all the time. He has n friends, numbered from 1 to n.</p><p>Recall that a permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array.</p><p>So his recent chat list can be represented with a permutation p of size n. p1 is the most recent friend Polycarp talked to, p2 is the second most recent and so on.</p><p>Initially, Polycarp&#39;s recent chat list p looks like 1,2,…,n (in other words, it is an identity permutation).</p><p>After that he receives m messages, the j-th message comes from the friend aj. And that causes friend aj to move to the first position in a permutation, shifting everyone between the first position and the current position of aj by 1. Note that if the friend aj is in the first position already then nothing happens.</p><p>For example, let the recent chat list be p=[4,1,5,3,2]:</p><p>if he gets messaged by friend 3, then p becomes [3,4,1,5,2];<br>if he gets messaged by friend 4, then p doesn&#39;t change [4,1,5,3,2];<br>if he gets messaged by friend 2, then p becomes [2,4,1,5,3].<br>For each friend consider all position he has been at in the beginning and after receiving each message. Polycarp wants to know what were the minimum and the maximum positions.</p><p>Input<br>The first line contains two integers n and m (1≤n,m≤3e5) — the number of Polycarp&#39;s friends and the number of received messages, respectively.</p><p>The second line contains m integers a1,a2,…,am (1≤ai≤n) — the descriptions of the received messages.</p><p>Output<br>Print n pairs of integers. For each friend output the minimum and the maximum positions he has been in the beginning and after receiving each message.</p><p>Examples<br>input<br>5 4<br>3 5 1 4<br>output<br>1 3<br>2 5<br>1 4<br>1 5<br>1 5<br>input<br>4 3<br>1 2 4<br>output<br>1 3<br>1 2<br>3 4<br>1 4<br>Note<br>In the first example, Polycarp&#39;s recent chat list looks like this:</p><p>[1,2,3,4,5]<br>[3,1,2,4,5]<br>[5,3,1,2,4]<br>[1,5,3,2,4]<br>[4,1,5,3,2]<br>So, for example, the positions of the friend 2 are 2,3,4,4,5, respectively. Out of these 2 is the minimum one and 5 is the maximum one. Thus, the answer for the friend 2 is a pair (2,5).</p><p>In the second example, Polycarp&#39;s recent chat list looks like this:</p><p>[1,2,3,4]<br>[1,2,3,4]<br>[2,1,3,4]<br>[4,2,1,3]</p><p>Problem solving:<br>这道题的意思是一开始有一个1-n的序列按顺序排列。然后会有m次操作，每次都会给出一个值，每次操作这个值都会跳到最前面，问你经过m次操作后，每个数能达到的最小和最大位置是哪里。<br>暴力的话肯定会超时。所以我们可以这样想，比如说第一个样例</p><pre><code class="lang-text">1 2 3 4 5会有四次操作，我们往前面放四个00 0 0 0 1 2 3 4 5每次操作一个数，就提到最前面，然后它本来的位置变成0，这个数此时的位置就是它前面的非0的数字的个数加一，操作过程中还要同时更新最大值这里有一个很巧的就是最小值不是1就是它本来的位置，因为如果对一个数操作，那么它的最小位置一定是1，如果没有对它操作，那它的最后的位置一定是大于等于初始位置，所以最小值很简单。样例中的操作0 0 0 3 1 2 0 4 50 0 5 3 1 2 0 4 00 1 5 3 0 2 0 4 04 1 5 3 0 2 0 0 0  最后再统计一次每个数的位置更新最大值。统计位置即看这个数前面有几个非零数字即可</code></pre><p>统计每个数前有几个非零数字，这里我们可以用树状数组实现，因为这里是动态的。单点修改和区间查询。用树状数组会很方便。<br>注意这里树状数组需要开到6e5.因为n前面我们加上了m个位置，</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 10;#define lowbit(x)    (x &amp; (-x))int       n, m, mx[maxn], mn[maxn], pos[maxn], mid[maxn];void add(int x, int k){    for (; x &lt; maxn; x += lowbit(x))        mid[x] += k;}int see(int x){    int ans = 0;    for (; x; x -= lowbit(x))        ans += mid[x];    return ans;}int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        mx[i] = mn[i] = i, pos[i] = i + m, add(i + m, 1);    for (int i = 0; i &lt; m; i++)    {        int mi; cin &gt;&gt; mi;        mx[mi] = max(mx[mi], see(pos[mi])); mn[mi] = 1;        add(pos[mi], -1);        pos[mi] = m - i;        add(pos[mi], 1);    }    for (int i = 1; i &lt;= n; i++)        mx[i] = max(mx[i], see(pos[i]));    for (int i = 1; i &lt;= n; i++)        cout &lt;&lt; mn[i] &lt;&lt; &quot; &quot; &lt;&lt; mx[i] &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 80 (Rated for Div. 2) D. Minimax Problem</title>
      <link href="/2020/01/17/cfedu80D/"/>
      <url>/2020/01/17/cfedu80D/</url>
      
        <content type="html"><![CDATA[<p>Link:<a href="https://codeforces.com/contest/1288/problem/D" target="_blank" rel="noopener"> D. Minimax Problem</a></p><p><center> D. Minimax Problem </center><br>Description:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/edu80-d.webp" data-fancybox="images" data-caption="题面" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/edu80-d.webp" class="img-shadow img-margin"></center></a><br>Example<br>input<br>6 5<br>5 0 3 1 2<br>1 8 9 1 3<br>1 2 3 4 5<br>9 1 0 3 7<br>2 3 0 6 3<br>6 4 1 7 0<br>output<br>1 5</p><p>Problem solving:<br>这道题的意思就是给你n个长度为m的序列，你可以任选两个序列经过操作变成一个序列。操作规则：新序列的第i位的值为你选择的两个序列中对应位置的两个数中的最大值。现在让你选两个序列使他们组成的新序列中的最小值最大。</p><p>遇到最小的最大，很容易就应该想到是二分，但是这道题看起来似乎不是那么容易二分。难点也就是check函数。看了<a href="https://www.bilibili.com/video/av83609526?from=search&amp;seid=9596831975824321873" target="_blank" rel="noopener">dl视频</a>之后才知道原来还可以这样二分</p><p>我们假设现在是在进行check(x)，首先我们把这n个序列中每个大于x的值标为1，把小于x的值标为0。全部改完之后可以看成是一个m位的二进制。然后还可以发现只要存在两个序列转换之后的“二进制”相互或一下可以变成m位都是1的话，这个x就是可行的。（虽然没有严谨的证明，但是可以自己想一下，确实是这样的）<br>至于m位全是1的判断，我们可以直接看这个数与<code>(i&lt;&lt;m)-1</code>是否相等即可</p><p>这样我们check就可以写好了，然后二分答案即可。因为m最多是8位，也就是256，平方一下还不到1e6.所以时间复杂度可以过的去。<br>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 10;int       r, l, n, m, a[maxn][10], mid, ans, ans1, ans2, val[(1 &lt;&lt; 8) + 10], flag;bool check(int x){    flag = 0; memset(val, 0, sizeof(val));    for (int i = 0; i &lt; n; i++)    {        int mi = 0;        for (int j = 0; j &lt; m; j++)            if (a[i][j] &gt;= x)                mi += (1 &lt;&lt; j);//(1&lt;&lt;j)即第j位为1时的值，累加起来就是这m位二进制表示的值        val[mi] = i + 1;//值位mi的是第i列，因为从0开始的所以加1    }    /*看能否找到满足最大的最小值为x的两列*/    for (int i = 0; i &lt; (1 &lt;&lt; m); i++)        for (int j = 0; j &lt; (1 &lt;&lt; m); j++)            if (val[i] != 0 &amp;&amp; val[j] != 0 &amp;&amp; ((i | j) == (1 &lt;&lt; m) - 1))//如果i和j的val不是0说明出现过                flag = 1, ans1 = val[i], ans2 = val[j];    return flag;}int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt; m; j++)            cin &gt;&gt; a[i][j];    l = -1, r = 1e9;    while (l &lt;= r)    {        mid = (l + r) &gt;&gt; 1;        if (check(mid))            l = mid + 1, ans = mid;        else            r = mid - 1;    }    check(ans);    cout &lt;&lt; ans1 &lt;&lt; &quot; &quot; &lt;&lt; ans2 &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goodbye 2019</title>
      <link href="/2019/12/31/2019/"/>
      <url>/2019/12/31/2019/</url>
      
        <content type="html"><![CDATA[<p>现在是2019年12月31日19:39，在寝室总结一下这一年</p><p>坐在这里 又突然想不到今年做了些什么。只是突然觉得，19年过去了，大家都在总结，狂欢。。。我在（盲目跟风？</p><p>其实也没什么，希望下一年考试不会挂科，在尽量拿几个牌子。</p><p>奔三了！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The 10th Henan Polytechnic University Programming Contest</title>
      <link href="/2019/12/23/HPU10th/"/>
      <url>/2019/12/23/HPU10th/</url>
      
        <content type="html"><![CDATA[<p>我六点闹钟起床，来到机房又打了几个板子，复习了一下暑期集训的那些题。八点二十的时候去了比赛的机房，配好环境之后等着学长来发密码条。发到最后了发现没我的，然后才发现我坐错机房了。。。但是环境都配好了，我就去我该去的机房拿上了我的密码条回来了。九点开始的比赛，因为种种原因，推到了九点十五。提前我已经把板子打好了。比赛开始前半分钟，题面压缩包的密码告诉了我们，我打开题面看了一眼A，就是一个输出。直接puts就行。毫无疑问，我A题0罚时拿了一血（全场最水最没有意义的一个一血。A过了之后，我就往下看题了，感觉B可以写，但是抱着先把题看完的心态，往下把题看完了。最后还是准备写B，B我怎么算复杂度都是1e7的复杂度，敲完之后，我看还没人交，以为自己又要有个一血，然后TLE？？？当时脑袋里就嗡嗡的。完了，T了。这时候榜单上有人过了G。我去看了一眼G，就是统计一个数中圈的个数。题面上有一句是这样的<code>8 has 2 cycles</code>，我看成了8和2都有两个圈（微笑。然后WA了两次，过了之后，名次已经排到后后面了，因为他们都没有罚时，而我已经有了3*20了。然后我看B有人过了，我还是很懵，1e7怎么可能会T？然后我忘了怎么改了一下，交了一发，这次是WA了。那时候心态是真的崩了。然后我又是关同步流，又是O2，O3优化的，又叫了一发，果然又T了。我想不能在一棵树上吊死，开了个新题F。F每啥，就是个大模拟，很快的敲出来之后我交了一发，WA了？？？我惊了。然后我又是各种读题，各种给自己试样例，改了一次交了次，WA，呵呵。榜单上有人过了D，我就先把F放了放去看D，看了一眼D，有思路但是不会写，就又回去改F了，F让我很不爽，关键是你就不知道哪错了。这时候，我在榜单上面排42名，银牌区都掉出来了亲。有一种鼠标一摔键盘一摔直接走的冲动。但是我忍住了。F又改了一发交了上去，又WA。我扭头就去写D，然后D过了。这时候一个<code>correct</code>的出现的感觉就像是久旱逢甘霖。我突然想起来B是不是在卡cin（关同步流也没用的那种），我又回去改B，弃用string，改用char数组。然后把strlen写在了外面，试了试没问题就交了。距离我交上去了一分钟多了，还在判，我想着，哦，又要T了。但是我怎么算都是1e7，这道题还是2s怎么会T呢？？？万念俱灰的时候，过了。它过了，鬼知道是在卡cin还是多计算的字符串长度，我笑了。B过了之后，我松了一口气。去上了个厕所，回来之后发现F也有人过了，我的一血也不会有了，但我还是准备写F，找不到bug我就重写，换着方式模拟，改了两次之后，WA了两次之后，过了。然后发现有人过了E，这道题我一开始就看了，感觉是个dp，但是过的人不少，我想着应该有简单的方法。然后就胡乱的敲了一个代码，样例过了之后就交了，然后就过了？？？（后来听题解的时候才知道，正解确实是dp，但是这个题选的摩斯密码，它很特殊，直接输出字符串长度/2就是答案）23333。现在我已经六题了。但是罚时爆炸。我看好几个7题的人都是过了J。然后我就去看J。这个题吧，卡了我将近三个小时。暴力我想不到怎么写，寄希望于是个有规律的数列，BM板子都抄了一边，O(n^3)的跑了前200项放到BM里面，WA。显然这不是有规律的数列，但是过的人那么多，我到最后都没过。最后听了题解才知道就是一道暴力的题，但是有优化。总的来说，题目还是很不错的，就是我太菜了。<br>最后抽奖环节也没抽到奖（六十几个人抽十个都抽不到的运气）。最终排名第10，没有滚出金牌区，好羡慕前面的人，奖金巨多，可是跟我并没有什么瓜西 。<br>期待了好久，担心了好久的校赛终于是安然的结束了。虽然名次不太理想，但是我知道我也就这个水平了，嘿嘿。接下来就该好好复习了呢，马上就是一大堆的考试。加油吧，少年。</p><p>补一下J题吧。<br>Link: <a href="https://hpuoj.com/contest/32/problem/J/" target="_blank" rel="noopener">HPU&#39;s birthday</a><br>Problem solving:<br>因为1e5的二进制才不到32位，所以可以构建出来最后的那个字符串进行遍历。<br>边遍历边统计1出现的次数（x），每次遇见0的时候，就相当于在已经出现的1里面选两个，方案数就是x*(x-1)/2，按照这个规则遍历完，每次累加即可。<br>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1e9 + 7;int main(){    long long n, x;    cin &gt;&gt; n;    while (n--)    {        cin &gt;&gt; x;        long long        mid = 0, ans = 0;        bitset&lt;64&gt; b(x);        string     s = b.to_string().substr(b.to_string().find_first_not_of(&#39;0&#39;));        string     t;        for (long long i = 0; i &lt; x; i++)            t += s;        for (long long i = 0; i &lt; t.size(); i++)        {            mid += (t[i] == &#39;1&#39;);            if (t[i] == &#39;0&#39;)            {                ans += mid * (mid - 1) / 2 % mod;            }        }        cout &lt;&lt; ans%mod &lt;&lt; endl;    }    return 0;}</code></pre><p>最后放上我的domjudge首页吧<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/HPU10-1.webp" data-fancybox="images" data-caption="domjudge" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/HPU10-1.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客小白月赛20 A 斐波那契</title>
      <link href="/2019/12/21/nowcoder3282A/"/>
      <url>/2019/12/21/nowcoder3282A/</url>
      
        <content type="html"><![CDATA[<p>Link:<a href="https://ac.nowcoder.com/acm/contest/3282/A" target="_blank" rel="noopener">斐波那契</a></p><p><center>斐波那契</center><br>Description:<br>Keven 特别喜欢斐波那契数列，已知,f[1]=f[2]=1,对于 n&gt;=3f[n]=f[n-2]+fib[n-1]<br>​并且他想知道斐波那契前n项平方和是多少？为了防止答案过大，请将最后的答案模1e9+7<br>输入描述:<br>第一行一个整数 n(1&lt;=n&lt;=1e18)</p><p>输出描述:<br>在一行中输出斐波那契数列的前n项平方和模 1e9+7</p><p>示例1<br>输入<br>5<br>输出<br>40<br>说明<br>1^2+^2+2^2+3^2+5^2=40</p><p>Problem solving:<br>我们可以推出来一个公式，然后直接矩阵快速幂就可以了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/nowcoder3282A-1.webp" data-fancybox="images" data-caption="公式" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/nowcoder3282A-1.webp" class="img-shadow img-margin"></center></a><br>但是这里我没用矩快，因为我了解到了一个更nb的算法——杜教BM<br>快速的解决解决线性递推求项<br>时间复杂度可以看这里:<a href="https://blog.csdn.net/Ike940067893/article/details/84781307" target="_blank" rel="noopener">https://blog.csdn.net/Ike940067893/article/details/84781307</a><br>这个记着板子就好了</p><p>Code:</p><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;using namespace std;#define rep(i, a, n)    for (int i = a; i &lt; n; i++)#define per(i, a, n)    for (int i = n - 1; i &gt;= a; i--)#define pb    push_back#define mp    make_pair#define all(x)          (x).begin(), (x).end()#define fi    first#define se    second#define SZ(x)           ((int) (x).size())typedef vector&lt;int&gt;      VI;typedef long long        ll;typedef pair&lt;int, int&gt;   PII;const ll mod = 1000000007;ll powmod(ll a, ll b){    ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1)    {        if (b &amp; 1)            res = res * a % mod;        a = a * a % mod;    }    return res;}// headint _;ll  n;namespace linear_seq {const int   N = 10010;ll          res[N], base[N], _c[N], _md[N];vector&lt;int&gt; Md;void mul(ll *a, ll *b, int k){    rep(i, 0, k + k) _c[i] = 0;    rep(i, 0, k) if (a[i])        rep(j, 0, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod;    for (int i = k + k - 1; i &gt;= k; i--)        if (_c[i])            rep(j, 0, SZ(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod;    rep(i, 0, k) a[i] = _c[i];}int solve(ll n, VI a, VI b) // a 系数 b 初值 b[n+1]=a[0]*b[n]+...{                           //        printf(&quot;%d\n&quot;,SZ(b));    ll  ans = 0, pnt = 0;    int k = SZ(a);    assert(SZ(a) == SZ(b));    rep(i, 0, k) _md[k - 1 - i] = -a[i]; _md[k] = 1;    Md.clear();    rep(i, 0, k) if (_md[i] != 0)        Md.push_back(i);    rep(i, 0, k) res[i] = base[i] = 0;    res[0]              = 1;    while ((1ll &lt;&lt; pnt) &lt;= n)        pnt++;    for (int p = pnt; p &gt;= 0; p--)    {        mul(res, res, k);        if ((n &gt;&gt; p) &amp; 1)        {            for (int i = k - 1; i &gt;= 0; i--)                res[i + 1] = res[i];            res[0]                       = 0;            rep(j, 0, SZ(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod;        }    }    rep(i, 0, k) ans = (ans + res[i] * b[i]) % mod;    if (ans &lt; 0)        ans += mod;    return ans;}VI BM(VI s){    VI  C(1, 1), B(1, 1);    int L = 0, m = 1, b = 1;    rep(n, 0, SZ(s))    {        ll d = 0;        rep(i, 0, L + 1) d = (d + (ll) C[i] * s[n - i]) % mod;        if (d == 0)            ++m;        else if (2 * L &lt;= n)        {            VI T = C;            ll c = mod - d * powmod(b, mod - 2) % mod;            while (SZ(C) &lt; SZ(B) + m)                C.pb(0);            rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod;            L                         = n + 1 - L; B = T; b = d; m = 1;        }        else        {            ll c = mod - d * powmod(b, mod - 2) % mod;            while (SZ(C) &lt; SZ(B) + m)                C.pb(0);            rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod;            ++m;        }    }    return C;}int gao(VI a, ll n){    VI c = BM(a);    c.erase(c.begin());    rep(i, 0, SZ(c)) c[i] = (mod - c[i]) % mod;    return solve(n, c, VI(a.begin(), a.begin() + SZ(c)));}};int main(){    scanf(&quot;%lld&quot;, &amp;n);    long long a = linear_seq::gao(VI{ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 }, n - 1);    long long b = linear_seq::gao(VI{ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 }, n);    printf(&quot;%lld\n&quot;, (a * b) % mod);}</code></pre><p>推导过程：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/nowcoder3282A-2.webp" data-fancybox="images" data-caption="过程" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/nowcoder3282A-2.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
            <tag> BM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 78 (Rated for Div. 2) D. Segment Tree</title>
      <link href="/2019/12/20/cfedu78D/"/>
      <url>/2019/12/20/cfedu78D/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1278/problem/D" target="_blank" rel="noopener">D. Segment Tree</a></p><p><center>D. Segment Tree</center><br>Description:<br>As the name of the task implies, you are asked to do some work with segments and trees.</p><p>Recall that a tree is a connected undirected graph such that there is exactly one simple path between every pair of its vertices.</p><p>You are given n segments [l1,r1],[l2,r2],…,[ln,rn], li&lt;ri for every i. It is guaranteed that all segments&#39; endpoints are integers, and all endpoints are unique — there is no pair of segments such that they start in the same point, end in the same point or one starts in the same point the other one ends.</p><p>Let&#39;s generate a graph with n vertices from these segments. Vertices v and u are connected by an edge if and only if segments [lv,rv] and [lu,ru] intersect and neither of it lies fully inside the other one.</p><p>For example, pairs ([1,3],[2,4]) and ([5,10],[3,7]) will induce the edges but pairs ([1,2],[3,4]) and ([5,7],[3,10]) will not.</p><p>Determine if the resulting graph is a tree or not.</p><p>Input<br>The first line contains a single integer n (1≤n≤5⋅1e5) — the number of segments.</p><p>The i-th of the next n lines contain the description of the i-th segment — two integers li and ri (1≤li&lt;ri≤2n).</p><p>It is guaranteed that all segments borders are pairwise distinct.</p><p>Output<br>Print &quot;YES&quot; if the resulting graph is a tree and &quot;NO&quot; otherwise.</p><p>Examples<br>input<br>6<br>9 12<br>2 11<br>1 3<br>6 10<br>5 7<br>4 8<br>output<br>YES<br>input<br>5<br>1 3<br>2 4<br>5 9<br>6 8<br>7 10<br>output<br>NO<br>input<br>5<br>5 8<br>3 6<br>2 9<br>7 10<br>1 4<br>output<br>NO</p><p>Problem solving:<br>这道题的意思就是给你n个线段，并且告诉你这n个线段的左右端点。如果有两条线段相交，且不是一条线段完全属于另一条，这两个线段代表的顶点之间就会有一条边。问你最后生成的图是不是一颗树。<br>需要判断线段是否相交才能知道哪两个点之间有边，但是直接暴力判断肯定会超时。所以我们可以通过一些策略和stl的使用大大提升效率。<br>直接用pair存线段的左右端点然后sort，默认按照first也就是左端点从小到大排序。排序之后，从小到大遍历，一条边一条边的往里面加，我们用map，边存已经可以用的线段的右端点，边存这个线段代表的端点。每一次加入一条新的线段，在map中的key中查找是否存在大于新的线段的左端点的值。如果没有直接break，加入下一条边。找到之后判断这个值跟新加入的线段的右端点的值比较，如果大于，也直接break，因为在map中我们存的就是右端点的值。并且map默认是按照key的升序存储的，如果当前已经大了，后面的就都不需要判断了。如果出现了满足条件的，判断这两个点的父节点是否相同，如果已经相同了，还满足条件，再加上就会出现环，直接输出no即可。然后与这一条新加入的线段满足条件的所有线段都处理完之后，这条新线段的右端点以及代表的顶点存入map即可。如果最后还没有出现环，判断所有的点的父节点是不是一个即可。如果不是，直接输出NO。最后，如果还没有退出，就输出YES。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;#define pil    pair&lt;int, int&gt;#define f      first#define  s     secondconst int     maxn = 1e6 + 10;int           n, f[maxn];pil           p[maxn];map&lt;int, int&gt; pos;int find(int x){    return f[x] != x ? f[x] = find(f[x]) : x;}int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)        cin &gt;&gt; p[i].f &gt;&gt; p[i].s, f[i] = i;    sort(p, p + n);    for (int i = 0; i &lt; n; i++)    {        int mid = p[i].f;        while (true)        {            auto it = pos.upper_bound(mid);            if (it == pos.end() || it-&gt;f &gt; p[i].s)                break;            int p = i, q = it-&gt;s;            if (find(p) == find(q))            {                cout &lt;&lt; &quot;NO\n&quot;;                return 0;            }            mid        = it-&gt;f;            f[find(p)] = find(q);        }        pos[p[i].s] = i;    }    for (int i = 0; i &lt; n; i++)    {        if (find(i) != find(0))        {            cout &lt;&lt; &quot;NO\n&quot;;            return 0;        }    }    cout &lt;&lt; &quot;YES\n&quot;;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> dsu </tag>
            
            <tag> tree </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 78 (Rated for Div. 2) C. Berry Jam</title>
      <link href="/2019/12/20/cfedu728c/"/>
      <url>/2019/12/20/cfedu728c/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1278/problem/C" target="_blank" rel="noopener">C. Berry Jam</a></p><p><center>C. Berry Jam</center><br>Description:<br>Karlsson has recently discovered a huge stock of berry jam jars in the basement of the house. More specifically, there were 2n jars of strawberry and blueberry jam.</p><p>All the 2n jars are arranged in a row. The stairs to the basement are exactly in the middle of that row. So when Karlsson enters the basement, he sees exactly n jars to his left and n jars to his right.</p><p>For example, the basement might look like this:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/cfedu78C-0.webp" data-fancybox="images" data-caption="Drew" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/cfedu78C-0.webp" class="img-shadow img-margin"></center></a><br>Being the starightforward man he is, he immediately starts eating the jam. In one minute he chooses to empty either the first non-empty jar to his left or the first non-empty jar to his right.</p><p>Finally, Karlsson decided that at the end the amount of full strawberry and blueberry jam jars should become the same.</p><p>For example, this might be the result:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/cfedu78C-1.webp" data-fancybox="images" data-caption="Drew" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/cfedu78C-1.webp" class="img-shadow img-margin"></center></a><br>He has eaten 1 jar to his left and then 5 jars to his right. There remained exactly 3 full jars of both strawberry and blueberry jam.<br>Jars are numbered from 1 to 2n from left to right, so Karlsson initially stands between jars n and n+1.</p><p>What is the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left?</p><p>Your program should answer t independent test cases.</p><p>Input<br>The first line contains one integer t (1≤t≤1000) — the number of test cases.</p><p>The first line of each test case contains a single integer n (1≤n≤1e5).</p><p>The second line of each test case contains 2n integers a1,a2,…,a2n (1≤ai≤2) — ai=1 means that the i-th jar from the left is a strawberry jam jar and ai=2 means that it is a blueberry jam jar.</p><p>It is guaranteed that the sum of n over all test cases does not exceed 1e5.</p><p>Output<br>For each test case print the answer to it — the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left.</p><p>Example<br>input<br>4<br>6<br>1 1 1 2 2 1 2 1 2 1 1 2<br>2<br>1 2 1 2<br>3<br>1 1 1 1 1 1<br>2<br>2 1 1 1<br>output<br>6<br>0<br>6<br>2<br>Note<br>The picture from the statement describes the first test case.</p><p>In the second test case the number of strawberry and blueberry jam jars is already equal.</p><p>In the third test case Karlsson is required to eat all 6 jars so that there remain 0 jars of both jams.</p><p>In the fourth test case Karlsson can empty either the second and the third jars or the third and the fourth one. The both scenarios will leave 1 jar of both jams.</p><p>Problem solving:<br>这道题的意思就是你现在在中间，左边有n瓶果酱，右边有n瓶果酱。有两种不同的果酱，你可以从中间往两边选果酱吃，问你最少选几次可以让剩下的两种果酱的数量相等。<br>因为只有两种果酱，所以我们可以用1和-1表示。 然后维护一个前缀和数组，这个数组中的值就可以代表前i个果酱里面有几个是多余的（即大于另一个果酱的个数）因为是要从中间开始往两边吃。所以我们对n左右分别考虑。对左边存储每一个数出现的最后一个位置，用map存一下。然后再看n右边，用当前位置的前缀和数组的值减去最后一个位置的值（这个算出来的就是当前位置到最后距离两种果酱数量相等还差几个以及哪种果酱，1和-1表示）。如果这个值在前面出现过，说明有一种满足要求的情况出现。此时答案就是（i-map[a[i]]），因为这里还需要对0初始化为0，所以需要用到map中的find，然后每次更新答案最小值即可。</p><p>说不一定能说清，解释一下样例可能会清楚一点</p><pre><code class="lang-txt">2  1 | 1 1-1 1 | 1 1-1 0   1 2mid=a[i]-a[2*n],ans=1e9i=2 mid=-2 find=endi=3 mid=-1 find!=end  ans=min(ans,i-map[a[i]])=2i=4 mid=0  find!=end  ans=min(ans,i-map[a[i]])=2ans=2</code></pre><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;int       a[maxn];int main(){    int t, n;    cin &gt;&gt; t;    while (t--)    {        cin &gt;&gt; n;        map&lt;int, int&gt; ma;        ma[0] = 0;        int           ans = 1e9;        for (int i = 1, x; i &lt;= 2 * n; i++)        {            cin &gt;&gt; x;            a[i]  = (x == 1 ? 1 : -1);            a[i] += a[i - 1];            if (i &lt;= n)                ma[a[i]] = i;        }        for (int i = n; i &lt;= 2 * n; i++)        {            int x = a[i] - a[2 * n];            if (ma.find(x) != ma.end())                ans = min(ans, i - ma[x]);        }        cout &lt;&lt; ans &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> Greedy </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019icpc-ecfinal西安游记</title>
      <link href="/2019/12/17/ecfinal/"/>
      <url>/2019/12/17/ecfinal/</url>
      
        <content type="html"><![CDATA[<p>机缘巧合下，有机会参加2019.12.14-15的在西北工业大学举办的ecfinal。<br>我第一次出去，就是去的<a href="https://www.cndrew.cn/2019/05/22/ICPC-Invitational-in-Xi&#39;an/" target="_blank" rel="noopener">西工大的邀请赛</a>，今年应该是最后一次出去了吧，也是西工大。还是，有点巧的。<br>因为14号正好要考四六级，所以我和两个学长是14号晚上走的。听他们正常时间去的人说，第一天有好几个企业的讲座。会送好多礼物，比如说手办，公仔，悠悠球什么的，可是这跟我并没有什么瓜西，感觉错亿啊。14号晚上坐城际到郑州然后转硬卧去西安。到了西安的时候是早上五点左右。我们准备先吃点早饭，我们深知在火车站附近吃饭会被宰，可是实在是找不到别的地方的店了，最后还是对肚子屈服了。随便找了一家店，我花了七块钱吃了可能有半个馒头？（说是包子，小，还没多少馅）。有一个学长，喝了一碗胡辣汤，十块钱。果然不是我能消费的起的2333。<br>我们吃完饭之后，就得赶紧赶公交去学校了，是真的远。我们坐了大概有两个多小时的公交，还转了一次，第二次公交从起点基本坐到了终点。不过还好赶到学校的时候才八点二十。队友给我们也准备了早餐，一杯豆浆和馍夹菜（还是很暖心的）。吃完饭之后，比赛就开始了。我这次的队友，依旧很强。oi爷和qg，强就完事了。一开始我看E的气球颜色很鲜艳，以为是签到，直接就去看了。看了之后发现跟最大流什么的有关，果断换题。突然看见了A看起来很简单的样子，没看一会，A已经有人过了。然后我们仨一起看A，看懂之后我跟qg找了会规律，正找着呢，oi爷过了。然后oi爷说E有思路，就去敲E了。我跟qg看M，然后我看了假题意，直接贡献了两罚时（这可能是我唯一的贡献了，还是负的233）.然后oi爷看了看M，敲了一会，过了。然后我们能开的题就剩E和H了。H我跟qg看了好久都没思路，oi爷也一直在写E。比赛还有四分钟的时候，oi爷提交了好多次修改之后的代码。但是最后那会的提交会pending好久，直到比赛结束我们都没看到结果（对自己封榜？）。然后我们没急着走，等了一会，看到了绿色，oi爷又过了。<br>闭幕仪式，怎么说呢，企业宣讲讲了好久，各种公司各种讲。主持人说，domjudge出bug了。不能滚榜了（实际上我觉得是宣讲占用了太多时间没时间滚了吧）。还没有讲题。领了我们的铜牌就提前走了。oi爷带我们拿了一个铜，真的太强了。<br>坐着学校送站的车，到了一个地铁口，跟邀请赛送的地方都是一样的。那时候才五点多快六点的样子，我们考虑去哪玩。最后决定我也不知道是啥，跟着走就完事了。然后各种转地铁，出来之后，学长带我们去吃了biang biang面。还挺好吃，就是没吃饱。大家都累了，就准备在饭馆休息一会。休息完之后我们又出发了。这次似乎是说要去回民街，跟着走就完事了，然后就真的只跟着走了，对没错，我们走了一晚上，一晚上。好像是导航导错了。然后坐上十一点的火车就会来学校了。<br>这次出去比赛发了一件蓝色的拉链卫衣，和一个灰色的书包，还是很舒服的。这个书包好像每年ecfinal都会发，之前看到学长的就很羡慕，现在我也有了233。虽然这次还拿到了牌子，但是可是说是跟我没什么关系，因为我的贡献只有那两罚时而已Orz。感谢oi爷和强哥带飞。<br>这基本上就是今年最后一次出去了，马上也就该期末考试了，好好复习！</p><center><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/ecfinal.webp" data-fancybox="images" data-caption="牌子" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/ecfinal.webp" class="img-shadow img-margin"></center></a></center>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构中的排序方式（堆,简单选择,快速,冒泡,希尔,折半插入,直接插入）</title>
      <link href="/2019/12/09/px/"/>
      <url>/2019/12/09/px/</url>
      
        <content type="html"><![CDATA[<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;const int maxn = 1e6 + 10;int       a[maxn];int main(){    // freopen(&quot;10000.txt&quot;, &quot;r&quot;, stdin);    for (int i = 1; i &lt;= 10000; i++)        cin &gt;&gt; a[i];    clock_t start, finish;    double  Total_time;    start = clock();    for (int i = 2, j; i &lt;= 10000; i++)    {        if (a[i] &lt; a[i - 1])        {            a[0] = a[i];            a[i] = a[i - 1];            for (j = i - 2; a[0] &lt; a[j]; j--)                a[j + 1] = a[j];            a[j + 1] = a[0];        }    }    finish     = clock();    Total_time = (double) (finish - start) / CLOCKS_PER_SEC;    cout &lt;&lt; Total_time &lt;&lt; endl;    // for (int i = 1; i &lt;= 100; i++)    //     cout &lt;&lt; a[i] &lt;&lt; endl;}</code></pre><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;const int maxn = 1e6 + 10;int       a[maxn];int main(){    // freopen(&quot;1000000.txt&quot;, &quot;r&quot;, stdin);    for (int i = 1; i &lt;= 1000000; i++)        cin &gt;&gt; a[i];    clock_t start, finish;    int     low, high, m;    double  Total_time;    start = clock();    for (int i = 2, j; i &lt;= 1000000; i++)    {        a[0] = a[i];        low  = 1, high = i - 1;        while (low &lt;= high)        {            m = (low + high) / 2;            if (a[0] &lt; a[m])                high = m - 1;            else                low = m + 1;        }        for (int j = i - 1; j &gt;= high + 1; j--)            a[j + 1] = a[j];        a[high + 1] = a[0];    }    finish     = clock();    Total_time = (double) (finish - start) / CLOCKS_PER_SEC;    cout &lt;&lt; Total_time &lt;&lt; endl;    // for (int i = 1; i &lt;= 100000; i++)    //     cout &lt;&lt; a[i] &lt;&lt; endl;}</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;const int maxn = 1e6 + 10;int       a[maxn], dt[4] = { 1, 3, 5 };void solve(int dk){    for (int j, i = dk + 1; i &lt;= 1000000; i++)    {        if (a[i] &lt; a[i - dk])        {            a[0] = a[i];            for (j = i - dk; j &gt; 0 &amp;&amp; a[0] &lt; a[j]; j -= dk)            {                a[j + dk] = a[j];            }            a[j + dk] = a[0];        }    }}int main(){    // freopen(&quot;1000000.txt&quot;, &quot;r&quot;, stdin);    for (int i = 1; i &lt;= 1000000; i++)        cin &gt;&gt; a[i];    clock_t start, finish;    int     low, high, m;    double  Total_time;    start = clock();    for (int k = 0; k &lt; 3; k++)        solve(dt[k]);    finish     = clock();    Total_time = (double) (finish - start) / CLOCKS_PER_SEC;    cout &lt;&lt; Total_time &lt;&lt; endl;    // for (int i = 1; i &lt;= 100; i++)    //     cout &lt;&lt; a[i] &lt;&lt; endl;}</code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;const int maxn = 1e6 + 10;int       a[maxn];int main(){    // freopen(&quot;1000000.txt&quot;, &quot;r&quot;, stdin);    for (int i = 1; i &lt;= 1000000; i++)        cin &gt;&gt; a[i];    clock_t start, finish;    double  Total_time;    start = clock();    int     m = 1000000 - 1, flag = 1;    while ((m &gt; 0) &amp;&amp; (flag == 1))    {        flag = 0;        for (int j = 1; j &lt;= m; j++)            if (a[j] &gt; a[j + 1])            {                swap(a[j], a[j + 1]); flag = 1;            }        m--;    }    finish     = clock();    Total_time = (double) (finish - start) / CLOCKS_PER_SEC;    cout &lt;&lt; Total_time &lt;&lt; endl;    // for (int i = 1; i &lt;= 100; i++)    //     cout &lt;&lt; a[i] &lt;&lt; endl;}</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;const int maxn = 1e6 + 10;int       a[maxn];int solve(int low, int high){    a[0] = a[low];    int mi = a[low];    while (low &lt; high)    {        while (low &lt; high &amp;&amp; a[high] &gt;= mi)            high--;        a[low] = a[high];        while (low &lt; high &amp;&amp; a[low] &lt;= mi)            low++;        a[high] = a[low];    }    a[low] = a[0];    return low;}void Qsort(int low, int high){    if (low &lt; high)    {        int mid = solve(low, high);        Qsort(low, mid - 1);        Qsort(mid + 1, high);    }}int main(){    // freopen(&quot;1000000.txt&quot;, &quot;r&quot;, stdin);    for (int i = 1; i &lt;= 1000000; i++)        cin &gt;&gt; a[i];    clock_t start, finish;    double  Total_time;    start = clock();    Qsort(1, 1000000);    finish     = clock();    Total_time = (double) (finish - start) / CLOCKS_PER_SEC;    cout &lt;&lt; Total_time &lt;&lt; endl;    // for (int i = 1; i &lt;= 100; i++)    //     cout &lt;&lt; a[i] &lt;&lt; endl;}</code></pre><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;const int maxn = 1e6 + 10;int       a[maxn];int main(){    // freopen(&quot;100.txt&quot;, &quot;r&quot;, stdin);    for (int i = 1; i &lt;= 1000000; i++)        cin &gt;&gt; a[i];    clock_t start, finish;    double  Total_time;    start = clock();    for (int i = 1; i &lt; 1000000; i++)    {        int k = i;        for (int j = i + 1; j &lt;= 1000000; j++)            if (a[j] &lt; a[k])                k = j;        if (k != i)        {            swap(a[i], a[k]);        }    }    finish     = clock();    Total_time = (double) (finish - start) / CLOCKS_PER_SEC;    cout &lt;&lt; Total_time &lt;&lt; endl;    // for (int i = 1; i &lt;= 100; i++)    //     cout &lt;&lt; a[i] &lt;&lt; endl;}</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;const int maxn = 1e6 + 10;int       a[maxn];void solve(int s, int m){    int rc = a[s];    for (int j = 2 * s; j &lt;= m; j *= 2)    {        if (j &lt; m &amp;&amp; a[j] &lt; a[j + 1])            j++;        if (rc &gt;= a[j])            break;        a[s] = a[j]; s = j;    }    a[s] = rc;}int main(){    // freopen(&quot;10000.txt&quot;, &quot;r&quot;, stdin);    for (int i = 1; i &lt;= 1000000; i++)        cin &gt;&gt; a[i];    clock_t start, finish;    double  Total_time;    start = clock();    for (int i = 1000000 / 2; i &gt; 0; i--)        solve(i, 1000000);    for (int i = 1000000; i &gt; 1; i--)    {        int x = a[1];        a[1] = a[i];        a[i] = x;        solve(1, i - 1);    }    finish     = clock();    Total_time = (double) (finish - start) / CLOCKS_PER_SEC;    cout &lt;&lt; Total_time &lt;&lt; endl;    // for (int i = 1; i &lt;= 100; i++)    //     cout &lt;&lt; a[i] &lt;&lt; endl;}</code></pre><p>这是对不同数量级的数据进行时间测试的结果，数据具有偶然性，仅供参考<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/pxx.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/pxx.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Discrete mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> DS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们这一辈最大的姐，她结婚了</title>
      <link href="/2019/12/04/xhkl/"/>
      <url>/2019/12/04/xhkl/</url>
      
        <content type="html"><![CDATA[<p>我们家，亲戚很多。每家都有很多孩子，逢年过节的都会很热闹。<br>我们这一辈有大约五个人。我，我亲姐，我表姐，我表弟，我表妹。我们年龄没有差多少，所以都是从小一起玩到大的。关系很好，特别好的那种。<br>在学校听说，那个表姐要结婚了，我直接找辅导员请了三天假，周末踏上了回家的客车，我姐结婚，我必须得去。我告诉自己。（顺便正好回家看看<br>因为是周六中午临时决定的坐客车回家，那班车是1点50发车，我1点从寝室跑出来跑到院楼机房，跑回去赶上一辆小白，然后赶上一班公交。到了车站的时候才1点半。很累，但是心里很开心，因为要回家了。<br>这客车，它贼慢。路上睡睡玩玩手机也就过去了。到我们那车站的时候已经六点了。我穿的不厚，冻着我了。回到家，在家洗了澡，晚上跟我爸妈玩了会“挤黑五”就睡了。周日自己在家玩了一天没啥好说的。周一早上我到了我要结婚的姐姐家。<br>农村结婚，在外面支的大锅做大锅饭吃。周一上午跟我那个表弟和表妹玩了一会（我的表弟和要结婚的那个表姐是亲兄弟）。长时间的分离，一开始还是会有一些生疏感的。但是慢慢的就没了。<br>中午吃的捞面条，挺好吃的。下午他们给我们几个分配了任务——吹气球，贴气球。我们需要把我姐的屋子装饰一下。都忙完的时候已经晚上了。晚上吃的熬菜，也很好吃，吃的很饱。<br>到了九点多的时候，大家都说要早点睡了，我跟我表弟睡一起。他们说要订外卖就一起顶了外卖。临睡觉前，我问我表弟：明天你姐就嫁人了，心里就没有什么感触吗？他跟我说没啥感觉。但是我心里是有点不舒服的，虽然不是我亲姐，但是一想到来他们家看不到我姐，心里就很不舒服。<br>第二天一早就起床了，跟我表弟和一个表哥一起去往接新娘的婚车要经过的路上贴红纸（习俗），红纸很好看，但是温度真的很低，冻得我两手通红。贴完纸吃了饭，就在家里等男方来接了。这个时候伴娘和新娘已经在屋里面堵好了门，准备“闹”一下新郎。我表弟跟我说，心里突然有点不舒服，说不上来为什么。大约十点半的时候，婚车来了。新郎和伴郎来接新娘了，他们在闹，我不是很喜欢热闹就在最后面看着，跟我表弟一起。旁边就是我老舅的卧室。我看到我老舅和几个不认识的亲戚在里面坐着，只是抽烟，也不说话。一开始也没多想。<br>后来新娘被接出来，摄影师说你们一家拍个照吧。然后我老舅，妗，表弟，表姐，表姐夫，他们拍了张照，拍完之后，我老舅直接就往我市走，我正好在路上，看到了他眼眶湿了。当我看到我老舅泪湿了眼眶的时候，我也情不自禁地红了眼圈。我表弟这个时候已经泣不成声了。关于他们的眼泪，我想，一部分应该是感动，但一大部分应该是不舍吧。一起生活了二十余年的女儿（姐姐）走了，去别人家了。而我的眼泪，一部分是“兔死狐悲”的忧伤，我姐也总会有一天嫁出去，那时候我可能比我表弟还要狼狈吧。一部分是看到了在我旁边坐着的爸，他心里也不好受。虽然说结婚是一件喜事，但是结婚也就意味着离别，离别就意味着伤感，即使你能结婚之后天天往家跑，那也不一样了。<br>我是送嫁妆的，做的是我一个姐夫的车。在车上，我抱着我姐的嫁妆我想了好多，想了别人的事，家里的事，还有，自己的事。<br>我也不敢说是我长大了，感觉看透了好多东西，反正是好多事都放下了，看的没那么重了。我也不会再处在那个渣女的阴影下了，我也不会骂她了。自我感觉也少了很多戾气。挺好的，这次请假回来玩了三天，也玩够了。好好复习，好好代码！加油<br>最后回到主题，祝我姐新婚快乐，百年好合！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧文五（捕蝇草）如何系鞋带——视频教学</title>
      <link href="/2019/11/28/irv5/"/>
      <url>/2019/11/28/irv5/</url>
      
        <content type="html"><![CDATA[<p>前一段时间给自己的欧文五黑金洗了一下，把鞋带都拆下来了。其实我拆到一半的时候还在想会不会穿不回去了，但是既然拆了就拆完吧，车到山前必有路。<br>然后我就凉了，鞋干了之后，穿了好几次都没成功把鞋带穿进去。在网上搜了一下，框框里面刚输入欧文五，就出来了怎么系鞋带。（笑死了有没有</p><p>应该是我脑子笨，看不懂网上的详细的讲解。自己摸索了好久好久，终于是穿好了鞋带。</p><p>首先你要把捕蝇草上面的那个线从斜面上的那个线中间从外到内插过去<br>然后穿回捕蝇草的小孔里面穿出来。<br>描述的话会很抽象，所以我专门录了个视频，因为都是一样的，所以我就录了最下面的那个，剩下的都这样弄就行。<br>我不知道是只有我的这样还是都是这样，最下面那个孔非常小，所以你可以用一只手指头把绳往上顶，然后用一个小指甲剪或者镊子一类的东西辅助一下。</p><p>直接上视频(推荐全屏观看)</p><video id="video" controls preload="none" poster="https://cdn.jsdelivr.net/gh/drew233/cdn/irv1.webp" width="700" height="450">      <source id="mp4" src="https://cdn.jsdelivr.net/gh/drew233/cdn/inv50.mp4" type="video/mp4">      </video><video id="video" controls preload="none" poster="https://cdn.jsdelivr.net/gh/drew233/cdn/irv2.webp" width="700" height="450">    <source id="mp4" src="https://cdn.jsdelivr.net/gh/drew233/cdn/inv51.mp4" type="video/mp4">    </video>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU-3118 Arbiter</title>
      <link href="/2019/11/26/hdu3118/"/>
      <url>/2019/11/26/hdu3118/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://acm.hdu.edu.cn/showproblem.php?pid=3118" target="_blank" rel="noopener">Arbiter</a></p><p><center>Arbiter</center><br>Arbiter is a kind of starship in the StarCraft science-fiction series. The Arbiter-class starship is a Protoss warship specializing in providing psychic support. Arbiters were crewed exclusively by Judicators; unlike other warships that were manned predominantly by Templar. The Judicator used the Arbiter as a base to provide support using space-time manipulation.<br>Arbiters could weaken space-time, tearing rifts in the fabric of space-time, creating a vortex linking another location to the Arbiter’s location. This could be used to move personnel over long distances between stars.<br>In the meantime of widely used Arbiter to transfer, KMXS, the captain of one Arbiter, was warning that some person had got a serious mental disorder after the trip on his Arbiter. By using mice as model animals, he found the sake, it’s because of chirality!<br>Every person has chirality, either left-handed or right-handed. Actually all the persons must live with the food which has the same chirality. When one person took Arbiter from one star to another one, his chirality will be changed (from left-handed to right-handed or from right-handed to left-handed). If a person took a long trip and finally got back to his own star, however, his chirality might be changed to the opposite state other than his original, which would cause fatal mental disorder, or even death.<br>KMXS has the channels map among the starts and he need to prohibit minimum number of channels from traveling so that wherever a person starts his traveling from when he gets his original star he’ll be safe. KMXS turns to your help.</p><p>Input<br>The first line of input consists of an integer T, indicating the number of test cases.<br>The first line of each case consists of two integers N and M, indicating the number of stars and the number of channels. Each of the next M lines indicates one channel (u, v) which means there is a bidirectional channel between star u and star v (u is not equal to v).</p><p>Output<br>Output one integer on a single line for each case, indicating the minimum number of channels KMXS must prohibit to avoid mental disorder.</p><p>Constraints<br>0 &lt; T &lt;= 10<br>0 &lt;= N &lt;= 15 0 &lt;= M &lt;= 300<br>0 &lt;= u, v &lt; N and there may be more than one channel between two stars.<br>Sample Input<br>1<br>3 3<br>0 1<br>1 2<br>2 0</p><p>Sample Output<br>1</p><p>Problem solving:<br>这道题的题意我没看。但是让你求的就是给你一个平凡图，问你最少需要删几条边使得图中没有奇环（即一个环是由奇数个边连起来的）。<br>上海站的那道题跟这个简直一模一样，枯了。</p><p>二分图，一个图是二分图的充要条件是图中所有的环都是偶环，全都是偶环也就是没有奇环。并且这个题目数据范围也不大，最多还不到16个点，所以我们可以使用二进制枚举来写。二进制位是0的是二分图的一边，是1的就是二分图的另一边，如果出现在同一边的两个点之间有一条边，删除即可。枚举每一种情况，16个点，2^16种情况，每次更新最小值即可。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;iostream&gt;using namespace std;const int maxn = 521;struct node{    int u, v;} a[maxn];int main(){    int t, n, m;    cin &gt;&gt; t;    while (t--)    {        int ans = 0x3f3f3f3f;        cin &gt;&gt; n &gt;&gt; m;        for (int i = 0; i &lt; m; i++)            cin &gt;&gt; a[i].u &gt;&gt; a[i].v;        for (int i = 0; i &lt; (1 &lt;&lt; n); i++)        {            int mid = 0;            for (int j = 0, u, v; j &lt; m; j++)            {                u = a[j].u, v = a[j].v;                if (((i &gt;&gt; u) &amp; 1) == ((i &gt;&gt; v) &amp; 1))                    mid++;            }            ans = min(ans, mid);        }        cout &lt;&lt; ans &lt;&lt; endl;    }    return 0;}</code></pre><p>反思一下：二分图和二进制枚举也不是没学过，不会使用，真的是自己的锅，以后加油！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> 二进制枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三傻打铁日记-2019ICPC上海站</title>
      <link href="/2019/11/25/icpcsh/"/>
      <url>/2019/11/25/icpcsh/</url>
      
        <content type="html"><![CDATA[<p>通过很激烈刺激(并不)的选拔赛我们队获得了去上海的机会。魔都？心里还是很激动的，挺期待。<br>终于等到了11月22号，我们是坐硬卧火车去，先要中转到郑州，我们一行人坐公交到车站，先去了郑州，然后坐上了去上海的火车。我们晚饭是需要在火车上解决的，提前就买好了。有泡面，辣条，馒头，火腿，还有真空包装的鸡腿。吃吃喝喝大家都挺开心的。吃完饭之后，洋佬他们拿出扑克牌玩了起来斗地主，我也没兴趣，加上晚上会有一场牛客的Rating赛，就没跟他们一起玩牌。七点了，我拿出来电脑，挤在小小的座位上，顺便提一下，我运气不错是下铺，他们在床上玩牌方便我就坐在过道上的座位打牛客。其实也不是多想打牛客，主要是为了抽奖和Rating233.牛客第一题是个dp，想了好久不知道怎么写，OI爷过了之后直接copy了他的代码，好，过了，哈哈哈哈哈。然后就开始看电影了，为了防止火车上无聊，我下载了三部电影，那天晚上看了两部。</p><p>我在很帅气(SB)的写题<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170218.jpeg" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170218.jpeg" class="img-shadow img-margin"></center></a></p><p>过了会他们也不打牌了，我也不想看电影了。我们就都准备睡了。那晚上睡得还是不错的，我属于那种怎么样都能睡着的人，他们说什么热了冷了我倒是没感觉到。</p><p>出来火车我们就直接转地铁了。不过刚出来车站就感觉到上海那边一点都不冷。</p><p>刚出站的景色<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170258.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170258.webp" class="img-shadow img-margin"></center></a></p><p>第一次还走错了方向，走对方向之后上了地铁。我们需要转两次线，大约坐了半个小时的地铁，我们到了距离宾馆最近的车站，因为学校周围的宾馆都订满了，所以我们定在了离学校两站远的宾馆。出来地铁站，走了一点多公里，到了我们的宾馆，（说实话我们这个宾馆跟想象中的差的有点多2333</p><p>去宾馆路上看到的上海的天空，我觉得像是油画一样，真的好看<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170440.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170440.webp" class="img-shadow img-margin"></center></a></p><p>到了宾馆大约才七点多，前台说现在还不能住，最晚是12点才可以。然后我们就把书包什么的放在了宾馆前台。跟着老师准备去吃饭，然后到学校报道去。</p><p>我在宾馆测量的身高体重<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170533.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170533.webp" class="img-shadow img-margin"></center></a></p><p>我们在宾馆周围转了一下，并没有发现有什么不错的早餐，就决定先去学校，然后看学校周围有什么好吃的没。到了学校发现学校周围并没有什么早餐，然后就决定先去报道吧。到了体育馆前面，我们先拍了照，就往里面走。那时也才七点多，人家说现在还不能报道，日程安排上写的确实是八点半报道。TAT。于是我们一行人准备去学校餐厅看一下，吃点东西。想着应该会支持支付宝微信的吧，没想到，只能刷人家学校的饭卡（或者是校园卡？我也不知道）。我们饿的顶不住了，也没地方吃饭，那会有点生无可恋的感觉。我们又拐回去体育馆，准备报道然后问问志愿者哪里可以吃早饭。我们拐回去的时候，已经开始报道了，虽然并没有到八点半。我们领了衣服，领了参赛手册，参赛牌等等一堆东西。从志愿者口中得知学校西门有小吃。然后我们就去了，一边逛着校园一边就到了，到了之后发现也没多少东西，进了一个粥店，我还没进去呢，前面的人就出来了，我问他们怎么回事，他们说一碗小米粥13，这可能是黄金小米吧。最后我吃了个鸡蛋煎饼？（鬼知道他们的“鸡蛋煎饼”为什么那么难吃），喝了一杯粥（他们的粥并不是现做的。是包装好的，成箱买的那种感觉），我再也不想吃这个饼了，我告诉自己。</p><p>吃完饭我们跟宾馆联系，人家说有三个房间空出来了，我们正好三个队伍，于是就准备先过去，一个队一间房先休息一下，坐车是真的累。然后我们骑着共享单车从学校出来，回去宾馆。他们学校校园里面也超美。但是我忘了拍照，只有这一张菊展的微笑.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170931.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125170931.webp" class="img-shadow img-margin"></center></a><p>我们回去宾馆，每个队伍一间房回去先休息了。<br>我从我的房间的窗户看到外面房顶有好几只特别可爱的小猫。</p><p>我们是有午餐的餐券的，中午十二点我们就集合准备去学校吃午饭了。还是共享单车，我们去到上海大学的水秀餐厅二楼，拿饭票换了饭吃。一份米，一块鱼肉，几个肉排，一盘豆腐。这就时我们的午饭。说实话这个午饭吃得并不舒服，提供的汤我就尝了一口整个人都不好了。多余的饭票也不能换饮料。不是很好吃也算是吃饱了，去体育馆准备热身赛，在开幕式看到了Kuangbin巨巨，跟想象中的不太一样，很帅。开幕式结束之后，过了会热身赛就开始了。电脑是Linux的，VsCode和Clion我们都用不好，只能退而求其次选择了CodeBlock。热身赛也就签了一道题，还因为交错文件WA了好几次。两个小时之后热身赛就结束了。</p><p>我们早就商量好热身赛结束后，去外滩或者别的地方转转。从我们比赛的上海大学到外滩大约是16公里，我跟我另一个队友——文哥！！！（也是一个贼强的队友）不是很想坐地铁。于是我们又了个大胆的想法，共享单车。所以结果就是，他们七个人坐地铁去，我们两个骑着共享单车去了。十六公里，其实也没有很远，我们两个一边骑着车一边聊着，一边欣赏路边的风景，一会就到了。中途跟着导航差点还有一次一起进了局子（没看清导航。这次骑行给我最大的印象就是上海的生活节奏真的很快，一辆辆电车从旁边飞速经过，未见其人先闻其声，电车上的电铃似乎都不够他们用一样。我跟我队友小心翼翼地生怕撞上。这天晚上回到宾馆的时候我里面穿的保暖衣已经湿透了，当然这是后话了，</p><p>沿途风景以及陪伴我们将近两个小时的共享单车<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125172748.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125172748.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125172822.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125172822.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125172900.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125172900.webp" class="img-shadow img-margin"></center></a><br>好看的地方真的很多，就不一一贴上来了。</p><p>我们到了外滩之后，看了黄浦江，看了东方明珠，跟他们七个人碰头之后找了个路人给我们拍了一张照片。涉及到隐私问题我就不贴了。</p><p>东方明珠<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125173212.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125173212.webp" class="img-shadow img-margin"></center></a></p><p>我们逛的差不多的时候就准备找地方吃饭了，外滩那边我们是真的不敢去吃，就决定先会去宾馆那一片。回去路上给我家喵喵在miniso里面买了一只柴犬的玩偶，手感是真的好，狗也是真的可爱，希望她喜欢。我们从地铁出来之后旁边正好有很多饭店，就找了一家吃了饭，我们点了菜，还有米有面。吃的挺饱的，吃完才知道，鸡蛋西红柿面13一碗，太秀了。</p><p>吃完之后就回宾馆了，洗澡，上床，打开电视看个电影，我跟狗就睡了。我依然睡得很舒服，但是他们好像是睡得有点晚了而且宾馆旁边就是KTV，声音有点大，他们睡得好像不怎么好。第二天早上我六点就起床了，洗漱之后，打开电视听了会歌，到了七点半跟大家集合去学校了。不知道为什么上大没有给我们发早餐券，宾馆也没有提供早饭，本来我们前一天晚上商量的是早上不吃了，买点小零食吃算了。但是大家又决定去西门吃点早饭。于是我们骑着贡献单车就去了，去的时候已经马上八点了。我要了两个叉烧，一杯豆浆，仍然是那种小饮料一样包装的盒子。还是常温的。一口一个叉烧，两三口一杯豆浆，我的早饭，就没了。等大家吃完之后已经八点二十二左右了，我们出来发现我们骑过来的共享单车已经没有了。一路上也没看见别的，不得不走回去了。走到体育馆的时候已经八点四十多了，比赛九点开始，上了个厕所就赶紧回去坐着了。等到九点一开始，我们就拆开试题册。开始了长达五个小时的阅读理解。。。关于正式赛，没啥好说的，最后差点爆零，一题垫底。</p><p>比赛结束之后，我们三个队两个队打铁，真的是没心情去参加闭幕式。就跟何不好准备去找个篮球场看看，发现人家室外的球场都收费，对不起，打扰了。我们回去之后发现他们都去参加闭幕式了，也就进去了，滚榜的时候确实很刺激，最后前四全被中学爷包揽，不过他们是打星队，排名第五的上交大捧杯，可是这跟我都没有什么关系，只能说2020年的清华北大新生是真的刘辟。</p><p>闭幕式结束之后我们准备在学校吃晚餐然后就去坐车。晚上的饭挺不错，我吃了两份，贼饱。<br>就在我们马上要离开这个伤心的地方的时候突然意识到，教练的那个袋子丢了，里面放着的三个教练杯子虽然不重要，但是邀请函在里面，我们报账需要用的，是我的锅，我们又跑回去体育馆找袋子，体育馆里面已经清干净了。我们又是问志愿者又是问老师的，最后袋子没找到，但是拿了几张多余的邀请函，也算是可以了。杯子丢了很心疼。</p><p>上海之旅就这样结束了，回来的时候路上还下了不大不小的雨。回到学校我倒头就睡，睡了一上午还是很舒服的，在外面睡觉真的不安稳。这次</p><p>出去过两次，都打铁了。真的应了那句话，电子竞技，菜是原罪。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125180159.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191125180159.webp" class="img-shadow img-margin"></center></a><br>但是我不怕，我还有一年时间，下次出去，我才不要打铁！！！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shortest Path on a Line</title>
      <link href="/2019/11/22/Atcoder5635/"/>
      <url>/2019/11/22/Atcoder5635/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://nikkei2019-2-qual.contest.atcoder.jp/tasks/nikkei2019_2_qual_d" target="_blank" rel="noopener">Shortest Path on a Line</a></p><p><center>Shortest Path on a Line</center><br>Problem solving:<br>We have N points numbered 1 to N arranged in a line in this order.</p><p>Takahashi decides to make an undirected graph, using these points as the vertices. In the beginning, the graph has no edge. Takahashi will do M operations to add edges in this graph. The i-th operation is as follows:</p><p>The operation uses integers Li and Ri between 1 and N (inclusive), and a positive integer Ci. For every pair of integers (s,t) such that Li≤s&lt;t≤Ri, add an edge of length Ci between Vertex s and Vertex t.<br>The integers L1,…,LM, R1,…,RM, C1,…,CM are all given as input.</p><p>Takahashi wants to solve the shortest path problem in the final graph obtained. Find the length of the shortest path from Vertex 1 to Vertex N in the final graph.</p><p>Constraints<br>2≤N≤1e5<br>1≤M≤1e5<br>1≤Li&lt;Ri≤N<br>1≤Ci≤1e9<br>Input<br>Input is given from Standard Input in the following format:</p><p>N M<br>L1 R1 C1<br>:<br>LM RM CM</p><p>Output<br>Print the length of the shortest path from Vertex 1 to Vertex N in the final graph. If there is no shortest path, print -1 instead.</p><p>Sample Input 1<br>4 3<br>1 3 2<br>2 4 3<br>1 4 6<br>Sample Output 1<br>5<br>We have an edge of length 2 between Vertex 1 and Vertex 2, and an edge of length 3 between Vertex 2 and Vertex 4, so there is a path of length 5 between Vertex 1 and Vertex 4.</p><p>Sample Input 2<br>4 2<br>1 2 1<br>3 4 2<br>Sample Output 2<br>-1<br>Sample Input 3<br>10 7<br>1 5 18<br>3 4 8<br>1 3 5<br>4 7 10<br>5 9 8<br>6 10 5<br>8 10 3<br>Sample Output 3<br>28</p><p>Problem solving:<br>这道题的意思是，给你n个节点，然后给你m组L，R，C。代表着从L到[L+1,R]内的任何一个节点都有一条权值为C的边，让你求从1到n的最短距离。</p><p>如果每次输入LR之后都暴力建边的话，时间复杂度是O(N^2)的。所以这道题很巧妙的点就来了，你可以先预处理一下。</p><p>对除了1节点的每一个节点都与它的上一个节点之间建一条权值为0的有向边，即i---&gt;i-1(i!=1)，这样以后输入LRC之后就建一条从L到R的一条权值为C的边，这样就相当于从L到[L+1,R]内的任何一个节点都有一条权值为C的边。因为中间点之间的权值都为0.这样优化一下时间复杂度就是O(nlogn)了<br>。建好图之后跑一遍Dijkstra就行了。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const ll maxn = 1e5 + 10, INF = 0x3f3f3f3f3f3f3f3f;ll       n, m, vis[maxn], dis[maxn];#define pil    pair&lt;ll, ll&gt;#define vec    vector&lt;pil&gt;#define pb     push_back#define mp     make_pairvector&lt;pil&gt;                             V[maxn];priority_queue&lt;pil, vec, greater&lt;pil&gt; &gt; q;void init(){    for (int i = 2; i &lt;= n; i++)        V[i].pb(mp(i - 1, 0));}void solve(){    dis[1] = 0;    for (int i = 2; i &lt;= n; i++)        dis[i] = INF;    q.push(mp(dis[1], 1));    while (!q.empty())    {        pil p = q.top(); q.pop();        ll  x = p.second; if (vis[x])            continue;        vis[x] = 1;        for (int i = 0; i &lt; V[x].size(); i++)        {            ll y = V[x][i].first, d = V[x][i].second;            if (vis[y])                continue;            if (dis[y] &gt; dis[x] + d)                dis[y] = dis[x] + d;            q.push(mp(dis[y], y));        }    }    if (dis[n] != INF)        cout &lt;&lt; dis[n] &lt;&lt; endl;    else        cout &lt;&lt; &quot;-1\n&quot;;}int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n &gt;&gt; m;    init();    for (int i = 0, u, v, w; i &lt; m; i++)    {        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        V[u].pb(mp(v, w));    }    solve();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Atcoder </tag>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>养胃和伤胃水果名单，一起养生吧</title>
      <link href="/2019/11/19/health/"/>
      <url>/2019/11/19/health/</url>
      
        <content type="html"><![CDATA[<p>本文转载自康复之路网，康复之路<a href="https://link.zhihu.com/?target=https%3A//www.kangfuzhilu.com" target="_blank" rel="noopener">康复之路抗癌网_肿瘤网-康复之路</a>，为您提供更多癌症知识！</p><p>养胃和伤胃水果名单，胃不好的人一定要看一眼</p><p>现代很多人患上胃病，时间长了伤害是很严重的。</p><p>很多水果有益于养胃，下面就为胃不好的素食者列出几款适合吃和不适合吃的水果名单：</p><p>1.木瓜<br>木瓜含木瓜酵素，有助于分解并加强蛋白质吸收。可缓解消化不良和胃炎。木瓜也是健脾养胃、治胃痛的好食物。</p><p>注意：木瓜性偏寒，不建议空腹食用。</p><p>另外，木瓜煲汤能更好的发挥其养胃功效，生吃效果没那么显著，而且生吃的话，味道也不怎么好。</p><p>2.石榴<br>中医认为味道甘甜的石榴具有生津止渴、润燥的功效，而味道酸涩的石榴可以治疗胃痛、腹泻等疾病。</p><p>另外，石榴中含有鞣酸、维生素C、柠檬酸、苹果酸等多种有助于消化和降血脂的物质，对于调理肠胃有一定的功效。</p><p>注意：石榴籽不太容易消化，肠胃不好的人可以连籽嚼嚼，然后吐出来。</p><p>3.菠萝<br>菠萝性味甘平，具有健胃消食、补脾止泻、清胃解渴等功能。</p><p>每100克菠萝果实中所含的维生素C高达30毫克，并含有丰富的水分，适当食用对肾炎、高血压病患者有益。</p><p>它的果肉中和木瓜一样含有一种能分解蛋白质的酵素。</p><p>注意：每次吃菠萝也不可过多，过量食用对肠胃有害。</p><p>4.葡萄<br>葡萄可入胃经、肝经、肾经，味甘养血，属于平性水果，营养吸收较差的人可吃葡萄养脾胃。</p><p>葡萄含铁质及许多抗氧化物质，无论是在中医或西方营养学眼中，都是对健康有益的水果，脾胃养好了自然就能生血，可改善轻微贫血。</p><p>注意：容易腹泻的人要少吃葡萄，否则更容易拉肚子。</p><p>5.香蕉<br>香蕉可入脾经、胃经，可以润便、润肠、降血压的食物，且味甘性平，是养肠胃很好的水果。</p><p>注意：香蕉吃多了容易胀气，尤其有糖尿病、肥胖的人要少吃。</p><p>6.樱桃<br>樱桃营养丰富，其中铁的含量尤为突出，超过柑橘、梨和苹果20倍以上，居水果首位。</p><p>樱桃性温，味甘微酸，具有补中益气、调中益颜、健脾开胃的功效。</p><p>注意：樱桃属火，不可多食，身体阴虚火旺者更应忌食或少食。</p><p>7.芒果<br>中医认为芒果味甘酸、性凉无毒，具有清热生津、解渴利尿、益胃止呕等功效，芒果特别适合胃阴不足、口渴咽干、胃气虚弱、呕吐晕般等症。</p><p>另外，芒果中所含的糖类及维生素含量非常高，尤其是维生素A原的含量占了水果之最，还有明目的作用。</p><p>8.荔枝<br>荔枝味甘、酸、性温，入心、脾、肝经，可止呃逆、止腹泻，是顽固性呃逆及五更泻者的食疗佳品。</p><p>同时，荔枝具有健脾益气、温中养胃的功效、对脾胃虚弱病者较适宜。</p><p>9.苹果<br>苹果味甘、性凉，可健脾、补气益胃、生津润燥，适宜脾虚食少、胃阴亏虚、阴虚胃痛等症。</p><p>相比生吃苹果，煮熟的苹果更适合养胃止腹泻，熟吃除了部分维生素丢失外，苹果的大部分营养成分均可保留。</p><p>﻿而且煮过的果胶会起到吸附的作用，这样会更容易吸附有毒物质。</p><p>10.桑椹<br>桑椹可补血润喉，又含有维生素C、B群等营养素，且和葡萄一样都属于高抗氧化力的水果。</p><p>在中医理论中，桑椹可养脾胃、养血，对肠胃吸收能力的促进有帮助，也可改善轻微贫血。</p><p>以下是胃不好别碰的四大水果：</p><p>1.柿子<br>柿子味美但‘收敛’!柿子味道鲜美而且营养丰富，但也有不足之处，食之过多也有危害。</p><p>﻿柿子中含有一定数目的单宁，柿皮含量更高，吃柿子时的口涩、舌麻就是单宁收敛的缘故。</p><p>单宁有很强的收敛作用，在胃内易与胃酸结合，从而凝固成块。</p><p>2.山楂<br>山楂开胃但易结石!山楂酸甜可口，具有消食化积的作用，是增进食欲的最佳果品之一，但吃过多是有害的。</p><p>山楂中的果胶和单宁酸含量高，接触胃酸易凝结成不溶于水的沉淀，与食物残渣等胶着在一起，形成胃结石。</p><p>结石可引起胃溃疡、胃出血，甚至胃壁坏死和穿孔。</p><p>但是，把山楂煮熟了吃会减少单宁酸的影响。</p><p>3.猕猴桃<br>猕猴桃通便但‘烧心’!猕猴桃属寒性，过食损伤脾胃的阳气，会产生腹痛、腹泻等症状。</p><p>猕猴桃中所含的大量维生素C和果胶成分，会增加胃酸，加重胃的负担，产生腹痛、泛酸、烧心等症状。</p><p>4.鲜枣<br>鲜枣好吃但枣皮扎胃!鲜枣不宜吃太多，否则会伤肠胃，大枣的膳食纤维含量很高，一次大量摄入会刺激肠胃，造成胃肠不适。</p><p>膳食纤维大部分存在于枣皮中，枣皮薄而坚硬，边缘很锋利，如果胃粘膜刚好有炎症或者溃疡，会加重胃痛和不适。</p><p>吃水果的讲究：</p><p>1.必须是当地产的<br>目前物流发达，很多水果都是外地的水果，不是本地的水果，正所谓“一方水土养一方人”。</p><p>外地的水果，最适合产地的人食用，因为当地的气温、土质、环境，造就出来的东西，就是养当地人的，吃异地的水果，就很容易伤身体。</p><p>﻿比如海南冬天产西瓜，湖北冬天不产西瓜，如果将冬天海南的西瓜运到湖北来，在大冷的冬天食用，与食毒药无异。</p><p>2.必须符合时令<br>秋天天气干燥，大自然赐给我们雪梨，滋阴润燥;</p><p>夏天天气炎热，大自然赐给我们西瓜，清凉解暑。</p><p>如果将雪梨保存到第二年夏天来食用，就算是当地产的，也是害人不浅，因为夏天潮湿，食用雪梨会加重体内的湿邪啊。</p><p>目前市面上的很多水果都不是当令的，苹果一年四季都在卖，圣女果一年四季都在卖，香蕉也是……</p><p>这些水果吃起来自然对身体是不利的，因为首先他们不符合时令。</p><p>其次在保养这些水果的过程中，人为地使用了一些防腐剂，两者的毒害，身体受不了啊。</p><p>另外，很多水果为了卖个好价钱，提前上市，常常使用一些激素，加速水果的成熟。</p><p>比如市面上卖的“桃”，外表看起来很漂亮，好像是熟了，其实吃的时候发现，其核还是嫩。</p><p>这说明桃没有熟，只是打了催熟剂，让他的表面看起来像是熟的。这样的水果目前很多啊!</p><p>他们也不符合“时令”。</p><p>3.是否符合身体的需求<br>水果中有很多是寒凉的，久食、大量吃损伤脾阳。</p><p>目前我们大多数人，心浮气躁，心气沉不下来，形成上热下寒的状态，上面热燥，下焦却寒凉。</p><p>﻿吃用寒凉的水果虽然当时心中舒服，但牺牲的是自己的肾阳，时间久后最终会导致脾肾阳虚。</p><p>女的会月经不调、子宫长肌瘤、脸上长斑;男的会腰痛、腿沉、腰椎间盘突出……</p><p>很多患者长期大便稀塘、冬天双脚冰冷、下肢静脉曲张等，无不与进食寒凉的食物有关。</p><p>民间有句俗语：病号不忌嘴，大夫跑断腿。</p><p>寒凉的水果天天吃，服用再多的药物也是枉然啊!</p><p>病人会说：水果加热了能吃吗，加热了就不寒了嘛!</p><p>寒性水果加热了改变不了水果的寒性，就好比我们喝菊花茶，虽然是用开水泡茶的，喝起来烫嘴，但它还是下火的，寒性的，因为它的药性是寒凉的。</p><p>寒性水果加热了改变不了水果的凉性，除非你放一些生姜、黑胡椒、肉桂、八角之类的温性调料，与水果一起加热，但这样的水果还好吃吗?</p><p>4.病人少吃水果、戒掉水果的原因<br>少吃水果、戒掉水果的出发点是希望如今“把水果当饭吃”的饮食习惯回归到以“五谷为养”的饮食基础。</p><p>首先来看，宣传吃水果对身体好的多为西方人，他们的祖宗也是吃肉长大的，他们的膳食中以各种肉类、奶制品为主。</p><p>﻿而且喜饮酒、咖啡之类，蔬菜很少，所以卫生舆论呼吁多吃水果蔬菜来减少肥胖问题、使身体更健康。</p><p>而中国人的祖先是吃素为主长大的。现代中国人父辈中，有谁听说是吃肉长大的?那时候有菜里有点肉星都是奢望。</p><p>﻿中国人的体型相对于西方人而言多为偏瘦小，既不适合大量吃肉，也不适合把水果当饭吃。</p><p>﻿尤其是现代女性，为了苗条、美丽，使劲地吃水果，结果把皮肤吃得发黄、无光泽，还长着雀斑。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 600 (Div. 2) - D. Harmonious Graph</title>
      <link href="/2019/11/17/cf1253/"/>
      <url>/2019/11/17/cf1253/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1253/problem/D" target="_blank" rel="noopener">D. Harmonious Graph</a></p><p><center>D. Harmonious Graph</center><br>Description:<br>You&#39;re given an undirected graph with n nodes and m edges. Nodes are numbered from 1 to n.</p><p>The graph is considered harmonious if and only if the following property holds:</p><p>For every triple of integers (l,m,r) such that 1≤l&lt;m&lt;r≤n, if there exists a path going from node l to node r, then there exists a path going from node l to node m.<br>In other words, in a harmonious graph, if from a node l we can reach a node r through edges (l&lt;r), then we should able to reach nodes (l+1),(l+2),…,(r−1) too.</p><p>What is the minimum number of edges we need to add to make the graph harmonious?</p><p>Input<br>The first line contains two integers n and m (3≤n≤200 000 and 1≤m≤200 000).</p><p>The i-th of the next m lines contains two integers ui and vi (1≤ui,vi≤n, ui≠vi), that mean that there&#39;s an edge between nodes u and v.</p><p>It is guaranteed that the given graph is simple (there is no self-loop, and there is at most one edge between every pair of nodes).</p><p>Output<br>Print the minimum number of edges we have to add to the graph to make it harmonious.</p><p>Examples<br>input<br>14 8<br>1 2<br>2 7<br>3 4<br>6 3<br>5 7<br>3 8<br>6 8<br>11 12<br>output<br>1<br>input<br>200000 3<br>7 9<br>9 8<br>4 5<br>output<br>0<br>Note<br>In the first example, the given graph is not harmonious (for instance, 1&lt;6&lt;7, node 1 can reach node 7 through the path 1→2→7, but node 1 can&#39;t reach node 6). However adding the edge (2,4) is sufficient to make it harmonious.</p><p>In the second example, the given graph is already harmonious.</p><p>Problem solving:<br>这道题的意思是给你一张图可能是不连通的图。每个顶点都有一个编号。规定一种特殊的图：这个图中如果从顶点i可以到达顶点j，并且如果存在一个数k(i&lt;k&lt;j)，那么i也应该可以到达k。现在给你一个图，问你至少需要再加几条边可以让这个图变成规定的那种特殊的图。</p><p>一开始毫无思路，最后还是靠bly过了这道题。吹爆bly。<br>我们通过并查集把输入的有边的顶点连在一起，此时父节点是同一个顶点的点是可以相互到达的。<br>我们每次都让最小的顶点做一个连通块的父节点。首先对一个中间变量赋值为节点n的父节点，然后从n开始遍历每一个顶点，如果当前顶点的值小于那个中间变量，说明他和上一个连通块没有关系。就对mid的值进行更新。然后如果出现i&gt;=mid的情况，就看这个节点的父节点跟不跟mid相等，如果不相等就连一条边连起来，答案加一。然后更新一下mid的最小值，因为我们一直是以最小的点作为父节点。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;int       f[maxn];int find(int x){    return f[x] != x ? f[x] = find(f[x]) : x;}void join(int x, int y){    x = find(x), y = find(y);    if (x != y)    {        if (x &lt; y)            swap(x, y);        f[x] = y;    }}int main(){    ios::sync_with_stdio(0);    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        f[i] = i;    for (int i = 0, u, v; i &lt; m; i++)    {        cin &gt;&gt; u &gt;&gt; v;        join(u, v);    }    int ans = 0, mid = find(n);    for (int i = n; i &gt;= 1; i--)    {        if (i &lt; mid)            mid = find(i);        else if (find(i) != mid)            join(i, mid), ans++;        mid = min(find(i), mid);    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> thinking </tag>
            
            <tag> dsu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 76 (Rated for Div. 2) - E. The Contest</title>
      <link href="/2019/11/15/cfedu76E/"/>
      <url>/2019/11/15/cfedu76E/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1257/problem/E" target="_blank" rel="noopener">E. The Contest</a></p><p><center>E. The Contest</center><br>Description:<br>A team of three programmers is going to play a contest. The contest consists of n problems, numbered from 1 to n. Each problem is printed on a separate sheet of paper. The participants have decided to divide the problem statements into three parts: the first programmer took some prefix of the statements (some number of first paper sheets), the third contestant took some suffix of the statements (some number of last paper sheets), and the second contestant took all remaining problems. But something went wrong — the statements were printed in the wrong order, so the contestants have received the problems in some random order.</p><p>The first contestant has received problems a1,1,a1,2,…,a1,k1. The second one has received problems a2,1,a2,2,…,a2,k2. The third one has received all remaining problems (a3,1,a3,2,…,a3,k3).</p><p>The contestants don&#39;t want to play the contest before they redistribute the statements. They want to redistribute them so that the first contestant receives some prefix of the problemset, the third contestant receives some suffix of the problemset, and the second contestant receives all the remaining problems.</p><p>During one move, some contestant may give one of their problems to other contestant. What is the minimum number of moves required to redistribute the problems?</p><p>It is possible that after redistribution some participant (or even two of them) will not have any problems.</p><p>Input<br>The first line contains three integers k1,k2 and k3 (1≤k1,k2,k3≤2e5,k1+k2+k3≤2e5) — the number of problems initially taken by the first, the second and the third participant, respectively.</p><p>The second line contains k1 integers a1,1,a1,2,…,a1,k1 — the problems initially taken by the first participant.</p><p>The third line contains k2 integers a2,1,a2,2,…,a2,k2 — the problems initially taken by the second participant.</p><p>The fourth line contains k3 integers a3,1,a3,2,…,a3,k3 — the problems initially taken by the third participant.</p><p>It is guaranteed that no problem has been taken by two (or three) participants, and each integer ai,j meets the condition 1≤ai,j≤n, where n=k1+k2+k3.</p><p>Output<br>Print one integer — the minimum number of moves required to redistribute the problems so that the first participant gets the prefix of the problemset, the third participant gets the suffix of the problemset, and the second participant gets all of the remaining problems.</p><p>Examples<br>input<br>2 1 2<br>3 1<br>4<br>2 5<br>output<br>1<br>input<br>3 2 1<br>3 2 1<br>5 4<br>6<br>output<br>0<br>input<br>2 1 3<br>5 6<br>4<br>1 2 3<br>output<br>3<br>input<br>1 5 1<br>6<br>5 1 2 4 7<br>3<br>output<br>2<br>Note<br>In the first example the third contestant should give the problem 2 to the first contestant, so the first contestant has 3 first problems, the third contestant has 1 last problem, and the second contestant has 1 remaining problem.</p><p>In the second example the distribution of problems is already valid: the first contestant has 3 first problems, the third contestant has 1 last problem, and the second contestant has 2 remaining problems.</p><p>The best course of action in the third example is to give all problems to the third contestant.</p><p>The best course of action in the fourth example is to give all problems to the second contestant.</p><p>Problem solving:<br>这道题的意思就是三个人一队做n道题，第一个人只做前面几个题，第三个人只做后面几个题，剩下的题第二个人做。但是现在发题的人给他们发的顺序并不是他们想要的顺序，问你最少需要换多少次可以同时满足三个人的要求。（可以出现某几个人一道题没有的情况）</p><p>一开始毫无思路，但是仔细一想，按照题目描述的来就是三个人做题的序号就是一个严格的升序。所以我们可以把三个人的题自己排序完之后全部放在一起，求一个最大上升子序列。然后用总题数减最大上升子序列的长度就是答案。这个应该还是很好理解的。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int maxn = 2e5 + 10;const int inf = 0x3f3f3f3f;int       a[maxn], b[maxn], c[maxn], d[maxn], dp[maxn];using namespace std;int main(){    ios::sync_with_stdio(0);    int x, y, z;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;    for (int i = 0; i &lt; x; i++)        cin &gt;&gt; a[i];    for (int i = 0; i &lt; y; i++)        cin &gt;&gt; b[i];    for (int i = 0; i &lt; z; i++)        cin &gt;&gt; c[i];    sort(a, a + x);    sort(b, b + y);    sort(c, c + z);    for (int i = 0; i &lt; x; i++)    {        d[i] = a[i];    }    for (int i = x; i &lt; x + y; i++)    {        d[i] = b[i - x];    }    for (int i = x + y; i &lt; x + y + z; i++)        d[i] = c[i - x - y];    cout &lt;&lt; endl;    fill(dp, dp + x + y + z, inf);    for (int i = 0; i &lt; x + y + z; i++)    {        *lower_bound(dp, dp + x + y + z, d[i]) = d[i];    }    cout &lt;&lt; x + y + z - (lower_bound(dp, dp + x + y + z, inf) - dp) &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> Greedy </tag>
            
            <tag> Codeforces </tag>
            
            <tag> LIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 76 (Rated for Div. 2) - C.Dominated Subarray</title>
      <link href="/2019/11/15/cfedu76C/"/>
      <url>/2019/11/15/cfedu76C/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1257/problem/C" target="_blank" rel="noopener">Dominated Subarray</a></p><center>C. Dominated Subarray</center><p>Description:<br>Let&#39;s call an array t dominated by value v in the next situation.</p><p>At first, array t should have at least 2 elements. Now, let&#39;s calculate number of occurrences of each number num in t and define it as occ(num). Then t is dominated (by v) if (and only if) occ(v)&gt;occ(v′) for any other number v′. For example, arrays [1,2,3,4,5,2], [11,11] and [3,2,3,2,3] are dominated (by 2, 11 and 3 respectevitely) but arrays [3], [1,2] and [3,3,2,2,1] are not.</p><p>Small remark: since any array can be dominated only by one number, we can not specify this number and just say that array is either dominated or not.</p><p>You are given array a1,a2,…,an. Calculate its shortest dominated subarray or say that there are no such subarrays.</p><p>The subarray of a is a contiguous part of the array a, i. e. the array ai,ai+1,…,aj for some 1≤i≤j≤n.</p><p>Input<br>The first line contains single integer T (1≤T≤1000) — the number of test cases. Each test case consists of two lines.</p><p>The first line contains single integer n (1≤n≤2⋅1e5) — the length of the array a.</p><p>The second line contains n integers a1,a2,…,an (1≤ai≤n) — the corresponding values of the array a.</p><p>It&#39;s guaranteed that the total length of all arrays in one test doesn&#39;t exceed 2⋅1e5.</p><p>Output<br>Print T integers — one per test case. For each test case print the only integer — the length of the shortest dominated subarray, or −1 if there are no such subarrays.</p><p>Example<br>input<br>4<br>1<br>1<br>6<br>1 2 3 4 5 1<br>9<br>4 1 2 4 5 4 3 2 1<br>4<br>3 3 3 3<br>output<br>-1<br>6<br>3<br>2<br>Note<br>In the first test case, there are no subarrays of length at least 2, so the answer is −1.</p><p>In the second test case, the whole array is dominated (by 1) and it&#39;s the only dominated subarray.</p><p>In the third test case, the subarray a4,a5,a6 is the shortest dominated subarray.</p><p>In the fourth test case, all subarrays of length more than one are dominated.</p><p>Problem solving:<br>这道题的意思就是给你一个数列，让你找到两个相等的数(要求他们中间没有出现别的相等的数)之间的距离。</p><p>直接用一个数组记录一下某个数的出现位置。如果输入的时候发现这个数出现过，更新一下min的答案值以及这个数最新出现的位置。一开始我在纠结这样找会忽略两个数中间出现另外相等的数的情况，但是仔细一想我们让求得是最小值，如果两个数中间出现了另外两个相等的数，早就被min更新到ans了。题不难，主要是思想。所以还是记录一下。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int t, n;    cin &gt;&gt; t;    while (t--)    {        int         ans = 0x3f3f3f3f;        cin &gt;&gt; n;        vector&lt;int&gt; a(n +1); vector&lt;int&gt; pos(n+1);        for (int i = 1; i &lt;= n; i++)        {            cin &gt;&gt; a[i];            if (!pos[a[i]])                pos[a[i]] = i;            else                ans = min(ans, i - pos[a[i]]+1), pos[a[i]] = i;        }        if (ans == 0x3f3f3f3f)            cout &lt;&lt; &quot;-1\n&quot;;        else            cout &lt;&lt; ans &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 76 (Rated for Div. 2) - D. Yet Another Monster Killing Problem</title>
      <link href="/2019/11/15/cfedu76D/"/>
      <url>/2019/11/15/cfedu76D/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1257/problem/D" target="_blank" rel="noopener">Yet Another Monster Killing Problem</a></p><center>D -Yet Another Monster Killing Problem</center><p>Description:</p><p>You play a computer game. In this game, you lead a party of m heroes, and you have to clear a dungeon with n monsters. Each monster is characterized by its power ai. Each hero is characterized by his power pi and endurance si.</p><p>The heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day.</p><p>When the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated k monsters, the hero fights with the monster k+1). When the hero fights the monster, there are two possible outcomes:</p><p>if the monster&#39;s power is strictly greater than the hero&#39;s power, the hero retreats from the dungeon. The current day ends;<br>otherwise, the monster is defeated.<br>After defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the i-th hero cannot defeat more than si monsters during each day), or if all monsters are defeated — otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends.</p><p>Your goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don&#39;t fight the monsters at all. Each hero can be used arbitrary number of times.</p><p>Input<br>The first line contains one integer t (1≤t≤1e5) — the number of test cases. Then the test cases follow.</p><p>The first line of each test case contains one integer n (1≤n≤2⋅1e5) — the number of monsters in the dungeon.</p><p>The second line contains n integers a1, a2, ..., an (1≤ai≤1e9), where ai is the power of the i-th monster.</p><p>The third line contains one integer m (1≤m≤2⋅1e5) — the number of heroes in your party.</p><p>Then m lines follow, each describing a hero. Each line contains two integers pi and si (1≤pi≤1e9, 1≤si≤n) — the power and the endurance of the i-th hero.</p><p>It is guaranteed that the sum of n+m over all test cases does not exceed 2⋅1e5.</p><p>Output<br>For each test case print one integer — the minimum number of days you have to spend to defeat all of the monsters (or −1 if it is impossible).</p><p>Example<br>input<br>2<br>6<br>2 3 11 14 1 8<br>2<br>3 2<br>100 1<br>5<br>3 5 100 2 3<br>2<br>30 5<br>90 1<br>output<br>5<br>-1</p><p>Problem solving:<br>这道题的意思就是给你一堆怪物，然后给你几个战士。怪物和战士都有自己的攻击力，战士还会有一个耐力。只要战士的攻击力不小于怪物的攻击力，就可以把这个怪物杀死。每天只能派出一个战士，并且战士每杀一只怪物耐力减一。每个战士一天可以尽量多的杀怪物。问你最少需要几天可以把怪物杀完，如果杀不完就输出-1.注意：杀死怪物的顺序应该与输入的顺序一样，不能变</p><p>这里我补的代码里面主要思想是贪心。一共有n个怪物。那就把坚持i(1&lt;=i&lt;=n)天的战士的最大的攻击力存起来。然后从第一个怪物开始遍历，找到最多可以一天内杀死的怪物数，再从下一个怪物开始找，循环下去直到找完或者输出-1。具体可以看代码注释，个人认为写的还是很明白的。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    ios::sync_with_stdio(0);cin.tie();    int N, n, m;    cin &gt;&gt; N;    while (N--)    {        int         flag = 0, ans = 0;        cin &gt;&gt; n;        vector&lt;int&gt; a(n);        vector&lt;int&gt; mx(n); //mx数组的含义很重要，它代表的是耐力为i的战士的最大攻击力        for (int i = 0; i &lt; n; i++)            cin &gt;&gt; a[i];        cin &gt;&gt; m;        for (int i = 0, x, y; i &lt; m; i++)        {            cin &gt;&gt; x &gt;&gt; y;             mx[y - 1] = max(mx[y - 1], x);//这里我们下标从0开始。mx[i]代表的是可以坚持i天的战士的最大攻击力        }        for (int i = n - 2; i &gt;= 0; i--)            mx[i] = max(mx[i], mx[i + 1]);//这样处理是为了得到可以坚持至少i天的战士的最大攻击力，因为如果某个战士耐力大于i并且攻击力也更大，那么mx[i]的值就应该是他的攻击力。所以我们要从后往前推储存最大值        for (int i = 0; i &lt; n;)//从头开始杀怪物        {            int j = i, x = 0;            while (j &lt; n &amp;&amp; mx[j - i ] &gt;= max(x, a[j]))//这里mx的下标是j-i，要好好理解。这个while循环其实就是在找从第一只怪物开始吗，一天内最多杀死几只怪物            {                x = max(x, a[j]);                j++;            }//分别看当前一天内最多可以杀几只怪物，max(x,a[j])代表的就是这几天内怪物的最大攻击力，mx[j-i]代表的是战士的最大攻击力，如果战士的最大攻击力已经小于怪物了，说明连着打只能打j-i只怪物。然后跳出这个while循环            if (j == i)            {                flag = 1; break;            }//这是处理一下，j==i的情况只有一种情况会出现，即最大的战士攻击力小于这个怪物的攻击力，那么肯定杀不完            ans++;//杀死这j-i只怪物用一天            i = j;//从上一天杀死的最后一只怪物的下一只怪物开始下一次循环        }        if (flag)            cout &lt;&lt; &quot;-1\n&quot;;        else            cout &lt;&lt; ans &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> greedy </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费搭建一个属于你的个人博客 |git+nodejs+github+hexo|（傻瓜式操作）</title>
      <link href="/2019/11/11/sghexo/"/>
      <url>/2019/11/11/sghexo/</url>
      
        <content type="html"><![CDATA[<p>CSDN,博客园,简书,等都是比较出名的博客网站。你只需要注册一个账号就可以拥有一个个人博客。<br>优点；方便，简单。<br>缺点：受限于人，可自定义化弱（博客园的自定义还是很给力的），广告漫天（此条只针对某N。</p><p>然而，身为计算机专业的我们就是喜欢捣鼓一些东西。于是一种东西进入了我们的视野，个人博客</p><p>个人博客:<br>现在比较火的有Hexo，jekyll，Hugo，（前面三个都可以做到免费）Typecho，Wordpress（后面这两个需要有服务器）等框架。<br>这里主要介绍一下hexo的安装。</p><p>介绍一些我们是怎么实现的个人博客，我个人理解的就是以hexo为框架生成博客网站源文件，然后借助github上面的github pages托管功能，实现可以外网访问的个人博客。<br>当然不只是github可以。国内的gitee，coding等都是不错的选择。当然，如果你有一个服务器，也是一样的。但是就不需要下面这麻烦了。</p><p>hexo官网: <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">传送门</a></p><p>首先我们列一下需要安装的软件</p><ol><li>git : <a href="https://git-scm.com/" target="_blank" rel="noopener">点击去官网下载</a>  这个官网下载可能比较慢，这里我找到了阿里的镜像，可以去<a href="https://npm.taobao.org/mirrors/git-for-windows/v2.24.0.windows.2/" target="_blank" rel="noopener">阿里镜像下载</a></li><li>nodejs : <a href="https://nodejs.org/en/" target="_blank" rel="noopener">点击去官网下载</a></li></ol><h4 id="安装所需软件"><a href="#安装所需软件" class="headerlink" title="安装所需软件"></a>安装所需软件</h4><p>点击去我放的链接下载完成后会得到两个文件，如图，文件名分别是<code>Git-2.24.0.2-64-bit.exe</code>，<code>node-v12.13.0-x64.msi</code>，可能会因为版本原因不是完全一样，但是问题不大，只要是Git呵node就行。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111203829.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111203829.webp" class="img-shadow img-margin"></center></a><br>然后分别点击安装即可。<br>这两个选项是设置默认安装位置的，可以根据自己情况进行调整。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204001.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204001.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204014.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204014.webp" class="img-shadow img-margin"></center></a><br>之后安装过程中弹出来的选项全部默认即可。等全部安装完之后就可以进入下一步了。</p><h4 id="创建github账号并配置SSH"><a href="#创建github账号并配置SSH" class="headerlink" title="创建github账号并配置SSH"></a>创建github账号并配置SSH</h4><p>github账号的创建还是很简单的。直接入github的<a href="https://github.com/" target="_blank" rel="noopener">官网</a><br>会直接显示注册页面，如图所示<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204633.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204633.webp" class="img-shadow img-margin"></center></a><br>然后填写上你相用的GitHub的用户名，填上邮箱，密码之后点击<code>Sign up for Github</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204715.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204715.webp" class="img-shadow img-margin"></center></a><br>然后有时候会有一个人机验证，有时候没有，如果有就照着做一下就行。一般就是让你把一个图片转正。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111205619.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111205619.webp" class="img-shadow img-margin"></center></a><br>那个<code>Email preferences</code>选不选都无所谓，选了就会经常受到github的一些新闻什么的。<br>验证成功后点击<code>Next：Select a plan</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204733.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111204733.webp" class="img-shadow img-margin"></center></a><br>就会跳转到这个界面<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111210213.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111210213.webp" class="img-shadow img-margin"></center></a><br>我们直接choose free就行。<br>然后跳转到的页面里这些东西随便选选就行<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111210256.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111210256.webp" class="img-shadow img-margin"></center></a><br>然后他就会让你验证邮箱，去邮箱里找到github给你发的邮件，里面有一个链接直接点进去就行了。至此，你的github账号算是注册好了<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111210503.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111210503.webp" class="img-shadow img-margin"></center></a></p><p>接下来是配置SSH<br>去<code>我的电脑</code>里面任意找一个文件夹右键选择<code>git bash here</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211016.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211016.webp" class="img-shadow img-margin"></center></a><br>在命令行里面输入</p><pre><code class="lang-git">ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></pre><p>这里面的邮件地址就是你注册github用的邮箱地址<br>接下来就是按回车，大约按三次回车就可以了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211148.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211148.webp" class="img-shadow img-margin"></center></a></p><p>然后找到<code>C:\Users\你的用户名\.ssh\id_rsa.pub</code>的文件，用记事本或者各种文本编辑器打开。把里面的内容复制下来。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211927.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211927.webp" class="img-shadow img-margin"></center></a><br>在github中找到setting-&gt;SSH and GPG keys 然后点击<code>New SSH key</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211443.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211443.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211618.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211618.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211714.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211714.webp" class="img-shadow img-margin"></center></a><br>把你刚才复制下来的内容粘贴到key里面，title随便写一个就行<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211812.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111211812.webp" class="img-shadow img-margin"></center></a><br>填写之后点击<code>Add SSH key</code>即可 这就是我们刚才添加的ssh<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111212034.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111212034.webp" class="img-shadow img-margin"></center></a></p><p>然后我们可以检测一下有没有配置成功。直接在刚才的git命令行里面输入</p><pre><code class="lang-git">ssh -T git@github.com</code></pre><p>这里输入一个yes<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111212210.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111212210.webp" class="img-shadow img-margin"></center></a><br>如果你也看到了<code>You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>就说明SSH配置好了。<br>至此这一步也就完成了。</p><h4 id="安装hexo以及初始化博客文件目录"><a href="#安装hexo以及初始化博客文件目录" class="headerlink" title="安装hexo以及初始化博客文件目录"></a>安装hexo以及初始化博客文件目录</h4><p>找到你想存放博客的位置，右键点击<code>git bash here</code><br>首先我们要安装hexo，在命令行输入</p><pre><code class="lang-git">npm install hexo-cli -g</code></pre><p>等他安装完之后是这样子的。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111212647.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111212647.webp" class="img-shadow img-margin"></center></a><br>然后我们可以在命令行输入</p><pre><code class="lang-git">hexo init name</code></pre><p>这里的name是你自定义的，随便起什么都行。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111212847.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111212847.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111213358.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111213358.webp" class="img-shadow img-margin"></center></a><br>这样初始化就完成了。</p><p>然后我们进入博客目录，需要安装一个插件（什么是插件？我们下面再说）<br>仍然是<code>git bash here</code>，我们输入命令</p><pre><code class="lang-git">npm install hexo-deployer-git --save</code></pre><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111215507.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111215507.webp" class="img-shadow img-margin"></center></a><h4 id="关于hexo的一些常用命令"><a href="#关于hexo的一些常用命令" class="headerlink" title="关于hexo的一些常用命令"></a>关于hexo的一些常用命令</h4><h5 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h5><p>是hexo generate的简写形式，生成静态文件到public文件夹</p><h5 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h5><p>是 hexo server 的缩写,启动本地服务器，用于预览主题。默认地址： <a href="https://localhost:4000/" target="_blank" rel="noopener">https://localhost:4000/</a>, 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</p><h5 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h5><p>清除缓存文件db.json 和已生成的静态文件public</p><h5 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h5><p>是hexo deploy的简写形式，部署静态文件到设定的仓库</p><p>上面的命令通常可以一起写位<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br>清除缓存，生成静态文件，并本地预览<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br>清除缓存，生成静态文件，并部署到指定github仓库</p><p>我们通常会先本地预览感觉可以了再上传到指定仓库github</p><h4 id="第一次本地生成后预览"><a href="#第一次本地生成后预览" class="headerlink" title="第一次本地生成后预览"></a>第一次本地生成后预览</h4><p>首先进入到我们的博客目录然后右键点击&#39;git bash here&#39;<br>在命令行中输入</p><pre><code class="lang-git">hexo g &amp; hexo s</code></pre><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111213610.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111213610.webp" class="img-shadow img-margin"></center></a><p>然后打开浏览器输入<code>localhost:4000</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111213726.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111213726.webp" class="img-shadow img-margin"></center></a><br>你会看到是这样的，此时你已经成功了一大半了，接下来就是传到github上面了<br><code>ctrl+c</code>可以终止<code>hexo s</code></p><h4 id="创建github仓库并将hexo文件上传至github"><a href="#创建github仓库并将hexo文件上传至github" class="headerlink" title="创建github仓库并将hexo文件上传至github"></a>创建github仓库并将hexo文件上传至github</h4><p>首先我们去创建一个github仓库<br>回到github主页，点击<code>Create a repository</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111213954.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111213954.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111214144.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111214144.webp" class="img-shadow img-margin"></center></a><br>这里的repository name我们规定一下格式,即<code>githubname.github.io</code>。这个是有原因的，具体是啥忘了。其他的选项都不用管<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111214210.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111214210.webp" class="img-shadow img-margin"></center></a><br>然后点击<code>Create repository</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111214442.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111214442.webp" class="img-shadow img-margin"></center></a><br>这个时候你的仓库就创建好了</p><p>之后我们需要修改博客根目录下的<code>_config.yml</code>文件<br>这个文件叫做hexo的配置文件，一般最开始我们需要修改的地方就是在最下面</p><pre><code class="lang-yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: &#39;&#39;</code></pre><p>我们需要把他修改成这样的格式</p><pre><code class="lang-yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:    type: git    repository: git@github.com:username/username.github.io.git    branch: master</code></pre><p>在这个里面也就是修改成下面这个样子</p><pre><code class="lang-yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:    type: git    repository: git@github.com:601Test/601Test.github.io.git    branch: master</code></pre><p>修改完之后点击保存即可。<br>之后我们在命令行输入</p><pre><code class="lang-git">hexo g &amp; hexo d</code></pre><p>发现会是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111215623.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111215623.webp" class="img-shadow img-margin"></center></a><br>报错信息里面说的很清楚<code>Please tell me who you are</code><br>所以我们需要再git命令行里面设置一下自己的信息，这个只需要第一次设置一下，以后就都不需要设置了。<br>首先是</p><pre><code class="lang-git">git config --global user.email &quot;you email&quot;</code></pre><p>然后是</p><pre><code class="lang-git">git config --global user.name &quot;yourname&quot;</code></pre><p>虽然这里的email和name都是可以随便填的，但是我们还是规矩点<br>写成注册GitHub用的email和name。</p><p>然后我们再次执行<code>hexo d</code>就可以发现是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111220148.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111220148.webp" class="img-shadow img-margin"></center></a><br>如果你看到的是这样的说明你已经成功了。<br>然后我们回到刚才github新建的仓库会发现里面多了很多文件。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111220405.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111220405.webp" class="img-shadow img-margin"></center></a><br>然后我们打开浏览器访问<code>name.github.io</code>就发现博客已经可以访问了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111220417.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111220417.webp" class="img-shadow img-margin"></center></a></p><p>至此，我们搭建hexo博客的教程就结束了。</p><h4 id="hexo插件"><a href="#hexo插件" class="headerlink" title="hexo插件"></a>hexo插件</h4><p>hexo有很多可以扩展的功能。主题，插件，等等等等。<br>这里我大概介绍一下插件的使用，主题啊，美化啊什么的大家可以自己学，你会发现很有意思的，上课在想，下课再想，妙啊<br>常用的那些个插件直接百度就会有教程。所以我也不用说的那么详细。<br>一般插件的开发人员都会把插件上传到npm上面，你需要的只是一行命令。<br>这里我们以一个我最喜欢的插件为例介绍一下。<br>这个插件叫<code>hexo-generator-random</code>.<a href="https://github.com/Drew233/hexo-generator-random" target="_blank" rel="noopener">github地址</a>（悄悄说一句，作者开发插件不易，正好大家搭建博客需要用到github可以点进去这个链接点一个star。替作者谢谢大家了）</p><p>这个插件的作用就是生成一个html可以随机跳转到你的所有文章中的一篇。全自动的，wordpress中有直接的函数，作者感觉很羡慕，找不到hexo如何实现，就自己写了个插件。</p><p>我们进入博客根目录，依然是右键<code>git bash here</code><br>输入命令</p><pre><code class="lang-git">npm install hexo-generator-random</code></pre><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111221907.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191111221907.webp" class="img-shadow img-margin"></center></a><p>等他安装完就行了。对没错，就是这么简单。<br>但是每种插件的使用方式都不同，有的会让你在配置文件中加入一些东西，照着作者或教程说的来就行。不过这个<code>hexo-generator-random</code>不用那么麻烦，安装即用。</p><h4 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h4><p>之前看见群里有一个人说的一句话让我很有感慨，他说，看着现在的你们费尽心思地美化自己的博客就跟当年费尽心思美化qq空间是一样的。确实是这样的，我也有幸正好经历了这两个阶段。不知道以后会不会有更好的东西代替个人博客，但我对博客的热爱，是不会消退的。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cycle String?</title>
      <link href="/2019/11/10/cstring/"/>
      <url>/2019/11/10/cstring/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/gym/102392/problem/D" target="_blank" rel="noopener">Cycle String? </a></p><p><center>Cycle String? </center><br>Description:<br>Great wizard gave Alice and Bob a cycle string of length 2⋅n, which has no repeated substrings of length n. In a cycle string, character si+1 comes after si. Also, s1 comes after s2n.</p><p>Unfortunately, evil gin shuffled all the symbols of the string. Help Alice and Bob restore the original string so that the above condition is satisfied.</p><p>Input<br>The first line contains one string s of length 2⋅n (2≤2⋅n≤1000000) which consists only of the lowercase Latin letters.</p><p>Output<br>Print &quot;NO&quot; (without quotes) to the first line if it is impossible to restore the string so that the condition is satisfied. Otherwise, in the first line print &quot;YES&quot; (without quotes).</p><p>In the second line print one string — the restored string.</p><p>If there are multiple answers, print any.</p><p>Examples<br>Input<br>cbbabcacbb<br>Output<br>YES<br>abbabcbccb<br>Input<br>aa<br>Output<br>NO<br>Input<br>afedbc<br>Output<br>YES<br>afedbc<br>Note<br>In the first example, substrings of the restored string are: &quot;abbab&quot;, &quot;bbabc&quot;, &quot;babcb&quot;, &quot;abcbc&quot;, &quot;bcbcc&quot;, &quot;cbccb&quot;, &quot;bccba&quot;, &quot;ccbab&quot;, &quot;cbabb&quot;, &quot;babba&quot;.</p><p>Note that the first example does not contain repetitions, however it can be rewritten as another cycle with no repetitions. Thus, the solution is not unique — the given example is also a correct solution.</p><p>In the second example, it is impossible to restore the string so that no repetition exists.</p><p>In the third example, there is no need to change anything.</p><p>Problem solving:<br>这道题的意思就是给你一个长度为2n的字符串，问你它所有的长度为n的字串有没有重复的。如果有重复的，看能不能通过交换某几个字母的位置来避免相同子串的产生，如果可以就输出&quot;YES&quot;，否则输出&quot;NO&quot;。交换次数是无限次的。</p><p>因为交换次数是无限的的，所以我们只考虑每种字母的个数就行了。我们首先可以用一个数组存一下每个字符出现的次数。通过我跟我队友找规律发现，只要有某个字母出现的次数大于n并且只出现了两种以内的字母，并且出现次数少的那个字母只出现过一次时输出<code>NO</code>。否则就肯定可以。</p><p>然后输出转换后的序列的时候需要先排一个序，然后从个数多的存进一个字符串，但是这个时候可能会出现某种情况导致会有重复的字串出现，所以我们需要来一个小处理即<code>swap(ans[l-2],ans[l/2]);</code>就是把第n+1位的字符与第n-1位的字符交换一下。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int a[30];struct node{    char c; int v;} p[30];bool cmp(node a, node b){    return a.v &gt; b.v;}int main(){    set&lt;char&gt; se;    string    s, ans;    cin &gt;&gt; s;    int       l = s.size();    for (int i = 0; i &lt; s.size(); i++)        a[s[i] - &#39;a&#39;]++, se.insert(s[i]);    int mid = se.size();    for (int i = 0; i &lt; 26; i++)    {        if (a[i] &gt; l / 2 &amp;&amp; mid &lt;= 2)            if (!(a[i] &lt; l - 2))                return cout &lt;&lt; &quot;NO\n&quot;, 0;    }    cout &lt;&lt; &quot;YES\n&quot;;    for (int i = 0; i &lt; 26; i++)    {        p[i].c = i + &#39;a&#39;;        p[i].v = a[i];    }    sort(p, p + 26, cmp);    for (int i = 0; i &lt; 26; i++)    {        while (p[i].v--)            ans += p[i].c;    }    swap(ans[l-2],ans[l/2]);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客CSP-S提高组赛前集训营6 A 集合统计</title>
      <link href="/2019/11/09/nowcoder1105A/"/>
      <url>/2019/11/09/nowcoder1105A/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://ac.nowcoder.com/acm/contest/1105/A" target="_blank" rel="noopener">集合统计</a></p><p>Description:</p><p>定义一个集合S的f函数为f(S)=max{a}−min{a}(a∈S)<br>给定一个集合S，求该集合所有非空子集的f函数之和。对10^9+7取模。</p><p>输入描述:<br>第一行一个数n，表示|S|<br>第二行n个数表示集合中的元素。保证没有重复元素。<br>输出描述:<br>输出共1行，即该集合所有非空子集的f函数对10^9+7取模的和。<br>示例1<br>输入<br>4<br>1 5 2 7<br>输出<br>48</p><p>Problem solving:<br>这道题的意思就是给你一个集合，让你求这个集合中所有非空子集中的最大最小值的差之和。集合中元素个数最多为1e6个。<br>一开始想的是暴力，但是肯定不行（数据太大了。然后想到了找规律！对，就是找规律。然后我列出来了这样的规律。对这个集合中的元素排一下序，排序之后，每个值对最后答案的贡献不管正负肯定都是2^n-1(n=1,2,3,.....)。根据这个规律写肯定也能写出来。但是就在这时，学长告诉了我：<br>排序完第i个值对答案的贡献是<code>a[i]*(2^i-2^(n-i-1))</code>(i从0开始)。直接算一下就行了。<br>我们考虑第排序完第i位的值，这个值与它之前的任意个数组成的子集中他都是最大值，对答案的贡献为正，即<code>a[i]*2^i</code>，这个值与它之后的任意个数组成的子集中他都是最最小值，对答案的贡献为负，即<code>a[i]*(-2^(n-i-1))</code>。</p><p>这道题确实不难，但是这种思想真的是我现在所欠缺的！</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 1e6 + 10;ll       er[maxn], a[maxn];const ll mod = 1e9 + 7;int main(){    er[0] = 1, er[1] = 2;    for (int i = 2; i &lt;= 1e6; i++)        er[i] = (2 * er[i - 1]) % mod;    ll n, ans = 0;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)        cin &gt;&gt; a[i];    sort(a, a + n);    for (int i = 0; i &lt; n; i++)    {        ans += ((er[i] - er[n - i - 1] + mod) % mod * a[i] + mod) % mod;        ans %= mod;    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 599 (Div. 2) D	 0-1 MST</title>
      <link href="/2019/11/08/cd599D/"/>
      <url>/2019/11/08/cd599D/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1243/problem/D" target="_blank" rel="noopener">D. 0-1 MST</a></p><p><center>D. 0-1 MST</center><br>Description:<br>Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.</p><p>It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either 0 or 1; exactly m edges have weight 1, and all others have weight 0.</p><p>Since Ujan doesn&#39;t really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?</p><p>Input<br>The first line of the input contains two integers n and m (1≤n≤1e5, 0≤m≤min(n*(n−1)/2,1e5)), the number of vertices and the number of edges of weight 1 in the graph.</p><p>The i-th of the next m lines contains two integers ai and bi (1≤ai,bi≤n, ai≠bi), the endpoints of the i-th edge of weight 1.</p><p>It is guaranteed that no edge appears twice in the input.</p><p>Output<br>Output a single integer, the weight of the minimum spanning tree of the graph.</p><p>Examples<br>input<br>6 11<br>1 3<br>1 4<br>1 5<br>1 6<br>2 3<br>2 4<br>2 5<br>2 6<br>3 4<br>3 5<br>3 6<br>output<br>2<br>input<br>3 0<br>output<br>0<br>Note<br>The graph from the first sample is shown below. Dashed edges have weight 0, other edges have weight 1. One of the minimum spanning trees is highlighted in orange and has total weight 2.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191108195255.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191108195255.webp" class="img-shadow img-margin"></center></a><br>In the second sample, all edges have weight 0 so any spanning tree has total weight 0.</p><p>Problem solving:<br>这道题的意思就是给你一个图，然后告诉你一些边，这些边的权值为1，其他的未给出的边的权值为0。然后问你这个图的最小生成树的权值是多少。</p><p>因为边很多，存的话会超时（1e10的复杂度）。所以我们换一种思路想一下。有一个名词叫补图的连通块。在这个题里面的意思就是找出被权值为0的边连起来的连通块个数，再减一就行了，跟hdu的畅通工程有点像。</p><p>求补图的连通块个数。我这里使用了bfs写的，还可以用并查集什么的写。（当成板子记住吧）</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;set&lt;int&gt; V[maxn],s;int m,n,x,y,ans,vis[maxn];queue&lt;int&gt; q;void bfs(int x){    q.push(x);    vis[x]=1,s.erase(x);    while(!q.empty())    {        int mid=q.front();q.pop();        for(auto i=s.begin();i!=s.end();)        {            int mi=*i++; //这里很重要，因为我们要删除，所以需要先加上而不是在for循环里面直接i++            if(V[mi].count(mid)==0)            {                s.erase(mi);                q.push(mi);                vis[mi]=1;            }        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)   s.insert(i);    while(m--)    {        cin&gt;&gt;x&gt;&gt;y;        V[x].insert(y),V[y].insert(x);    }    for(int i=1;i&lt;=n;i++)   if(!vis[i]) bfs(i),ans++;    cout&lt;&lt;ans-1&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> STL </tag>
            
            <tag> bfs </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 597 (Div. 2)  D. Shichikuji and Power Grid</title>
      <link href="/2019/11/07/cf592/"/>
      <url>/2019/11/07/cf592/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1245/problem/D" target="_blank" rel="noopener">D. Shichikuji and Power Grid</a></p><p><center>D. Shichikuji and Power Grid</center><br>Description:<br>Shichikuji is the new resident deity of the South Black Snail Temple. Her first job is as follows:</p><p>There are n new cities located in Prefecture X. Cities are numbered from 1 to n. City i is located xi km North of the shrine and yi km East of the shrine. It is possible that (xi,yi)=(xj,yj) even when i≠j.</p><p>Shichikuji must provide electricity to each city either by building a power station in that city, or by making a connection between that city and another one that already has electricity. So the City has electricity if it has a power station in it or it is connected to a City which has electricity by a direct connection or via a chain of connections.</p><p>Building a power station in City i will cost ci yen;<br>Making a connection between City i and City j will cost ki+kj yen per km of wire used for the connection. However, wires can only go the cardinal directions (North, South, East, West). Wires can cross each other. Each wire must have both of its endpoints in some cities. If City i and City j are connected by a wire, the wire will go through any shortest path from City i to City j. Thus, the length of the wire if City i and City j are connected is |xi−xj|+|yi−yj| km.<br>Shichikuji wants to do this job spending as little money as possible, since according to her, there isn&#39;t really anything else in the world other than money. However, she died when she was only in fifth grade so she is not smart enough for this. And thus, the new resident deity asks for your help.</p><p>And so, you have to provide Shichikuji with the following information: minimum amount of yen needed to provide electricity to all cities, the cities in which power stations will be built, and the connections to be made.</p><p>If there are multiple ways to choose the cities and the connections to obtain the construction of minimum price, then print any of them.</p><p>Input<br>First line of input contains a single integer n (1≤n≤2000) — the number of cities.</p><p>Then, n lines follow. The i-th line contains two space-separated integers xi (1≤xi≤1e6) and yi (1≤yi≤106) — the coordinates of the i-th city.</p><p>The next line contains n space-separated integers c1,c2,…,cn (1≤ci≤1e9) — the cost of building a power station in the i-th city.</p><p>The last line contains n space-separated integers k1,k2,…,kn (1≤ki≤1e9).</p><p>Output<br>In the first line print a single integer, denoting the minimum amount of yen needed.</p><p>Then, print an integer v — the number of power stations to be built.</p><p>Next, print v space-separated integers, denoting the indices of cities in which a power station will be built. Each number should be from 1 to n and all numbers should be pairwise distinct. You can print the numbers in arbitrary order.</p><p>After that, print an integer e — the number of connections to be made.</p><p>Finally, print e pairs of integers a and b (1≤a,b≤n, a≠b), denoting that a connection between City a and City b will be made. Each unordered pair of cities should be included at most once (for each (a,b) there should be no more (a,b) or (b,a) pairs). You can print the pairs in arbitrary order.</p><p>If there are multiple ways to choose the cities and the connections to obtain the construction of minimum price, then print any of them.</p><p>Examples<br>input<br>3<br>2 3<br>1 1<br>3 2<br>3 2 3<br>3 2 3<br>output<br>8<br>3<br>1 2 3<br>0<br>input<br>3<br>2 1<br>1 2<br>3 3<br>23 2 23<br>3 2 3<br>output<br>27<br>1<br>2<br>2<br>1 2<br>2 3<br>Note<br>For the answers given in the samples, refer to the following diagrams (cities with power stations are colored green, other cities are colored blue, and wires are colored red):</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191107132123.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191107132123.webp" class="img-shadow img-margin"></center></a><p>For the first example, the cost of building power stations in all cities is 3+2+3=8. It can be shown that no configuration costs less than 8 yen.</p><p>For the second example, the cost of building a power station in City 2 is 2. The cost of connecting City 1 and City 2 is 2⋅(3+2)=10. The cost of connecting City 2 and City 3 is 3⋅(2+3)=15. Thus the total cost is 2+10+15=27. It can be shown that no configuration costs less than 27 yen.</p><p>Problem solving:<br>这道题的意思就是给你n个城市，现在要为这n个城市通电。每个城市自己建造一座电站的花费告诉我们了，每两个城市通过电线连起来的花费是这两个城市的曼哈顿距离与这两个城市拉电线的花费之和的乘积。现在问你能给n个城市通电的最小花费。</p><p>我们可以用最小生成树写。首先设置一个超级源点，让这个点与n个城市建边，边的权值为这个城市建造电站的花费。再给每两个城市之间建边，边的权值是这两个城市拉电线的花费。然后最小生成树写一发就行了。还有个很恶心的东西就是输出的控制。不过也很好实现。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e6 + 10;ll        f[maxn];struct node{    ll x, y;} p[maxn];struct Node{    ll u, v, w;} P[maxn];bool cmp(Node a, Node b){    return a.w &lt; b.w;}#define pil    pair&lt;ll, ll&gt;bool cmp2(pil a, pil b){    return a.first &lt; b.first;}ll find(ll x){    return x != f[x] ? f[x] = find(f[x]) : x;}void join(ll x, ll y){    x = find(x), y = find(y);    if (x != y)        f[x] = y;}vector&lt;pil&gt; Ans, AAns;ll          r[maxn];int main(){    ios::sync_with_stdio(0);    ll co, n, pos;    cin &gt;&gt; n; pos = n + 1;    for (int i = 0; i &lt;= n; i++)        f[i] = i;    for (int i = 1; i &lt;= n; i++)    {        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    }    for (int i = 1; i &lt;= n; i++)    {        cin &gt;&gt; co; P[i].u = i, P[i].v = 0, P[i].w = co;    }    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; r[i];    for (int i = 1; i &lt;= n; i++)        for (int j = i + 1; j &lt;= n; j++)        {            ll mid = (abs(p[i].x - p[j].x) + abs(p[i].y - p[j].y)) * (r[i] + r[j]);            P[pos].u = j, P[pos].v = i, P[pos++].w = mid;        }    sort(P + 1, P + 1 + pos, cmp);    ll ans = 0, MMid = 0, mmid = 0;    for (int i = 1; i &lt;= pos; i++)    {        if (find(P[i].u) != find(P[i].v))        {            join(P[i].u, P[i].v), ans += P[i].w;            if (P[i].u != 0 &amp;&amp; P[i].v != 0)                MMid++, Ans.push_back(make_pair(P[i].u, P[i].v));            else                mmid++, AAns.push_back(make_pair(P[i].u, P[i].v));        }    }    cout &lt;&lt; ans &lt;&lt; endl;    cout &lt;&lt; mmid &lt;&lt; endl;    sort(AAns.begin(), AAns.end(), cmp2);    for (int i = 0; i &lt; AAns.size(); i++)    {        ll a1 = AAns[i].first, a2 = AAns[i].second;        if (a1)            cout &lt;&lt; a1 &lt;&lt; &quot; &quot;;        else            cout &lt;&lt; a2 &lt;&lt; &quot; &quot;;    }    cout &lt;&lt; endl;    cout &lt;&lt; MMid &lt;&lt; endl;    for (int i = 0; i &lt; Ans.size(); i++)    {        ll a1 = Ans[i].first, a2 = Ans[i].second;        if (a1 &gt; a2)            swap(a1, a2);        cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; endl;    }}</code></pre><p>可能我的代码写得有点丑，不过思想到位了就行。我也懒得改了。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Codeforces </tag>
            
            <tag> MST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛的舞会The Cow Prom(tarjan求强连通分量板子题)</title>
      <link href="/2019/11/04/lg-2683/"/>
      <url>/2019/11/04/lg-2683/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://www.luogu.org/problem/P2863" target="_blank" rel="noopener">USACO06JAN 牛的舞会The Cow Prom</a></p><center>[USACO06JAN]牛的舞会The Cow Prom</center><p>Description:<br>The N (2 &lt;= N &lt;= 10,000) cows are so excited: it&#39;s prom night! They are dressed in their finest gowns, complete with corsages and new shoes. They know that tonight they will each try to perform the Round Dance.</p><p>Only cows can perform the Round Dance which requires a set of ropes and a circular stock tank. To begin, the cows line up around a circular stock tank and number themselves in clockwise order consecutively from 1..N. Each cow faces the tank so she can see the other dancers.</p><p>They then acquire a total of M (2 &lt;= M &lt;= 50,000) ropes all of which are distributed to the cows who hold them in their hooves. Each cow hopes to be given one or more ropes to hold in both her left and right hooves; some cows might be disappointed.</p><p>约翰的N (2 &lt;= N &lt;= 10,000)只奶牛非常兴奋，因为这是舞会之夜！她们穿上礼服和新鞋子，别 上鲜花，她们要表演圆舞.</p><p>只有奶牛才能表演这种圆舞.圆舞需要一些绳索和一个圆形的水池.奶牛们围在池边站好， 顺时针顺序由1到N编号.每只奶牛都面对水池，这样她就能看到其他的每一只奶牛.</p><p>为了跳这种圆舞，她们找了 M(2&lt;M&lt; 50000)条绳索.若干只奶牛的蹄上握着绳索的一端， 绳索沿顺时针方绕过水池，另一端则捆在另一些奶牛身上.这样，一些奶牛就可以牵引另一些奶 牛.有的奶牛可能握有很多绳索，也有的奶牛可能一条绳索都没有.</p><p>对于一只奶牛，比如说贝茜，她的圆舞跳得是否成功，可以这样检验：沿着她牵引的绳索， 找到她牵引的奶牛，再沿着这只奶牛牵引的绳索，又找到一只被牵引的奶牛，如此下去，若最终 能回到贝茜，则她的圆舞跳得成功，因为这一个环上的奶牛可以逆时针牵引而跳起旋转的圆舞. 如果这样的检验无法完成，那她的圆舞是不成功的.</p><p>如果两只成功跳圆舞的奶牛有绳索相连，那她们可以同属一个组合.</p><p>给出每一条绳索的描述，请找出，成功跳了圆舞的奶牛有多少个组合？</p><p>For the Round Dance to succeed for any given cow (say, Bessie), the ropes that she holds must be configured just right. To know if Bessie&#39;s dance is successful, one must examine the set of cows holding the other ends of her ropes (if she has any), along with the cows holding the other ends of any ropes they hold, etc. When Bessie dances clockwise around the tank, she must instantly pull all the other cows in her group around clockwise, too. Likewise,</p><p>if she dances the other way, she must instantly pull the entire group counterclockwise (anti-clockwise in British English).</p><p>Of course, if the ropes are not properly distributed then a set of cows might not form a proper dance group and thus can not succeed at the Round Dance. One way this happens is when only one rope connects two cows. One cow could pull the other in one direction, but could not pull the other direction (since pushing ropes is well-known to be fruitless). Note that the cows must Dance in lock-step: a dangling cow (perhaps with just one rope) that is eventually pulled along disqualifies a group from properly performing the Round Dance since she is not immediately pulled into lockstep with the rest.</p><p>Given the ropes and their distribution to cows, how many groups of cows can properly perform the Round Dance? Note that a set of ropes and cows might wrap many …</p><p>输入格式<br>Line 1: Two space-separated integers: N and M</p><p>Lines 2..M+1: Each line contains two space-separated integers A and B that describe a rope from cow A to cow B in the clockwise direction.</p><p>输出格式<br>Line 1: A single line with a single integer that is the number of groups successfully dancing the Round Dance.</p><p>输入输出样例<br>输入 #1<br>5 4<br>2 4<br>3 5<br>1 2<br>4 1<br>输出 #1<br>1<br>说明/提示<br>Explanation of the sample:</p><p>ASCII art for Round Dancing is challenging. Nevertheless, here is a representation of the cows around the stock tank:</p><pre><code class="lang-txt">       _1___      /**** \   5 /****** 2  / /**TANK**|  \ \********/   \ \******/  3    \ 4____/  /     \_______/</code></pre><p>Cows 1, 2, and 4 are properly connected and form a complete Round Dance group. Cows 3 and 5 don&#39;t have the second rope they&#39;d need to be able to pull both ways, thus they can not properly perform the Round Dance.</p><p>Problem solving:<br>这道题就是求一下强连通分量(自己一个点形成的强连通分量不可以)的个数。关于这个我也说不清也没啥好说的。单纯记录一下这道题，和tarjan的板子。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int   maxn = 5e4 + 10;int         dfn[maxn], low[maxn], Time = 0, cnt = 0, Stack[maxn], top = -1;bool        vis[maxn];int         n, m;vector&lt;int&gt; V[maxn];inline int read(){    int  x = 0, flag = 1;    char c = getchar();    while (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)    {        if (c == &#39;-&#39;)            flag = -1;        c = getchar();    }    while (c &lt;= &#39;9&#39; &amp;&amp; c &gt;= &#39;0&#39;)    {        x = x * 10 + (int) (c - &#39;0&#39;);        c = getchar();    }    return x * flag;}inline void tarjan(int x){    dfn[x]       = low[x] = Time++;    Stack[++top] = x;    vis[x]       = 1;    for (int i = 0; i &lt; V[x].size(); i++)    {        if (!vis[V[x][i]])            tarjan(V[x][i]), low[x] = min(low[x], low[V[x][i]]);        else            low[x] = min(low[x], dfn[V[x][i]]);    }    if (dfn[x] == low[x])    {        int j, flag = 0;        do        {            j = Stack[top--];            flag++;            vis[j] = 0;        } while (j != x);        if (flag &gt; 1)            cnt++;    }}int main(){    int n, m;    n = read(), m = read();    for (int i = 0; i &lt; m; i++)    {        int x, y;        x = read(), y = read();        V[x].push_back(y);    }    for (int i = 1; i &lt;= n; i++)        if (!dfn[i])            tarjan(i);    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> tarjan </tag>
            
            <tag> luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 479 (Div. 3) E. Cyclic Components</title>
      <link href="/2019/10/23/cf479-E/"/>
      <url>/2019/10/23/cf479-E/</url>
      
        <content type="html"><![CDATA[<p>link: <a href="https://codeforces.com/contest/977/problem/E" target="_blank" rel="noopener">E. Cyclic Components</a></p><p><center>E. Cyclic Components</center><br>Description:<br>You are given an undirected graph consisting of n vertices and m edges. Your task is to find the number of connected components which are cycles.</p><p>Here are some definitions of graph theory.</p><p>An undirected graph consists of two sets: set of nodes (called vertices) and set of edges. Each edge connects a pair of vertices. All edges are bidirectional (i.e. if a vertex a is connected with a vertex b, a vertex b is also connected with a vertex a). An edge can&#39;t connect vertex with itself, there is at most one edge between a pair of vertices.</p><p>Two vertices u and v belong to the same connected component if and only if there is at least one path along edges connecting u and v.</p><p>A connected component is a cycle if and only if its vertices can be reordered in such a way that:</p><ul><li>the first vertex is connected with the second vertex by an edge,</li><li>the second vertex is connected with the third vertex by an edge,</li><li>...</li><li>the last vertex is connected with the first vertex by an edge,</li><li>all the described edges of a cycle are distinct.</li></ul><p>A cycle doesn&#39;t contain any other edges except described above. By definition any cycle contains three or more vertices.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191023131405.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191023131405.webp" class="img-shadow img-margin"></center></a><p>There are 6 connected components, 2 of them are cycles: [7,10,16] and [5,11,9,15].<br>Input<br>The first line contains two integer numbers n and m (1≤n≤2⋅1e5, 0≤m≤2⋅1e5) — number of vertices and edges.</p><p>The following m lines contains edges: edge i is given as a pair of vertices vi, ui (1≤vi,ui≤n, ui≠vi). There is no multiple edges in the given graph, i.e. for each pair (vi,ui) there no other pairs (vi,ui) and (ui,vi) in the list of edges.</p><p>Output<br>Print one integer — the number of connected components which are also cycles.</p><p>Examples<br>input<br>5 4<br>1 2<br>3 4<br>5 4<br>3 5<br>output<br>1<br>input<br>17 15<br>1 8<br>1 12<br>5 11<br>11 9<br>9 15<br>15 5<br>4 13<br>3 13<br>4 3<br>10 16<br>7 10<br>16 7<br>14 3<br>14 4<br>17 6<br>output<br>2<br>Note<br>In the first example only component [3,4,5] is also a cycle.</p><p>The illustration above corresponds to the second example.</p><p>Problem solving:<br>这道题的意思就是给你一个有好多部分组成的图，问里面有几个部分是满足条件的。需要满足的条件是这一部分里面所有的点构成一个循环并且每个点最多两个边。（就比如说题目描述的里面的那个图中的[5,11,9,15]一样，就是一个循环的，但是[3，4，13，14]就不行，因为3到4那还有一条边）</p><p>其实知道了题意之后很自然的就会想到并查集吧（可能是我这两天一直在做。把每个连通块分开存储，再判断每一块是否满足条件即可。分开存储，我这用了并查集实现，父节点相等就说明在一个连通块中。判断是否满足条件的时候，我们可以用每个顶点的度数来写。因为按照题目中的意思也就是说如果这一部分的所有顶点的度数都是2，才可以满足条件。直接输入的时候预处理一下就行啦。可以看代码注释。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int   maxn = 2e5 + 10;int         n, m, in[maxn], f[maxn], ans, fa[maxn];vector&lt;int&gt; V[maxn];int find(int x){    return x != f[x] ? f[x] = find(f[x]) : x;}void join(int x, int y){    x = find(x), y = find(y);    if (x != y)        f[x] = y;} //并查集int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        f[i] = i;    for (int i = 0, u, v; i &lt; m; i++)    {        cin &gt;&gt; u &gt;&gt; v;        in[u]++, in[v]++; //预处理每个结点的度数        join(u, v);    }    for (int i = 1; i &lt;= n; i++)        find(i);  //这一步是必须有的,因为我们处理的时候每个部分的父节点只有一个来表示，不加这一步的话可能导致明明是一个部分的点却被处理成了两个部分。如果还是不理解，可以注释之后输出f[i]和不注释的时候输出f[i]对比着看看。    for (int i = 1; i &lt;= n; i++)    {        V[f[i]].push_back(i);  //把以f[i]为父节点的点存在一起    }    for (int i = 1; i &lt;= n; i++)    {        if (V[i].size() == 0) //如果就没有以i为父节点的点，直接跳过            continue;        int flag = 1;        for (int j = 0; j &lt; V[i].size(); j++)        {            if (in[V[i][j]] != 2)            {                flag = 0;                break;            }        } //如果连通块中的每个节点的度数都是2，答案才能加一        ans += flag;    }    cout &lt;&lt; ans &lt;&lt; endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> dsu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 548 (Div. 2) - C  Edgy Trees</title>
      <link href="/2019/10/21/cf548-C/"/>
      <url>/2019/10/21/cf548-C/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1139/problem/C" target="_blank" rel="noopener">Edgy Trees</a></p><center> Edgy Trees</center><p>Description:<br>You are given a tree (a connected undirected graph without cycles) of n vertices. Each of the n−1 edges of the tree is colored in either black or red.</p><p>You are also given an integer k. Consider sequences of k vertices. Let&#39;s call a sequence [a1,a2,…,ak] good if it satisfies the following criterion:</p><ol><li>We will walk a path (possibly visiting same edge/vertex multiple times) on the tree, starting from a1 and ending at ak.</li><li>Start at a1, then go to a2 using the shortest path between a1 and a2, then go to a3 in a similar way, and so on, until you travel the shortest path between ak−1 and ak.</li><li>If you walked over at least one black edge during this process, then the sequence is good.</li></ol><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191021161402.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191021161402.webp" class="img-shadow img-margin"></center></a><p>Consider the tree on the picture. If k=3 then the following sequences are good: [1,4,7], [5,5,3] and [2,3,7]. The following sequences are not good: [1,4,6], [5,5,5], [3,7,3].</p><p>There are nk sequences of vertices, count how many of them are good. Since this number can be quite large, print it modulo 1e9+7.</p><p>Input<br>The first line contains two integers n and k (2≤n≤1e5, 2≤k≤100), the size of the tree and the length of the vertex sequence.</p><p>Each of the next n−1 lines contains three integers ui, vi and xi (1≤ui,vi≤n, xi∈{0,1}), where ui and vi denote the endpoints of the corresponding edge and xi is the color of this edge (0 denotes red edge and 1 denotes black edge).</p><p>Output<br>Print the number of good sequences modulo 109+7.</p><p>Examples<br>input<br>4 4<br>1 2 1<br>2 3 1<br>3 4 1<br>output<br>252<br>input<br>4 6<br>1 2 0<br>1 3 0<br>1 4 0<br>output<br>0<br>input<br>3 5<br>1 2 1<br>2 3 0<br>output<br>210<br>Note<br>In the first example, all sequences (4^4) of length 4 except the following are good:</p><ul><li>[1,1,1,1]</li><li>[2,2,2,2]</li><li>[3,3,3,3]</li><li>[4,4,4,4]</li></ul><p>In the second example, all edges are red, hence there aren&#39;t any good sequences.</p><p>Problem solving:<br>这道题的意思就是给你一个图，图中的边有黑色的有红色的，让你选k个顶点，保证从这k个顶点中的第一个顶点走到最后一个顶点的路径上一定会经过一条黑色的边。并且可以一个点走很多次，问你可以有多少种不同的k个点的组成方式。</p><p>显然如果两个点之间所有的边都是红色的，不会满足题意，除了这种情况，都满足。所以我们可以用并查集把每个由红色边组成的连通块中包含的点的个数算出来，总共n个点选k个，总选择方案个数是n^k，减去这些连通块中的满足条件的方案个数就是答案。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll    maxn = 1e5 + 10;const ll    mod = 1e9 + 7;ll          k, n, f[maxn];map&lt;ll, ll&gt; ma;ll find(ll x){    return f[x] == x ? x : f[x] = find(f[x]);}void join(ll x, ll y){    x    = find(x), y = find(y);    f[x] = y; ma[y] += ma[x];   // ma用来存储以y为根节点的连通块中节点的个数}ll poww(ll x, ll y){    ll ans = 1;    while (y)    {        if (y &amp; 1)            ans = (ans * x) % mod;        x   = (x * x) % mod;        y &gt;&gt;= 1;    }    return ans;}int main(){    ios::sync_with_stdio(0);    cin &gt;&gt; n &gt;&gt; k;    for (ll i = 1; i &lt;= n; i++)        f[i] = i, ma[i] = 1;    ll ans = poww(n, k);    for (ll i = 1, u, v, w; i &lt; n; i++)    {        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        if (!w)            join(u, v);    }    for (ll i = 1; i &lt;= n; i++)        if (f[i] == i)            ans = (ans - poww(ma[i], k) + mod) % mod;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> dsu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-generator-random | Hexo插件</title>
      <link href="/2019/10/19/plugin/"/>
      <url>/2019/10/19/plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-generator-random"><a href="#hexo-generator-random" class="headerlink" title="hexo-generator-random"></a>hexo-generator-random</h1><p>github地址:<a href="https://github.com/Drew233/hexo-generator-random" target="_blank" rel="noopener">hexo-generator-random</a><br>欢迎大家star</p><h3 id="初衷及历程"><a href="#初衷及历程" class="headerlink" title="初衷及历程"></a>初衷及历程</h3><p>忘了在多久之前看到朋友的博客中有个随机浏览一篇文章的功能，问了一下发现是php中的一个函数（我也不是很懂2333）.但是我用的是hexo，也很想可以有这个功能。一开始没想那么多直接暴力用python爬取了我博客所有文章的链接，然后用一个html跳转，这样做的话会有几个很不方便的地方，比如说每次有新文章都得手动更新一个那个html，太麻烦了。然后我就寻思着做一个实现这个功能的插件。说干就干。可是这方面百度谷歌上面都没有什么让人能看得懂的教程，官网上的中文翻译也是有点模糊不清，英文又看不太懂。那几天心里面充满了想做但是又不知道怎么做的烦躁，用无从下手来描述太合适了。我又是看hexo里面的生成归档，标签什么的代码的，又是看各种插件的代码的。终于是知道了是用的<code>node.js</code>写插件的，好吧还是我太菜了，官网好像有说。我的锅我的锅。一开始想着模仿生成rss订阅的那个插件一样，但是没弄好，就换方向了。那两天做这个做到入魔，逃了好多课（把班长快气死了。。。然后在网上看到一个大佬的生成所有链接向百度提交的插件，<a href="https://gitee.com/eillott/projects" target="_blank" rel="noopener">传送门</a>，传送到他的码云仓库，%一下然后感谢一下，对我帮助非常大。最后终于是做好了。</p><h3 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h3><p>hexo-generator-random是一款hexo插件，作用是生成一个<code>random.html</code>，随即跳转到博客下所有文章中的一篇。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>在<code>public</code>文件夹中生成一个<code>random.html</code>，访问<code>yoursite/random</code>即可随即跳转一篇文章。</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>当前最新版本为1.0.0</p><p>版本2.0.0预计更新内容：在每篇文章的Front-matter中设置一个参数来控制是否添加到随机文章，希望我不会咕咕咕吧</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>本插件用到的依赖如下：</p><ol><li>minimatch</li><li>path</li><li>fs</li><li>object-assign<br>上面四个依赖，前三个一般hexo init之后都会有，但是第四个一般都没有（我自己测试的时候是没有的。<br>所以你需要先安装一下object-assign<pre><code>npm install object-assign</code></pre></li></ol><h4 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h4><p>把本仓库的内容git clone或download到本地，然后把保存到本地的文件夹放在<code>../blog/node_modules</code>文件夹中</p><p>然后，在博客根目录下的<code>package.json</code>里面的<code>dependencies</code>中加入这一行</p><pre><code>&quot;hexo-generator-random&quot;: &quot;^1.0.0&quot;</code></pre><p>注意：如果你是加到最后一行的，在这个上面的一行要加上逗号</p><p>这是完成后的效果</p><pre><code>&quot;dependencies&quot;: {  &quot;hexo&quot;: &quot;^4.0.0&quot;,  &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,  &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,  &quot;hexo-generator-index&quot;: &quot;^1.0.0&quot;,  &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,  &quot;hexo-generator-random&quot;: &quot;^1.0.0&quot;,  &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;,  &quot;hexo-renderer-marked&quot;: &quot;^2.0.0&quot;,  &quot;hexo-renderer-stylus&quot;: &quot;^1.1.0&quot;,  &quot;hexo-server&quot;: &quot;^1.0.0&quot;,  &quot;object-assign&quot;: &quot;^4.1.1&quot;}</code></pre><h4 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h4><p>同上，首先安装依赖</p><pre><code>npm install object-assign</code></pre><p>然后直接安装本插件即可</p><pre><code>npm install hexo-generator-random</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在博客根目录下的<code>_config.yml</code>里面的<code>url</code>需要改成<code>/</code>或者你的域名&#39;</p><h4 id="已知Bug"><a href="#已知Bug" class="headerlink" title="已知Bug"></a>已知Bug</h4><p>不同的主题可能会有其他页面混进随机文章</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>上面的配置如果都是正确的话，当你hexo g之后，在public文件夹下会生成一个random.html。<br>直接访问yoursite/random.html就可以感受这个随机文章了。<br>你甚至可以直接在菜单栏里面加上一个菜单，path写上<code>/random.html/</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 592 (Div. 2)   D. Paint the Tree</title>
      <link href="/2019/10/15/cf592-D/"/>
      <url>/2019/10/15/cf592-D/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1244/problem/D" target="_blank" rel="noopener">D. Paint the Tree</a></p><center>D. Paint the Tree</center><p>Description:<br>You are given a tree consisting of n vertices. A tree is an undirected connected acyclic graph.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191015112124.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191015112124.webp" class="img-shadow img-margin"></center></a><br>Example of a tree<br>You have to paint each vertex into one of three colors. For each vertex, you know the cost of painting it in every color.</p><p>You have to paint the vertices so that any path consisting of exactly three distinct vertices does not contain any vertices with equal colors. In other words, let&#39;s consider all triples (x,y,z) such that x≠y,y≠z,x≠z, x is connected by an edge with y, and y is connected by an edge with z. The colours of x, y and z should be pairwise distinct. Let&#39;s call a painting which meets this condition good.</p><p>You have to calculate the minimum cost of a good painting and find one of the optimal paintings. If there is no good painting, report about it.</p><p>Input<br>The first line contains one integer n (3≤n≤100000) — the number of vertices.</p><p>The second line contains a sequence of integers c1,1,c1,2,…,c1,n (1≤c1,i≤1e9), where c1,i is the cost of painting the i-th vertex into the first color.</p><p>The third line contains a sequence of integers c2,1,c2,2,…,c2,n (1≤c2,i≤1e9), where c2,i is the cost of painting the i-th vertex into the second color.</p><p>The fourth line contains a sequence of integers c3,1,c3,2,…,c3,n (1≤c3,i≤1e9), where c3,i is the cost of painting the i-th vertex into the third color.</p><p>Then (n−1) lines follow, each containing two integers uj and vj (1≤uj,vj≤n,uj≠vj) — the numbers of vertices connected by the j-th undirected edge. It is guaranteed that these edges denote a tree.</p><p>Output<br>If there is no good painting, print −1.</p><p>Otherwise, print the minimum cost of a good painting in the first line. In the second line print n integers b1,b2,…,bn (1≤bi≤3), where the i-th integer should denote the color of the i-th vertex. If there are multiple good paintings with minimum cost, print any of them.</p><p>Examples<br>input<br>3<br>3 2 3<br>4 3 2<br>3 1 3<br>1 2<br>2 3<br>output<br>6<br>1 3 2<br>input<br>5<br>3 4 2 1 2<br>4 2 1 5 4<br>5 3 2 1 1<br>1 2<br>3 2<br>4 3<br>5 3<br>output<br>-1<br>input<br>5<br>3 4 2 1 2<br>4 2 1 5 4<br>5 3 2 1 1<br>1 2<br>3 2<br>4 3<br>5 4<br>output<br>9<br>1 3 2 1 3<br>Note<br>All vertices should be painted in different colors in the first example. The optimal way to do it is to paint the first vertex into color 1, the second vertex — into color 3, and the third vertex — into color 2. The cost of this painting is 3+2+1=6.</p><p>Problem solving:<br>这道题的意思就是给你一个树和三种颜色，每个点染这三种颜色都会有不同的消费，并且让任意三个可以连起来的顶点都不能有同一种颜色，问你在最优策略下，怎样染色花费最少。如果不能满足任意三个可以连起来的顶点不会出现同一种颜色，输出<code>-1</code>，如果有满足条件的，首先输出最小花费，然后输出每个顶点的染色情况。</p><p>一开始还以为是多复杂的图论题，后来发现只是个思维题。。。首先我们要知道</p><ol><li>如果这个树不是一条链状的，就一定不能满足任意三个可以连起来的顶点不会出现同一种颜色的条件</li><li>如果前三个顶点的颜色确定了，那么后面所有的顶点的颜色就都确定了。也就是说假设前三个顶点的颜色为ABC，那么这颗链状树的染色情况就是<code>ABCABCABCABCABC......</code>，所以只要我们知道了前三个点的颜色，后面的顶点直接对三取余就可以知道它的颜色了。</li></ol><p>证明我们先放在后面。现在你已经知道这两个条件了。那么是不是就很简单了，直接暴力就行。首先判断一下这个树是不是一条链，如果不是直接输出&#39;-1&#39;，如果是就先用dfs算出每个顶点的层数，然后枚举前三个点的情况，这总共才六种情况，暴力枚举即可，算出最小值，更新最小值的时候顺便更新一下每个点的颜色。这里因为颜色都是确定的，所以我们只看第i个顶点的层数对3的余数即可知道它的颜色。</p><p>证明：</p><ol><li>如果一条树是非链性的，比如说这样的一棵树<a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191015144917.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191015144917.webp" class="img-shadow img-margin"></center></a>1和2相邻，颜色不能相同，这已经用了两种了。因为123和124都是联通的，所以可以知道3和4都是第三种颜色。但是这样的话，234中就有了颜色相同的点，所以必须是链状的才能满足题目中的要求。</li><li>假设一个链状树ABCDEFG，ABC的颜色确定为123的话，那么D的颜色一定是1，因为BCD中不能出现颜色相同的。即证2。</li></ol><p>所以这道题就很简单了，判断后暴力枚举。具体实现的时候会有一些细节需要注意，具体看代码注释<br>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb    push_backconst int   maxn = 1e5 + 10;int         n, c[maxn][3], Ans[maxn], C[5] = { 0, 1, 2, 3 }, dep[maxn], in[maxn];ll          s[3][3];vector&lt;int&gt; V[maxn];void dfs(int u, int f){    for (int i = 0; i &lt; V[u].size(); i++)    {        if (V[u][i] != f)        {            dep[V[u][i]] = dep[u] + 1;            dfs(V[u][i], u);        }    }}int main(){    cin &gt;&gt; n;    for (int i = 0; i &lt; 3; i++)    {        for (int j = 1; j &lt;= n; j++)        {            cin &gt;&gt; c[j][i];        }    }    for (int i = 1, u, v; i &lt; n; i++)    {        cin &gt;&gt; u &gt;&gt; v;        V[v].pb(u); V[u].pb(v);        in[u]++, in[v]++;        if (in[u] &gt; 2 || in[v] &gt; 2) //这里用来判断是不是链状的        {            puts(&quot;-1&quot;);            return 0;        }    }    for (int i = 1; i &lt;= n; i++)    {        if (in[i] == 1) //找到根节点然后开始dfs，算出每个点的层数        {            dfs(i, 0);            break;        }    }    for (int i = 1; i &lt;= n; i++)        for (int j = 0; j &lt; 3; j++)            s[dep[i] % 3][j] += c[i][j];//初始化处理对3取模分别为0，1，2的顶点们染成三种颜色之一的颜色的花费，方便下面暴力枚举的时候使用    ll ans = 0x3f3f3f3f3f3f3f3f;    do    {        ll mid = 0;        for (int i = 1; i &lt;= 3; i++)            mid += s[i - 1][C[i] - 1];        if (mid &lt; ans)        {            ans = mid;            for (int i = 1; i &lt;= 3; i++)                Ans[i] = C[i];        }    } while (next_permutation(C + 1, C + 4));//暴力枚举，三种颜色，三个顶点的情况    cout &lt;&lt; ans &lt;&lt; endl;    for (int i = 1; i &lt;= n; i++)        cout &lt;&lt; Ans[dep[i] % 3 + 1] &lt;&lt; &quot; &quot;;    return 0;}</code></pre><p>代码里面有很多对下标的处理，一定要注意。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> dfs </tag>
            
            <tag> thinking </tag>
            
            <tag> codedforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU - 6222   Heron and His Triangle</title>
      <link href="/2019/10/13/Triangle/"/>
      <url>/2019/10/13/Triangle/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://acm.hdu.edu.cn/showproblem.php?pid=6222" target="_blank" rel="noopener">Heron and His Triangle HDU - 6222 </a></p><p><center>Heron and His Triangle</center><br>Description:<br>A triangle is a Heron’s triangle if it satisfies that the side lengths of it are consecutive integers t-1, t, t+ 1 and thatits area is an integer. Now, for given n you need to find a Heron’s triangle associated with the smallest t bigger<br>than or equal to n.</p><p>Input<br>The input contains multiple test cases. The first line of a multiple input is an integer T (1 ≤ T ≤ 30000) followedby T lines. Each line contains an integer N (1 ≤ N ≤ 10^30).</p><p>Output<br>For each test case, output the smallest t in a line. If the Heron’s triangle required does not exist, output -1.</p><p>Sample Input<br>4<br>1<br>2<br>3<br>4</p><p>Sample Output<br>4<br>4<br>4<br>4</p><p>Problem solving:<br>这道题的意思是给你一个n，让你求一个大于n的最小的i，满足边为i，i+1，i-1的三角形的面积是整数。然后输出<br>这道题的n范围是10^30，肯定不能直接暴力写。队友用三角形的面积公式，打了个表，看了前满足面积是整数的i的几个数，对着那几个数看了看，发现一个规律。ans[i]=4*ans[i-1]+ans[i-2]，也不知道对不对，就用python打了个表，把前10^30里面满足条件的值都写了出来，因为不能用python交，所以那些数都用了字符串存了起来。最后输入之后直接在字符串数组中找到第一个大于输入的就行了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define fast ios::sync_with_stdio(false)const int mod=1e9+7;const int maxn=1e5+10;string s[120]={&quot;4&quot;,&quot;14&quot;,&quot;52&quot;,&quot;194&quot;,&quot;724&quot;,&quot;2702&quot;,&quot;10084&quot;,&quot;37634&quot;,&quot;140452&quot;,&quot;524174&quot;,&quot;1956244&quot;,&quot;7300802&quot;,&quot;27246964&quot;,&quot;101687054&quot;,&quot;379501252&quot;,&quot;1416317954&quot;,&quot;5285770564&quot;,&quot;19726764302&quot;,&quot;73621286644&quot;,&quot;274758382274&quot;,&quot;1025412242452&quot;,&quot;3826890587534&quot;,&quot;14282150107684&quot;,&quot;53301709843202&quot;,&quot;198924689265124&quot;,&quot;742397047217294&quot;,&quot;2770663499604052&quot;,&quot;10340256951198914&quot;,&quot;38590364305191604&quot;,&quot;144021200269567502&quot;,&quot;537494436773078404&quot;,&quot;2005956546822746114&quot;,&quot;7486331750517906052&quot;,&quot;27939370455248878094&quot;,&quot;104271150070477606324&quot;,&quot;389145229826661547202&quot;,&quot;1452309769236168582484&quot;,&quot;5420093847118012782734&quot;,&quot;20228065619235882548452&quot;,&quot;75492168629825517411074&quot;,&quot;281740608900066187095844&quot;,&quot;1051470266970439230972302&quot;,&quot;3924140458981690736793364&quot;,&quot;14645091568956323716201154&quot;,&quot;54656225816843604128011252&quot;,&quot;203979811698418092795843854&quot;,&quot;761263020976828767055364164&quot;,&quot;2841072272208896975425612802&quot;,&quot;10603026067858759134647087044&quot;,&quot;39571031999226139563162735374&quot;,&quot;147681101929045799118003854452&quot;,&quot;551153375716957056908852682434&quot;,&quot;2056932400938782428517406875284&quot;,&quot;7676576228038172657160774818702&quot;,&quot;28649372511213908200125692399524&quot;,&quot;106920913816817460143341994779394&quot;,&quot;399034282756055932373242286718052&quot;,&quot;1489216217207406269349627152092814&quot;,&quot;5557830586073569145025266321653204&quot;,&quot;20742106127086870310751438134520002&quot;,&quot;77410593922273912097980486216426804&quot;,&quot;288900269562008778081170506731187214&quot;,&quot;1078190484325761200226701540708322052&quot;,&quot;4023861667741036022825635656102100994&quot;,&quot;15017256186638382891075841083700081924&quot;,&quot;56045163078812495541477728678698226702&quot;,&quot;209163396128611599274835073631092824884&quot;,&quot;780608421435633901557862565845673072834&quot;,&quot;2913270289613924006956615189751599466452&quot;,&quot;10872472737020062126268598193160724792974&quot;,&quot;40576620658466324498117777582891299705444&quot;,&quot;151434009896845235866202512138404474028802&quot;,&quot;565159418928914618966692270970726596409764&quot;,&quot;2109203665818813240000566571744501911610254&quot;,&quot;7871655244346338341035574016007281050031252&quot;,&quot;29377417311566540124141729492284622288514754&quot;,&quot;109638014001919822155531343953131208104027764&quot;,&quot;409174638696112748497983646320240210127596302&quot;,&quot;1527060540782531171836403241327829632406357444&quot;,&quot;5699067524434011938847629318991078319497833474&quot;,&quot;21269209556953516583554114034636483645584976452&quot;,&quot;79377770703380054395368826819554856262842072334&quot;,&quot;296241873256566700997921193243582941405783312884&quot;,&quot;1105589722322886749596315946154776909360291179202&quot;,&quot;4126117016034980297387342591375524696035381403924&quot;,&quot;15398878341817034439953054419347321874781234436494&quot;,&quot;57469396351233157462424875086013762803089556342052&quot;,&quot;214478707063115595409746445924707729337576990931714&quot;,&quot;800445431901229224176560908612817154547218407384804&quot;,&quot;2987303020541801301296497188526560888851296638607502&quot;,&quot;11148766650265975981009427845493426400857968147045204&quot;,&quot;41607763580522102622741214193447144714580575949573314&quot;,&quot;155282287671822434509955428928295152457464335651248052&quot;,&quot;579521387106767635417080501519733465115276766655418894&quot;,&quot;2162803260755248107158366577150638708003642730970427524&quot;,&quot;8071691655914224793216385807082821366899294157226291202&quot;,&quot;30123963362901651065707176651180646759593533897934737284&quot;,&quot;112424161795692379469612320797639765671474841434512657934&quot;,&quot;419572683819867866812742106539378415926305831840115894452&quot;,&quot;1565866573483779087781356105359873898033748485925950919874&quot;,&quot;5843893610115248484312682314900117176208688111863687785044&quot;,&quot;21809707866977214849469373154240594806801003961528800220302&quot;};int main(){    int n;string ss;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;ss;        for(int i=0;i&lt;120;i++)        {            int x,y;            x=s[i].size(),y=ss.size();            if(x&lt;y)    continue;            if(x==y)            {                if(s[i]&gt;=ss)                {                    cout&lt;&lt;s[i]&lt;&lt;endl;                    break;                }            }            if(x&gt;y)            {                cout&lt;&lt;s[i]&lt;&lt;endl;                break;            }        }    }    return 0;}</code></pre><p>很长的一个表(2333</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA 7263 - Today Is a Rainy Day</title>
      <link href="/2019/10/09/uva7263/"/>
      <url>/2019/10/09/uva7263/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://vjudge.net/contest/332255#problem/C" target="_blank" rel="noopener">Vjudge</a><br>      　　　<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=5275" target="_blank" rel="noopener">UVA</a></p><p>Description:<br>PDF题面:<a href="https://vj.z180.cn/6b8ba036b2d9f7d4d3608e470fd6d7ff?v=1570346524" target="_blank" rel="noopener">Today is a rainy day</a><br>Today is a rainy day. The temperature is apparently lower than yesterday. Winter is coming. It always<br>leaves people feeling fatigued and tired.<br>Lee hasn’t prepared for winter yet. As he wakes up this morning, he looks out of the window.<br>Yesterday’s shining sunlight can no longer be seen. It is dark outside. The sky looks so heavy that it<br>may collapse down at any moment. Lee gets out of his bed, shakes his head slightly to make himself<br>more awake. But it’s of no use for him. Then he goes to the restroom and washes up.<br>Lee has a class in fifteen minutes. If he sets out immediately, he may gets to the classroom on time.<br>But he is not in the mood to do so. He decides to skip class and does something more interesting to<br>train his mind.<br>He takes out a draft paper and writes a list of digits using a dice. It is obvious that the digits are<br>all between 1 and 6. And then he applies two kind of modifications to the digits. The first kind is<br>to modify one digit into another. The second kind is to modify one kind of digits into another. For<br>example, he can modify “12123” to “12121” using the first kind of modification, or modify “12123” to<br>“13133” using the second kind of modification. In the process of modification, all digits should be in<br>{1, 2, 3, 4, 5, 6};<br>After a few modifications, he feels tired but pleased. He’s got a list of digits which is very different<br>from the original one. Thinking of the next thing to do, Lee becomes a little excited. He is going to<br>figure out the least number of modifications to transform the final list back to the original one using<br>the same rules.<br>Lee made it in a very short time. Can you do this like him?<br>Input<br>There are up to 100 test cases.<br>For each test case, there are two lines containing two lists of digits, representing the original list<br>and the final list in order. The digits are all between 1 and 6. It is guaranteed that two lists are of<br>same length. The length will not be greater than 110.<br>Output<br>For each test case, output one integer, the answer.<br>Sample Input<br>22345611<br>12345611<br>2234562221<br>1234561221<br>2234562211<br>1234561111<br>22345622112<br>12345611111<br>654321654321654321654321<br>123456123456123456123456<br>Sample Output<br>1<br>2<br>3<br>3<br>11</p><p>Problem solving:<br>这道题的意思就是给你两个只有1~6这六个数字组成的字符串，有一种操作是把一个字符串中的一类字符串都换成另一个。比如说这个字符串里面的1全部换成2，第二种操作就是单独的换一个。都是可以任意换的，问你最少换几次，能使第二个字符串和第一个字符串相等。</p><p>一开始信誓旦旦的跟队友说这是一道dp的题，然后心安理得的训练赛的时候跳过。<br>后来补题的时候发现，哦，原来是BFS，啊！怎么能这么写，太妙了吧。（好了不<del>BB</del>了，我们开始讨论这个解题思路</p><p>首先我们要知道因为这里要求的步数是最小的，所以我们要尽可能地使用更换一类的操作，才会使总操作数最小。关于这个的证明，网上搜出来的题解大多没有具体说，因为这个确实是属于“一想就是这样的啊”的结论。但是我们想一下，如果现在有两个串分别是”123456“和”123455“，这个时候当然是一次，并且这一次无论是哪种操作，结果都是一样的。但是如果这个串是”123444“和”123333“，如果你一个一个换，需要四次，但是如果你先把&#39;3&#39;全部换成&#39;4&#39;，再对那个剩下的变成4的3的处理其实就跟上一种情况说的一样了。其实总结一句话说就是，只要换一个能解决的换一类都能解决。（仅是个人理解）</p><p>并且这个字符串中只是由1~6这六个字符串组成的，所以我们考虑每一种第二类变化的话，会有将近6^6种变化。所以我们可以通过使用一个六位的字符串来标示出来这将近6^6种变化以及变换所需要的次数计算出来并存起来，这就用到了BFS。然后枚举每一种情乱，再看剩下会有哪些不同的数再采用一个变的那种变化，取最小值即可。</p><p>网上大部分题解说到这就丢代码了。可能高智商比较好明白，但是我整整想了一天才搞明白。<br>&#39;通过使用一个六位的字符串来标示出来这将近6^6种变化以及变换所需要的次数计算出来并存起来&#39;这句话就是重点，我门这个算出来的是每一位数字变化之后的情况，所以我们初始情况下首先定义一个”123456“的字符串进行bfs。这里再说下去，会更加抽象和不好理解，我给代码加上了我认为的完全清晰的注释。可以一边看代码一边看注释理解这句话。</p><p>Code:</p><pre><code class="lang-c++">// 注：下面注释中无特别说明的均表示变化一类的那种变化#include &lt;bits/stdc++.h&gt;using namespace std;const int        maxn = 1e6 + 10;const int        INF = 0x3f3f3f3f;string           x, y;map&lt;string, int&gt; ma;   // 记录从”123456“变化到每种情况所需要的次数queue&lt;string&gt;    que;  //BFS需要用到string           pre[maxn];  //存下来每一种可以变化到的情况，方便以后遍历int              pos = 0;void init()  //预处理出来每一种变化情况{    string a, b;    ma[&quot;123456&quot;] = 1;   //标记123456已经出现过，避免死循环    que.push(&quot;123456&quot;);    pre[++pos] = &quot;123456&quot;; //存入string数组    while (!que.empty())    {        string mid = que.front(), Mid = &quot;000000&quot;;        que.pop();        for (int i = 0; i &lt; 6; i++)  //这个双重for循环就是模拟的把所有的i+1换成j+1        {            for (int j = 0; j &lt; 6; j++)            {                if (i == j)     //如果这两个相等，就没必要换下去了                    continue;                for (int k = 0; k &lt; 6; k++)  //只有6个字符，所以这里循环6次就行                {                    if (mid[k] == &#39;1&#39; + i)    //如果当前情况下，出现了一个跟i+1的值相等的数就需要变化成j+1                        Mid[k] = &#39;1&#39; + j;                    else                        Mid[k] = mid[k];        //如果不是i+1，不需要变化                }                if (!ma[Mid])   //如果ma[mid]为0，说明这种情况还没记录过                {                    ma[Mid] = ma[mid] + 1;  //Mid这种情况是mid变化了一次过来的，所以变化次数加一                    que.push(Mid);                    pre[++pos] = Mid;   //存进字符串数组                }            }        }    }}int solve(){    int ans = INF, l = x.size();   //因为答案是一个最小值，要取min，所以初始化为一个极大值    for (int i = 1; i &lt;= pos; i++) //遍历每一种可以变化到的情况    {        int cnt = ma[pre[i]] - 1;  //这种情况下的答案初始化为已经变化了的次数，因为我们计算变化次数的时候123456也算了一次，所以要减一        for (int j = 0; j &lt; l; j++)  //遍历需要变换的字符串的每一个字符，判断它与当前这种变换的情况下的结果需要再进行几次第一次变化才可以相等        {            if (pre[i][y[j] - &#39;0&#39; - 1] != x[j])   //这一步真的是关键，pre[i]代表的是当前遍历到的这种变化情况下123456每一个字符所对应的变化到的字符，因为我们一开始就是初始化的123456，所以pre[i][y[j] - &#39;0&#39; - 1]代表的就是123456这六个字符在这一次变化下的结果。这个理解了就很简单了                cnt++;   //如果pre[i][y[j] - &#39;0&#39; - 1]与x[j]不等，当前情况答案加一，因为需要一次第一种变化        }        ans = min(ans, cnt);  //答案每次更新为最小值    }    return ans;}int main(){    init();  //预处理    while (cin &gt;&gt; x &gt;&gt; y)    {        cout &lt;&lt; solve() &lt;&lt; endl;    }}</code></pre><p>可能看完了你还不是很明白，其实理解的关键就在于BFS预处理得到的结果以及<code>pre[i][y[j] - &#39;0&#39; - 1] != x[j])</code>的理解。<br>这里我在说一遍（没用的话也没事，如果帮到了你我很荣幸）：BFS中从123456开始搜索，每次得到的情况都是其中一个数字变化成另外一个数字的情况。例如，pre字符串数组中会有223456，323456，111111等。代表的就是对应位置上的数字经过了ma[pre[i]]次变化之后变成的数字。初始状态下字符串为123456，正好跟下标是对应的，所以我们可以直接用pre[i][S[i]-&#39;0&#39;-1]来表示当前pre[i]的情况下变化成的数字，在跟之前的字符串的这个位置的字符进行比较，如果不等，就再来一次只变化一个的操作，答案加一。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The 2016 ACM-ICPC Asia China-Final Contest  L - World Cup</title>
      <link href="/2019/10/05/nanshou/"/>
      <url>/2019/10/05/nanshou/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/gym/101194/attachments" target="_blank" rel="noopener">L - World Cup</a></p><center>World Cup</center><p>pdf题面: <a href="https://vj.z180.cn/e4ddab4bbddb4d48602cd7ef31d6c6fa?v=1570161746" target="_blank" rel="noopener">World Cup</a><br>Description:<br>Here is World Cup again, the top 32 teams come together to fight for the World Champion.<br>The teams are assigned into 8 groups, with 4 teams in each group. Every two teams in the same<br>group will play a game (so there are totally 6 games in each group), and the winner of this game<br>gets 3 points, loser gets 0 point. If it is a tie game, both teams get 1 point.<br>After all games finished, we get the scoreboard, but we forget the result of each game, can you<br>help us to figure the result of each game? We only care about the win/lose/tie result of each<br>game, but we don’t care the goals in each game.<br>Input<br>The input starts with one line containing exactly one integer T, which is the number of test cases.<br>Each test case contains four space-separated integers A, B, C, D, in a line, which indicate the<br>points each team gets after all 6 games.<br>Output<br>For each test case, output one line containing Case #x: y, where x is the test case number<br>(starting from 1) and y is “Yes” if you can point out the result of each game, or “No” if there are<br>multiple game results satisfy the scoreboard, or “Wrong Scoreboard” if there is no game result<br>matches the scoreboard.<br>Limits<br>• 1 ≤ T ≤ 100.<br>• 0 ≤ A, B, C, D ≤ 100.<br>Sample input<br>3<br>9 6 3 0<br>6 6 6 0<br>10 6 3 0<br>Sample Output<br>Case #1: Yes<br>Case #2: No<br>Case #3: Wrong Scoreboard<br>Note<br>In sample case #1, the only scenaro will be: the first team wins all the three games it plays, the<br>second team loses to the first team and wins the other two, the third team only wins the game<br>with the fourth, and the fourth team lose all the games.<br>In sample case #2, the fourth team loses all the games, and the first three teams get into a<br>winning-cycle, but there may be two different winning-cycles: first team wins second team, second<br>team wins third team, third team wins first team OR first team wins third team, third team wins<br>second team, second team wins first team. We can’t figure which winning-cycle is the actual game<br>result.<br>In sample case #3, the first team get 10 points, but no team could get more than 9 points by<br>play three games, so it is a wrong scoreboard.</p><p>Problem solving:<br>这道题的意思就是有四个队，每两个队之间都要进行一场比赛，获胜的队加三分，平局的话两个队都加一分。现在给你一个最后的分数的情况，问你可以不可以判断出比赛中胜负的情况。<br>如果可以就输出Yes，如果多种胜负情况都会出现这种结果，就输出No，如果不会有任何一种情况导致这种结果的出现就输出Wrong Scoreboard。</p><p>这里用一个结构体来表示四个队两两个队之间的关系。</p><p>总共六场比赛，每次比赛三种结果，用dfs枚举一下，算出所有情况，因为只有四个结果，并且每个结果都是小于等于9的数字，所以我们可以直接加成字符串存起来，然后用map进行标记。按照上面说的就是如果map的string的值为0就输出Wrong，值为1的话输出Yes，否则输出No。</p><p>其实这个dfs的过程还是很有意思的。注意回溯的过程。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int score[4], T, jie[4];struct node{    int a, b;}                pk[6] = { 0, 1, 0, 2, 0, 3, 1, 2, 1, 3, 2, 3 };map&lt;string, int&gt; ma;void DFS(int n){    if (n == 6)    {        string mid;        for (int i = 0; i &lt; 4; i++)            mid += score[i];        ma[mid]++;        return;    }    for (int i = 0; i &lt; 3; i++)    {        int x = score[pk[n].a], y = score[pk[n].b];        if (i == 0)            score[pk[n].a] += 3;        else if (i == 1)            score[pk[n].b] += 3;        else            score[pk[n].a] += 1, score[pk[n].b] += 1;        DFS(n + 1);        score[pk[n].a] = x; score[pk[n].b] = y;    }}int main(){    DFS(0);    cin &gt;&gt; T;    for (int k = 1; k &lt;= T; k++)    {        string mid;        for (int i = 0; i &lt; 4; i++)        {            cin &gt;&gt; jie[i]; mid += jie[i];        }        printf(&quot;Case #%d: &quot;, k);        if (ma[mid] == 0)            puts(&quot;Wrong Scoreboard&quot;);        else if (ma[mid] == 1)            puts(&quot;Yes&quot;);        else            puts(&quot;No&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现已更新自动实现随机文章（插件）| Hexo实现随机文章 （暴力实现）</title>
      <link href="/2019/10/03/random/"/>
      <url>/2019/10/03/random/</url>
      
        <content type="html"><![CDATA[<p>实现随机文章功能的插件：<br>博客链接：<a href="https://cndrew.cn/2019/10/19/plugin/" target="_blank" rel="noopener">https://cndrew.cn/2019/10/19/plugin/</a><br>Github链接： <a href="https://github.com/Drew233/hexo-generator-random" target="_blank" rel="noopener">https://github.com/Drew233/hexo-generator-random</a><br>欢迎大家使用</p><p>在wordpress里面随机文章的实现好像是专门有一个php函数可以获得所有的文章链接然后随机一下。但是html里面似乎是没有类似的，所以我产生了一个神奇的想法。</p><p>把我的所有文章链接放进去，然后随机跳转。难点就是所有文章链接怎么搞，如果你的文章少还好说，直接cv就行。但是就像我一样，150+的文章，甚至比我的还多，就会很难受，所以看下去吧，</p><p>先总体说一下步骤</p><ol><li>使用python爬取博客所有链接，然后筛选出来文章的链接</li><li>使用html实现随机链接的跳转。</li></ol><p>首先我们需要爬取所有链接，直接用python实现就很方便</p><pre><code class="lang-python">import requestsfrom bs4 import BeautifulSoupdef getHTMLText(url):    &#39;&#39;&#39;    此函数用于获取网页的html文档    &#39;&#39;&#39;    try:        #获取服务器的响应内容，并设置最大请求时间为6秒        res = requests.get(url, timeout = 6)        #判断返回状态码是否为200        res.raise_for_status()        #设置该html文档可能的编码        res.encoding = res.apparent_encoding        #返回网页HTML代码        return res.text    except:        return &#39;产生异常&#39;def main():    &#39;&#39;&#39;    主函数    &#39;&#39;&#39;    b=[]    r=[]    #目标网页，这个可以换成一个你喜欢的网站    for i in range (1,16):# 因为直接爬取域名下的不知道为什么会只能爬第一页的，所以这里专门处理一下页数，按照你的页数更改这个16的值        if i==1:            url = &#39;https://cndrew.cn&#39;        else:            url = &#39;https://cndrew.cn/page/&#39;+str(i)        # print(url)        demo = getHTMLText(url)        #解析HTML代码        soup = BeautifulSoup(demo, &#39;html.parser&#39;)        #模糊搜索HTML代码的所有包含href属性的&lt;a&gt;标签        a_labels = soup.find_all(&#39;a&#39;, attrs={&#39;href&#39;: True})        #获取所有&lt;a&gt;标签中的href对应的值，即超链接        for a in a_labels:            # print(a.get(&#39;href&#39;))            b.append(a.get(&#39;href&#39;))    print(&#39;Over&#39;)    # for i in b:    #     print(i)    print(&#39;over&#39;)    for x in b:        if x not in a:            a.append(x)    for i in a:        print(i)    # f=open(&#39;../out.txt&#39;,&#39;w&#39;)    # for i in a:    #     f.write(str(i))    #     f.write(&#39;\n&#39;)    # f.close()main()</code></pre><p>把上面代码中所有的cndrew.cn修改成你的域名，并修改你的page数<br>然后运行一遍，因为这里输出到文件一直出现中文编码（我这有些中文的链接）的错误，所以写进文件一直出错，如果你的没有的话，可以直接把最下面那几行的注释取消。如果你不知道该取消那些注释或者跟我一样有中文链接，那就跟我一样，直接把运行框里的所有链接复制粘贴出来。</p><p>然后你会发现，这里面除了文章的链接还有各种各样的，比如说标签啊，分类啊，甚至是友链啊什么的。手动删就完事了。其实这一步也可以用python甚至是c语言实现，但是太麻烦了，还是手动。你把你想随机链接到的页面留下就行。</p><p>所有链接处理好之后，为了在随机的那个html里面的格式，我们可以使用python进行格式的修改</p><pre><code class="lang-python">f = open(&#39;../out.txt&#39;)flag = 0res=[]for line in f.readlines():    line = line.strip(&#39;\n&#39;)#取消readline的换行    s=&quot;urls[&quot;+str(flag)+&quot;]= \&quot;https://cndrew.cn&quot;    s+=line+&quot;\&quot;;&quot;    flag=flag+1    res.append(s)f=open(&#39;../out2.txt&#39;,&#39;w&#39;)#写进文件for i in res:    f.write(str(i))    f.write(&#39;\n&#39;)f.close()</code></pre><p>这一步其实就是把所有的链接补全，并且直接套用html中需要用到的格式。注意用你的域名替换掉cndrew.cn。</p><p>等你上面执行完之后，你的<code>out2.txt</code>里面就是你所需要的所有的连接了，并且是已经套好了html中所需要用到的格式。下一步</p><pre><code class="lang-html">&lt;body onload=&quot;javascript:dogo();&quot;&gt;&lt;script&gt;function dogo(){    var urls = new Array();    urls[0] = &quot;1.HTML&quot;;//    urls[1] = &quot;2.HTML&quot;;//    urls[2] = &quot;3.HTML&quot;;//    urls[3] = &quot;4.HTML&quot;;//    urls[4] = &quot;5.HTML&quot;;//把这里的内容替换掉    n = Math.floor(Math.random()*5);    location.href= urls[n];}&lt;/script&gt;</code></pre><p>把你的<code>out2.txt</code>文件中的所有<code>urls[i]=&quot;&quot;</code>复制，替换到上面的我带有注释的地方</p><p>然后剩下的就是在hexo菜单或者随便你想要的地方添加一个页面。<br>例如你想在hexo的菜单添加一个页面<br>首先在<code>../blog/source/</code>中新建一个<code>random</code>文件夹，文件夹的名字是可以自定义的。<br>然后再这个文件夹中新建一个&#39;index.html&#39;文件，把上面那一步的html代码复制粘贴过来，在最前面加上<code>layout:false</code>.</p><pre><code class="lang-html">---layout: false---&lt;body onload=&quot;javascript:dogo();&quot;&gt;&lt;script&gt;function dogo(){    var urls = new Array();    urls[0] = &quot;1.HTML&quot;;//    urls[1] = &quot;2.HTML&quot;;//    urls[2] = &quot;3.HTML&quot;;//    urls[3] = &quot;4.HTML&quot;;//    urls[4] = &quot;5.HTML&quot;;//把这里的内容替换掉    n = Math.floor(Math.random()*5);    location.href= urls[n];}&lt;/script&gt;</code></pre><p>然后每次你新建一个文章，在你的random目录下的index.html中就新加一个链接就行了。</p><p>至此，这个功能就添加完成了，其实这只是个无脑暴力的做法，还是期待大佬们做出来直接封装好的插件之类的东东。</p><p><a href="/random">点我尝试随机文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> html </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Preliminary Contest for ICPC Asia Shanghai 2019   K. Peekaboo</title>
      <link href="/2019/10/02/Peekaboo/"/>
      <url>/2019/10/02/Peekaboo/</url>
      
        <content type="html"><![CDATA[<p>前排提示: <a href="https://boctorio.com/2019/10/01/%E5%9C%86%E4%B8%8A%E6%95%B4%E7%82%B9%E4%B8%AA%E6%95%B0%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">BLY倾情力作</a></p><p>题目链接: <a href="https://nanti.jisuanke.com/t/41421" target="_blank" rel="noopener">Peekaboo</a></p><center>Peekaboo</center><p>Description:<br>Tension is in the air! You are playing a game Peekaboo with Kblack and CSL. All of you are in a 2D grid. You are at point (0, 0)(0,0). Kblack and CSL has hidden themselves at some lattice point (xx-coordinate and yy-coordinate are both integers) out of your sight, but you have the psycho connection that tells you the distance between you and Kblack is aa, the distance between you and CSL is bb and the distance between Kblack and CSL is cc. You now want to know all the possible positions of Kblack and CSL.</p><p>InputFile<br>The first line is an integer TT (1≤T≤20), which is the number of cases.</p><p>The next TT lines each have three space-separated integers a, b, ca,b,c (1≤a,b,c≤1e9), respectively denoting the distance in the problem statement.</p><p>OutputFile<br>For each case, you should output firstly in a line, an integer nn, which is the number of possible positions.</p><p>For the next nn lines, each line contains four space-separated integers x1, y1, x2, y2<br>which are the Kblack&#39;s position and CSL&#39;s position. In particular, the possible positions should follow the lexicographical order. The data guarantees that ∑n≤1e5</p><p>样例输入<br>2<br>1 1 1<br>3 4 5<br>样例输出<br>0<br>8<br>-3 0 0 -4<br>-3 0 0 4<br>0 -3 -4 0<br>0 -3 4 0<br>0 3 -4 0<br>0 3 4 0<br>3 0 0 -4<br>3 0 0 4</p><p>Problem solving:<br>这道题的意思就是你在原点，即（0，0），现在有两个人，其中一个跟你的距离为a，另外一个人跟你的距离为b，并且你知道他们两个人之间的距离是c。现在还知道这两个人的坐标都是整数。问你总共有多少种满足情况的坐标并输出。<br>其实这就很容易想到，先找到那两个人的坐标，然后判断他俩的距离是不是跟给定的是相等的。现在相当于我们知道，所要求的两个点到原点的距离并且他们的坐标是整数。也就可以转换成这类问题：求以原点为圆心，且半径确定的圆在坐标轴上能经过的整数坐标。这也就是我在最开始放的链接。为了防止你在翻上去，我在在这里放一次：<a href="https://boctorio.com/2019/10/01/%E5%9C%86%E4%B8%8A%E6%95%B4%E7%82%B9%E4%B8%AA%E6%95%B0%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">圆上整点个数及坐标求解方法-boctorio</a>.<br>所以这道题也就很显然了，我们分别求出来半径为a，b的圆心为原点的圆上的整数坐标，然后两个for循环判断距离是否为c并输出。剩下的就是一些细节的处理了。具体看代码</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll       n, a, b, c;#define pll    pair&lt;ll, ll&gt;ll       d[4][2] = { 1, 1, 1, -1, -1, 1, -1, -1 };set&lt;pll&gt; se[2];struct node{    ll x1, y1, x2, y2;};vector&lt;node&gt; V;void div(ll r, ll exp, ll flag){    for (ll i = 1; i * i &lt; r; i++)    {        ll x = (ll) sqrt(r - i * i);        if (x * x + i * i == r &amp;&amp; x != i)        {            ll a = x * x - i * i, b = 2 * x * i;            for (int j = 0; j &lt; 4; j++)                se[flag].insert({ d[j][0] * a * exp, d[j][1] * b * exp });            for (int j = 0; j &lt; 4; j++)                se[flag].insert({ d[j][0] * b * exp, d[j][1] * a * exp });        }    }}void lo(ll r, ll flag){    se[flag].clear();    se[flag].insert({ r, 0ll });    se[flag].insert({ -r, 0ll });    se[flag].insert({ 0ll, r });    se[flag].insert({ 0ll, -r });    div(r, 1, flag);    for (ll i = 2; i * i &lt;= r; i++)    {        if (r % i == 0)        {            div(i, r / i, flag);            div(r / i, i, flag);        }    }}void solve(){    cin &gt;&gt; n;    while (n--)    {        V.clear();        ll ans = 0;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        lo(a, 0); lo(b, 1);        for (set&lt;pll&gt;::iterator it = se[0].begin(); it != se[0].end(); it++)        {            for (set&lt;pll&gt;::iterator its = se[1].begin(); its != se[1].end(); its++)            {                ll x1 = it-&gt;first, y1 = it-&gt;second, x2 = its-&gt;first, y2 = its-&gt;second;                if (sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) == c)                    ans++, V.push_back({ x1, y1, x2, y2 });            }        }        cout &lt;&lt; ans &lt;&lt; endl;        for (int i = 0; i &lt; V.size(); i++)        {            cout &lt;&lt; V[i].x1 &lt;&lt; &quot; &quot; &lt;&lt; V[i].y1 &lt;&lt; &quot; &quot; &lt;&lt; V[i].x2 &lt;&lt; &quot; &quot; &lt;&lt; V[i].y2 &lt;&lt; endl;        }    }}int main(){    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    solve();    return 0;}</code></pre><p>这道题卡输入，如果不关同步流会TLE</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器+宝塔面板+Xshell 搭建MC联机服务器 - 傻瓜式操作</title>
      <link href="/2019/10/02/mcserver/"/>
      <url>/2019/10/02/mcserver/</url>
      
        <content type="html"><![CDATA[<p>我的环境</p><ol><li>阿里云学生机，系统是Linux</li><li>宝塔面板</li><li>Xshell</li></ol><p>mincraft，中文名我的世界，发行了十年左右的一款像素游戏。我第一次接触他是在初中，如果你真的以为这个游戏画面不够精美或者是只是无脑拆搭方块，那你就真的错了。关于mc我就不说那么多了，主要还是说一下服务器的搭建吧。</p><h2 id="Java的安装"><a href="#Java的安装" class="headerlink" title="Java的安装"></a>Java的安装</h2><p>首先我想说一下java的安装，好多教程都直接忽略了这一步，还是让我感到很不解的，因为这个java的安装耗费了我大量的时间，甚至想放弃服务器的搭建。（PS：可能是因为我太小(han)白(pi)了</p><p>Q：为什么要安装java？<br>我也不知道为啥，但是玩mc就是需要java，安装就行了（傻瓜式操作精髓——我不知道</p><p>好，那我们开始安装。<br>据说&#39;apt-get install java&#39;等等的指令也是可以实现的，并且这种安装会很舒服，一下就好了。但是呢，我也不知道是不是我的系统的问题，就是报错，无法定位到这个包，所以无法安装，也找了很多解决办法，但都没什么软用。</p><p>所以我选择了这种，如果你上面那种可以用就不需要看这个了，因为我的这种方法确实很麻烦，但是很好理解也很好操作，起码不会像上面那种方法一样报错（233</p><p>首先去下载JDK</p><p>传送门: <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">官网</a></p><p>先传送到官网下载合适的JDK版本。这里我选择的是Linux x64的<code>jdk-8u221-linux-x64.tar.gz</code>版本<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002110832.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002110832.webp" class="img-shadow img-margin"></center></a><br>注意这里一定要下载后缀是.tar.gz的版本</p><p>下载完之后是需要上传到你的服务器并解压的。命令行的话会很麻烦（不是我不会，就是太麻烦了，对）。所以，我们的宝塔面板大显神威嚯。<br>在user目录下新建一个java文件夹，然后把你下载的tar.gz上传到这个文件夹中，上传完成后进行解压。解压完大约是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002111840.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002111840.webp" class="img-shadow img-margin"></center></a><br>解压出来的文件夹我重命名了一下，这个无所谓，你也可以重命名，但是得记住这个名字，因为下一步会用到。</p><p>然后需要设置一下环境变量<br>在<code>etc/profile</code>里面添加如下内容并保存</p><pre><code class="lang-txt">set java environmentJAVA_HOME=/usr/java/jdk1.8.0_151        JRE_HOME=/usr/java/jdk1.8.0_151/jre     CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH</code></pre><p>注意：<code>JAVA_HOME</code>和<code>JRE_HOME</code>的路径是你自己解压到的地方，需要修改。</p><p>然后在命令行输入</p><pre><code class="lang-Xshell">java -version</code></pre><p>如果命令执行之后是类似这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002115932.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002115932.webp" class="img-shadow img-margin"></center></a><br>那说明你的java安装好了</p><h2 id="服务端的安装"><a href="#服务端的安装" class="headerlink" title="服务端的安装"></a>服务端的安装</h2><p>传送门:<a href="https://yivesmirror.com/downloads/paper" target="_blank" rel="noopener">Yive&#39;s Mirror</a><br>去上面那个镜像网站下载一个你想用的mc的版本，这里我下载的是1.12.2<br>直接Download就行了。<br>下载完会得到一个<code>xxx.jar</code>文件。然后你把他放在你的服务器上就行。可以新建一个目录<code>mc</code>之类的用来存放这个服务器的文件，或者像我一样直接往根目录一塞。<br>然后在命令行去到你的放有前面下载的那个jar文件的路径下，运行这个命令</p><pre><code class="lang-Xshell">java -Xmx1024M -Xms1024M -jar “minecraft_server.jar” nogui</code></pre><p>我用””括起来的那部分需要你替换成自己的jar文件的名字</p><p>第一遍运行它会直接退出。这是正常情况，然后你可以在同一个目录下发现一个<code>eula.txt</code>，把里面那个<code>eula=false</code>改成<code>eula=true</code>，代表着你同意了它的各种条款。然后继续执行以下上面那个命令。这一次的时间可能会比较长因为要加载很多东西，等到加载完，大概是这个样子的话，你的服务器就可以访问了。</p><p>但是还有一个问题，这个是默认开启正版验证的，国内正版应该是很少的。所以你可以去找到你的跟jar同目录下的有一个叫做<code>server.properties</code>的文件，找到里面的<code>online-mode=</code>，默认的应该是true，改成false即可。</p><p>到这里你已经成功的开启了服务器，只需要下载对应的客户端就可以一起联机了。</p><p>这里顺便说一下服务器图标以及名字下面那一行小黑字如何进行自定义。</p><ol><li>图标<br>找到你想用的图标，分辨率改成64*64的，并重命名为<code>server-icon.webp</code>，就会自动匹配。</li><li>那一行小字<br>还是那个<code>server.properties</code>文件，找到<code>motd=</code>，在后面改成你想用的话，中文的话需要用Unicode编码来写。还有各种各样花里胡哨的写法，可以参考这里：<a href="https://minecraft-zh.gamepedia.com/%E6%A0%B7%E5%BC%8F%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">传送门</a>。我就不说这个了。</li></ol><h2 id="如何进入自己的服务器"><a href="#如何进入自己的服务器" class="headerlink" title="如何进入自己的服务器"></a>如何进入自己的服务器</h2><ol><li>打开mc</li><li>点击多人游戏，添加服务器</li><li>名字随意。ip写上你的服务器的公网ip</li><li>不出意外的话就可以愉快的跟小伙伴一起玩耍了</li></ol><p>可能会出现怎么都链接不上的情况，导致这个的原因一般都是因为25565端口没有打开。<br>在阿里云或者腾讯云的控制台都可以打开。但是这个我不是很懂，还是直接给出傻瓜式的命令行操作吧。</p><pre><code class="lang-Xshell">sudo ufw allow 25565</code></pre><p>上面的命令执行结束之后返回的如果是</p><pre><code class="lang-Xshell">Rule addedRule added (v6)</code></pre><p>就可以了。</p><p>到这一步就已经算是配置好了。你的服务器也已经可以和小伙伴一起玩耍了。不过这只是纯净版的生存。如果你想添加模组的话，请继续往下看。</p><h2 id="给自己的服务器安装Forge以使用mod"><a href="#给自己的服务器安装Forge以使用mod" class="headerlink" title="给自己的服务器安装Forge以使用mod"></a>给自己的服务器安装Forge以使用mod</h2><p>先去这里: <a href="https://files.minecraftforge.net/maven/net/minecraftforge/forge/index_1.12.2.html" target="_blank" rel="noopener">传送门</a> 下载合适版本的forge<br>选择这个版本进行安装（如果是Windows就选Windos就行）<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002132144.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002132144.webp" class="img-shadow img-margin"></center></a><br>下载完之后上传到服务器上面，同理还是可以用宝塔面板进行上传。很简单</p><p>上传完之后进入到这个文件所在的目录运行</p><pre><code class="lang-Xshell">java -Xms512m -Xmx1024m -jar forge-xxx-installer.jar nogui --installServer</code></pre><p>xxx代表的就是你的文件名和这里不一样的地方，用你的文件名即可。运行一下就好。</p><p>然后运行</p><pre><code class="lang-Xshell">java -Xms1024m -Xmx1024m -jar forge-xxx-universal.jar nogui</code></pre><p>等待运行完之后你会发现目录下面多了一个mods文件夹，用什么mod往里面加就行了。版本要适配，然后之后每一次启动服务器就用上面那个命令就行了。</p><p>这里为什么用宝塔会很方便呢？<br>上传文件什么的很方便就不说了，修改文件的时候也可以直接修改不需要用vim那么麻烦。</p><p>这是我的服务器现在的样子。如果你有兴趣跟我们一起玩（加了宝可梦模组），那就来吧。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002134143.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20191002134143.webp" class="img-shadow img-margin"></center></a><br><a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=c5de5765988ed85da94714cc7c8266b630f9d561b09a50698d790f9b1da957b6">快上车！一起做精灵宝可梦大师</a></p><p>服务器计划最多8人，现已有2人</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> minecraft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（4-9月 小总结）</title>
      <link href="/2019/09/28/zj28/"/>
      <url>/2019/09/28/zj28/</url>
      
        <content type="html"><![CDATA[<p>上次总结是五个月之前了，这中间发生的事也不多但也不少。一项一项列一下吧。</p><p>暑假前的生活还是很无趣的，每天就是上课，刷题，玩。</p><p>暑假经历了36天左右的<a href="https://cndrew.cn/categories/Training/" target="_blank" rel="noopener">集训</a>，虽然自己没有变强多少，但这也是个难忘的回忆把。</p><p>暑假买了自己第一台服务器，阿里云的学生机，一个月十块钱还是很舒服的。有了服务器本来说想用wordpress写博客，后来发现wp的水比我想得还深。所以还是用我的hexo把哈哈哈。目前是hexo托管在我的服务器上面，还用了宝塔面板，可视化操作还是很秀的。</p><p>自己也搭了不少东西，虽然都是套的板子，23333</p><ol><li><p>青岛大学开源OJ<br>这个本来是搭在虚拟机试一下，然后出锅了，就给他删了。但是还是有记录的<br><a href="https://cndrew.cn/2019/08/23/oj/" target="_blank" rel="noopener">开源青岛大学oj的搭建(傻瓜式操作)</a></p></li><li><p>Chevereto搭建的图床<br>对我们这一行的人图床应该不用解释了。<br>很妙的就接触到了Chevereto<br>首先是自己搭了一个给自己人用: <a href="https://cf.cndrew.cn/" target="_blank" rel="noopener">Uncle_drew的图床</a><br>搭好了图床之后跟工作人员取得了联系并做了Chevereto文档的中文翻译<br><a href="https://ch.cndrew.cn/" target="_blank" rel="noopener">Chevereto中文文档</a></p></li><li><p>在宝塔的一键部署源码的帮助下，搭建了自己的可道云私人云盘<br><a href="https://cloud.cndrew.cn/" target="_blank" rel="noopener">Uncle_drew的云盘</a><br>主要是用于机房的各种代码或者文件的同步，qq啊邮箱啊发着也太麻烦了</p></li><li><p>PrivateBin搭建代码分享平台<br>之前用的一直是Ubuntu paste，后来无聊的时候发现了这个就自己搞了一个<br><a href="https://paste.cndrew.cn/" target="_blank" rel="noopener">Uncle_drew的代码分享平台</a></p></li></ol><p>自己搞得玩的东西也就上面这些了。</p><p>再说一下算法吧，暑期集训结束之后，就是一堆网络赛。虽然说是也跟学长一起打了几场，但基本是一道题都做不出来的那种（wdtn）。马上就要打区域赛了，想去上海，希望队友给力（别被我托废了2333</p><p>马上就是国庆假期了，可是因为有训练回不了家还是很难受的，看着我妈给我发的“路费”红包，但是我却回不去，唉，既然都不回去了更要好好搞！！！</p><p>就这样，2019.9.28 8:32德鲁大叔不想写题在这发发牢骚</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一卡通大冒险</title>
      <link href="/2019/09/26/hdu-2512/"/>
      <url>/2019/09/26/hdu-2512/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://acm.hdu.edu.cn/showproblem.php?pid=2512" target="_blank" rel="noopener">一卡通大冒险</a></p><p><center>一卡通大冒险</center><br>Description:<br>因为长期钻研算法， 无暇顾及个人问题，BUAA ACM/ICPC 训练小组的帅哥们大部分都是单身。某天，他们在机房商量一个绝妙的计划&quot;一卡通大冒险&quot;。这个计划是由wf最先提出来的，计划的内容是，把自己的联系方式写在校园一卡通的背面，然后故意将自己的卡&quot;遗失&quot;在某处（如水房，TD，食堂，主M。。。。）他们希望能有MM看到他们遗失卡，能主动跟他们联系，这样就有机会请MM吃饭了。他们决定将自己的一卡通夹在基本相同的书里，然后再将书遗失到校园的各个角落。正当大家为这个绝妙的计划叫好时，大家想到一个问题。很明显，如果只有一张一卡通，那么只有一种方法，即，将其夹入一本书中。当有两张一卡通时，就有了两种选择，即，将两张一卡通夹在一本书里，或者分开夹在不同的书里。当有三张一卡通时，他们就有了5种选择，即：<br>((A),(B),(C)) , ((A,B),(C)), ((B,C),(A)), ((A,C),(B)) ,((A,B,C)) 于是，<br>这个邪恶计划的组织者wf希望了解，如果ACM训练对里有n位帅哥（即有N张一卡通），那么要把这些一卡通夹到书里有多少种不同的方法。</p><p>Input<br>包含多组数据，第一行为n，表示接下来有n组数据。以下每行一个数x，表示共有x张一卡通。（1≤x≤2000）.</p><p>Output<br>对每组数据，输出一行：不同的方法数，因为这个数可能非常大，我们只需要它除以1000的余数。</p><p>Sample Input<br>4<br>1<br>2<br>3<br>100</p><p>Sample Output<br>1<br>2<br>5<br>751</p><p>Problem solving:<br>这道题也可以用贝尔数解决。也可以用二维dp解决。我们选择的后者。<br>递推公式为</p><pre><code class="lang-txt">dp[x][y]=1    x==ydp[x][y]=dp[x-1][y]*y+dp[x-1][y-1]  x!=y</code></pre><p>虽然规律是很简单的，但是推出来的过程是真的坎坷。也是第一次自己推出来的。很开心！<br>其实这道题不用找规律也可以想起来。<br>如果假如说现在五张卡片，如果你想放三本书里面。那么这个总共的次数会有两个<code>来源</code>。其中之一是四张卡片放在三本书里面，还有一种就是四张卡片放在两本书里面。后者想要变成三本书，新多的那张卡片必须自己放一本书，所以这是直接加上的就行。但是前面的那个就不一样了，他会有很多情况。再每种三本书的方法中，每本书都可以新放进一张卡片，也就是说这种情况下可以放的次数为dp[x-1][y]*y。两者相加，递推打表后直接输出就行。</p><p>在杭电上面64MS就过了，我觉得有点玄学，毕竟预处理的时候是O(n^2)。。。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;iostream&gt;using namespace std;int dp[2005][2005];int main(){    for (int i = 1; i &lt;= 2000; i++)    {        dp[i][1] = dp[i][i] = 1;        for (int j = 2; j &lt; i; j++)        {            dp[i][j] = (dp[i - 1][j] * j % 1000 + dp[i - 1][j - 1] % 1000) % 1000;        }    }    int n, a;    cin &gt;&gt; n;    while (n--)    {        int ans = 0;        cin &gt;&gt; a;        for (int i = 1; i &lt;= a; i++)            ans += dp[a][i];        cout &lt;&lt; ans % 1000 &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> dp </tag>
            
            <tag> hdu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 588 (Div. 2) - C. Anadi and Domino</title>
      <link href="/2019/09/24/cf1230C/"/>
      <url>/2019/09/24/cf1230C/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1230/problem/C" target="_blank" rel="noopener">C. Anadi and Domino</a></p><center>C. Anadi and Domino</center><p>Description:<br>Anadi has a set of dominoes. Every domino has two parts, and each part contains some dots. For every a and b such that 1≤a≤b≤6, there is exactly one domino with a dots on one half and b dots on the other half. The set contains exactly 21 dominoes. Here is an exact illustration of his set:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190924071559.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190924071559.webp" class="img-shadow img-margin"></center></a><br>Also, Anadi has an undirected graph without self-loops and multiple edges. He wants to choose some dominoes and place them on the edges of this graph. He can use at most one domino of each type. Each edge can fit at most one domino. It&#39;s not necessary to place a domino on each edge of the graph.</p><p>When placing a domino on an edge, he also chooses its direction. In other words, one half of any placed domino must be directed toward one of the endpoints of the edge and the other half must be directed toward the other endpoint. There&#39;s a catch: if there are multiple halves of dominoes directed toward the same vertex, each of these halves must contain the same number of dots.</p><p>How many dominoes at most can Anadi place on the edges of his graph?</p><p>Input<br>The first line contains two integers n and m (1≤n≤7, 0≤m≤n⋅(n−1)/2) — the number of vertices and the number of edges in the graph.</p><p>The next m lines contain two integers each. Integers in the i-th line are ai and bi (1≤a,b≤n, a≠b) and denote that there is an edge which connects vertices ai and bi.</p><p>The graph might be disconnected. It&#39;s however guaranteed that the graph doesn&#39;t contain any self-loops, and that there is at most one edge between any pair of vertices.</p><p>Output<br>Output one integer which denotes the maximum number of dominoes which Anadi can place on the edges of the graph.</p><p>Examples<br>input<br>4 4<br>1 2<br>2 3<br>3 4<br>4 1<br>output<br>4<br>input<br>7 0<br>output<br>0<br>input<br>3 1<br>1 3<br>output<br>1<br>input<br>7 21<br>1 2<br>1 3<br>1 4<br>1 5<br>1 6<br>1 7<br>2 3<br>2 4<br>2 5<br>2 6<br>2 7<br>3 4<br>3 5<br>3 6<br>3 7<br>4 5<br>4 6<br>4 7<br>5 6<br>5 7<br>6 7<br>output<br>16<br>Note<br>Here is an illustration of Anadi&#39;s graph from the first sample test:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190924071656.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190924071656.webp" class="img-shadow img-margin"></center></a><br>And here is one of the ways to place a domino on each of its edges:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190924072031.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190924072031.webp" class="img-shadow img-margin"></center></a><br>Note that each vertex is faced by the halves of dominoes with the same number of dots. For instance, all halves directed toward vertex 1 have three dots.</p><p>Problem solving:<br>这道题一开始我没读懂题意。<br>题意就是给了你总共有21张多米诺骨牌，每张牌有两个面，然后给你一个无向图，保证没有环和一个顶点多条边的情况存在。现在让你在这个图中的每个边放多米诺骨牌。有一个放置规则，问你最多能放几张多米诺骨牌上去。<br>放置规则就是，每个点的权值都是一样的，你在每条边上放的多米诺骨牌，因为它有两个面。需要保证两个面上面的大小就是它指向的点的权值。就比如说样例一的解释中顶点1，2，3，4，所对应的权值分别是3，1，6，3。并且每张牌只能用一次。</p><p>因为数据范围也很小，总共最多七个点，二十一条边，每个点的权值的情况只有六种（1，2，3，4，5，6）.我们可以暴力枚举每一种情况，用顶点的权值去推这条边能放的多米诺骨牌，进而推到每一条边，然后取所有情况中的最大值就是答案。</p><p>枚举的时候用到了dfs（这个是真的很巧，bly说这应该是基本操作的，我枯了。dfs的枚举应该就不用说了。具体的solving看代码注释吧。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int Map[50][50], domin[50], n, m, a, b, ans;/*因为数据范围很小，所以这里直接用二维数组存图了。domin数组表示当前节点枚举到的权值，50开的有点大了已经。不过问题不大*/int check(){    set&lt;pair&lt;int, int&gt; &gt; se;//为了解决记录哪种牌有没有被用过的麻烦，我们直接把所有能放的牌都丢进这个set里面，最后set的size就是这种枚举情况下的最大值    for (int i = 1; i &lt;= n; i++)        for (int j = i + 1; j &lt;= n; j++)//双重for循环对每两个顶点就行判断            if (Map[i][j] &amp;&amp; domin[i] &lt;= domin[j])//如果这两个点是联通的并且i的权值小于等于j的权值（因为多米诺骨牌也是有方向的），说明这里是可以放一张牌的。                se.insert(make_pair(domin[i], domin[j]));//满足情况的丢进set    return se.size();//返回set的size，也就是这种情况下的答案。}void dfs(int x)//枚举每个点的权值的每种情况{    if (x == n + 1)//如果已经枚举了n个点，说明这一种枚举的情况已经结束了。    {        ans = max(ans, check());//每次对答案取一下最大值，保证算出来的是最多放置的多米诺骨牌数，check函数就是用来求当前所有顶点权值已知的情况下最多能放多少多米诺骨牌        return;    }    for (int i = 1; i &lt;= 6; i++)    {        domin[x] = i;//将当前这个顶点，六种情况分别列出来        dfs(x + 1);//枚举下一个顶点    }}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; m; i++)    {        cin &gt;&gt; a &gt;&gt; b;        Map[a][b] = Map[b][a] = 1;//输入之后存图，注意是双向的，因为是无向图    }    dfs(1);//从第一个顶点开始枚举    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190924075022.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190924075022.webp" class="img-shadow img-margin"></center></a><p>cf终于不是绿名了，虽然多少有点py的意思在里面。还是很知足的。下个目标-&gt;1500</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> dfs </tag>
            
            <tag> codeforces </tag>
            
            <tag> thinking </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ - 2492   A Bug&#39;s Life</title>
      <link href="/2019/09/22/poj2492/"/>
      <url>/2019/09/22/poj2492/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://poj.org/problem?id=2492" target="_blank" rel="noopener">poj-2492</a></p><p>Description:<br>Background<br>Professor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs.<br>Problem<br>Given a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it.<br>Input</p><p>The first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one.<br>Output</p><p>The output for every scenario is a line containing &quot;Scenario #i:&quot;, where i is the number of the scenario starting at 1, followed by one line saying either &quot;No suspicious bugs found!&quot; if the experiment is consistent with his assumption about the bugs&#39; sexual behavior, or &quot;Suspicious bugs found!&quot; if Professor Hopper&#39;s assumption is definitely wrong.<br>Sample Input</p><p>2<br>3 3<br>1 2<br>2 3<br>1 3<br>4 2<br>1 2<br>3 4<br>Sample Output</p><p>Scenario #1:<br>Suspicious bugs found!</p><p>Scenario #2:<br>No suspicious bugs found!</p><p>Problem solving:<br>这道题的意思就是给你几组数，每组数有两个数代表这两个数，代表这两个编号的虫子是相爱的，即他们不是同性的。<br>问你输入的数据中会不会存在相同性别（同性恋）的情况存在。</p><p>这道题的做法还是很多的，二分图，带权并查集什么什么的。<br>但是上面那两个我都不熟悉。所以选择了裸并查集加一个小处理的办法。</p><p>这里我们用x+n代表跟x性别不同的虫子，每次join的时候对（x+n,y）和(x,y+n)进行join即可。然后如果出现性别相同的直接标记一下，就是并查集啦。因为这里性别是有两种，说明是要分成两队的，直接并查集显然是不可以的。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;iostream&gt;using namespace std;#define zhengshu    intconst int maxn = 1e5;int       p[maxn];int find(int x){    return p[x] != x ? p[x] = find(p[x]) : x;}void join(zhengshu x, zhengshu y){    x = find(x), y = find(y);    if (x != y)        p[x] = y;}int main(){    zhengshu t, n, m, x, y;    scanf(&quot;%d&quot;, &amp;t);    for (zhengshu j = 1; j &lt;= t; j++)    {        zhengshu flag = 0;        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        for (zhengshu i = 1; i &lt;= 2 * n; i++)            p[i] = i;        for (zhengshu i = 0; i &lt; m; i++)        {            scanf(&quot;%d %d&quot;, &amp;x, &amp;y);            if (find(x) == find(y))                flag = 1;            else                join(x + n, y), join(x, y + n);        }        printf(&quot;Scenario #%d:\n&quot;, j);        if (flag)            puts(&quot;Suspicious bugs found!&quot;);        else            puts(&quot;No suspicious bugs found!&quot;);        puts(&quot;&quot;);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列卷积</title>
      <link href="/2019/09/20/nowcoder1087-c/"/>
      <url>/2019/09/20/nowcoder1087-c/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://ac.nowcoder.com/acm/contest/1087/C" target="_blank" rel="noopener">牛客挑战赛32-C</a></p><center>斐波那契数列卷积</center><p>Description:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190920215800.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190920215800.webp" class="img-shadow img-margin"></center></a><br>输入<br>3<br>输出<br>2<br>示例2<br>输入<br>19260817<br>输出<br>511682927</p><p>Problem solving:<br>这道题题意没啥好说的。看公式就能看懂。<br>这道题第一眼就觉得是矩阵快速幂的题。但是一直没找到通项公式。后来在bly的帮助下知道了通项公式：<br><code>a[n]=a[n-1]+a[n-2]+f[n-1]</code><br>然后直接矩阵快速幂就行了。</p><p>推理过程：</p><pre><code class="lang-txt">a[n]=f[1]*f[n-1]+f[2]*f[n-2]+f[3]*f[n-3]+f[4]*f[n-4]+...+f[n-2]*f[2]+f[n-1]*f[1]a[n-1]=f[1]*f[n-2]+f[2]*f[n-3]+f[3]*f[n-4]+f[4]*f[n-5]+...+f[n-3]*f[2]+f[n-2]*f[1]a[n]-a[n-1]=f[1]*f[n-3]+f[2]*f[n-4]+f[3]*f[n-5]+f[4]*f[n-6]+...+f[n-2]*f[1]+f[n-1]*f[1]　　　　　　=a[n-2]+f[n-1]即 a[n]=a[n-1]+a[n-2]+f[n-1]</code></pre><p>如果推理过程觉得太抽象可以代几个数试试</p><p>矩阵快速幂的时候构建的两个矩阵如图<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190920225633.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190920225633.webp" class="img-shadow img-margin"></center></a></p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 998244353;struct node{    ll a[4][4];};node mul(node a,node b){    node ans;    for(int i=0;i&lt;4;i++)        for(int j=0;j&lt;4;j++)            ans.a[i][j]=0;    for(int i=0;i&lt;4;i++)    {        for(int j=0;j&lt;4;j++)        {            for(int k=0;k&lt;4;k++)            {                ans.a[i][j]=(ans.a[i][j]+((a.a[i][k]%mod)*(b.a[k][j]%mod))%mod)%mod;            }        }    }    return ans;}node poww(node a,ll b){    node ans;    memset(ans.a,0,sizeof(ans.a));    for(int i=0;i&lt;4;i++)    ans.a[i][i]=1;    while(b)    {        if(b&amp;1)    ans=mul(ans,a);        a=mul(a,a);        b&gt;&gt;=1;    }    return ans;}node yl,bly;int main(){    ios::sync_with_stdio(0);    ll n;    cin&gt;&gt;n;    memset(yl.a,0,sizeof(yl.a));    memset(bly.a,0,sizeof(bly.a));    yl.a[0][0]=1;    yl.a[0][1]=1;    yl.a[0][2]=1;    yl.a[1][0]=1;    yl.a[2][2]=1;    yl.a[2][3]=1;    yl.a[3][2]=1;    bly.a[2][0]=1;    bly.a[0][0]=1;    bly.a[3][0]=1;    if(n==1)    cout&lt;&lt;0&lt;&lt;endl;    else if(n==2)    cout&lt;&lt;1&lt;&lt;endl;    else    {        node ans=poww(yl,n-2);        ans=mul(ans,bly);        cout&lt;&lt;ans.a[0][0]&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 73 (Rated for Div. 2) - D. Make The Fence Great Again</title>
      <link href="/2019/09/20/cfedu73-D/"/>
      <url>/2019/09/20/cfedu73-D/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1221/problem/D" target="_blank" rel="noopener">D. Make The Fence Great Again</a></p><center>D. Make The Fence Great Again</center><p>Description:<br>You have a fence consisting of n vertical boards. The width of each board is 1. The height of the i-th board is ai. You think that the fence is great if there is no pair of adjacent boards having the same height. More formally, the fence is great if and only if for all indices from 2 to n, the condition ai−1≠ai holds.</p><p>Unfortunately, it is possible that now your fence is not great. But you can change it! You can increase the length of the i-th board by 1, but you have to pay bi rubles for it. The length of each board can be increased any number of times (possibly, zero).</p><p>Calculate the minimum number of rubles you have to spend to make the fence great again!</p><p>You have to answer q independent queries.</p><p>Input<br>The first line contains one integer q (1≤q≤3e5) — the number of queries.</p><p>The first line of each query contains one integers n (1≤n≤3e5) — the number of boards in the fence.</p><p>The following n lines of each query contain the descriptions of the boards. The i-th line contains two integers ai and bi (1≤ai,bi≤1e9) — the length of the i-th board and the price for increasing it by 1, respectively.</p><p>It is guaranteed that sum of all n over all queries not exceed 3e5.</p><p>It is guaranteed that answer to each query will not exceed 1e18.</p><p>Output<br>For each query print one integer — the minimum number of rubles you have to spend to make the fence great.</p><p>Example<br>input<br>3<br>3<br>2 4<br>2 1<br>3 5<br>3<br>2 3<br>2 10<br>2 6<br>4<br>1 7<br>3 3<br>2 6<br>1000000000 2<br>output<br>2<br>9<br>0<br>Note<br>In the first query you have to increase the length of second board by 2. So your total costs if 2⋅b2=2.</p><p>In the second query you have to increase the length of first board by 1 and the length of third board by 1. So your total costs if 1⋅b1+1⋅b3=9.</p><p>In the third query the fence is great initially, so you don&#39;t need to spend rubles.</p><p>Problem solving:<br>这道题的意思就是给你一个由多个栅栏组成的木板，给你每块木板的高度以及它每增加一单位高度需要耗费的卢布（rubles）。现在问你如何在保证所有的相邻的木板高度都不同的情况下耗费最少的卢布数，让你输出这个最小的花费。<br>先添一波BLY！！！<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190920090214.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190920090214.webp" class="img-shadow img-margin"></center></a><br>我们考虑如果有相邻的数相等，那么其中任意一个加一就行，但是它加一之后有可能会跟另一个方向上相邻的数字相等，所以每个木板只有三种情况，不加，加一或者加二。我们设置一个二维数组dp[maxn][3],表示第i个木板之前的所有木板达到要求需要耗费的卢布数。开始时初始化为一个极大值。然后一直转移下去。因为前面的如果有变化所以可能也会导致后面的情况有变化，所以需要用的dp。<br>转移方程: <code>dp[i][k] = min(dp[i][k], dp[i - 1][j] + k * b[i])</code> 能用到这个转移方程必须有一个前提条件：<code>a[i - 1] + j != a[i] + k</code><br>最后我们只需要输出dp[n-1][0]([1],[2])中的最小值就行了。</p><p>输入输出数据比较多，所以直接用cin会超时（枯了）。可以关闭同步流用cin或者直接用scanf。唉，scanf大法好啊！！！</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 3e5 + 10;const ll inf = 0x3f3f3f3f3f3f3f3f;ll       a[maxn], b[maxn], dp[maxn][3];int main(){    ll q, n;    ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);    cin &gt;&gt; q;    while (q--)    {        cin &gt;&gt; n;        for (ll i = 0; i &lt; n; i++)            cin &gt;&gt; a[i] &gt;&gt; b[i];        for (ll i = 0; i &lt; n; i++)            for (ll j = 0; j &lt; 3; j++)                dp[i][j] = inf;        dp[0][0] = 0, dp[0][1] = b[0], dp[0][2] = b[0] * 2;        for (ll i = 1; i &lt; n; i++)            for (ll j = 0; j &lt; 3; j++)                for (ll k = 0; k &lt; 3; k++)                    if (a[i - 1] + j != a[i] + k)                        dp[i][k] = min(dp[i][k], dp[i - 1][j] + k * b[i]);        cout &lt;&lt; min(dp[n - 1][0], min(dp[n - 1][1], dp[n - 1][2])) &lt;&lt; endl;    }return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google常用语法(转载)</title>
      <link href="/2019/09/17/funny/"/>
      <url>/2019/09/17/funny/</url>
      
        <content type="html"><![CDATA[<center><font size="5">Google 常用语法　　　　　--mryang</font></center><h2 id="搜索结果要求包含两个及两个以上关键字"><a href="#搜索结果要求包含两个及两个以上关键字" class="headerlink" title="搜索结果要求包含两个及两个以上关键字"></a>搜索结果要求包含两个及两个以上关键字</h2><p>一般搜索引擎需要在多个关键字之间加上“ ”，而 Google 无需用明文的“ ”来表示逻辑“与”操作，只要空格就可以了<br>Google 的关键字可以是单词（中间没有空格），也可以是短语<br>（中间有空格）。但是，用短语做关键字，必须加英文引号，否则空格会被当作“与”操作符。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170518.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170518.webp" class="img-shadow img-margin"></center></a></p><h2 id="搜索结果要求不包含某些特定信息"><a href="#搜索结果要求不包含某些特定信息" class="headerlink" title="搜索结果要求不包含某些特定信息"></a>搜索结果要求不包含某些特定信息</h2><p>Google 用减号“-”表示逻辑“非”操作。“A –B”表示搜索包含 A 但没有 B 的网页。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170537.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170537.webp" class="img-shadow img-margin"></center></a></p><h2 id="搜索结果至少包含多个关键字中的任意一个"><a href="#搜索结果至少包含多个关键字中的任意一个" class="headerlink" title="搜索结果至少包含多个关键字中的任意一个"></a>搜索结果至少包含多个关键字中的任意一个</h2><p>Google 用大写的“OR”表示逻辑“或”操作。搜索“A OR B [OR C…]”，意思就是说，搜索的网页中，要么有 A，要么有 B，要么同时有 A 和 B(或 C 等)。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170643.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170643.webp" class="img-shadow img-margin"></center></a></p><h2 id="通配符问题"><a href="#通配符问题" class="headerlink" title="通配符问题"></a>通配符问题</h2><p>很多搜索引擎支持通配符号，如“*”代表一连串字符，“?”代表单个字符等。Google 对通配符支持有限。它目前只可以用“<em>”来替代单个字符，而且包含“</em>”必须用&quot;&quot;引起来。</p><p>比如，“&quot;以*治国&quot;”，表示搜索第一个为“以”，末两个为“治<br>国”的四字短语，中间的“*”可以为任何字符</p><h2 id="对搜索的网站进行限制"><a href="#对搜索的网站进行限制" class="headerlink" title="对搜索的网站进行限制"></a>对搜索的网站进行限制</h2><p>“site”表示搜索结果局限于某个具体网站或者网站频道，如 “www.sina.com.cn”、“edu.sina.com.cn”，或者是某个域名，如“com.cn”、“com”等等。如果是要排除某网站或者域名范围内的页面，只需用“-网站/域名”.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170715.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170715.webp" class="img-shadow img-margin"></center></a><h2 id="在某一类文件中查找信息"><a href="#在某一类文件中查找信息" class="headerlink" title="在某一类文件中查找信息"></a>在某一类文件中查找信息</h2><p>“filetype:”是 Google 开发的非常强大实用的一个搜索语法。也就是说，Google 不仅能搜索一般的文字页面，还能对某些二进制文档进行检索。目前，Google 已经能检索微软的 Office 文档<br>如.xls、.ppt、.doc，.rtf，WordPerfect 文档，Lotus1-2-3 文档，Adobe 的.pdf 文档，ShockWave 的.swf 文档（Flash 动画）等<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170755.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170755.webp" class="img-shadow img-margin"></center></a></p><h2 id="搜索的关键字包含在-URL-链接中"><a href="#搜索的关键字包含在-URL-链接中" class="headerlink" title="搜索的关键字包含在 URL 链接中"></a>搜索的关键字包含在 URL 链接中</h2><p>“inurl”语法返回的网页链接中包含第一个关键字，后面的关键字则出现在链接中或者网页文档中。有很多网站把某一类具有相同属性的资源名称显示在目录名称或者网页名称中，比如“MP3”、<br>“GALLARY”等，于是，就可以用 INURL 语法找到这些相关资源链接，然后，用第二个关键词确定是否有某项具体资料。INURL 语法和基本搜索语法的最大区别在于，前者通常能提供非常精确的专题资料。<br>注意：“inurl:”后面不能有空格，Google 也不对 URL 符号如<br>“/”进行搜索。例如，Google 会把“cgi-bin/phf”中的“/”当成空格处理。<br>“allinurl”语法返回的网页的链接中包含所有作用关键字。这个查询的关键字只集中于网页的链接字符串。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170837.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170837.webp" class="img-shadow img-margin"></center></a></p><p>例如：查 midi 音乐 《沙漠骆驼》<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170904.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170904.webp" class="img-shadow img-margin"></center></a></p><h2 id="搜索的关键字包含在网页标题中"><a href="#搜索的关键字包含在网页标题中" class="headerlink" title="搜索的关键字包含在网页标题中"></a>搜索的关键字包含在网页标题中</h2><p>“intitle”和“allintitle”的用法类似于上面的 inurl 和<br>allinurl，只是后者对 URL 进行查询，而前者对网页的标题栏进行查询。网页标题，就是 HTML 标记语言 title 中之间的部分。网页设计的一个原则就是要把主页的关键内容用简洁的语言表示在网页标题中。因此，只查询标题栏，通常也可以找到高相关率的专题页<br>面。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170937.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917170937.webp" class="img-shadow img-margin"></center></a></p><h2 id="搜索的关键字包含在网页的“锚”（anchor）链点内"><a href="#搜索的关键字包含在网页的“锚”（anchor）链点内" class="headerlink" title="搜索的关键字包含在网页的“锚”（anchor）链点内"></a>搜索的关键字包含在网页的“锚”（anchor）链点内</h2><p>所谓“锚”，就是在同一个网页中快速切换链接点。与 URL 和<br>TITLE 类似，Google 提供了两种对 anchor 的检索，“inanchor”和<br>“allincnchor”。对此不作详述。</p><h2 id="搜索所有链接到某个-URL-地址的网页"><a href="#搜索所有链接到某个-URL-地址的网页" class="headerlink" title="搜索所有链接到某个 URL 地址的网页"></a>搜索所有链接到某个 URL 地址的网页</h2><p>如果你拥有一个个人网站，估计很想知道有多少人对你的网站作了链接。而“link”语法就能让你迅速达到这个目的。<br>示例：搜索所有含指向 “www.gxela.gov.cn”链接的网页。 搜索：“link: www.gxela.gov.cn”<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171007.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171007.webp" class="img-shadow img-margin"></center></a></p><h2 id="查找与某个页面结构内容相似的页面"><a href="#查找与某个页面结构内容相似的页面" class="headerlink" title="查找与某个页面结构内容相似的页面"></a>查找与某个页面结构内容相似的页面</h2><p>“related”用来搜索结构内容方面相似的网页。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171036.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171036.webp" class="img-shadow img-margin"></center></a></p><h2 id="从-Google-服务器上缓存页面中查询信息"><a href="#从-Google-服务器上缓存页面中查询信息" class="headerlink" title="从 Google 服务器上缓存页面中查询信息"></a>从 Google 服务器上缓存页面中查询信息</h2><p>“cache”用来搜索 Google 服务器上某页面的缓存，通常用于查找某些已经被删除的死链接网页，相当于使用普通搜索结果页面中的“网页快照”功能。</p><h2 id="图片搜索"><a href="#图片搜索" class="headerlink" title="图片搜索"></a>图片搜索</h2><p>https:/<a href="https://cdn.jsdelivr.net/gh/drew233/cdn.google.com" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/drew233/cdn.google.com</a></p><h2 id="网页翻译"><a href="#网页翻译" class="headerlink" title="网页翻译"></a>网页翻译</h2><p>你懂英文，但是你不见得就懂德文、法文、拉丁文。如果搜索出来的页面是这些语言怎么办？<br>试着做以下搜索：“big bang site:fr”。这个表示查找关于宇宙大爆炸的法文网页。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171107.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171107.webp" class="img-shadow img-margin"></center></a></p><h2 id="寻找特定网页里的关键字"><a href="#寻找特定网页里的关键字" class="headerlink" title="寻找特定网页里的关键字"></a>寻找特定网页里的关键字</h2><p>“intext:” 寻找特定网页里的关键字，他不理会网址和文章标标题。<br>例如 “intext:exploits” 将只返回包含指定关键字 “exploits”的网页的地址。</p><h2 id="电话簿查询美国街道地址和电话号码信息phonebook"><a href="#电话簿查询美国街道地址和电话号码信息phonebook" class="headerlink" title="电话簿查询美国街道地址和电话号码信息phonebook:"></a>电话簿查询美国街道地址和电话号码信息phonebook:</h2><p>例如 “phonebook:Lisa+CA”将查询名字里面包含“Lisa” 并住在加州的人的所有名字。这对黑客使用社会工程学去挖掘个人信息是很有用的。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171124.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171124.webp" class="img-shadow img-margin"></center></a></p><h2 id="发现允许目录浏览的-web-网站"><a href="#发现允许目录浏览的-web-网站" class="headerlink" title="发现允许目录浏览的 web 网站"></a>发现允许目录浏览的 web 网站</h2><p>[Index of]<br>利用“Index of ”语法去发现允许目录浏览的 web 网站，就象在本地的普通目录一样。下面是一些有趣的查询：<br>Index of /admin Index of /passwd Index of /password Index of /mail<br>“Index of /” +passwd “Index of /” +password.txt “Index of /” +.htaccess “Index of /root”<br>“Index of /cgi-bin” “Index of /logs” “Index of /config”<br>（包含引号）<br>[利用“inurl:”或 “allinurl:” 寻找有漏洞的网站或服务器]<br>a、利用“allinurl:winnt/system32/” 查询：列出的服务器上本来应该受限制的诸如“system32” 等目录，如果你运气足够好，你会发现“system32” 目录里的“cmd.exe” 文件，并能执行他，接下来就是提升权限并攻克了。<br>b、 查询“allinurl:wwwboard/passwd.txt”将列出所有有</p><p>“WWWBoard Password vulnerability”漏洞的服务器，阅读更多请<br>参见下面链接。https:<br>//www.securiteam.com/exploits/2BUQ4S0SAW.html<br>c、查询“inurl:.bash_history” 将列出互联网上可以看见<br>“inurl:.bash_history” 文件的服务器。这是一个命令历史文 件，这个文件包含了管理员执行的命令，有时会包含一些敏感信息比如管理员键入的密码。d、查询“inurl:config.txt” 将看见网上暴露了<br>“inurl:config.txt”文件的服务器，这个文件包含了经过哈希编码的管理员的密码和数据库存取的关键信息。<br>e、还有一些其他一些使用“inurl:”和“allinurl:”查询组合的例子。<br>inurl:admin filetype:txt inurl:admin filetype:db inurl:admin filetype:cfg inurl:mysql filetype:cfg inurl:passwd filetype:txt inurl:”wwwroot/*.” inurl:adpassword.txt inurl:webeditor.php inurl:file_upload.php<br>inurl:gov filetype:xls “restricted”</p><p>index of ftp +.mdb allinurl:/cgi-bin/ +mailto<br>（以上查询包含引号）<br>[利用“intitle:”和“allintitle:” 寻找有漏洞的服务器]<br>a、通过[allintitle: “index of /root”] 查询列出有<br>“root”目录存取权限的服务器的列表，这个目录经常包含敏感信息，通过这些信息服务器可能会被轻易攻克。<br>b、通过[allintitle: “index of /admin”] 查询列出有<br>“admin”目录列表权限的服务器的，绝大部分 web 程序使用<br>“admin”用户名去储存管理员权限。这个目录下的敏感信息可能会被利用来轻易地攻克服务器。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171141.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917171141.webp" class="img-shadow img-margin"></center></a></p><h2 id="google-上的黑客语法察看基本情况："><a href="#google-上的黑客语法察看基本情况：" class="headerlink" title="google 上的黑客语法察看基本情况："></a>google 上的黑客语法察看基本情况：</h2><p>inurl:*.asp 返回一些基本信息<br>site:xx.com 返回所有与该有关的 url</p><p>link:xx.com 返回所有与该站做了连接的站<br>site:xx.com filetype:txt 查找 TXT 文件 其他的依次内推</p><p>查找后台<br>site:xx.com intext:管理site:xx.com inurl:login site:xx.com intitle:后台</p><p>查看服务器使用的程序site:xx.com filetype:asp site:xx.com filetype:php site:xx.com filetype:jsp site:xx.com filetype:aspx</p><p>查 看 上 传 漏 洞 ： site:xx.com inurl:file site:xx.com inurl:load</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>define: 当我们用 define 进行查询的时候，Google 会返回包含查询关键词定义的网面。例［define: blog］，这个查询将会返回<br>Blog 的定义。</p><p>info: 提交 info:url，将会显示需要查询网站的一些信息。例<br>［info:gothotel.com］，提交这个查询，将会返回网站<br>gothotel.com 的所有信息。<br>insubject: 当我们用 insubject 进行查询的时候，Google 会限制论坛搜索结果仅是那些在主题里边包含了查询关键词的网面。<br>［insubject:”falling asleep”］，提交这个查询，Google 会返回在文章主题里边包含了”falling asleep”的文章。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Useful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器+宝塔+PrivateBin 搭建代码分享平台</title>
      <link href="/2019/09/17/Privatebin/"/>
      <url>/2019/09/17/Privatebin/</url>
      
        <content type="html"><![CDATA[<p>我搭建好的平台，欢迎大家使用：<a href="https://paste.cndrew.cn/" target="_blank" rel="noopener">Demo</a></p><p>前排提示：此教程为傻瓜式。深究请联系我（我知道的会说）或者去官网或github寻找解决方案<br>官网地址：<a href="https://privatebin.info/" target="_blank" rel="noopener">PrivateBin</a><br>github地址：<a href="https://github.com/PrivateBin/PrivateBin/" target="_blank" rel="noopener">PrivateBin</a><br>感谢一下这个大佬让我学到不少：<a href="https://www.senra.me/deploy-your-private-online-clipboard-using-privatebin/" target="_blank" rel="noopener">Senra</a></p><p>一开始接触代码分享平台是这个：<a href="https://paste.ubuntu.com/" target="_blank" rel="noopener">ubuntu paste</a>，就觉得很震惊很厉害。然后就了解到了PrivateBin。立马就寻思着自己也搞一个，说出去也是够装🖊的哈哈哈。这个功能还是很多的，有密码查看，有阅后即焚，还可以开放讨论，还支持代码高亮</p><p>你需要有的东西</p><ol><li>配置好宝塔面板的服务器</li><li>一个联网的电脑</li><li>一个跟我一样灵活的脑子</li></ol><p>大致步骤如下</p><ol><li>去github下载压缩包</li><li>在宝塔新建一个站点并把压缩包上传到站点目录后解压</li></ol><p>下载压缩包，目前最新的版本是1.3。<a href="https://github.com/PrivateBin/PrivateBin/archive/1.3.zip" target="_blank" rel="noopener">点我下载</a></p><p>在宝塔新建站点什么的就不用说了，然后解压也没啥好说的。</p><p>不出意外的话，等你全部弄好的时候，打开你新建的这个站点会看到这样的界面<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917163327.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917163327.webp" class="img-shadow img-margin"></center></a><br>看到红色你一定跟我一样害怕了吧（233<br>提示消息是</p><pre><code class="lang-txt">This website is using an insecure connection! Please only use it for testing.For more information [see this FAQ entry](https://github.com/PrivateBin/PrivateBin/wiki/FAQ#why-does-it-show-me-an-error-about-an-insecure-connection).</code></pre><p>其实意思就是你没有开始httpss，告诉你不安全。这个一般情况下开启了httpss之后就没了（我是这样的）。<br>关于如何开启httpss可以看看我之前的一篇文章: <a href="https://cndrew.cn/2019/08/29/httpss/" target="_blank" rel="noopener">开启httpss</a></p><p>然后最后主要提一下自定义的问题吧。<br>如果不修改一些东西的话，跟官网的demo一样，岂不是很不”好看”，个人认为。<br>但是这个也不像wordpress和chevereto有一个可视化的后台更改某些设置。对我这种小白有点不太友好。如果你跟我一样茫然就看下去吧。</p><p>首先你得找到配置文件<br>配置文件是<code>/cfg/conf.sample.php</code>，这里面会有很多可选的配置项<br>这里面我觉得有必要更改的就个地方</p><ol><li>网站标题</li><li>语言选择器开启（这个默认是关闭的）</li></ol><p>注意这里虽然有配置文件但你是不可以在这个文件里面修改的，你需要新建一个<code>conf.php</code>文件，把<code>conf.sample.php</code>的内容全部复制进去修改才会生效，或者你可以直接修改<code>conf.sample.php</code>文件，然后重命名。<code>conf.sample.php</code>这个只是一个示例文件，没什么用的。</p><ol><li>关于网站标题的修改。官方文档中说直接修改这个文件中的name=&quot;&quot;中的内容就可以，但是我的不行，这个一会再说。</li><li>语言选择器的开启<br>在你的配置文件中找到这部分内容<pre><code class="lang-php">; by default PrivateBin will guess the visitors language based on the browsers; settings. Optionally you can enable the language selection menu, which uses; a session cookie to store the choice until the browser is closed.languageselection = true//(这里本来是false，修改成true)</code></pre>然后你就会发现你的小站多了个这个<br>1<a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917164337.webp" target="_blank" rel="noopener"></a></li></ol><p>这个就加好了。下面说一下网站名的更改，默认的名字是<code>PrivateBin</code>,在配置文件中我修改一直没有效果。<br>但是我们可以找到<code>/tpl/bootstrap.php</code>这个文档<br>把里面的title标签中间原本的内容删掉换成你想用的</p><pre><code class="lang-php">?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;meta https-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;meta name=&quot;robots&quot; content=&quot;noindex&quot; /&gt;        &lt;meta name=&quot;google&quot; content=&quot;notranslate&quot;&gt;        &lt;title&gt;&lt;?php echo I18n::_($NAME); ?&gt;&lt;/title&gt;//把这一行替换成&lt;title&gt;（你想用的名字）&lt;/title&gt;&lt;?php</code></pre><p>这样就换好网站名了。</p><p>还有一个就是网站的favico的更换，favico就是那个小图标。<br>这个可以直接用你想用的图片去替换<code>/img/favico.ico</code>就行了</p><p>配置文件中还有很多可配置项，你可以去我上面推荐的官网或这大佬的博客里面看看。<br>我的搭建好的最终的效果<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917165034.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190917165034.webp" class="img-shadow img-margin"></center></a><br>欢迎大家使用哦</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么电脑配置不错，玩mc的时候开光影却特别卡（傻瓜式操作）</title>
      <link href="/2019/09/16/mcgy/"/>
      <url>/2019/09/16/mcgy/</url>
      
        <content type="html"><![CDATA[<p>首先上几张光影（都是我自己截的）美图<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916154843.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916154843.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916154924.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916154924.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916155551.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916155551.webp" class="img-shadow img-margin"></center></a></p><p>前排提示：我只是傻瓜式操作，可能你的电脑会跟我的不太一样，但是基本上大差不差的。如果这样了还不行，换显卡吧（滑稽</p><p>在桌面右键打开<code>NVIDIA 控制面板</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916155201.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916155201.webp" class="img-shadow img-margin"></center></a><br>你可以直接在全局设置中的首选图形处理器选择高性能NVIDIA处理器。</p><p>也可以在程序设计中找的你的&#39;JAVA8&#39;，更改它的首选图形处理器<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916155355.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190916155355.webp" class="img-shadow img-margin"></center></a></p><p>点击应用。就好了。</p><p>不说了，我继续去玩！！！</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> minecraft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中秋快乐！</title>
      <link href="/2019/09/13/zhongqiu/"/>
      <url>/2019/09/13/zhongqiu/</url>
      
        <content type="html"><![CDATA[<p>中秋节，在学校有事不能回家还是很忧伤的。也罢，中秋快乐！</p><p>中秋彩蛋: <a href="https://about.cndrew.cn/caidan/" target="_blank" rel="noopener">电子竞技虽好，不要忘了家人朋友哦</a></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 577 (Div. 2) - C</title>
      <link href="/2019/09/13/cf1201-C/"/>
      <url>/2019/09/13/cf1201-C/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforc.es/contest/1201/problem/C" target="_blank" rel="noopener">Codeforces Round 577 (Div. 2) - C</a></p><p><center>Maximum Median</center><br>Description:<br>You are given an array a of n integers, where n is odd. You can make the following operation with it:</p><p>Choose one of the elements of the array (for example ai) and increase it by 1 (that is, replace it with ai+1).<br>You want to make the median of the array the largest possible using at most k operations.</p><p>The median of the odd-sized array is the middle element after the array is sorted in non-decreasing order. For example, the median of the array [1,5,2,3,5] is 3.</p><p>Input<br>The first line contains two integers n and k (1≤n≤2⋅1e5, n is odd, 1≤k≤1e9) — the number of elements in the array and the largest number of operations you can make.</p><p>The second line contains n integers a1,a2,…,an (1≤ai≤1e9).</p><p>Output<br>Print a single integer — the maximum possible median after the operations.</p><p>Examples<br>input<br>3 2<br>1 3 5<br>output<br>5<br>input<br>5 5<br>1 2 1 1 1<br>output<br>3<br>input<br>7 7<br>4 1 2 4 3 4 4<br>output<br>5<br>Note<br>In the first example, you can increase the second element twice. Than array will be [1,5,5] and it&#39;s median is 5.</p><p>In the second example, it is optimal to increase the second number and than increase third and fifth. This way the answer is 3.</p><p>In the third example, you can make four operations: increase first, fourth, sixth, seventh element. This way the array will be [5,1,2,5,3,5,5] and the median will be 5.</p><p>Problem solving:<br>这道题的意思就是给你一组数，然后给你一个k值，你可以随意地把k分配到每一个数上，现在要求你分完之后得到最大的的中位数的值。我是从二分的tag找到的这道题。一开始毫无思路。后来发现，首先前半部分的数对答案是不会有影响的，所以我们只需要处理中间的数以及他后面的数就行。所以先sort一下，然后从中间那个数开始进行二分。二分的最小值就是中间值的大小，二分的最大值就是中间的值加上k。二分中check的时候我们需要从中间开始遍历每一个数，累加每一个数大于mid的值的多少，最后跟k比较。如果k小于那个累加的值，说明这个mid达不到。反之说明可以。</p><p>二分是真的巧妙<br>Code:</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 2e5 + 10;typedef long long ll;ll        a[maxn], n, k, mid;bool check(ll x){    ll s = 0;    for (ll i = mid; i &lt;= n; i++)    {        if (a[i] &lt; x)            s += (x - a[i]);        if (k &lt; s)            return 0;    }    return 1;}int main(){    cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    sort(a + 1, a + n + 1);    mid = (1 + n) &gt;&gt; 1;    ll l, r;    l = a[mid], r = a[mid] + k;    while (l &lt;= r)    {        ll m = (l + r) &gt;&gt; 1;        if (check(m))        {            l = m + 1;        }        else            r = m - 1;    }    cout &lt;&lt; l - 1 &lt;&lt; endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 583 (Div. 1 + Div. 2, based on Olympiad of Metropolises) - D</title>
      <link href="/2019/09/12/cf1214-D/"/>
      <url>/2019/09/12/cf1214-D/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforc.es/contest/1214/" target="_blank" rel="noopener">Codeforces Round #583 (Div. 1 + Div. 2, based on Olympiad of Metropolises)</a></p><center>Treasure Island</center><p>Description:<br>All of us love treasures, right? That&#39;s why young Vasya is heading for a Treasure Island.</p><p>Treasure Island may be represented as a rectangular table n×m which is surrounded by the ocean. Let us number rows of the field with consecutive integers from 1 to n from top to bottom and columns with consecutive integers from 1 to m from left to right. Denote the cell in r-th row and c-th column as (r,c). Some of the island cells contain impassable forests, and some cells are free and passable. Treasure is hidden in cell (n,m).</p><p>Vasya got off the ship in cell (1,1). Now he wants to reach the treasure. He is hurrying up, so he can move only from cell to the cell in next row (downwards) or next column (rightwards), i.e. from cell (x,y) he can move only to cells (x+1,y) and (x,y+1). Of course Vasya can&#39;t move through cells with impassable forests.</p><p>Evil Witch is aware of Vasya&#39;s journey and she is going to prevent him from reaching the treasure. Before Vasya&#39;s first move she is able to grow using her evil magic impassable forests in previously free cells. Witch is able to grow a forest in any number of any free cells except cells (1,1) where Vasya got off his ship and (n,m) where the treasure is hidden.</p><p>Help Evil Witch by finding out the minimum number of cells she has to turn into impassable forests so that Vasya is no longer able to reach the treasure.</p><p>Input<br>First line of input contains two positive integers n, m (3≤n⋅m≤1000000), sizes of the island.</p><p>Following n lines contains strings si of length m describing the island, j-th character of string si equals &quot;#&quot; if cell (i,j) contains an impassable forest and &quot;.&quot; if the cell is free and passable. Let us remind you that Vasya gets of his ship at the cell (1,1), i.e. the first cell of the first row, and he wants to reach cell (n,m), i.e. the last cell of the last row.</p><p>It&#39;s guaranteed, that cells (1,1) and (n,m) are empty.</p><p>Output<br>Print the only integer k, which is the minimum number of cells Evil Witch has to turn into impassable forest in order to prevent Vasya from reaching the treasure.</p><p>Examples<br>input<br>2 2<br>..<br>..<br>output<br>2<br>input<br>4 4<br>....</p><h1 id><a href="#" class="headerlink" title=".#."></a>.#.</h1><p>....<br>.#..<br>output<br>1<br>input<br>3 4<br>....<br>.##.<br>....<br>output<br>2<br>Note<br>The following picture illustrates the island in the third example. Blue arrows show possible paths Vasya may use to go from (1,1) to (n,m). Red illustrates one possible set of cells for the Witch to turn into impassable forest to make Vasya&#39;s trip from (1,1) to (n,m) impossible.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190912223133.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190912223133.webp" class="img-shadow img-margin"></center></a><p>Problem solving:<br>这道题我一开始以为是xjb找规律，然后把每种情乱都考虑了之后发现并不是。因为会有无数种情况。<br>这道题的意思就是给你一个图，<code>#</code>代表不能走的地方，然后问你为了不让这个人走到终点，终点就是（n-1,m-1），你最少得放几个<code>#</code>，这个人只能往左边或往下边走。<br>首先我们要知道这个答案也就三种情况：0，1，2，因为最差的情况下只需要把起点的右边和下边封住就行了。<br>还有一点就是如果直接用二维字符数组存是存不下的，所以用string数组。<br>这道题我们需要dfs来写。因为dfs有一个特性就是一条路走到头，俗称不撞南墙不回头。<br>我们先dfs一遍，看在不加<code>#</code>的情况下可不可到达终点，如果已经不可以了，直接输出0即可，如果可以就再来一遍dfs。但是如果不做任何处理就dfs，显然是没用的。因为我们进行第二次dfs就说明初始情况下，肯定是可以到达终点的，所以我们在dfs的过程中，把一条可以走到终点的路全部换成<code>#</code>，然后再进行dfs，如果还可以到终点，说明只封一下是不够的。答案就是二。如果第二次dfs的时候走不到终点了，说明答案就是1.<br>这个很透彻的体现了dfs的一条路走到底，我很喜欢这道题！！！</p><p>Code：</p><pre><code class="lang-c++">#include &lt;iostream&gt;using namespace std;const int maxn = 1e6 + 10;string    s[maxn]; int n, m;bool dfs(int x, int y){    if (x == n - 1 &amp;&amp; y == m - 1)        return 1;    if (x &gt;= n || y &gt;= m || s[x][y] == &#39;#&#39;)        return 0;    if (x || y)        s[x][y] = &#39;#&#39;;    return dfs(x + 1, y) || dfs(x, y + 1);}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++)        cin &gt;&gt; s[i];    if (!dfs(0, 0))        puts(&quot;0&quot;);    else    {        if (dfs(0, 0))            puts(&quot;2&quot;);        else            puts(&quot;1&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> dfs </tag>
            
            <tag> codeforces </tag>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表实现数组的功能</title>
      <link href="/2019/09/12/DS-sxb/"/>
      <url>/2019/09/12/DS-sxb/</url>
      
        <content type="html"><![CDATA[<pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct{    int *elem, len;}Array;const int maxn = 1e5;int       j,choose,n,e,gn,fn,ip,in,choose2,Insert,dn;Array a;// typedef int Statusint InitList(Array &amp;L){    L.elem = new int[maxn];    if (!L.elem)        return -2;    L.len = 0;    return 1;}int GetElem(Array L, int i, int &amp;e){    if ((i &lt; 1) || (i &gt; L.len))        return 0;    e = L.elem[i - 1];    return 1;}int LocateElem(Array L, int e){    for (int i = 0; i &lt; L.len; i++)        if (L.elem[i] == e)            return i + 1;    return 0;}int ListInsert(Array &amp;L, int i, int e){    if ((i &lt; 1) || (i &gt; L.len + 1))        return -2;    if (L.len == maxn)        return 0;    for (j = L.len - 1; j &gt;= i - 1; j--)    {        L.elem[j + 1] = L.elem[j];    }    L.elem[i - 1] = e;    L.len++;    return 1;}int ListDelete(Array &amp;L, int i){    if ((i &lt; 1) || (i &gt; L.len + 1))        return 0;    for (j = i; j &lt;= L.len - 1; j++)        L.elem[j - 1] = L.elem[j];    L.len--;    return 1;}int main(){    // Array a;    // InitList(a);    // for (int xx = 1; xx &lt;= 10; xx++)    //     cin &gt;&gt; a.elem[xx], a.len++;    // cout &lt;&lt; LocateElem(a, 5);    cout&lt;&lt;&quot;--------若要正常使用本功能，请在最开始的时候选择初始化--------\n\n\n&quot;;    cout &lt;&lt; &quot;1.初始化\n&quot;; cout &lt;&lt; &quot;2.取值\n&quot;; cout &lt;&lt; &quot;3.查找\n&quot;; cout &lt;&lt; &quot;4.插入\n&quot;; cout &lt;&lt; &quot;5.删除\n&quot;;cout &lt;&lt; &quot;0.退出\n&quot;;    choose=-1;    while(choose!=0)    {        cout&lt;&lt;&quot;请选择：&quot;;        cin&gt;&gt;choose;        switch(choose)        {            case 1:                if(InitList(a)==1)                {                    puts(&quot;初始化成功&quot;);                    cout&lt;&lt;&quot;请输入你要输入的数据个数：&quot;;cin&gt;&gt;n;                    cout&lt;&lt;&quot;请输入&quot;&lt;&lt;n&lt;&lt;&quot;个数：\n&quot;;                    for(j=0;j&lt;n;j++)                        cin&gt;&gt;a.elem[j],a.len++;                    cout&lt;&lt;&quot;存储成功\n&quot;;                }                else    puts(&quot;存储分配失败&quot;);                break;            case 2:                cout&lt;&lt;&quot;请输入你想取出来的数的位置：&quot;;cin&gt;&gt;gn;                if(GetElem(a,gn,e))    cout&lt;&lt;&quot;取出来的数为：&quot;&lt;&lt;e&lt;&lt;endl;                else    cout&lt;&lt;&quot;位置不存在\n&quot;;                break;            case 3:                cout&lt;&lt;&quot;请输入你想查找的数值：&quot;;cin&gt;&gt;fn;                if(LocateElem(a,fn))    cout&lt;&lt;&quot;查找成功\n这个数是数列中的第&quot;&lt;&lt;LocateElem(a,fn)&lt;&lt;&quot;个元素\n&quot;;                else    cout&lt;&lt;&quot;查找失败，这个数不存在\n&quot;;                break;            case 4:                cout&lt;&lt;&quot;请输入你想插入的元素：&quot;;cin&gt;&gt;in;                cout&lt;&lt;&quot;请输入你想插入到的位置：&quot;;cin&gt;&gt;ip;                Insert=ListInsert(a,ip,in);                if(Insert==0)    cout&lt;&lt;&quot;插入失败，存储空间已满\n&quot;;                if(Insert==-2)    cout&lt;&lt;&quot;插入失败，插入位置不存在\n&quot;;                if(Insert==1)                {                    cout&lt;&lt;&quot;插入成功\n&quot;;                    choose2=-1;                    cout&lt;&lt;&quot;是否要查看插入之后的数组？1=是，0=否：&quot;;cin&gt;&gt;choose2;                    if(choose=1)                    for(int i=0;i&lt;a.len;i++)                        cout&lt;&lt;a.elem[i]&lt;&lt;&quot; &quot;;                    cout&lt;&lt;endl;                }                break;            case 5:                cout&lt;&lt;&quot;请输入你想删除的数的位置：&quot;;cin&gt;&gt;dn;                if(ListDelete(a,dn))    cout&lt;&lt;&quot;删除成功\n&quot;;                else    cout&lt;&lt;&quot;删除失败\n&quot;;                break;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Discrete mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> DS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为你的hexo博客添加说说页面</title>
      <link href="/2019/09/11/shuoshuo/"/>
      <url>/2019/09/11/shuoshuo/</url>
      
        <content type="html"><![CDATA[<p>已实现动态的说说页面，可实时发布说说。详情见：<a href="https://cndrew.cn/2020/04/10/hexo-shuoshuo/" target="_blank" rel="noopener">为你的hexo博客添加动态的（可直接发布说说的）说说页面</a></p><p>解决导语中的问题的很好的一个办法就是，添加一个说说的页面，每次只有一两句话，以类似于时间轴的形式展现出来。<br>我在网上搜了好久，基本上都是针对于wordpress的php的代码。wordpress我是真的用不好，还是hexo得我心。<br>然后我这个前端小白，抱着试一试的心理把php的代码直接做成页面放进了我的博客。没想到还真的成了。但是肯定也是改了一些东西的，不然这篇文章意义何在？<br>一个比较大的变化就是，原版的代码中使用php获取当前时间的函数再html中我没有找到与之对应的。所以有个很尴尬的问题就是，当你想新建一个说说并且显示日期的时候，你得手动。。。这个确实不太方便，但是我的能力也就止步于此了。<br>我是在这里找到的源码：<a href="https://liuyanzhao.com/945.html" target="_blank" rel="noopener">纯代码给wordpress增加说说/微博/微语功能 | 言曌博客</a></p><p>下面是hexo添加这个页面的大致步骤。</p><ol><li>在<code>..\blog文件夹\source</code>中新建一个文件夹，命名随意，但是一定要记住。这里我新建的文件夹叫<code>shuoshuo</code></li><li>在文件夹中新建一个<code>index.html</code>，并将代码粘贴进去</li><li>在对应的主题页面菜单添加说说，并链接到创建的说说页面</li></ol><p>上面的第一第三步不难，并且每个主题可能还不一样，所以就不细说了。</p><p>第二步：<br>将下面的代码粘贴到你的index.html中<br><a href="https://paste.cndrew.cn/?373cc8e8db2294fa#6Z2aNLnjSBiSSeAquQWqEv5G1RDSdVHw9H3jSBw7ms2u" target="_blank" rel="noopener">特殊原因，点击这个去复制代码（不知名的直接放代码页面会卡爆艹）</a></p><p>每次想要新建一个说说的时候按照这个格式来</p><pre><code class="lang-html">&lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp&quot; class=&quot;avatar avatar-48&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;&lt;!-- 这个img src里面的链接是说说头像的链接 --&gt;    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;    &lt;!-- 这个href是你想要让这个说说链接到的地方，如果没有不管它就行 --&gt;        &lt;p&gt;&lt;/p&gt;        &lt;p&gt;&lt;!-- 这里写的就是说说的内容 --&gt;&lt;/p&gt;        &lt;p&gt;&lt;/p&gt;        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;            2019年9月10日            &lt;!-- 这个地方写上时间，如果不想写删除就行了。 --&gt;        &lt;/p&gt;    &lt;/a&gt;&lt;/li&gt;</code></pre><p>按照你的想法将上面的代码改好之后，粘贴到你的shuoshuo文件夹中index.html里面。根据每个\<li>标签查找你应该粘贴到的位置。注意这个顺序就会是你在页面上现实的顺序。</li></p><p>为了预防你还不知道怎么添加，给你一个三个说说的部分代码的例子</p><pre><code class="lang-html">&lt;div id=&quot;primary&quot; class=&quot;content-area&quot; style=&quot;&quot;&gt;    &lt;main id=&quot;main&quot; class=&quot;site-main&quot; role=&quot;main&quot;&gt;        &lt;div id=&quot;shuoshuo_content&quot;&gt;            &lt;ul class=&quot;cbp_tmtimeline&quot;&gt;                &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp&quot; class=&quot;avatar avatar-48&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;                        &lt;p&gt;&lt;/p&gt;                        &lt;p&gt;第一个说说&lt;/p&gt;                        &lt;p&gt;&lt;/p&gt;                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;                            2019年9月10日                        &lt;/p&gt;                    &lt;/a&gt;                &lt;/li&gt;                &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp&quot; class=&quot;avatar avatar-48&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;                        &lt;p&gt;&lt;/p&gt;                        &lt;p&gt;第一个说说&lt;/p&gt;                        &lt;p&gt;&lt;/p&gt;                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;                            2019年9月10日                        &lt;/p&gt;                    &lt;/a&gt;                &lt;/li&gt;                &lt;li&gt; &lt;span class=&quot;shuoshuo_author_img&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp&quot; class=&quot;avatar avatar-48&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;/span&gt;                    &lt;a class=&quot;cbp_tmlabel&quot; href=&quot;&quot;&gt;                        &lt;p&gt;&lt;/p&gt;                        &lt;p&gt;第一个说说&lt;/p&gt;                        &lt;p&gt;&lt;/p&gt;                        &lt;p class=&quot;shuoshuo_time&quot;&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;                            2019年9月10日                        &lt;/p&gt;                    &lt;/a&gt;                &lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;&lt;/div&gt;</code></pre><p>这里我还是挺希望大家可以留言评论的，因为点赞功能我加不上。。。这个源码很强的一点就是我试了好几个主题，它的兼容性都特别好，直接融入主题，毫无违和感的那种，还是舔一波原作者，太强了。</p><p>效果图：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190911134335.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190911134335.webp" class="img-shadow img-margin"></center></a><br>我的说说界面传送门: <a href="/shuoshuo">Drew最帅</a></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Preliminary Contest for ICPC Asia Xuzhou 2019-M</title>
      <link href="/2019/09/09/xuzhou/"/>
      <url>/2019/09/09/xuzhou/</url>
      
        <content type="html"><![CDATA[<p>Link： <a href="https://nanti.jisuanke.com/t/41395" target="_blank" rel="noopener">Longes subsequence</a></p><p><center>Longest subsequence</center><br>String is a very useful thing and a subsequence of the same string is equally important.</p><p>Now you have a string s with length n and a string t with length m. Find out the longest subsequence in the string s so that the lexicographical order of this subsequence is strictly larger than t.</p><p>Input<br>two integers n, m in the first line</p><p>（All characters are lowercase letters）</p><p>The second line is a string s</p><p>The third line is a string t</p><p>1≤n,m≤1e6</p><p>Output<br>Output an integer representing the longest length, otherwise output -1.</p><p>样例输入1<br>9 3<br>aaabbbccc<br>abc<br>样例输出1<br>6<br>样例输入2<br>9 3<br>aaabbbccc<br>zzz<br>样例输出2<br>-1</p><p>Problem solving:<br>先占着，慢慢补</p><p>Code:</p><pre><code class="lang-c++"></code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈皮的一天</title>
      <link href="/2019/09/09/zom/"/>
      <url>/2019/09/09/zom/</url>
      
        <content type="html"><![CDATA[<p>今天被小哥哥带去森林公园耍了小半天。本来因为某些事压抑的心情也是得到了极大的缓解。<br>开心就完事了。<br>我很喜欢的一首歌。</p><center>好心分手 卢巧音 王力宏</center><p>是否很惊讶讲不出说话<br>没错我是说你想分手吗<br>曾给你驯服到就像绵羊<br>何解会反咬你一下你知吗<br>也许该反省不应再说话<br>被放弃的我应有此报吗<br>如果我曾是个坏牧羊人能否再让我<br>试一下抱一下<br>回头望伴你走从来未曾幸福过<br>恨太多没结果往事重提是折磨<br>下半生陪住你怀疑快乐也不多<br>被我伤让你痛<br>好心一早放开我<br>从头努力也坎坷统统不要好过<br>为何唱着这首歌<br>为怨恨而分手问你是否原谅我<br>若注定有一点苦楚<br>不如自己亲手割破<br>回头吧不要走<br>不要这样离开我<br>恨太多没结果往事重提是折磨<br>下半生陪住你怀疑快乐也不多<br>没有心别再拖<br>好心一早放开我<br>从头努力也坎坷<br>统统不要好过<br>为何唱着这首歌<br>为怨恨而分手问你是否原谅我<br>若勉强也分到不多不如什么也摔破<br>好心分手每天播<br>可知歌者也奈何<br>难行就无谓再拖<br>好心一早放开我从头努力也坎坷<br>统统不要好过<br>为何唱着这首歌<br>为怨恨而分手问你是否原谅我<br>若注定有一点苦楚<br>不如自己亲手割破</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FBI树</title>
      <link href="/2019/09/08/nowcoder1086-A/"/>
      <url>/2019/09/08/nowcoder1086-A/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://ac.nowcoder.com/acm/contest/1086/A" target="_blank" rel="noopener">nowcoder-1086-A</a></p><p><center>FBI树</center><br>Description:<br>我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。</p><p>FBI树是一种二叉树[1]，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2^N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：</p><p>1) T的根结点为R，其类型与串S的类型相同；</p><p>2) 若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。</p><p>现在给定一个长度为2N的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历[2]序列。</p><blockquote><p>[1] 二叉树：二叉树是结点的有限集合，这个集合或为空集，或由一个根结点和两棵不相交的二叉树组成。这两棵不相交的二叉树分别称为这个根结点的左子树和右子树。</p><p>[2] 后序遍历：后序遍历是深度优先遍历二叉树的一种方法，它的递归定义是：先后序遍历左子树，再后序遍历右子树，最后访问根。</p></blockquote><p>输入描述:<br>第一行是一个整数N（0 &lt;= N &lt;= 10）<br>第二行是一个长度为2^N的“01”串。<br>输出描述:<br>一个字符串，即FBI树的后序遍历序列。<br>示例1<br>输入<br>3<br>10001011<br>输出<br>IBFBBBFIBFIIIFF<br>备注:<br>对于40%的数据，N &lt;= 2；<br>对于全部的数据，N&lt;= 10。</p><p>Problem solving:<br>这道题我一开始是没看懂的。但是在csdn上看到了一张巨巨的图。这里借用一下（手动@<a href="https://blog.csdn.net/wwwwcw" target="_blank" rel="noopener">wwwwcw</a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190908204905.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190908204905.webp" class="img-shadow img-margin"></center></a></p><p>看了这个图首先题意不是问题了。我想到了暴力遍历每一个子串。但是太难写了。看到了巨巨的dfs版本。忽然看到了新世界。<br>我们dfs的时候传两个参数，一个左端点一个右端点。每次去中间的值，如果r和l不相等，就继续dfs，但是这次dfs需要两个，一个是左边（即l-mid），另一个是右边（mid+1,r），如果dfs的过程中r与l相等了，就判断这次l和r之间的01组成，输出对应的字符。这道题还涉及到了基础的二叉树。虽然对这个不太了解，但是对这个题影响不大。</p><p>这道题给我最大的感觉就是让我加深了对dfs的理解。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int n; string s;void dfs(int l, int r){    int mid = (l + r) / 2;    if (r != l)    {        dfs(l, mid);        dfs(mid + 1, r);    }    int x, y;    x = y = 0;    for (int i = l; i &lt;= r; i++)    {        if (s[i] - &#39;0&#39; == 0)            x++;        else            y++;    }    if (x &amp;&amp; y)        cout &lt;&lt; &quot;F&quot;;    if (x &amp;&amp; !y)        cout &lt;&lt; &quot;B&quot;;    if (!x &amp;&amp; y)        cout &lt;&lt; &quot;I&quot;;}int main(){    cin &gt;&gt; n &gt;&gt; s;    dfs(0, s.size() - 1);    return 0;}</code></pre><p>dfs是真的妙！！！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 72 (Rated for Div. 2) - C</title>
      <link href="/2019/09/08/cfedu72-C/"/>
      <url>/2019/09/08/cfedu72-C/</url>
      
        <content type="html"><![CDATA[<p><cecnter>The Number Of Good Substrings&lt;/center&gt;<br>Description:<br>You are given a binary string s (recall that a string is binary if each character is either 0 or 1).</cecnter></p><p>Let f(t) be the decimal representation of integer t written in binary form (possibly with leading zeroes). For example f(011)=3,f(00101)=5,f(00001)=1,f(10)=2,f(000)=0 and f(000100)=4.</p><p>The substring sl,sl+1,…,sr is good if r−l+1=f(sl…sr).</p><p>For example string s=1011 has 5 good substrings: s1…s1=1, s3…s3=1, s4…s4=1, s1…s2=10 and s2…s4=011.</p><p>Your task is to calculate the number of good substrings of string s.</p><p>You have to answer t independent queries.</p><p>Input<br>The first line contains one integer t (1≤t≤1000) — the number of queries.</p><p>The only line of each query contains string s (1≤|s|≤2⋅1e5), consisting of only digits 0 and 1.</p><p>It is guaranteed that ∑i=1t|si|≤2⋅1e5.</p><p>Output<br>For each query print one integer — the number of good substrings of string s.</p><p>Example<br>input<br>4<br>0110<br>0101<br>00001000<br>0001000<br>output<br>4<br>3<br>4<br>3</p><p>Problem solving:<br>这道题真的很有意思。它就是给你一个只有0跟1组成的字符串，然后问在它的子串中有多少个串，以二进制形式表示的值跟它的长度是相等的。这里有一点我们需要知道就是你可以在前面补零。所以我们可以直接遍历字符串，找到1的时候在处理。并且2的20次方就已经超过了2e5，所以我们只需要处理到最多20位之后就不会有满足情况的子串出现了。这一步很重要。<br>首先我们在遍历的时候就处理0的个数。然后直到我们遇到一，以这个1为起点，往后延申最多20位，用你构造出来的二进制形式的值跟当前子串的长度的差值跟前面0的个数的关系。如果0的个数够多，那么就一定可以有一个满足情况的子串出现。因为我们往前补不论多少0，结果都是不会变的。<br>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int    n;    string s;    cin &gt;&gt; n;    while (n--)    {        cin &gt;&gt; s;        int mid = 0, ans = 0;        for (int i = 0; i &lt; s.size(); i++)        {            if (s[i] == &#39;0&#39;)//遇到1之前累计0的个数                mid++;            else            {                ans++;//1本身就满足，所以先加一                int cnt = 1;                for (int j = i + 1; j &lt; min(i + 20, (int) s.size()); j++)                {                    if (s[j] == &#39;0&#39;)//如果新加的二进制位是0，在原来的值的基础上乘2就行                        cnt *= 2;                    else//如果是1，还得加上。这就类似于位运算的一个模拟                        cnt = cnt * 2 + 1;  \                    if (mid &gt;= (cnt - j + i - 1))//如果0的个数大于当前子串的值与当前子串的长度的差值，说明这个可以构造成功，答案加一                        ans++;                }                mid = 0;//每次遇到1之后就把之前记录的0的个数清空            }        }        cout &lt;&lt; ans &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛51 - B,C,D</title>
      <link href="/2019/09/07/nowc1083/"/>
      <url>/2019/09/07/nowc1083/</url>
      
        <content type="html"><![CDATA[<h4 id="子串查询"><a href="#子串查询" class="headerlink" title="子串查询"></a>子串查询</h4><p>Description:<br>给出一个长度为n的字符串s和q个查询。对于每一个查询，会输入一个字符串t，你需要判断这个字符串t是不是s的子串。子串的定义就是存在任意下标a&lt;b&lt;c&lt;d&lt;e，那么”s[a]s[b]s[c]s[d]s[e]”就构成s的一个子串。如”abc”的子串有”a”、”b”、”c”、”ab”、”ac”、”bc”、”abc”。<br>输入描述:<br>第一行两个数n，q。1&lt;=n，q&lt;=1e5。</p><p>第二行一个长度为n的字符串s,所有字符都为小写拉丁字符。</p><p>接下来q行每行一个字符串t。1&lt;=|t|&lt;=50。<br>输出描述:<br>对于每个查询，如果t是s的字串，输出”YES”,否则输出”NO”。每个答案占一行。<br>示例1<br>输入<br>8 4<br>ababcbaa<br>abac<br>accb<br>aaaa<br>abcba<br>输出<br>YES<br>NO<br>YES<br>YES</p><p>Problem solving:<br>这道题我一看还以为是跟之前暑假集训时候的一到积分赛的题一样。然后直接暴力着写，T了4发。后来才发现暴力的话是1e5乘1e5。然后学长说序列自动机。百度了一下。发现就是序列自动机裸题<br>说一下我对序列自动机的理解吧。nxt[i][j]就是用一个二维数组存一下以当前位置i为起点的第一次出现j(j可以用0-26表示a-z)的位置。具体的我也说不清，看代码悟吧。<br>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;int       nxt[maxn][30], now[30];int main(){    memset(now, -1, sizeof(now));    int    n, q, flag, ans;    string a, b;    cin &gt;&gt; n &gt;&gt; q &gt;&gt; a;    for (int i = a.size() - 1; i &gt;= 0; i--)    {        for (int j = 0; j &lt; 26; j++)        {            nxt[i][j] = now[j];        }        now[a[i] - &#39;a&#39;] = i;//用now数组存一下当前字母的位置。    }    for (int i = 0; i &lt; a.size(); i++)    {        cout &lt;&lt; now[a[i] - &#39;a&#39;];        for (int j = 0; j &lt; 26; j++)        {            cout &lt;&lt; nxt[i][j] &lt;&lt; endl;        }    }    while (q--)    {        flag = 0;        cin &gt;&gt; b;        int mid = now[b[0] - &#39;a&#39;];        if (mid == -1)        {            puts(&quot;NO&quot;);            continue;        }        for (int i = 1; i &lt; b.size(); i++)        {            mid = nxt[mid][b[i] - &#39;a&#39;];            if (mid == -1)            {                flag = 1;                break;            }        }        if (!flag)            puts(&quot;YES&quot;);        else            puts(&quot;NO&quot;);    }}</code></pre><h4 id="勾股定理"><a href="#勾股定理" class="headerlink" title="勾股定理"></a>勾股定理</h4><p>Description:<br>给出直角三角形其中一条边的长度n，你的任务是构造剩下的两条边，使这三条边能构成一个直角三角形。<br>输入描述:<br>一个整数n。<br>输出描述:<br>另外两条边b,c。答案不唯一，只要输出任意一组即为合理，如果无法构造请输出-1。<br>示例1<br>输入<br>3<br>输出<br>4 5<br>示例2<br>输入<br>4<br>输出<br>3 5<br>备注:<br>0&lt;=n&lt;=1e9</p><p>1&lt;=b,c&lt;=1e18</p><p>n,b,c均为整数<br>Problem solving:<br>这道题没什么意思。是个规律，我也没找到。把这个题放在这就是为了记一下这个规律，万一以后有用呢。</p><p>对小范围数据进行打表，即可发现存在以下规律：<br>1.当n&gt;2时总有方法可以构造<br>2.当n是奇数总存在两条边b,c使得c-b==1并且n^2+b^2=c^2<br>3.当n是偶数总存在两条边b,c使得c-b==2并且n^2+b^2=c^2<br>因此我们可以设边c=x,分n是奇数和偶数的情况，有<br>1.n是奇数，b=x-1-&gt;n^2+(x-1)^2=x^2-&gt;x=(n^2+1)/2<br>2.n是偶数，b=x-2-&gt;n^2+(x-2)^2=x^2-&gt;x=(n^2+4)/4</p><p>源于：<a href="https://ac.nowcoder.com/discuss/248083" target="_blank" rel="noopener">牛客练习赛51题解</a></p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    long long n;    cin&gt;&gt;n;    if(n&lt;=2)    puts(&quot;-1&quot;);    else if(n&amp;1)    cout&lt;&lt;(n*n+1)/2-1&lt;&lt;&quot; &quot;&lt;&lt;(n*n+1)/2&lt;&lt;endl;    else    cout&lt;&lt;(n*n+4)/4-2&lt;&lt;&quot; &quot;&lt;&lt;(n*n+4)/4&lt;&lt;endl;    return 0;}</code></pre><h4 id="羊吃草"><a href="#羊吃草" class="headerlink" title="羊吃草"></a>羊吃草</h4><p>链接：<a href="https://ac.nowcoder.com/acm/contest/1083/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/1083/D</a><br>来源：牛客网</p><p>有一个草原可以用一个1~400的数轴表示。有n头羊和q个查询。每头羊的编号分别是1，2，3…n。第i头羊只喜爱数轴上[ai，bi]这样的一个闭区间，每一时刻每头羊只可能在自己喜爱的区间的某个点上吃草。现在给出q个查询，每个查询两个整数l，r。你需要计算出在同一时刻，最多能有多少头羊同时在这个区间内吃草。数轴上每一个整点同一时刻只能容纳一只羊，羊只会在整点吃草。</p><p>输入描述:<br>第一行三个数n q。</p><p>第二行n个数a1 a2…an。</p><p>第三行n个数b1 b2…bn。</p><p>接下来q行每行两个数l，r。表示询问的区间。<br>输出描述:<br>对于每个查询，输出一个整数表示答案。<br>示例1<br>输入<br>5 3<br>1 1 1 2 4<br>1 1 1 3 5<br>1 5<br>2 5<br>1 3<br>输出<br>3<br>2<br>2<br>备注:<br>1&lt;=n，q&lt;=400</p><p>1&lt;=ai&lt;=bi&lt;=400</p><p>1=l&lt;=r&lt;=400</p><p>Problem solving:<br>这道题我看题解里面写了一堆看不懂的东西。但是看通过代码的时候看到一个巨佬用贪心过了。<br>把每只羊能吃的草的范围用结构体存一下。然后以左端点升序排序。保证当前位置能来的羊尽可能的不去干扰下一个羊。感觉有点类似于看电视的那道题了。没个地方最多只能有一只羊，所以需要一个标记数组。<br>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;struct node{    int l, r;}    p[500];bool vis[500];bool cmp(node a, node b){    if (a.r == b.r)        return a.l &lt; b.l;    return a.r &lt; b.r;}int main(){    int n, q;    cin &gt;&gt; n &gt;&gt; q;    for (int i = 0; i &lt; n; i++)        cin &gt;&gt; p[i].l;    for (int j = 0; j &lt; n; j++)        cin &gt;&gt; p[j].r;    sort(p, p + n, cmp);    while (q--)    {        memset(vis, 0, sizeof(vis));        int l, r, ans = 0;        cin &gt;&gt; l &gt;&gt; r;        for (int i = 0; i &lt; n; i++)        {            for (int j = p[i].l; j &lt;= p[i].r; j++)            {                if (j &gt;= l &amp;&amp; j &lt;= r &amp;&amp; !vis[j])                {                    ans++, vis[j] = 1;                    break;                }            }        }        cout &lt;&lt; ans &lt;&lt; endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 序列自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 72 (Rated for Div. 2) - B</title>
      <link href="/2019/09/06/cfedu72-B/"/>
      <url>/2019/09/06/cfedu72-B/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1217" target="_blank" rel="noopener">Educational Codeforces Round 72 (Rated for Div. 2)</a></p><p><center>Zmei Gorynich</center><br>Description:<br>You are fighting with Zmei Gorynich — a ferocious monster from Slavic myths, a huge dragon-like reptile with multiple heads!<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190906145947.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190906145947.webp" class="img-shadow img-margin"></center></a><br>Initially Zmei Gorynich has x heads. You can deal n types of blows. If you deal a blow of the i-th type, you decrease the number of Gorynich&#39;s heads by min(di,curX), there curX is the current number of heads. But if after this blow Zmei Gorynich has at least one head, he grows hi new heads. If curX=0 then Gorynich is defeated.</p><p>You can deal each blow any number of times, in any order.</p><p>For example, if curX=10, d=7, h=10 then the number of heads changes to 13 (you cut 7 heads off, but then Zmei grows 10 new ones), but if curX=10, d=11, h=100 then number of heads changes to 0 and Zmei Gorynich is considered defeated.</p><p>Calculate the minimum number of blows to defeat Zmei Gorynich!</p><p>You have to answer t independent queries.</p><p>Input<br>The first line contains one integer t (1≤t≤100) – the number of queries.</p><p>The first line of each query contains two integers n and x (1≤n≤100, 1≤x≤1e9) — the number of possible types of blows and the number of heads Zmei initially has, respectively.</p><p>The following n lines of each query contain the descriptions of types of blows you can deal. The i-th line contains two integers di and hi (1≤di,hi≤1e9) — the description of the i-th blow.</p><p>Output<br>For each query print the minimum number of blows you have to deal to defeat Zmei Gorynich.</p><p>If Zmei Gorynuch cannot be defeated print −1.</p><p>Example<br>input<br>3<br>3 10<br>6 3<br>8 2<br>1 4<br>4 10<br>4 1<br>3 2<br>2 6<br>1 100<br>2 15<br>10 11<br>14 100<br>output<br>2<br>3<br>-1<br>Note<br>In the first query you can deal the first blow (after that the number of heads changes to 10−6+3=7), and then deal the second blow.</p><p>In the second query you just deal the first blow three times, and Zmei is defeated.</p><p>In third query you can not defeat Zmei Gorynich. Maybe it&#39;s better to convince it to stop fighting?<br>Problem solving:<br>这道题其实看懂了就会发现，就是那个蜗牛从井底往上爬的问题。每爬多少就会下滑多少。这道题里面是每减少多少就会增加多少。问你多少次之后可以变成零，并且每次减小的是本身还剩下的值和要减的值中的最小值，所以如果可以减少的话，那么一定会有一次减为零。所以我们需要记录两个最大值，一个是每次净减少的值，另一个是每次减少的值。具体看代码<br>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int n, m, x, a, b, maxn, maxm;    cin &gt;&gt; n;    while (n--)    {        maxn = 0, maxm = 0;        cin &gt;&gt; m &gt;&gt; x;        for (int i = 0; i &lt; m; i++)        {            cin &gt;&gt; a &gt;&gt; b;            maxn = max(maxn, a); maxm = max(maxm, (a - b));        }        if (maxn &gt;= x)//如果存在一次减少的值，只用这个一次就可以变成0            puts(&quot;1&quot;);        else if (maxm == 0)//如果maxm没有变还是0，说明这个它的初始值就不会减小，直接输出-1            puts(&quot;-1&quot;);        else            cout &lt;&lt; 1 + (x - maxn + maxm - 1) / maxm &lt;&lt; endl;//除去最后一次减掉的最多的，然后向上取整    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> codeforces </tag>
            
            <tag> thinking </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 72 (Rated for Div. 2) - A</title>
      <link href="/2019/09/06/cfedu72/"/>
      <url>/2019/09/06/cfedu72/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1217" target="_blank" rel="noopener">Educational Codeforces Round 72 (Rated for Div. 2)</a></p><p><center>Creating a Character</center><br>Description:<br>You play your favourite game yet another time. You chose the character you didn&#39;t play before. It has str points of strength and int points of intelligence. Also, at start, the character has exp free experience points you can invest either in strength or in intelligence (by investing one point you can either raise strength by 1 or raise intelligence by 1).</p><p>Since you&#39;d like to make some fun you want to create a jock character, so it has more strength than intelligence points (resulting strength is strictly greater than the resulting intelligence).</p><p>Calculate the number of different character builds you can create (for the purpose of replayability) if you must invest all free points. Two character builds are different if their strength and/or intellect are different.</p><p>Input<br>The first line contains the single integer T (1≤T≤100) — the number of queries. Next T lines contain descriptions of queries — one per line.</p><p>This line contains three integers str, int and exp (1≤str,int≤108, 0≤exp≤1e8) — the initial strength and intelligence of the character and the number of free points, respectively.</p><p>Output<br>Print T integers — one per query. For each query print the number of different character builds you can create.</p><p>Example<br>input<br>4<br>5 3 4<br>2 1 0<br>3 5 5<br>4 10 6<br>output<br>3<br>1<br>2<br>0<br>Note<br>In the first query there are only three appropriate character builds: (str=7,int=5), (8,4) and (9,3). All other builds are either too smart or don&#39;t use all free points.</p><p>In the second query there is only one possible build: (2,1).</p><p>In the third query there are two appropriate builds: (7,6), (8,5).</p><p>In the fourth query all builds have too much brains.</p><p>Problem solving:<br>这道题的意思就是有一个角色，给了你他的智力值和体力值的大小，然后给了你现在可分配的点数。问你有多少种情况。可以在把所有点数分完之后体力值大于智力值。每个点数都可以分配给智力值或体力值而加一。<br>数据范围1e8*100，直接暴力肯定会超时。<br>所以我们可以用二分来写。找到能满足条件的最小的分配给体力的值，然后用总点数减去这个值就是可以达到目的的分配次数。二分中的check直接判断体力值加上mid与智力值加上总点数-mid的大小关系即可。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a,b,e,x;bool check(int x){    if(a+x&gt;(b+(e-x)))  return 1;    return 0;}int main(){    ll n;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;a&gt;&gt;b&gt;&gt;e;        ll l=0,r=e,mid;        while(l&lt;=r)        {            mid=(l+r)/2;            if(check(mid))  r=mid-1;            else    l=mid+1;        }        cout&lt;&lt;e-r&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chevereto的中文文档</title>
      <link href="/2019/09/01/cnChevereto/"/>
      <url>/2019/09/01/cnChevereto/</url>
      
        <content type="html"><![CDATA[<p>去这里看最新进度: <a href="https://ch.cndrew.cn/" target="_blank" rel="noopener">Chevereto中文文档</a></p><p>2019.8.30  看到了Chevereto官方的文档，但是没找到中文的文档，有了翻译的想法<br>2019.8.31  着手招募成员，准备开始翻译<br>2019.9.01  与Chevereto的工作人员取得联系，并获得了他的支持。预计一个月内完成翻译。<br>2019.9.01  翻译了两天了，全是用的空闲时间。并且发现自己还是比较适合一个人单干，这个我也好痛苦。唉，不知道该怎么配合。算了。一个人干也挺好。记录一下目前的进度：7/34。预计第一次翻译完大约就在一个星期到两个星期之间。然后Debug再用一个星期到两个星期。正好是答应了开发人员的一个月。完美。<br>顺便得瑟一下取得的开发人员支持的聊天记录，说句题外话，真的喜欢外国知识圈的氛围。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190901225843.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190901225843.webp" class="img-shadow img-margin"></center></a><br>翻译版本<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190901230426.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190901230426.webp" class="img-shadow img-margin"></center></a><br>2019.9.02 今天的变化还是比较大的，我觉得还是找小伙伴一起搞吧，自己太难了。也谢谢我的小伙伴先。记录一下目前的进度11/34，虽然进度今天有点慢了，主要是这个进度看的是小标题的数量，每个小标题的内容是不同的，并且里面内容的难度也是不同的。这个进度不包括我的小伙伴的，保守估计，总进度的话，16/34应该是有的。再说一下，Chevereto的那个开发人员，挺有意思哈哈哈。然后说一下，今天，我中奖了！！！牛客的衣服，哈哈哈哈，第十几场中了一次，这第60场有中了一次。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190902230359.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190902230359.webp" class="img-shadow img-margin"></center></a><br>2019.9.03 今天进度21/35.预计再三天内可以完成第一遍翻译。鲁道夫老哥也不回我消息了，有点小慌哦。<br>2019.9.04 第一边翻译已完成，接下来会复查一遍然后就完成了。<br>2019.9.17 所有的复查已经完成，已经跟鲁道夫提交，等待ing<br>2019.9.18 工作人员已将本文档链接放在了官方文档。这步翻译基本完成，但是还需要跟着他们更新的步伐进行维护，我和我的团队会尽力保持同步。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190918071650.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190918071650.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Translate </tag>
            
            <tag> Chevereto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 582 (Div. 3)</title>
      <link href="/2019/08/31/cf582/"/>
      <url>/2019/08/31/cf582/</url>
      
        <content type="html"><![CDATA[<p>比赛链接： <a href="https://codeforces.com/contest/1213" target="_blank" rel="noopener">Codeforces Round #582 (Div. 3)</a></p><p>比赛时候就写出来两道题，还有一道是py的，赛后又补了三题。剩下的也要补，一定要补！！！</p><h2 id="A-Chips-Moving"><a href="#A-Chips-Moving" class="headerlink" title="A  Chips Moving"></a>A  Chips Moving</h2><p>description:<br>You are given n chips on a number line. The i-th chip is placed at the integer coordinate xi. Some chips can have equal coordinates.</p><p>You can perform each of the two following types of moves any (possibly, zero) number of times on any chip:</p><p>Move the chip i by 2 to the left or 2 to the right for free (i.e. replace the current coordinate xi with xi−2 or with xi+2);<br>move the chip i by 1 to the left or 1 to the right and pay one coin for this move (i.e. replace the current coordinate xi with xi−1 or with xi+1).<br>Note that it&#39;s allowed to move chips to any integer coordinate, including negative and zero.</p><p>Your task is to find the minimum total number of coins required to move all n chips to the same coordinate (i.e. all xi should be equal after some sequence of moves).</p><p>Input<br>The first line of the input contains one integer n (1≤n≤100) — the number of chips.</p><p>The second line of the input contains n integers x1,x2,…,xn (1≤xi≤1e9), where xi is the coordinate of the i-th chip.</p><p>Output<br>Print one integer — the minimum total number of coins required to move all n chips to the same coordinate.</p><p>Examples<br>input<br>3<br>1 2 3<br>output<br>1<br>input<br>5<br>2 2 2 3 3<br>output<br>2<br>Note<br>In the first example you need to move the first chip by 2 to the right and the second chip by 1 to the right or move the third chip by 2 to the left and the second chip by 1 to the left so the answer is 1.</p><p>In the second example you need to move two chips with coordinate 3 by 1 to the left so the answer is 2.</p><p>Problem solving:<br>这道题的意思就是给你一组数，然后给了你两种变换方式，一种是当前数加二或者减二，这种变换方式是免费的。一种是当前数加一或者减一，这种变换方式需要支付一个货币。问你这组数全部变换成一样的数最少需要多少货币。</p><p>我们注意到加二减二是免费的，所以只要这个用的是能用的最多的，那就一定能得到最少需要的货币。不管是奇数还是偶数，加二减二之后奇偶性不变。所以我们可以记录一下奇数和偶数的个数，让比较多的一类数通过加减二来变换，然后另一类通过加减一变成另一种类型的数。（奇数变偶数，偶数变奇数），所以我们只要取奇数数量和偶数数量的最小值，就是答案。</p><p>code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn = 105;long long a[maxn];int main(){    long long n,ans=0,os=0,x;    cin&gt;&gt;n;    for(long long i=0;i&lt;n;i++)    {        cin&gt;&gt;x;        if(x%2==0)    ans++;        else    os++;    }    cout&lt;&lt;min(ans,os)&lt;&lt;endl;}</code></pre><h2 id="B-Bad-Prices"><a href="#B-Bad-Prices" class="headerlink" title="B  Bad Prices"></a>B  Bad Prices</h2><p>description:<br>Polycarp analyzes the prices of the new berPhone. At his disposal are the prices for n last days: a1,a2,…,an, where ai is the price of berPhone on the day i.</p><p>Polycarp considers the price on the day i to be bad if later (that is, a day with a greater number) berPhone was sold at a lower price. For example, if n=6 and a=[3,9,4,6,7,5], then the number of days with a bad price is 3 — these are days 2 (a2=9), 4 (a4=6) and 5 (a5=7).</p><p>Print the number of days with a bad price.</p><p>You have to answer t independent data sets.</p><p>Input<br>The first line contains an integer t (1≤t≤10000) — the number of sets of input data in the test. Input data sets must be processed independently, one after another.</p><p>Each input data set consists of two lines. The first line contains an integer n (1≤n≤150000) — the number of days. The second line contains n integers a1,a2,…,an (1≤ai≤1e6), where ai is the price on the i-th day.</p><p>It is guaranteed that the sum of n over all data sets in the test does not exceed 150000.</p><p>Output<br>Print t integers, the j-th of which should be equal to the number of days with a bad price in the j-th input data set.<br>Example<br>input<br>5<br>6<br>3 9 4 6 7 5<br>1<br>1000000<br>2<br>2 1<br>10<br>31 41 59 26 53 58 97 93 23 84<br>7<br>3 2 1 2 3 4 5<br>output<br>3<br>0<br>1<br>8<br>2</p><p>Problem solving:<br>(这道题我一开始没看懂意思，后来懂了，我太难了<br>题意就是给你一组数，如果当前的数比它后面的每一个数都要小，那么这个数就不是<code>bad price</code>。反之就是。问你<code>bad price</code>的个数。</p><p>所以我们只需要判断如果当前数不是从它开始到最后的数中的最小值，那么它就是<code>bad price</code>，答案加一。<br>这里需要构建一个后缀最小值数组。注意要从后往前构造。</p><p>code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn = 150005;long long a[maxn],b[maxn];int main(){    long long n,m;    cin&gt;&gt;n;    while(n--)    {        long long ans=0;        cin&gt;&gt;m;        for(long long i=0;i&lt;m;i++)        {            cin&gt;&gt;a[i];        }        for(long long i=m-1;i&gt;=0;i--)        {            if(i==m-1)    b[i]=a[i];            else    b[i]=min(b[i+1],a[i]);        }        for(long long i=0;i&lt;m;i++)        {            if(a[i]!=b[i])    ans++;        }        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h2 id="C-Book-Reading"><a href="#C-Book-Reading" class="headerlink" title="C  Book Reading"></a>C  Book Reading</h2><p>description:<br>Polycarp is reading a book consisting of n pages numbered from 1 to n. Every time he finishes the page with the number divisible by m, he writes down the last digit of this page number. For example, if n=15 and m=5, pages divisible by m are 5,10,15. Their last digits are 5,0,5 correspondingly, their sum is 10.</p><p>Your task is to calculate the sum of all digits Polycarp has written down.</p><p>You have to answer q independent queries.</p><p>Input<br>The first line of the input contains one integer q (1≤q≤1000) — the number of queries.</p><p>The following q lines contain queries, one per line. Each query is given as two integers n and m (1≤n,m≤1016) — the number of pages in the book and required divisor, respectively.</p><p>Output<br>For each query print the answer for it — the sum of digits written down by Polycarp.</p><p>Example<br>input<br>7<br>1 1<br>10 1<br>100 3<br>1024 14<br>998244353 1337<br>123 144<br>1234312817382646 13<br>output<br>1<br>45<br>153<br>294<br>3359835<br>0<br>427262129093995</p><p>Problem solving:<br>这道题的意思就是给你两个数n,m,让你求在1~n内的m的倍数的个位上的数字的和。<br>先说一下我的思路吧。因为我们只需要考虑个位，所以无论m是多少，只考虑它的个位就行，因为个位上的数也就从0-9有十种情况。并且每一个数加几次之后就会从头开始，这是个循环。所以可以先把0~9的情况列出来，然后你会发现只需要分四种情况讨论</p><pre><code class="lang-txt">0   01   1 2 3 4 5 6 7 8 9 0 12   2 4 6 8 0 23   3 6 9 2 5 8 1 4 7 0 34   4 8 2 6 0 45   5 0 56   6 2 8 4 0 67   7 4 1 8 5 2 9 6 3 0 78   8 6 4 2 0 89   9 8 7 6 5 4 3 2 1 0 9</code></pre><p>四种情况也就是</p><ol><li>m的个位是0，此时答案就是0</li><li>m的个位是5，此时循环长度是2，并且每一个循环的总和是5</li><li>m的个位是除了上面几种情况的偶数，此时循环长度是5，并且每一个循环的总和是20</li><li>m的个位是除了上面几种情况的奇数，此时循环长度是10，并且每一个循环的总和是45</li></ol><p>然后就是代码</p><p>code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;int main(){    ll t;    cin&gt;&gt;t;    while(t--)    {        ll ans=0;        ll n,m;        cin&gt;&gt;n&gt;&gt;m;        if(m%10==0)    ans=0;        else if(m%10==5)        {            n/=m;            ans+=(n/2)*5;            n%=2;            ll mid=m%10;            for(ll i=0;i&lt;n;i++)            {                ans+=mid;                mid=(mid+m%10)%10;            }        }        else if(m%10%2==0)        {            n/=m;            ans+=(n/5)*20;            n%=5;            ll mid=m%10;            for(ll i=0;i&lt;n;i++)            {                ans+=mid;                mid=(mid+m%10)%10;            }        }        else if(m%10%2==1)        {            n/=m;            ans+=(n/10)*45;            n%=10;            ll mid=m%10;            for(ll i=0;i&lt;n;i++)            {                ans+=mid;                mid=(mid+m%10)%10;            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><p>然后说一下川巨的办法，顺便说一下。川巨是真的强。<br>因为是个位，所以只要这个数加10次，个位就一定会出现至少一次循环。所以以10为循环节的长度。先算出来m个位的10次循环每次的值，并且求出来总和。然后算出n里面有几个m，也就是总个数。然后再除以10就是循环节的个数，乘以循环的总和。然后再算n/m%10之后的多余的那一部分的值，因为上面计算的时候也一起存了下来所以直接用就行。<br>再说一下，川巨是真的强。</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll a[100];int main(){    ios::sync_with_stdio(false);    int t;    ll n,m;    cin&gt;&gt;t;    while (t --)    {        cin&gt;&gt;n&gt;&gt;m;        ll ans = 0,cnt = 0;        for (int i = 1;i &lt;= 10;i ++)            a[i] = m*i%10,cnt += a[i];        n /= m;        ans = n/10*cnt;        for (int i = 1;i &lt;= n%10;i ++) ans += a[i];            cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;    }    return 0;}</code></pre><h2 id="D-Equalizing-by-Division"><a href="#D-Equalizing-by-Division" class="headerlink" title="D    Equalizing by Division"></a>D    Equalizing by Division</h2><p>description:<br>The only difference between easy and hard versions is the number of elements in the array.</p><p>You are given an array a consisting of n integers. In one move you can choose any ai and divide it by 2 rounding down (in other words, in one move you can set ai:=⌊ai2⌋).</p><p>You can perform such an operation any (possibly, zero) number of times with any ai.</p><p>Your task is to calculate the minimum possible number of operations required to obtain at least k equal numbers in the array.</p><p>Don&#39;t forget that it is possible to have ai=0 after some operations, thus the answer always exists.</p><p>Input<br>The first line of the input contains two integers n and k (1≤k≤n≤2⋅1e5) — the number of elements in the array and the number of equal numbers required.</p><p>The second line of the input contains n integers a1,a2,…,an (1≤ai≤2⋅1e5), where ai is the i-th element of a.</p><p>Output<br>Print one integer — the minimum possible number of operations required to obtain at least k equal numbers in the array.</p><p>Examples<br>input<br>5 3<br>1 2 2 4 5<br>output<br>1<br>input<br>5 3<br>1 2 3 4 5<br>output<br>2<br>input<br>5 3<br>1 2 3 3 3<br>output<br>0</p><p>我懒得写公式，题意不太对的地方可以看截图<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190831094436.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190831094436.webp" class="img-shadow img-margin"></center></a><br>Problem solving:<br>这道题的意思就是给你两个数n和k，n是数组的长度，问你能不能在这n个数中经过变换让里面出现k个相等的数，变化的方式是每次除以2.问你最小的变换次数。</p><p>这道题我是没什么思路的。然后看了下Codancer的代码。Orz。Codancer太强了。</p><p>首先要思考一下，每个数除以2，比如说16，8都能变成2，但是16需要3次，而8只需要2次。所以我们要先按照升序排个序。<br>然后遍历数组中的元素，模拟当前数除以2知道除到0的时候，并且累计每次出现的数的出现次数，以及出现这个数需要的变换次数。因为我们已经按照大小排了序，所以当前得到的一定是当前的最小值。如果一个数的出现次数大于等于k，那么答案就需要更新一个成最小值，用min即可。</p><p>code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5+10;int a[maxn];int main(){    int n,k,ans=0x3f3f3f3f;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];    map&lt;int,int&gt; ma;//用来标记每个数的出现次数    map&lt;int,int&gt; maa;//用来标记转换到当前数需要的次数（局部的    sort(a,a+n);    for(int i=0;i&lt;n;i++)    {        int cnt=0;//cnt记录的就是转换次数        int mid=a[i];        while(mid)        {            ma[mid]++;maa[mid]+=cnt;            if(ma[mid]&gt;=k)  ans=min(ans,maa[mid]);//如果出现了出现次数大于等于k的数，更新答案            mid/=2;            cnt++;        }    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> thinking </tag>
            
            <tag> codedforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器+宝塔+Chevereto 搭建个人图床</title>
      <link href="/2019/08/30/img/"/>
      <url>/2019/08/30/img/</url>
      
        <content type="html"><![CDATA[<p>图床，大家应该都不陌生了。不管是写markdown还是html什么什么的，总会用到图片的链接。可是有些图片是我们自己的，他没有链接。这个时候我们就需要一些<del>NB</del>特殊的手段生成它的外链。由此诞生出了图床<br>我一开始了解到图床时发现在github上搭建的博客调用本地图片速度很慢，知道了可以用图床。<br>一开始用的是这个图床，也确实用了很久，很好用的一个免费图床，给大家推荐一下：<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a><br>可是随着我图片的增多，这个图床也渐渐地不能满足我的需求。<br>于是我去学长那白嫖了一个备案过的子域名，在七牛云上创建了一个存储空间结合picgo这个<del>NB</del>特殊的软件当成自己的图床。这个我现在还在用。<br>还有很多图床，比如说洛谷，简书，博客园啊什么的都可以当成“图床”用的（不要打我。<br>然后我就看到了很多大佬都自己搭图床，自己心里也挺痒痒，就去百度了一下，发现了这个<code>Chevereto</code>这个厉害的东西。<br>你需要有的东西</p><ol><li>服务器，配置好宝塔面板，服务器环境要求最低是Apache / NGiNX web server，PHP 5.5.0 ，MySQL 5.0</li><li>一个联网的电脑</li><li>一个跟我一样灵活的脑子</li></ol><p>总结一下步骤先</p><ol><li>前去github下载压缩包。</li><li>在宝塔面板新建网站，并且创建一个数据库。</li><li>将下载的压缩包解压至你新建的网站的目录。注意这里需要更改一个东西。</li><li>打开新建的网站，跟着提示一步步配置。</li></ol><p>几分钟之后你会拥有一个和这个基本上一样的属于自己的图床<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830180755.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830180755.webp" class="img-shadow img-margin"></center></a></p><p>下载压缩包<br>你可以<a href="https://github.com/Chevereto/Chevereto-Free" target="_blank" rel="noopener">点这里</a>去github下载，也就4MB，一会就下载完了。<br>或者用我提供的<a href="https://www.cndrew.cn/download/image.zip" target="_blank" rel="noopener">下载链接</a>点击下载。</p><p>在宝塔新建一个网站这个就不用多说了吧。<br>然后创建一个数据库。</p><p>把下载好的压缩包上传到你新建的网站的目录里面然后解压。<br>注意这里需要更改一个东西<br>首先找到网站的设置<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830175421.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830175421.webp" class="img-shadow img-margin"></center></a><br>找到配置文件<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830175451.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830175451.webp" class="img-shadow img-margin"></center></a><br>在最后一个大括号前加入下面的代码<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830175602.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830175602.webp" class="img-shadow img-margin"></center></a><br>加完之后是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830175636.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190830175636.webp" class="img-shadow img-margin"></center></a></p><pre><code class="lang-配置文件"># Disable access to .ht* fileslocation ~ /\.ht {    deny all;}# Disable access to sensitive files in app pathlocation ~ /(app|content|lib)/.*\.(po|php|lock|sql)$ {   deny all;}# Disable log on not found images + image replacementlocation ~* (jpe?g|webp|gif) {    log_not_found off;    error_page 404 /contenthttps://cdn.jsdelivr.net/gh/drew233/cdn/system/default/404.gif;}# Enable CORS header (needed for CDN)location ~* \.(ttf|ttc|otf|eot|woff|woff2|css|js)$ {    add_header Access-Control-Allow-Origin &quot;*&quot;;}# Force serve upload path as static content (match your upload folder if needed)location https://cdn.jsdelivr.net/gh/drew233/cdn {}# Route dynamic request to index.phplocation / {    try_files $uri $uri/ /index.php?$query_string;}</code></pre><p>然后进入到你新建的网站，跟随着设置一步一步来就行。这里会让你输入一次你的数据库的名字账号和密码，把你上面新建的那个输进去就好了。</p><p>全部设置好之后你会获得一个管理员账号（名字密码都是自己设置的。点击登陆进去可以进入仪表盘设置网站的外观和配置。<br>然后到这里就搭建结束了。</p><p>我是用宝塔搭建的，适合像我这样的小白参考。大佬轻喷。</p><p>目前我的图床已知bug</p><ol><li>注册账号好像不能很好的工作。</li><li>就算你有账号登陆也不一定可以成功。</li></ol><p>我的解决方法</p><ol><li>把游客的权限提升成为了和注册用户一样的权限。（有点小猥琐，不过就自己人用这个图床，也没啥哈哈。这里权限指的是上传的图片最大大小均为5MB，并且永久保存。</li></ol><p>至于这个图床的安装过程没有详细讲主要是因为确实没啥好说的，每一步都有提示，跟着来就行了。</p><p>我的图床，如果你看到了这里。欢迎你使用我的图床，最后说一下，这个图床自动适配手机端，赞！<br>点击这里进入我的图床   <a href="https://cf.cndrew.cn/" target="_blank" rel="noopener">Happy Image</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于宝塔的服务器建站开启https(一如既往的傻瓜式)</title>
      <link href="/2019/08/29/https/"/>
      <url>/2019/08/29/https/</url>
      
        <content type="html"><![CDATA[<p>之前用github和coding的时候，httpss是他们会帮你自动配好的，所以也一直没有接触过这些东西（虽然现在也不知道这是什么神魔鬼怪。<br>宝塔上提供的也有免费的SSL证书，但是需要实名认证，而我实名认证过不去，鬼知道为什么。所以另辟蹊径。总结一下基本步骤</p><ol><li>在阿里云申请免费的SSL证书（有钱的话随意。我选择阿里云也只是因为我的域名在阿里云。</li><li>申请成功后下载证书。</li><li>在宝塔上添加证书并开启强制httpss。</li></ol><p>申请免费证书（这里以阿里云为例，别的应该大差不差<br>在阿里云进入域名列表，然后点击你要加httpss的域名，如图<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173442.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173442.webp" class="img-shadow img-margin"></center></a><br>然后点击免费开启SSL证书<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173556.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173556.webp" class="img-shadow img-margin"></center></a><br>如果你已经买过了证书就点击<code>返回证书列表</code>，如果你还没有就点击申请<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173705.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173705.webp" class="img-shadow img-margin"></center></a><br>点确定，这里不要担心这里的1700（这里没有显示免费的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173837.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173837.webp" class="img-shadow img-margin"></center></a><br>进了这个页面选择免费型然后购买就行了(你甚至可以多买几个，我买了十个)<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173936.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829173936.webp" class="img-shadow img-margin"></center></a><br>然后进入证书列表<br>找到一个你刚才购买的证书，点击申请<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829174119.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829174119.webp" class="img-shadow img-margin"></center></a><br>这个填的就不用多说了<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829174152.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829174152.webp" class="img-shadow img-margin"></center></a><br>填完之后如果填的正确就会通过申请，大概五分钟左右吧。阿里云会给你邮箱和信息提醒<br>然后去你的已签发的证书列表找到你刚才申请的那个，点击下载，就会弹出这个界面，这里下载Nginx的就行（我的是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829174458.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829174458.webp" class="img-shadow img-margin"></center></a><br>下载完是一个压缩包打开，解压出来是两个这样的文件，文件名不重要，重要的是后缀。后缀是这两个就没问题<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829174735.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829174735.webp" class="img-shadow img-margin"></center></a><br>然后把这两个文件打开，用记事本啊或者各种文本编辑器打开。<br>然后去宝塔面板，打开网站<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175135.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175135.webp" class="img-shadow img-margin"></center></a><br>找到你要设置httpss的网站点击设置<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175202.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175202.webp" class="img-shadow img-margin"></center></a><br>点击SSL，然后点击里面其他证书<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175327.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175327.webp" class="img-shadow img-margin"></center></a><br>然后把你下载的<code>xxx.key</code>文件里面的内容粘贴复制到密钥(KEY)里面<br>把你下载的<code>xxx.pem</code>文件里面的内容粘贴复制到证书(PEM格式)里面<br>填好之后点击保存<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175553.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175553.webp" class="img-shadow img-margin"></center></a><br>然后他就可以自动识别出来你的信息<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175646.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190829175646.webp" class="img-shadow img-margin"></center></a><br>这个时候你再点击强制httpss就行了。</p><p>如果有别的问题，可以去宝塔的官方<a href="https://www.bt.cn/bbs/thread-704-1-1.html" target="_blank" rel="noopener">帮助</a>页面找办法解决，或者联系我。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
            <tag> httpss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于备案</title>
      <link href="/2019/08/27/beian/"/>
      <url>/2019/08/27/beian/</url>
      
        <content type="html"><![CDATA[<p>我是在阿里云上面买的学生机。所以备案自然也是在阿里云进行的。<br>这里还是说一下，大家都直接用手机app备案就好了，速度是一方面，还有很<del>恶心</del>的一个原因就是你在pc上面进行备案等到需要人脸识别的时候还是需要去手机上进行的。这个还不如直接就去手机上弄。<br>首先我说一个很不爽的几点</p><ol><li>手机备案的话它每一条填的内容没有写要求。只有你被提示初审失败了才给你那一项的提示消息。</li><li>进行人脸识别的时候，要求必须把脸和肩膀都拍上去 。我脸长暂且不说，我让我同学离我很远拍，拍之前是有肩膀的，拍出来就只剩脸了。（黑人问号脸，我觉得他这个玩意是不是自动截取脸了？？？最后我仰着头拍，终于是搞上了肩膀。</li><li>阿里云的客服。备案专区的人工等的时间也太长了。等不到就提示你可以选择网上的人工客服，网上的人工客服排到之后十分钟不带回复你消息的。</li></ol><p>下面我们步入正题<br>现在备案确实步骤挺少的，我也没经历他们说的收快递对着幕布拍照。就是在填完基本信息之后，先是阿里云的初审，这个不过的话阿里云会通过邮件和电话通知你一下。这时候你的手机一定要保持畅通，能接到阿里云的电话它才会给你通过初审，一般是问你是不是这个网站的负责人，然后问你出生年月，或者问你身份证号。初审过了之后会有一个工信部的手机号验证，认证完之后就是等了。大概十天左右就可以接到通知啦。<br>我备案已经完成了，但是绑定域名却出现了打不开的问题，在找找问题，解决一下。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190827204206.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190827204206.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源青岛大学oj的搭建(傻瓜式操作)</title>
      <link href="/2019/08/23/oj/"/>
      <url>/2019/08/23/oj/</url>
      
        <content type="html"><![CDATA[<p>第一次搭建我是用的Vmware的linux虚拟机尝试的。毕竟虚拟机嘛，随便嗨</p><p>对于和我一样的小白推荐直接看我的安装(傻瓜式)。</p><p>给大家看一下官方文档的Readme</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Linux-环境"><a href="#Linux-环境" class="headerlink" title="Linux 环境"></a>Linux 环境</h3><ol><li><p>安装必要的依赖</p><pre><code class="lang-bash"> sudo apt-get update &amp;&amp; sudo apt-get install -y vim python-pip curl git pip install docker-compose</code></pre></li></ol><ol><li><p>安装 Docker</p><p> 国内用户使用脚本一键安装: <code>sudo curl -sSL https://get.daocloud.io/docker | sh</code><br> 国外用户使用脚本一键安装: <code>sudo curl -sSL get.docker.com | sh</code></p><p> 详细步骤参照： <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p></li></ol><h3 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h3><p>Windows 下的安装仅供体验，勿在生产环境使用。如有必要，请使用虚拟机安装 Linux 并将 OJ 安装在其中。</p><p>以下教程仅适用于 Win10 x64 下的 <code>PowerShell</code></p><ol><li>安装 Windows 的 Docker 工具</li><li>右击右下角 Docker 图标，选择 Settings 进行设置</li><li>选择 <code>Shared Drives</code> 菜单，之后勾选你想安装 OJ 的盘符位置（例如勾选D盘），点击 <code>Apply</code></li><li>输入 Windows 的账号密码进行文件共享</li><li>安装 <code>Python</code>、<code>pip</code>、<code>git</code>、<code>docker-compose</code>，安装方法自行搜索。</li></ol><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><ol><li><p>请选择磁盘空间富余的位置，运行下面的命令</p><pre><code class="lang-bash"> git clone -b 2.0 https://github.com/QingdaoU/OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy</code></pre></li><li><p>启动服务</p><pre><code class="lang-bash"> docker-compose up -d</code></pre></li></ol><p>根据网速情况，大约5到30分钟就可以自动搭建完成，全程无需人工干预。</p><p>等命令执行完成，然后运行 <code>docker ps -a</code>，当看到所有的容器的状态没有 <code>unhealthy</code> 或 <code>Exited (x) xxx</code> 就代表 OJ 已经启动成功。</p><h2 id="尽情享用吧"><a href="#尽情享用吧" class="headerlink" title="尽情享用吧"></a>尽情享用吧</h2><p>通过浏览器访问服务器的 https 80 端口或者 httpsS 443 端口，就可以开始使用了。后台管理路径为<code>/admin</code>, 安装过程中自动添加的超级管理员用户名为 <code>root</code>，密码为 <code>rootroot</code>， <strong>请务必及时修改密码</strong>。</p><p>不要忘记阅读文档 <a href="https://docs.onlinejudge.me/" target="_blank" rel="noopener">https://docs.onlinejudge.me/</a></p><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>2.0 版将一些常用设置放到了后台管理中，您可以直接登录管理后台对系统进行配置，而无需进行代码改动。</p><p>若需要对系统进行修改或二次开发，请参照各模块的<strong>README</strong>，修改完成后需自行构建Docker镜像并修改<code>docker-compose.yml</code></p><h2 id="遇到了问题？"><a href="#遇到了问题？" class="headerlink" title="遇到了问题？"></a>遇到了问题？</h2><p>请参照: <a href="https://docs.onlinejudge.me/#/onlinejudge/faq" target="_blank" rel="noopener">https://docs.onlinejudge.me/</a> ，如有其他问题请入群讨论或提issue。</p><h2 id="我的安装-傻瓜式-和我一样的小白可以直接看这里"><a href="#我的安装-傻瓜式-和我一样的小白可以直接看这里" class="headerlink" title="我的安装(傻瓜式)(和我一样的小白可以直接看这里)"></a>我的安装(傻瓜式)(和我一样的小白可以直接看这里)</h2><p>在linux安装的话也就是这几步</p><ol><li>进入终端，这个应该都会吧，右键桌面打开或者快捷键<code>ctrl+alt+t</code>，然后依次执行下面每一步的指令。</li><li>sudo apt-get update &amp;&amp; sudo apt-get install -y vim python-pip curl git</li><li>sudo apt-get install docker-compose</li><li>git clone -b 2.0 <a href="https://github.com/QingdaoU/OnlineJudgeDeploy.git" target="_blank" rel="noopener">https://github.com/QingdaoU/OnlineJudgeDeploy.git</a> &amp;&amp; cd OnlineJudgeDeploy</li><li>docker-compose up -d(root用户使用该命令)或sudo -E docker-compose up -d(非root用户使用该命令)</li></ol><p>然后如果每一步都正常运行结束，那么此时这个oj你已经可以通过本地访问了，在浏览器输入你的ip地址即可打开，虚拟机的ip好像都一样，是<code>127.0.0.1</code>。然后初始的管理员的用户名是root，密码是rootroot。(请及时修改密码)</p><p>但是你如果觉得这么简单的话就错了。在第五步中经常会出现握手错误(Handshake error)。这个我也不太明白，但是大体上的意思就是网络问题。你可以选择科学上网一波，也可以多试几次。<br>这样差不多就可以在虚拟机的本地进行是用了。</p><p>浏览器输入你的ip地址打开应该是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190823101035.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190823101035.webp" class="img-shadow img-margin"></center></a></p><p>如果你想用外网也可以访问你的oj，那你需要一个公网ip，如果没有的话会有很多实现此类功能的软件，百度即可。</p><p>根据官方的Readme文档，windos当然也可以安装，这里就不详细说了。</p><p>后来我想到我可以直接把它搭建在我的服务器上啊。我的服务器是centos系统的，然后为了这个我还专门换成了linux的系统。然后就跟上面一样了。无脑输入指令就行了。<br>但是会遇到一个问题，这样默认的这个oj使用的是80端口，那么如果你想换的话该如何换端口呢？<br>你首先要找到本地的<code>OnlineJudgeDeploy</code>文件夹，里面会有一个<code>docker-compose.yml</code>文件。<br>然后打开这个文件你会发现最下面有一个<code>port</code>，把里面的第一个80修改成你想用的端口就行了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190823102008.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190823102008.webp" class="img-shadow img-margin"></center></a></p><p>欢迎访问我的oj :<a href="https://47.98.185.31:1314/" target="_blank" rel="noopener">Uncle_drew</a></p><p>目前开放注册，题目也只有一道贼水贼水得题。毕竟刚学哈。</p><p>有问题可以评论或者直接联系我。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河南理工大学图灵杯 （Day36）</title>
      <link href="/2019/08/20/36/"/>
      <url>/2019/08/20/36/</url>
      
        <content type="html"><![CDATA[<p>集训的最后一天了，早上七点就起床了，本来想着去吃个饭，但是玩了会手机就不去吃饭了。直接去了机房，机房前面放满了昨天晚上吹的气球。刚开始也一直没来人，我去到我坐了一个暑假的地方打开电脑。玩了会，慢慢的人都来了，学长来贴了气球对应的题号，这时候我才知道有12道题。<br>到了九点，比赛就开始了，这次我的队友是洋佬和雨神，我们直接看的纸质的题面，因为只发了一份，我们就撕开了。然后洋佬说他记得红色气球是签到，红色气球对应的是f题。然后f题，就摇摇我说这道题可以搞，我一看也觉得很简单，就是给你两组数，问你在第一组出现过却没在第二组出现过的数字是多少。我手速快，用map敲了一遍，但是不太敢交，此时榜单还没人过题。各种检查没错误之后交了，我们三个人盯着榜单，然后，过了！！！顺利狗到一个一血然后还狗了个那会的rank1，现在才知道那道题完全可以用异或来做。。。我们过了一道题之后，好久好久一道题都没过，然后别人都两题三题了。我们被踩了，过的最多的是I题，这道题我们交给了雨神，他写完代码一直在改bug，也一直没交。然后我们一起看了D题，洋佬跟雨神一碰头，然后洋佬正好准备了带权并查集的板子，过了一会搞出来了，过了样例，然后就直接交了，洋佬还是nb，直接就过了。然后荣获D题一血，但是这个时候我们还是在被踩着。然后雨神改了改之前写的I题的代码，虽然错了几次，但是过了！！！过之前榜一是三题，过了之后我们也是三题但是，罚时高了点，暂位第二。然后雨神看到了G，说这个是个dp，然后特殊情况标记一下就行，我们说那你来搞，然后过了一会，他也过了样例，我们就直接交了，然后WA了。雨神说不该WA啊，仔细看了看代码，发现他忘了取模了。加上取模之后果然过了，这个时候我们已经四题了，我也记不清这个时候的排名了。然后我看到了H题，以为是冒泡排序的交换次数，对着白书打了板子，然后死循环了，鬼知道为啥。然后我们让雨神先写着J题的代码，他有思路，我跟洋佬乐悠悠地去开始找E题的规律。过了大约有几十分钟吧，我跟洋佬找到了E的规律，然后交了一发就过了。然后雨神发现J他用并查集写会有问题搞不出来，然后洋佬说他觉得可以用拓扑排序加并查集写，然后就写吧，洋佬都写了，当然就过了。J题我们过了之后已经六题了，妥妥的占着榜一的位置。这时候离封榜的一点还剩大约一个小时吧。我们发现最后一题好像是之前搞过，一个质因子分解就行了。也没想那么多，我就去搞了，搞完之后样例过了，然后我们自己有想了几种情况，也都过了，然后就直接交了。结果就TLE。后来雨神跟我说你先素数打个表在质因子分解，这样会节省一点时间。一开始我觉得跟这个无瓜，但是也没啥别的会写的题了，索性就打个表，然后交了，在还有三分钟封榜的时候我们7题了，稳居第一，第二才5题。然后最后一个小时，我们该蒙的都蒙了，该搞得也都搞了，但是再没过一道题。等到最后的时候，洋佬写了一发B但是我们交成了A。。。（幸亏后来结束之后试了一下没过，不然是真的要气死。</p><p>这次比赛的队名也都很有趣，什么菜虚鲲啊乔碧落啊，所以这次比赛也被称为菜碧之战。还是我们的队名好听，广告位招租（有兴趣的找我哦</p><p>两点比赛结束，我们两点半滚榜，在这之前我们一直是第一的。然后有个很“善良”的学长跟我们说有人过了八题。我们看了看封榜状态的榜单，因为我们当时分队是按照暑假的积分来的，我们是二队，一看一队加上过的和不知道结果的确实是8道题，当时心态就崩了，贼难受。然后有释然了，我们已经尽力了。过了会，滚榜开始了，越往上越激烈，到了一队的时候，他们先是从5题变成了6题，然后继续滚上面的，一队到了第三的时候，他们不知道结果的WA了一道，这意味着，我们才是第一，我跟队友激动的握手。然后一队他们最后过了6题，位居第三，奖品是每人一个坐垫。然后到了第二，他们竟然也从6题变成了7题，但是没反超我们，因为他们的罚时高了。于是正式的知道了他们是第二，奖品是每个人一个脖子是套着的哪个U型颈枕什么的。这个时候已经尘埃落定了，我们也才反应过来学长在唬我们，虽然最后我们还是7题但是我们依然是冠军！奖品是每人一个积木，我的是史迪仔，洋佬的是钢铁侠，雨神的是绿巨人。</p><p>整个暑假集训没当过第一，感谢两个队友带我飞（手动@洋佬@雨神</p><p>在这给大家得瑟一下我们的积木<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190822084657.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190822084657.webp" class="img-shadow img-margin"></center></a></p><p>补题的事以后再说，这里顺便再提一下一件悲伤的事，我的谷歌广告的账号被封了。没啥好说的，我没脾气<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190822085146.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190822085146.webp" class="img-shadow img-margin"></center></a></p><p>最后还是感谢一下学长们假期无私的付出，谢谢了。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尾声，也是开始</title>
      <link href="/2019/08/19/summer-final/"/>
      <url>/2019/08/19/summer-final/</url>
      
        <content type="html"><![CDATA[<p>这个假期学到了不少东西。自己也变强了不少，但是感觉还是看见不会的题就不会。这谁能受得了啊。<br>现在回想起来还是很有感触的。</p><p>我是在外面租的房子住了一个月。虽然说我们租房的地方有点偏僻，但毕竟是学校门口，该有的印象中的各种小吃也是不缺的。</p><p>那条回我们租的房子的路上，有每天吆喝买粥的老大爷，有一个卖烧饼的夫妻，他们经常拌嘴，但是跟我们说话的时候都会很温柔。还有一个饮品店的大叔，其实我叫他哥应该更合适。每天从机房出门回去的路上都能看见他抱着吉他看着视频自学。还有各种人家搬着桌子坐在外面纳凉。很有感觉，很有生活的气息，让我意识到我需要注意的不是只有代码。</p><p>从培训开始前的期待，到培训刚开始时候的精力充沛，到培训中积分赛每次都被打爆的颓废，到现在已经将要结束的惋惜。我知道，我的暑假就这样要过去了。我之前一直以为高考完的那个暑假是最难忘的，但是我发现这一次的才是最难忘的暑假。我学会了太多太多的东西。</p><p>这个暑假最大的收获应该是某头猪了吧，认识它之后我的世界就不只是只有代码了。挺感激它的。</p><p>暑假集训是结束了，但是我们的路还很长，省赛，区域赛，我不想铁牌就退役。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 35（河南理工大学暑期第三十五天）</title>
      <link href="/2019/08/19/35/"/>
      <url>/2019/08/19/35/</url>
      
        <content type="html"><![CDATA[<h2 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A + B Problem"></a>A + B Problem</h2><p>这道题没啥意思，就是拉来温暖一下榜单的<br>Code:</p><pre><code class="lang-c++">#include&lt;stdio.h&gt;int main(){    int a,b;    while(~scanf(&quot;%d %d&quot;,&amp;a,&amp;b))    printf(&quot;%d\n&quot;,a+b);    return 0;}</code></pre><h2 id="A-B-Problem-II"><a href="#A-B-Problem-II" class="headerlink" title="A + B Problem II"></a>A + B Problem II</h2><p>Description:<br>I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B.<br>Input<br>The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000.<br>Output<br>For each test case, you should output two lines. The first line is &quot;Case #:&quot;, # means the number of the test case. The second line is the an equation &quot;A + B = Sum&quot;, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases.<br>Sample Input<br>2<br>1 2<br>112233445566778899 998877665544332211<br>Sample Output<br>Case 1:<br>1 + 2 = 3</p><p>Case 2:<br>112233445566778899 + 998877665544332211 = 1111111111111111110</p><p>Problem solving:<br>这道题是经典的大数相加问题，c++选手得用模拟来写。<br>java选手就很舒服了。但是初衷是让大家用c++写。</p><p>java就不再解释了，直接大数搞就行了。</p><p>c++我这里用了string来模拟，仔细看代码吧，还是很有意思的。<br>Code:</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n;    cin &gt;&gt; n;    int m = 0;    int l = 0;    for (int i = 1; i &lt;= n; i++)    {        string s1, s2, s(10000, &#39;0&#39;);        cin &gt;&gt; s1 &gt;&gt; s2;        m++;        cout &lt;&lt; (l++ ? &quot;\n&quot; : &quot;&quot;);        reverse(s1.begin(), s1.end());        reverse(s2.begin(), s2.end());        for (int j = 0; j &lt; s1.length(); j++)            s[j] = s1[j];        int temp = 0;        for (int k = 0; k &lt; s2.length(); k++)        {            temp += s[k] - 48 + s2[k] - 48;            s[k]  = temp % 10 + &#39;0&#39;;            temp /= 10;        }        s[s2.length()] = s[s2.length()] - 48 + temp + 48;        reverse(s.begin(), s.end());        reverse(s1.begin(), s1.end());        reverse(s2.begin(), s2.end());        cout &lt;&lt; &quot;Case&quot; &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; endl;        cout &lt;&lt; s1 &lt;&lt; &quot;+&quot; &lt;&lt; s2 &lt;&lt; &quot;=&quot; &lt;&lt; s.substr(s.find_first_not_of(&#39;0&#39;)) &lt;&lt; endl;    }    return 0;}</code></pre><p>Code:</p><pre><code class="lang-java">import java.math.*;import java.util.*;import java.*;public class Main{    public static void main(String[] args)    {        Scanner cin = new Scanner(System.in);        int t = cin.nextInt();        int num = 1;        int x=0;        while(t&gt;0)        {            if(x!=0)    System.out.println(&quot;&quot;);            else x=1;            BigInteger a = cin.nextBigInteger();            BigInteger b = cin.nextBigInteger();            System.out.println(&quot;Case &quot;+num+&quot;:&quot;);            System.out.println(a+&quot; + &quot;+b+&quot; = &quot;+a.add(b));            num++;                        t--;        }    }}</code></pre><h2 id="Drainage-Ditches"><a href="#Drainage-Ditches" class="headerlink" title="Drainage Ditches"></a>Drainage Ditches</h2><p>Description:<br>Every time it rains on Farmer John&#39;s fields, a pond forms over Bessie&#39;s favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie&#39;s clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch.<br>Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network.<br>Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle.<br>Input<br>The input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch.<br>Output<br>For each case, output a single integer, the maximum rate at which water may emptied from the pond.<br>Sample Input<br>5 4<br>1 2 40<br>1 4 20<br>2 4 20<br>2 3 30<br>3 4 10<br>Sample Output<br>50<br>Problem solving:<br>可以去看看这个学长写的这道题的题解（课件内容大多来自这里<br><a href="https://boctorio.com/2019/08/14/%E7%BD%91%E7%BB%9C%E6%B5%81/" target="_blank" rel="noopener">https://boctorio.com/2019/08/14/%E7%BD%91%E7%BB%9C%E6%B5%81/</a><br>这道题真的是板子题，源点为1，汇点为n，直接套dinic就能过。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;const ll maxn = 1e6+10;ll n,m,s,t,u,v,w,cnt;struct edge{    ll to,dis,nxt;}G[maxn];ll head[maxn],d[maxn],cur[maxn];void add(ll from,ll to,ll dis){    G[cnt].to=to;    G[cnt].dis=dis;    G[cnt].nxt=head[from];    head[from]=cnt++;}ll dfs(ll u,ll flow){    if(u==t)    return flow;    ll x=0;    for(ll i=cur[u];i!=-1;i=G[i].nxt)    {        cur[u]=G[i].nxt;        ll v=G[i].to;        if(d[v]==d[u]+1&amp;&amp;G[i].dis&gt;0)        {            ll res=dfs(v,min(flow,G[i].dis));            flow-=res;            x+=res;            G[i].dis-=res;            G[i^1].dis+=res;            if(flow==0) break;        }    }    if(!x)  d[u]=-1;    return x;}void bfs(){    memset(d,-1,sizeof(d));    queue&lt;ll&gt; que;    que.push(s);    d[s]=0;    while(!que.empty())    {        ll u=que.front();que.pop();        for(ll i=head[u];i!=-1;i=G[i].nxt)        {            ll v=G[i].to;            if(d[v]==-1&amp;&amp;G[i].dis&gt;0)            {                d[v]=d[u]+1;                que.push(v);            }        }    }}void dinic(){    ll max_flow=0;    while(1)    {        bfs();        if(d[t]==-1)    break;        for(ll i=1;i&lt;=n;i++)    cur[i]=head[i];        max_flow+=dfs(s,INF);    }    cout&lt;&lt;max_flow&lt;&lt;endl;}int main(){    while(cin&gt;&gt;m&gt;&gt;n)    {        s=1,t=n;        memset(head,-1,sizeof(head));        cnt=0;        for(ll i=0;i&lt;m;i++)        {            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;            add(u,v,w);            add(v,u,0);        }        dinic();    }    return 0;}</code></pre><h2 id="Island-Transport"><a href="#Island-Transport" class="headerlink" title="Island Transport"></a>Island Transport</h2><p>Description:<br>In the vast waters far far away, there are many islands. People are living on the islands, and all the transport among the islands relies on the ships.<br>　　You have a transportation company there. Some routes are opened for passengers. Each route is a straight line connecting two different islands, and it is bidirectional. Within an hour, a route can transport a certain number of passengers in one direction. For safety, no two routes are cross or overlap and no routes will pass an island except the departing island and the arriving island. Each island can be treated as a point on the XY plane coordinate system. X coordinate increase from west to east, and Y coordinate increase from south to north.<br>　　The transport capacity is important to you. Suppose many passengers depart from the westernmost island and would like to arrive at the easternmost island, the maximum number of passengers arrive at the latter within every hour is the transport capacity. Please calculate it.<br>Input<br>　　The first line contains one integer T (1&lt;=T&lt;=20), the number of test cases.<br>　　Then T test cases follow. The first line of each test case contains two integers N and M (2&lt;=N,M&lt;=100000), the number of islands and the number of routes. Islands are number from 1 to N.<br>　　Then N lines follow. Each line contain two integers, the X and Y coordinate of an island. The K-th line in the N lines describes the island K. The absolute values of all the coordinates are no more than 100000.<br>　　Then M lines follow. Each line contains three integers I1, I2 (1&lt;=I1,I2&lt;=N) and C (1&lt;=C&lt;=10000) . It means there is a route connecting island I1 and island I2, and it can transport C passengers in one direction within an hour.<br>　　It is guaranteed that the routes obey the rules described above. There is only one island is westernmost and only one island is easternmost. No two islands would have the same coordinates. Each island can go to any other island by the routes.<br>Output<br>　　For each test case, output an integer in one line, the transport capacity.<br>Sample Input<br>2<br>5 7<br>3 3<br>3 0<br>3 1<br>0 0<br>4 5<br>1 3 3<br>2 3 4<br>2 4 3<br>1 5 6<br>4 5 3<br>1 4 4<br>3 4 2<br>6 7<br>-1 -1<br>0 1<br>0 2<br>1 0<br>1 1<br>2 3<br>1 2 1<br>2 3 6<br>4 5 5<br>5 6 3<br>1 4 6<br>2 5 5<br>3 6 4<br>Sample Output<br>9<br>6<br>Problem solving:<br>这道题看着就很恶心，实际上确实也很恶心。他给了你10s；10秒！！！<br>其实这道题跟C差不多的，只不过它的源点和汇点需要自己找出来，找的时候也很简单。我们只看x轴的坐标就行了。在最左边的看成是源点，在最右边的看成是汇点。<br>然后套板子<br>当你信心满满觉得要过的时候，你会发现，哦豁，TLE了。<br>如果你跟我一样用的是cin和cout，那么你一定会想到是cin和cout的锅。然后关闭同步流，信心满满的觉得要过得时候，你发现他还是会tle。<br>然后如果你跟我还一样，你会把cin和cout换成scanf和printf。当你信心满满的觉得这次一定会过的时候，你就又tle了。然后你会想到会不会是板子的锅。<br>是不是板子的锅我也不知道，应该是我的姿势不够优雅，所以用不了板子写这个题。</p><p>这道题讲道理就是一道简单的板子题，但是卡时间卡的比较严重，所以你需要各种优化。这道题是我拉的不好了，这种题没啥意思。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h.&gt;using namespace std;const int N = 100010;const int INF = 0x3f3f3f3f;typedef long long ll;int n,m,start,over;int deep[N],maxflow;struct edge{    int to,w,pre;}a[N&lt;&lt;2];int cnt=-1,head[N];void add(int from,int to,int w){    a[++cnt].to=to;    a[cnt].w=w;    a[cnt].pre=head[from];    head[from]=cnt;}bool bfs()//这里我们不用队列直接用数组代替{    memset(deep,-1,sizeof(deep));    int q[N&lt;&lt;1];    int fro,bac;    fro=bac=0;    q[bac++]=start,deep[start]=0;    while(fro&lt;bac)    {        int first=q[fro];        if(first==over) return 1;        for(int i=head[first];~i;i=a[i].pre)        {            if(deep[a[i].to]==-1&amp;&amp;a[i].w&gt;0)            {                deep[a[i].to]=deep[first]+1;                q[bac++]=a[i].to;            }        }        fro++;    }    return 0;}int dfs(int s,int cap){    if(s==over) return cap;    int flow=0,f;    for(int i=head[s];~i;i=a[i].pre)    {        int to=a[i].to;        if(deep[to]==deep[s]+1&amp;&amp;a[i].w)        {            f=dfs(to,min(cap-flow,a[i].w));            a[i].w-=f;            a[i^1].w+=f;            flow+=f;            if(flow==cap)   break;        }    }    if(flow==0) deep[s]=-2;    return flow;}void dinic(){    int tem=0;    while(bfs())        while((tem=dfs(start,INF))&gt;0)            maxflow+=tem;}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        maxflow=0,cnt=-1;        memset(head,-1,sizeof(head));        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        start = over = 1;        int x,y,z,x_min=INF,x_max=-INF;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d %d&quot;,&amp;x,&amp;y);            if(x&lt;x_min) start=i,x_min=x;            if(x&gt;x_max) over=i,x_max=x;        }        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);            add(x,y,z);            add(y,x,z);        }        dinic();        cout&lt;&lt;maxflow&lt;&lt;endl;    }    return 0;}</code></pre><h2 id="Power-Network"><a href="#Power-Network" class="headerlink" title="Power Network"></a>Power Network</h2><p>Description:<br>A power network consists of nodes (power stations, consumers and dispatchers) connected by power transport lines. A node u may be supplied with an amount s(u) &gt;= 0 of power, may produce an amount 0 &lt;= p(u) &lt;= p max(u) of power, may consume an amount 0 &lt;= c(u) &lt;= min(s(u),c max(u)) of power, and may deliver an amount d(u)=s(u)+p(u)-c(u) of power. The following restrictions apply: c(u)=0 for any power station, p(u)=0 for any consumer, and p(u)=c(u)=0 for any dispatcher. There is at most one power transport line (u,v) from a node u to a node v in the net; it transports an amount 0 &lt;= l(u,v) &lt;= l max(u,v) of power delivered by u to v. Let Con=Σ uc(u) be the power consumed in the net. The problem is to compute the maximum value of Con.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/6Y%60WGX%25LEP%5B7%28VJ%60LAC_GH0.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/6Y%60WGX%25LEP%5B7%28VJ%60LAC_GH0.webp" class="img-shadow img-margin"></center></a><br>An example is in figure 1. The label x/y of power station u shows that p(u)=x and p max(u)=y. The label x/y of consumer u shows that c(u)=x and c max(u)=y. The label x/y of power transport line (u,v) shows that l(u,v)=x and l max(u,v)=y. The power consumed is Con=6. Notice that there are other possible states of the network but the value of Con cannot exceed 6.<br>Input<br>There are several data sets in the input. Each data set encodes a power network. It starts with four integers: 0 &lt;= n &lt;= 100 (nodes), 0 &lt;= np &lt;= n (power stations), 0 &lt;= nc &lt;= n (consumers), and 0 &lt;= m &lt;= n^2 (power transport lines). Follow m data triplets (u,v)z, where u and v are node identifiers (starting from 0) and 0 &lt;= z &lt;= 1000 is the value of l max(u,v). Follow np doublets (u)z, where u is the identifier of a power station and 0 &lt;= z &lt;= 10000 is the value of p max(u). The data set ends with nc doublets (u)z, where u is the identifier of a consumer and 0 &lt;= z &lt;= 10000 is the value of c max(u). All input numbers are integers. Except the (u,v)z triplets and the (u)z doublets, which do not contain white spaces, white spaces can occur freely in input. Input data terminate with an end of file and are correct.<br>Output<br>For each data set from the input, the program prints on the standard output the maximum amount of power that can be consumed in the corresponding network. Each result has an integral value and is printed from the beginning of a separate line.<br>Sample Input<br>2 1 1 2 (0,1)20 (1,0)10 (0)15 (1)20<br>7 2 3 13 (0,0)1 (0,1)2 (0,2)5 (1,0)1 (1,2)8 (2,3)1 (2,4)7<br>         (3,5)2 (3,6)5 (4,2)7 (4,3)5 (4,5)1 (6,0)5<br>         (0)5 (1)2 (3)2 (4)1 (5)4<br>Sample Output<br>15<br>6<br>Hint<br>The sample input contains two data sets. The first data set encodes a network with 2 nodes, power station 0 with pmax(0)=15 and consumer 1 with cmax(1)=20, and 2 power transport lines with lmax(0,1)=20 and lmax(1,0)=10. The maximum value of Con is 15. The second data set encodes the network from figure 1.<br>Problem solving:<br>这个题意也很恶心<br>(原题描述的过于复杂,原题中的s[i]根本不用管)总共有n个节点，其中有发电站np个、用户nc个和调度器n-np-nc个三种节点以及M条电线(用于传输电流的)，每个发电站有一个最大发电量，每个用户有个最大接受电量，现在有m条有向边，边有一个最大的电流量，表示最多可以流出这么多电，现在从发电站发电到用户，问最多可以发多少电(被用户接受).</p><p>分析:<br>建立一个超级源点s,s到任意发电站i有(s,i,,p[i]) (表示该发电站最多能发p[i]电)<br>建立一个超级汇点t,任意用户j到t有边(j,t,c[j]) (表示该用户最多能消费c[j]电)<br>然后对于题目中描述的M条电线(u,v)L, 就有边(u,v,L).<br>最终我们求本图的最大流即可.(到汇点t的最大流就是所有用户能消费的最大电量)</p><p>然后这道题也是一个简单的板子题啦，主要是要自己确定一个源点和一个汇点。就是输入有点恶心。<br>把输入搞定也就是套板子了。在这里我没有用弧优化。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;const int INF = 0x3f3f3f3f;const int maxn = 2e5;using namespace std;struct edge{    int to,dis,nxt;}G[maxn];int head[maxn],d[maxn];int n,np,nc,m,cnt,s,t;void add(int from,int to,int dis){    G[cnt].to=to;    G[cnt].dis=dis;    G[cnt].nxt=head[from];    head[from]=cnt++;}int bfs(){    memset(d,-1,sizeof(d));    d[s]=0;    queue&lt;int&gt; q;    q.push(s);    while(!q.empty())    {        int u=q.front();        if(u==t)    return 1;        q.pop();        for(int i=head[u];i!=-1;i=G[i].nxt)        {            int v=G[i].to;            int dis=G[i].dis;            if(dis&amp;&amp;d[v]==-1)            {                d[v]=d[u]+1;                q.push(v);            }        }    }    return 0;}int dfs(int u,int flow){    if(u==t) return flow;    int x=0;    for(int i=head[u];i!=-1;i=G[i].nxt)    {        int v=G[i].to;        int dis=G[i].dis;        if(dis&amp;&amp;d[v]==d[u]+1)        {            int f=dfs(v,min(dis,flow-x));            G[i].dis-=f;            G[i^1].dis+=f;            x+=f;            if(x==flow) return x;        }    }    return x;}void dinic(){    int ans=0;    while(bfs())    {        ans+=dfs(s,INF);    }    cout&lt;&lt;ans&lt;&lt;endl;}int main(){    while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;np,&amp;nc,&amp;m))    {        cnt=0;        s=n+1;        t=s+1;        memset(head,-1,sizeof(head));        for(int i=0;i&lt;m;i++)        {            int x,y,w;            scanf(&quot; (%d,%d)%d&quot;,&amp;x,&amp;y,&amp;w);            add(x,y,w);            add(y,x,0);        }        for(int i=0;i&lt;np;i++)        {            int v,w;            scanf(&quot; (%d)%d&quot;,&amp;v,&amp;w);            add(s,v,w);            add(v,s,0);        }        for(int i=0;i&lt;nc;i++)        {            int u,w;            scanf(&quot; (%d)%d&quot;,&amp;u,&amp;w);            add(u,t,w);            add(t,u,0);        }        dinic();    }}</code></pre><h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>最后这道题是这位学长拉的，题解去看他的就完事了<br><a href="https://blog.csdn.net/cloudy_happy/article/details/97107699" target="_blank" rel="noopener">https://blog.csdn.net/cloudy_happy/article/details/97107699</a></p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU积分赛 （Day34）</title>
      <link href="/2019/08/18/34/"/>
      <url>/2019/08/18/34/</url>
      
        <content type="html"><![CDATA[<h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>Description:<br>Anxdada有一个长度为n的非负整数序列a1, a2, ..., an.<br>他想知道能否将这个序列划分成奇数个子序列,其中每个子序列的第一个数字是奇数,最后一个数字也是奇数,而且这个子序列的长度也是奇数</p><p>子序列就是原序列的一个连续的片段. 例如,{3, 4, 5}和{1}都是{1, 2, 3, 4, 5, 6}的子序列,但是{1, 2, 4}和{7}并不是{1, 2, 3, 4, 5, 6}的子序列</p><p>Input<br>第一行包含一个正整数n(1 ≤ n ≤ 100) — 原序列的长度.<br>第二行包含n个非负整数a1, a2, ..., an (0 ≤ ai ≤ 100) — 这个序列的元素.</p><p>Output<br>如果原序列可以按要求进行划分就输出&quot;Yes&quot;,否则输出&quot;No&quot;.</p><p>Simple Input 1<br>3<br>1 3 5<br>Simple Output 1<br>Yes<br>Simple Input 2<br>5<br>1 0 1 5 1<br>Simple Output 2<br>Yes<br>Simple Input 3<br>3<br>4 3 1<br>Simple Output 3<br>No<br>Simple Input 4<br>4<br>3 9 9 3<br>Simple Output 4<br>No<br>Note<br>在第一个样例中,把原序列划分为1个子序列: {1, 3, 5}满足题目的要求.<br>在第二个样例中,把原序列划分为3个子序列: {1, 0, 1}, {5}, {1}.<br>在第三个样例中,其中一个子序列一定以4开头,但是4是偶数,因此不符合题意.<br>在第四个样例中,把原序列划分为2个部分:{3, 9, 9},{3},但是2是偶数不满足题意.<br>Problem solving:<br>这道题的意思就是给你一个序列，问你能不能把它分成满足以下条件的几部分</p><ol><li>分出来的这一部分的长为奇数。</li><li>分出来的这一部分的首尾的数都是奇数。</li><li>总共分出来的部分数是奇数。</li></ol><p>首先如果这个序列的长度是一个偶数，那么他就不可能同时满足1跟3，因为奇数乘奇数还是奇数。<br>然后我们只需要再判断一下这个序列的首项和尾项是不是奇数。因为如果这两个有一个是偶数，那就不可能会满足题目中的要求。反之一定可以。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int main(){    int n,a[maxn],flag=0;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i];    }    if(n%2==0)    flag=1;    if(a[1]%2==0||a[n]%2==0)    flag=1;    cout&lt;&lt;(flag==1?&quot;No&quot;:&quot;Yes&quot;)&lt;&lt;endl;}</code></pre><h2 id="搜索漂亮的整数"><a href="#搜索漂亮的整数" class="headerlink" title="搜索漂亮的整数"></a>搜索漂亮的整数</h2><p>Description:<br>小红现在有两个列表的数字.</p><p>如果一个十进制数至少有一个数字来自列表一且至少有一个数字来自列表二，那么将这个数字叫做小红数，请你找出最小的正小红数</p><p>Input<br>第一行包括两个整数 n 和 m (1 ≤ n, m ≤ 9) — 分别代表第一个和第二个列表的长度。</p><p>第二行包含 n 个不同的数字 a1, a2, ..., an (1 ≤ ai ≤ 9) 代表列表一中的元素。</p><p>第三行包含 m 个不同的数字 b1, b2, ..., bm (1 ≤ bi ≤ 9) 代表列表二中的元素</p><p>Output<br>输出最小正小红数.</p><p>Example<br>Input<br>2 3<br>4 2<br>5 7 6<br>Output<br>25<br>Input<br>8 8<br>1 2 3 4 5 6 7 8<br>8 7 6 5 4 3 2 1<br>Output<br>1<br>Problem solving:<br>这道题的意思就是给你两组序列，让你从找到一个数，这个数的每一位都是这两组序列中的某一个数。问你这个数最小是多少。<br>考虑两种情况</p><ol><li>两个序列中有相等的数字出现，那么最小的数就是同时出现的数字里面的最小的那个。</li><li>没有相等的，就拿出来两个序列中的最小的数i,j，让它们两个之间较大的做个位，较小的做十位。即<code>ans=max(i,j)+min(i,j)*10</code>。</li></ol><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int a[12],b[12];int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];    for(int i=0;i&lt;m;i++)    cin&gt;&gt;b[i];    sort(a,a+n);    sort(b,b+m);    int ans=-1;    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;m;j++)        {            if(a[i]==b[j])            {                ans=a[i];                break;            }        }        if(ans!=-1)    break;    }    if(ans==-1)    {        ans=min(a[0],b[0])*10+max(a[0],b[0]);    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h2 id="hzy-和zsl-的生存挑战"><a href="#hzy-和zsl-的生存挑战" class="headerlink" title="hzy 和zsl 的生存挑战"></a>hzy 和zsl 的生存挑战</h2><p>Description:<br>zsl 和hzy 来到了臭臭城堡，打算挑战臭臭城堡的大魔王hyz，大魔王hyz设置了这样的一个挑战：</p><ol><li>zsl 和hzy两个人各自来到一间密室，期间两人无法以任何形式交流</li><li>大魔王hyz会随机在两个人的脑海里各发送一个数字，0或者是1</li><li>zsl 和 hzy 需要猜对这俩个数字才算通关，但是大魔王hyz觉得人生不能过于无敌，因此降低难度，只要两个人中有一个人答对就算是通关</li></ol><p>现在大魔王hyz 给出的数字可能的情况有 00， 01， 10， 11 四种，请按上述枚举的顺序，计算所有情况下zsl 和hzy 通关的几率。（假设zsl 和 hzy 两个人都足够机智，能够选择出最优决策）<br>Input<br>(空)<br>Output<br>输出四个答案，每个答案后面跟随一个换行符并且保留两位小数位，分别对应00，01，10，11的情况下，zsl和hzy通关的几率<br>Sample Input<br>(空)<br>Sample Output<br>1.00<br>0.00<br>0.50<br>0.55 (输出仅做格式参考,不保证正确性)<br>Problem solving:<br>这道题没啥意思。<br>hzy和zsl都很聪明，所以只要他们一个人说0一个人说1就一定可以出去。直接输出4个1就行。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    puts(&quot;1.00&quot;);    puts(&quot;1.00&quot;);    puts(&quot;1.00&quot;);    puts(&quot;1.00&quot;);    return 0;}</code></pre><h2 id="共享单车"><a href="#共享单车" class="headerlink" title="共享单车"></a>共享单车</h2><p>Description:<br>学长自从上次被打了一顿之后,就想着讨好实验室的人。<br>于是他决定带着实验室的人出去玩。实验室一共有k个人,出去玩需要骑自行车。<br>一共有m家共享单车公司提供自行车,第i家共享单车公司提供的自行车信息用li,ri,ci,pi表示。<br>其中:<br>li,ri表示这家公司从接下来的第li天到ri天,提供共享单车.<br>ci表示这家公司在这些天每天提供的单车数目.<br>pi表示租用每辆车需要的单价.<br>现在学长想在接下来连续的n天,每天都带着实验室的k个人出去玩,要求出行时候每个人都尽可能能坐到单车,即每天都要租k辆车,当然如果某一天所有公司全部加起来都没有提供k辆车,那么就将所有车都租下,让剩下的一些人走路,否则如果够k辆就一定要租k辆.<br>请你输出学长最少需要花多少钱.<br>Input<br>输入的第一行为3个整数n,k,m(1&lt;=n,k&lt;=10^6,1&lt;=m&lt;=2*10^5).<br>接下来m行,每行4个整数li,ri,ci,pi(1&lt;=li&lt;=ri&lt;=n,1&lt;=ci,pi&lt;=10^6).<br>Output<br>输出只有一行,表示学长最少需要花费的钱.<br>Examples<br>Input<br>5 7 3<br>1 4 5 3<br>1 3 5 2<br>2 5 10 1<br>Output<br>44<br>Input<br>7 13 5<br>2 3 10 7<br>3 5 10 10<br>1 2 10 6<br>4 5 10 9<br>3 4 10 8<br>Output<br>462<br>Problem solving:<br>暂无<br>Code:</p><pre><code class="lang-c++"></code></pre><h2 id="最小值最大值"><a href="#最小值最大值" class="headerlink" title="最小值最大值"></a>最小值最大值</h2><p>Description:<br>给出一个有n个整数的数组 a1, a2, ..., an 和一个整数k。你被要求把这个数组分成k 个非空的子段。 然后从每个k 个子段拿出最小值，再从这些最小值中拿出最大值。求这个最大值最大能为多少？</p><p>Input<br>第一行输入两个整数 n 和 k (1 ≤ k ≤ n ≤  1e5) — 数组a 的大小和要求分成子段的数目</p><p>第二行包含 n 整数 a1,  a2,  ...,  an ( - 1e9  ≤  ai ≤  1e9).</p><p>Output<br>输出答案——在你分离的每个子段中最小值中的最大值k</p><p>Example<br>Input<br>5 2<br>1 2 3 4 5<br>Output<br>5<br>Input<br>5 1<br>-4 -5 -3 -2 -1<br>Output<br>-5<br>Problem solving:<br>这道题很有意思。<br>他就是给你一组数，这组数有m个，问你分成m份的话，每一份的最小值中的最大值是多少。</p><p>看到了最小的最大我一开始以为是2分。但是check函数一直写不出来。再仔细一想发现这不就是个规律题吗。<br>分三种情况</p><ol><li>分成1份，此时的答案就是这组数中的最小值。</li><li>分成2份，此时的答案就是这组数的开头跟结尾的最大值。这个不太好理解。因为分成两份，每一份都要取一个最小值，所以我们把两边的两个数单独分成一组来考虑，此时就已经是最优解了。这一点不太好解释（因为我当时是病急乱投医这样写的，现在发现还是挺有道理的——因为我们要求的是最小的最大，可以自己举几个例子，你就会发现这个的巧妙）</li><li>除了前两种，此时的答案就是这组数中的最大值。因为当你可以分3份开始，你就可以把这组数中的最大值单独一个数分成一组，其他任意分。这时每组数的最小的最大值就是整组数中的最大值了。</li></ol><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6;const ll inf =1e9+10;ll a[maxn];int main(){    ll n,m;    cin&gt;&gt;n&gt;&gt;m;    for(ll i=0;i&lt;n;i++)    {        cin&gt;&gt;a[i];    }    if(m==2)    cout&lt;&lt;max(a[0],a[n-1])&lt;&lt;endl;    else    {        sort(a,a+n);        if(m==1)    cout&lt;&lt;a[0]&lt;&lt;endl;        else    cout&lt;&lt;a[n-1]&lt;&lt;endl;    }    return 0;}</code></pre><h2 id="Ring"><a href="#Ring" class="headerlink" title="Ring"></a>Ring</h2><p>Description:<br>邓布利多教授正在帮助哈利摧毁魂器。当他怀疑一个魂器出现在那里时，他去了冈特沙克。他看到Marvolo Gaunt的戒指，并将其确定为魂器。虽然他摧毁了它，但仍然受到诅咒的影响。斯内普教授正在帮助邓布利多解除诅咒。为此，他想给Dumbledore提供他制作的药水x滴。</p><p>x的值被计算为给定p，q，r和阵列a1，a2，......的p·ai + q·aj + r·ak的最大值，使得1≤i≤j≤k≤n。帮助Snape找到x的值。请注意x的值可能是负数。</p><p>Input<br>第一行输入包含4个整数n，p，q，r（ - 1e9≤p，q，r≤1e9, 1≤n≤1e5）。</p><p>下一行输入包含n个空格分隔的整数a1，a2，... an（ - 1e9≤ai≤1e9）。</p><p>Output<br>输出p≤ai+ q·aj + r·ak的最大值，只要1≤i≤j≤k≤n即可得到。</p><p>Examples<br>Input<br>5 1 2 3<br>1 2 3 4 5<br>Output<br>30<br>Input<br>5 1 2 -3<br>-1 -2 -3 -4 -5<br>Output<br>12<br>Note<br>In the first sample case, we can take i = j = k = 5, thus making the answer as 1·5 + 2·5 + 3·5 = 30.</p><p>In second sample case, selecting i = j = 1 and k = 5 gives the answer 12.<br>Problem solving:<br>暂无<br>Code:</p><pre><code class="lang-c++"></code></pre><h2 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h2><p>Description:<br>著名出题人小Q每次比赛后都会写一份《赛题分析》，包含比赛概况、每题的参考算法以及一些统计数值。</p><p>对于一道题来说，小Q会统计最短的验题人代码长度(Shortest judge solution)以及赛内参赛队伍最短的AC代码长度(Shortest team solution)。</p><p>统计验题人代码长度比较容易，因为验题人最多也不会超过20个。但是统计选手代码长度就不容易了，因为大赛区动辄三四百支队伍。</p><p>请写一个程序，帮助小Q统计最短代码长度。<br>Input<br>第一行包含一个正整数T(1≤T≤13)，表示赛题数量。</p><p>每道题第一行包含两个整数n,m(2≤n≤20,0≤m≤500)，分别表示验题人数量以及AC了该题的队伍数量。</p><p>第二行包含n个正整数a1,a2,...,an(50≤ai≤65536)，依次表示每个验题人的代码字节数。</p><p>第三行包含m个正整数b1,b2,...,bn(50≤bi≤65536)，依次表示每支AC队伍的代码字节数。若m=0则该行为空行。<br>Output<br>对于第i(1≤i≤T)道题，输出三行，第一行输出Problem x:，其中x=i+1000。</p><p>第二行输出Shortest judge solution: y bytes.，其中y表示最短的验题人代码字节数。</p><p>第三行输出Shortest team solution: z bytes.，其中z表示最短的选手代码字节数，若不存在请输出N/A。</p><p>注意：间隔都是一个空格。<br>Sample Input<br>2<br>3 2<br>3627 1460 5288<br>2365 2671<br>2 0<br>5510 7682<br>Sample Output<br>Problem 1001:<br>Shortest judge solution: 1460 bytes.<br>Shortest team solution: 2365 bytes.<br>Problem 1002:<br>Shortest judge solution: 5510 bytes.<br>Shortest team solution: N/A bytes.<br>Problem solving:<br>没啥好说的，sort就完事了。<br>我还PE了好几次。。。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 505;int a[maxn],b[maxn];int main(){    int t,n,m;    cin&gt;&gt;t;    for(int l=1;l&lt;=t;l++)    {        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];        for(int i=0;i&lt;m;i++)    cin&gt;&gt;b[i];        sort(a,a+n),sort(b,b+m);        printf(&quot;Problem %d:\n&quot;,l+1000);        printf(&quot;Shortest judge solution: %d bytes.\n&quot;,a[0]);        if(m)        printf(&quot;Shortest team solution: %d bytes.\n&quot;,b[0]);        else        printf(&quot;Shortest team solution: N/A bytes.\n&quot;);    }}</code></pre><h2 id="差异的可分割性"><a href="#差异的可分割性" class="headerlink" title="差异的可分割性"></a>差异的可分割性</h2><p>Description:<br>现在有n个整数，在这n个数中找出k个数，保证这k个数中任意两个数差的绝对值可以被m整除。<br>Input<br>第一行输入三个整数n，k，m(2&lt;=k&lt;=n&lt;=100000,1&lt;=m&lt;=100000)。<br>第二行包含n个整数a1，a2，...，  an（0 &lt;= ai &lt;= 10^9 )。<br>Output<br>如果不存在这样的k个数，输出&quot;No&quot;；<br>否则输出&quot;Yes&quot;后，在下一行输出这k个数,数与数之间用空格隔开。 (存在多种情况，输出任意一种)。<br>Example<br>Input<br>3 2 3<br>1 8 4<br>Output<br>Yes<br>1 4<br>Input<br>3 3 3<br>1 8 4<br>Output<br>No<br>Input<br>4 3 5<br>2 7 7 7<br>Output<br>Yes<br>2 7 7<br>Problem solving:<br>这道题也挺有意思的。输入的n代表有n个数，k，m就是问你在n个数中能不能找到k个数，使这k个数任意两个的差都可以被m整除。如果可以的话还要输出一种情况。</p><p>这道题我一开始是一点思路没有，暴力tle了几发之后想到了用取模来写。因为如果两个数的差对能被一个数m整除。那么这两个数对m的模一定是相等的。</p><p>但是还需要输出情况，所以我用了两个数组来存，一个存原始的，一个用结构体来存，存进去它取模之后的结果以及取模之前的序号，其实现在一想也可以直接存上它原来的值。</p><p>然后就存进去之后排一下序，所以这时候如果相等的个数大于k的话，就说明可以，然后再用结构体里面存的数据输出就行了。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6;int a[maxn];struct node{    int d,id;}p[maxn];bool cmp(node a,node b){    return a.d&lt;b.d;}int main(){    int n,k,m,flag=0;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;k,&amp;m);    for(int i=0;i&lt;n;i++)    scanf(&quot;%d&quot;,&amp;a[i]);    for(int i=0;i&lt;n;i++)    {        p[i].d=a[i]%m;        p[i].id=i;    }    sort(p,p+n,cmp);    int mid=p[0].d,cnt=1;    for(int i=1;i&lt;n;i++)    {        if(p[i].d==mid)        {            cnt++;        }        else        {            mid=p[i].d;            cnt=1;        }        if(cnt==k)        {            puts(&quot;Yes&quot;);            for(int j=i;j&gt;i-k;j--)            {                printf(&quot;%d &quot;,a[p[j].id]);            }            return 0;        }    }    puts(&quot;No&quot;);    return 0;}</code></pre><h2 id="扫雷"><a href="#扫雷" class="headerlink" title="扫雷"></a>扫雷</h2><p>Description:<br>扫雷游戏是晨晨和小璐特别喜欢的智力游戏，她俩最近沉迷其中无法自拔。<br>该游戏的界面是一个矩阵，矩阵中有些格子中有一个地雷，其余格子中没有地雷。 游戏中，格子可能处于己知和未知的状态。如果一个己知的格子中没有地雷，那么该 格子上会写有一个一位数，表示与这个格子八连通相邻的格子中地雷总的数量。<br>现在，晨晨和小璐在一个3行N列（均从1开始用连续正整数编号）的矩阵中进 行游戏，在这个矩阵中，第2行的格子全部是己知的，并且其中均没有地雷；而另外 两行中是未知的，并且其中的地雷总数量也是未知的。<br>晨晨和小璐想知道，第1行和第3行有多少种合法的埋放地雷的方案。<br>Input<br>包含多组测试数据，第一行一个正整数T，表示数据组数。<br>每组数据由一行仅由数字组成的长度为N的非空字符串组成，表示矩阵有3行N 列，字符串的第i个数字字符表示矩阵中第2行第i个格子中的数字。<br>保证字符串长度N &lt;= 10000，数据组数&lt;= 100。<br>Output<br>每行仅一个数字，表示安放地雷的方案数mod100,000,007的结果。<br>Sample Input<br>2<br>22<br>000<br>Sample Output<br>6<br>1<br>Problem solving:<br>暂无<br>Code:</p><pre><code class="lang-c++"></code></pre><h2 id="派对柠檬水"><a href="#派对柠檬水" class="headerlink" title="派对柠檬水"></a>派对柠檬水</h2><p>Description:<br>点完菜，他们发现好像觉得少了点什么？</p><p>想想马上就要回老家了某不愿透露姓名的林姓学长再次却陷入了沉思。。。。。。。。。</p><p>他默默的去前台打算点几瓶二锅头。</p><p>他发现菜单上有n 种不同毫升的酒. 第 i 种有2i - 1 毫升价格为ci 元.商店中每种类型的酒的数量可以被认为是无限的。.</p><p>他对于自己能喝多少还是有点B-Tree的，但是他认为喝酒一定要喝的尽兴，于是他打算买至少L 毫升，但是又要花最少的钱，现在他想知道他最少需要花多少钱</p><p>Input<br>第一行输入两个整数 n and L (1 ≤ n ≤ 30; 1 ≤ L ≤ 1e9) — 代表有n总酒和需要买的数量</p><p>第二行输入 n个整数s c1, c2, ..., cn (1 ≤ ci ≤ 1e9) —代表第i种酒需要的钱数</p><p>Output<br>输出一个整数，他买至少L 了毫升，所花的最少钱数</p><p>Example<br>Input<br>4 12<br>20 30 70 90<br>Output<br>150<br>Input<br>4 3<br>10000 1000 100 10<br>Output<br>10<br>Input<br>4 3<br>10 100 1000 10000<br>Output<br>30<br>Input<br>5 787787787<br>123456789 234567890 345678901 456789012 987654321<br>Output<br>44981600785557577<br>Note<br>在第一个例子中，你应该花90元购买一个8毫升的，花60元的购买两个2毫升的。总共你会得到12毫升只要150元。</p><p>在第二个例子中，即使你只需要3毫升，但是购买一个10元8毫升的便宜一些。</p><p>在第三个例子中，最好10元购买三个1毫升的。<br>Problem solving:<br>暂无<br>Code:</p><pre><code class="lang-c++"></code></pre><h2 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h2><p>Description:<br>Farmer John有n头奶牛.<br>某天奶牛想要数一数有多少头奶牛,以一种特殊的方式:<br>第一头奶牛为1号,第二头奶牛为2号,第三头奶牛之后,假如当前奶牛是第n头,那么他的编号就是2倍的第n-2头奶牛的编号加上第n-1头奶牛的编号再加上自己当前的n的三次方为自己的编号.<br>现在Farmer John想知道,第n头奶牛的编号是多少,估计答案会很大,你只要输出答案对于123456789取模.<br>Input<br>第一行输入一个T,表示有T组样例<br>接下来T行,每行有一个正整数n,表示有n头奶牛 (n&gt;=3)<br>其中，T=1e4,n&lt;=1e18<br>Output<br>共T行,每行一个正整数表示所求的答案<br>Sample Input<br>5<br>3<br>6<br>9<br>12<br>15<br>Sample Output<br>31<br>700<br>7486<br>64651<br>527023<br>Problem solving:<br>这个题就是给了你一个递推式<br><code>f(n)=f(n-1)+2*f(n-2)+n*n*n</code><br>然后告诉你f(1)=1,f(2)=2。让你求第n项的值，n的范围比较大，所以得用到矩阵快速幂，构建出来常熟矩阵和系数矩阵就行了（这是之前学矩快的时候的一道原题</p><p>难点就是构建n的三次方那里。<br>构建的矩阵看代码注释吧（还有别忘了给用到的矩阵先初始化为0）</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 123456789;struct node{    ll a[10][10];};node mul(node a,node b){    node ans;    memset(ans.a,0,sizeof(ans.a));    for(ll i=0;i&lt;6;i++)    {        for(ll j=0;j&lt;6;j++)        {            for(ll k=0;k&lt;6;k++)            {                ans.a[i][j]=(ans.a[i][j]+a.a[i][k]*b.a[k][j])%mod;            }        }    }    return ans;}node poww(node a,ll b){    node mid;    memset(mid.a,0,sizeof(mid.a));    for(ll i=0;i&lt;6;i++)    mid.a[i][i]=1;    while(b)    {        if(b&amp;1)    mid=mul(mid,a);        a=mul(a,a);        b/=2;    }    return mid;}int main(){    ll n,t;    cin&gt;&gt;n;    node s,mid;    memset(s.a,0,sizeof(s.a));    memset(mid.a,0,sizeof(mid.a));    s.a[0][0]=31;s.a[1][0]=2;s.a[2][0]=27;s.a[3][0]=9;s.a[4][0]=3;s.a[5][0]=1;//s是系数矩阵    mid.a[0][0]=1;mid.a[0][1]=2;mid.a[0][2]=1;mid.a[0][3]=3;mid.a[0][4]=3;mid.a[0][5]=1;    mid.a[1][0]=1;//mid是常数矩阵    mid.a[2][2]=1;mid.a[2][3]=3;mid.a[2][4]=3;mid.a[2][5]=1;    mid.a[3][3]=1;mid.a[3][4]=2;mid.a[3][5]=1;    mid.a[4][4]=1;mid.a[4][5]=1;mid.a[5][5]=1;    while(n--)    {        cin&gt;&gt;t;        if(t==1)    puts(&quot;1&quot;);        else if(t==2) puts(&quot;2&quot;);        else if(t==3)    puts(&quot;31&quot;);        else        {            node ans=poww(mid,t-3);            ans=mul(ans,s);            cout&lt;&lt;ans.a[0][0]&lt;&lt;endl;        }    }}</code></pre><h2 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h2><p>Description:<br>Hao得了重感冒。他将要去看 n 名医生来找出确切的诊断。每个医生都需要之前医生的所有的诊断信息，所以Hao需要按照规定的顺序访问医生（比如Hao应该先访问 1号医生,2号医生, 然后是3号医生，等等）。 Hao将从上一位医生那里获取关于他的健康信息。</p><p>医生有一个奇怪的工作表。第i名医生从si天起工作之后会每隔di 天再工作.所以医生在si, si + di, si + 2di, ....这段时间是处以上班状态</p><p>Hao一天只能访问一名医生，Hao访问完所有医生之后所花费的最短时间是多少？</p><p>Input<br>First line contains an integer n — number of doctors (1 ≤ n ≤ 1000).</p><p>Next n lines contain two numbers si and di (1 ≤ si, di ≤ 1000).</p><p>Output<br>Output a single integer — the minimum day at which Borya can visit the last doctor.</p><p>Example<br>Input<br>3<br>2 2<br>1 2<br>2 2<br>Output<br>4<br>Input<br>2<br>10 1<br>6 5<br>Output<br>11<br>Note<br>In the first sample case, Borya can visit all doctors on days 2, 3 and 4.</p><p>In the second sample case, Borya can visit all doctors on days 10 and 11.<br>Problem solving:<br>这道题就是给你每个医生开始上班的日期以及上班的周期。问你多久之后你能看完所有医生。每天只能看一个医生，并且你看医生的顺序是固定的，跟输入的顺序一样。</p><p>一个while模拟一下就行了。每次没到上班的日期就往上加。<br>注意：一天只能看一个医生。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int s[maxn],d[maxn];int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;s[i]&gt;&gt;d[i];    int ans=s[0];    for(int i=1;i&lt;n;i++)    {        int mid=s[i];        while(s[i]&lt;=ans)        {            s[i]+=d[i];        }        ans=s[i];    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 矩阵快速幂 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河南理工大学算法协会暑期集训积分赛（五） Day33</title>
      <link href="/2019/08/17/33/"/>
      <url>/2019/08/17/33/</url>
      
        <content type="html"><![CDATA[<h2 id="Steve的水池"><a href="#Steve的水池" class="headerlink" title="Steve的水池"></a>Steve的水池</h2><p>Description:<br>Steve 拥有深棕色头发，晒黑的褐色皮肤，紫色的眼睛，身穿青蓝色的衬衫，一条紫蓝色牛仔裤以及灰黑色的鞋子。他还拥有2px至4px大小的胳膊。Steve 似乎拥有轻微的浅棕色胡子茬，或者拥有一张嘴，这取决于你怎样看他。</p><p>Steve 需要种庄稼，圈养动物来获得食物来源，为了抵抗怪物，他需要挖矿获得铁锭，金锭，甚至钻石来制作更高级的武器装备，通常，他还需要对武器装备附魔，来提升效果，为此，他不得不需要经常下矿。</p><p>在经历了枯燥又乏味的矿工生活后，Steve 打算建造一个水池来放松放松，他打算把水池建造成一个高度为1，长宽分别为N,M的水池，为此，他需要向水池中倒水，但Steve 只有一个水桶，他不想要浪费更多的铁锭来制作更多的水桶，为此，他需要尽可能少的往水池里倒水以尽快建造好水池，但是Steve 的世界有一个很奇怪的特性，每向一个区域倒水的时候，在这个区域会形成一个水源，当一个区域四个方向中至少有两个方向紧挨着这个区域的地方都为水源的话，这个区域也将会形成水源，Steve 想要知道最少他需要倒多少次水才能使水池每处都形成水源。</p><p>输入格式<br>输入第1行为一个整数T。（1 ≤ T ≤ 1000）<br>第2行到第T+1行每行为两个整数N,M代表水池的长宽。（1 ≤ N,M ≤ 1e9）</p><p>输出格式<br>输出为T行，每行输出一个整数，代表Steve 最少需要的倒水次数。</p><p>样例<br>input<br>1<br>1 1<br>output<br>1<br>input<br>2<br>1 3<br>3 3<br>output<br>2<br>3</p><p>Problem solving:<br>这道题我是找规律做的。但是标程竟然是<code>(m+n)/2</code>向上取整。<br>我找规律过程艰辛就不细说了。<br>另外今天学到了ceil返回的是一个double类型！！！</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    int t;    ll n,m;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%lld %lld&quot;,&amp;m,&amp;n);        ll k=max(m,n)-min(m,n);        ll ans=min(m,n);        if(k%2==1)        {            ans+=(k)/2+1;        }        else        {            ans+=(k)/2;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    int t;    cin&gt;&gt;t;    ll n,m;    while(t--)    {        cin&gt;&gt;n&gt;&gt;m;        cout&lt;&lt;(ll)ceil((m+n)*0.5)&lt;&lt;endl;    }    return 0;}</code></pre><h2 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h2><p>Description:<br>骰子，中国传统民间娱乐用来投掷的博具，早在战国时期就已经被发明。</p><p>现在给你 n 个骰子，求 n 个骰子掷出点数之和为 a 的概率是多少。</p><p>输入格式<br>第一行输入一个整数 T，表示有 T 组测试数据（1≤T≤10）<br>每组测试数据输入两个整数n,a，表示共有n个骰子，骰子点数总和为a(1≤n≤1000,n≤a≤6∗n)</p><p>输出格式<br>如题。答案对 1e9+7 取余。</p><p>样例<br>input<br>2<br>1 2<br>2 2<br>output<br>166666668<br>27777778</p><p>Problem solving:<br>这道题就是给你骰子的个数，然后给你一个点数，问你那个点数出现的概率。因为涉及到精度所以要用逆元处理。<br>这道题是个dp。看了学长的标程才做(cv)出来了。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+10;const int mod = 1e9+7;typedef long long ll;ll dp[maxn][maxn*6];ll poww(ll x,ll y){    ll ans=1;    while(y)    {        if(y&amp;1)    ans=(ans*x)%mod;        x=(x*x)%mod;        y/=2;    }    return ans;}int main(){    int t,n,a;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(dp,0,sizeof(dp));        scanf(&quot;%d %d&quot;,&amp;n,&amp;a);        dp[0][0]=1;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=6*n;j++)            {                for(int k=j-6;k&lt;j;k++)                {                    if(k&lt;0)    continue;                    dp[i][j]=(dp[i][j]+dp[i-1][k])%mod;                }            }        }        printf(&quot;%d\n&quot;,dp[n][a]*poww(poww(6,n),mod-2)%mod);    }}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define pii pair&lt;int,int&gt;#define ll long longconst ll mod=1000000007;const int maxn=1000+10;ll dp[maxn][maxn*6];ll quickpow(ll a,ll b){    ll res=1;    while(b){        if(b&amp;1) res=res*a%mod;        a=a*a%mod;        b&gt;&gt;=1;    }    return res;}void solve(){    int t;    int n,a;    scanf(&quot;%d&quot;,&amp;t);    while(t--){        memset(dp,0,sizeof(dp));        scanf(&quot;%d %d&quot;,&amp;n,&amp;a);        dp[0][0]=1;        for(int i=1;i&lt;=n;i++){            for(int j=i;j&lt;=6*n;j++){                for(int k=j-6;k&lt;j;k++){                    if(k&lt;0) continue;                    dp[i][j]=(dp[i][j]+dp[i-1][k])%mod;                }            }        }        printf(&quot;%lld\n&quot;,dp[n][a]*quickpow(quickpow(6,n),mod-2)%mod);    }}int main(){    solve();    return 0;}</code></pre><h2 id="Subsequence"><a href="#Subsequence" class="headerlink" title="Subsequence"></a>Subsequence</h2><p>Description:<br>Steve  和 Alex 喜欢研究字符串，今天他们学到了一个新名词—“Subsequence“。对于字符串 s 和 t 来说，t 被称为 s 的”Subsequence“当且仅当 s 删除若干字母后能得到 t （也可以不删)。</p><p>例如：”ab”,”ac”,”bc”都是”abc”的”Subsequence“，而”ba”和”ca”则不是。</p><p>现在 Steve 和 Alex 手中各自有一个只由小写字母组成的字符串 s 和 t ，请判断 t 是否是 s 的”Subsequence“。</p><p>输入格式<br>第一行输入一个T,代表数据组数。<br>接下来输入T组，每组包含两行，第一行输入s，第二行输入t。<br>(1≤T≤1000,1≤|t|≤|s|≤10000)</p><p>输出格式<br>输出T行，如果t是s的”Subsequence“，输入”YES”,否则输出”NO”。</p><p>样例<br>input<br>3<br>abc<br>ac<br>abc<br>ba<br>abc<br>a<br>output<br>YES<br>NO<br>YES</p><p>Problem solving:<br>这道题就是签到题。直接从一开始就暴力查找即可。<br>个人认为有一点小小的贪心的思想。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        string x,y;        cin&gt;&gt;x&gt;&gt;y;        int l=x.size(),pos=0;        for(int i=0;i&lt;l;i++)        {            if(x[i]==y[pos])            {                pos++;            }        }        if(pos==y.size())        {            puts(&quot;YES&quot;);        }        else    puts(&quot;NO&quot;);    }}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; &#39; &#39; &lt;&lt; (x) &lt;&lt; endl;using namespace std;typedef long long ll;const int MAXN = 1e6 + 7;int main() {    int T;    cin &gt;&gt; T;    while(T--){        string s, t;        cin &gt;&gt; s &gt;&gt; t;        int n = s.size(), m = t.size();        int i, j;        i = j = 0;        while(i &lt; n &amp;&amp; j &lt; m){            if(s[i] == t[j])    j++;            i++;                    }        if(j == m)  cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="Steve的游戏名"><a href="#Steve的游戏名" class="headerlink" title="Steve的游戏名"></a>Steve的游戏名</h2><p>Description:<br>定义一个字符串s是一步字符串，当 s 满足以下两个条件：<br>s 中仅包含小写字母。<br>对于任意的1≤i&lt;|s|满足，s[i]+1=s[i+1]，也就是说，s[i]在英文字母表中的位置的下一位是s[i+1]，特别的，我们认为z的下一位是a，其中|s|表示s的长度。<br>举个例子：abc、zab 都是一步字符串，而 acd、zbc不是。<br>Steve 特别喜欢长长的名字，因此他在 Minecraft 中的名字特别特别的长。<br>Alex 对 Steve 的名字特别感兴趣，她想知道 Steve 的名字中有多少个子串是一步字符串。<br>形式化来说，对于一个字符串 s，问有多少对 <i,j> 满足 1≤i≤j≤n，且 s[i]...s[j] 是一步字符串。<br>保证 Steve 在 Minecraft 中的名字仅包含小写英文字母。</i,j></p><p>输入格式<br>输入包含多组测试数据。<br>第一行一个数字 T ，表示测试数据个数。<br>接下来每两行表示一个测试数据。<br>第一行一个数字 n 。<br>第二行一个长度为 n 的字符串 s。<br>数据范围：1≤T≤100,1≤n≤2e5</p><p>输出格式<br>一个数字表示答案。</p><p>样例<br>input<br>2<br>3<br>abc<br>3<br>zab<br>output<br>6<br>6<br>提示<br>abc中的一步字符串有a、b、c、ab、bc、abc。<br>zab中的一步字符串有z、a、b、za、ab、zab。</p><p>Problem solving:<br>这道题也挺简单的，一步字符串就是相邻的字符后面的比前面的a思科(ASCLL)码大1。z看作是a的下一位。<br>假设我们现在找到了一个长度为n的一步字符串，那么他的所有子串也都是一步字符串，字串个数为<code>(n+1)*n/2</code>。<br>所以我们只需要暴力查找到每一个最长的一步字符串然后加起来即可。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n,m;    string s;    scanf(&quot;%lld&quot;,&amp;n);    while(n--)    {        scanf(&quot;%lld&quot;,&amp;m);        cin&gt;&gt;s;        ll mid=1,ans=0;        for(ll i=0;i&lt;m-1;i++)        {            if((s[i]-&#39;a&#39;+1)%26==(s[i+1]-&#39;a&#39;)%26)            {                mid++;            }            else            {                ans+=(1+mid)*mid/2-mid;                mid=1;            }        }        if(mid)    ans+=(1+mid)*mid/2-mid;        ans+=m;        printf(&quot;%lld\n&quot;,ans);    }}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = (a); i &lt;= (b); ++i)#define per(i, a, b) for(int i = (a); i &gt;= (b); --i)#define debug(x) cerr &lt;&lt; #x &lt;&lt; &#39; &#39; &lt;&lt; (x) &lt;&lt; endl;using namespace std;typedef long long ll;const int MAXN = 2e5 + 7;int cnt[MAXN];int main() {    int T;    cin &gt;&gt; T;    while(T--){        int n;        string s;        cin &gt;&gt; n &gt;&gt; s;        cnt[n] = n;        per(i, n-2, 0){            if(((s[i] - &#39;a&#39; + 1) % 26 + &#39;a&#39;) == s[i+1]){                cnt[i+1] = cnt[i+2];            } else cnt[i+1] = i+1;        }        ll res = 0;        rep(i, 1, n){            res += 1LL * (cnt[i] - i + 1);        }        cout &lt;&lt; res &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="数字串"><a href="#数字串" class="headerlink" title="数字串"></a>数字串</h2><p>Description:<br>给你一个长度为 n 的数字串，找出其中位数不超过15位的不包含前导0和后导0的数 x ,使得 x+f(x) 是一个回文数,其中 f(x) 表示将 x 反转过来的数。</p><p>输入格式<br>多组输入，处理到文件结束,样例保证不超过1000组。<br>每组第一行一个整数 n ，表示数字串的长度(1≤n≤1000)，<br>接下来一行输入一个长度为 n 的数字串。</p><p>输出格式<br>第一行一个数 m 表示数字串中符合条件的数的个数(数可以重复)。<br>第二行从小到大输出 m 个数，每个数字之间以空格隔开。</p><p>样例<br>input<br>3<br>123<br>output<br>6<br>1 2 3 12 23 123<br>提示<br>1+1=2,<br>2+2=4,<br>3+3=6,<br>12+21=33,<br>23+32=55,<br>123+321=444</p><p>Problem solving:<br>神签到题，直接暴力模拟每个串就行。<br>这里卡到我的地方时不知道怎么遍历字符串的每个子串了。这个确实是我憨批了。<br>用字符串输入，然后遍历每个子串。转换成整型之后进行判断。<br>每一步都直接判断就行了。<br>因为输出时候有要求，所以我们把满足条件的都存进一个数组sort一下输出即可。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e4+10;ll a[maxn];ll solve(ll x){    ll res=0;    while(x)    {        res=res*10+x%10;        x/=10;    }    return res;}int main(){    int n;    string s;    while(cin&gt;&gt;n)    {        cin&gt;&gt;s;        int pos=0;        for(int i=0;i&lt;n;i++)        {            if(s[i]==&#39;0&#39;)    continue;            ll mid=0;            for(int j=0;j&lt;15&amp;&amp;i+j&lt;n;j++)            {                mid=mid*10+s[i+j]-&#39;0&#39;;                if(s[i+j]==&#39;0&#39;)    continue;                if(mid+solve(mid)==solve(mid+solve(mid)))                {                    a[pos++]=mid;                }            }        }        sort(a,a+pos);        cout&lt;&lt;pos&lt;&lt;endl;        for(int i=0;i&lt;pos;i++)            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;        puts(&quot;&quot;);    }    return 0;}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e4+10;ll a[maxn];ll solve(ll x){    ll res=0;    while(x)    {        res=res*10+x%10;        x/=10;    }    return res;}int main(){    int n;    string s;    while(cin&gt;&gt;n)    {        cin&gt;&gt;s;        int pos=0;        for(int i=0;i&lt;n;i++)        {            if(s[i]==&#39;0&#39;)    continue;            ll mid=0;            for(int j=0;j&lt;15&amp;&amp;i+j&lt;n;j++)            {                if(s[i+j]==&#39;0&#39;)    continue;                mid=mid*10+s[i+j]-&#39;0&#39;;                if(mid+solve(mid)==solve(mid+solve(mid)))                {                    a[pos++]=mid;                }            }        }        sort(a,a+pos);        cout&lt;&lt;pos&lt;&lt;endl;        for(int i=0;i&lt;pos;i++)            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;        puts(&quot;&quot;);    }    return 0;}</code></pre><h2 id="Alex的午饭"><a href="#Alex的午饭" class="headerlink" title="Alex的午饭"></a>Alex的午饭</h2><p>Description:<br>Steve 和Alex每天都在为午饭吃什么而发愁，因为吃的东西实在是太多了，而且很多都特别好吃。为了解决吃什么的问题，Alex决定每次吃饭前发布一个问卷调查，让他的好朋友选出他们今天最想吃的食物，然后Alex会根据问卷的结果来确定吃什么</p><p>每个问卷只收集一种食物，每个食物都由一个数字num来表示。Alex会选出问卷中出现次数超过问卷总数一半的数字来决定今天的午饭</p><p>输入格式<br>单组输入，每组两行</p><p>第一行有一个整数N  (1≤N≤2e7)</p><p>第二行有N个整数num  (num≤1e18)，代表每个问卷中的数字</p><p>输出格式<br>输出一个整数，即出现次数超过N2的数</p><p>样例<br>input<br>4<br>1 1 1 2<br>output<br>1<br>input<br>5<br>2 2 3 3 3<br>output<br>3<br>提示<br>保证每组数据一定存在符合条件的数<br>请注意题目上的内存限制</p><p>Problem solving:<br>这道题我是用map卡过得，但好像正解是一个xxx判断法，</p><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    ll a,t;    cin&gt;&gt;t;    ll res=0;ll ans;    for(ll i=0;i&lt;t;i++)    {        cin&gt;&gt;a;        if(!res)            ans=a;        if(a==ans)            res++;        if(a!=ans)            res--;    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h2 id="The-war-land"><a href="#The-war-land" class="headerlink" title="The war land"></a>The war land</h2><p>Description:<br>Steve 和 Alex 开始玩一款叫做战争大陆的游戏，整个地图由 n 个岛屿和 n−1 条桥梁组成，第 i 个岛屿的战略能力为 wi ，整个地图是联通的。游戏开始 Steve 和 Alex 需要断掉一座桥梁，这样整个地图就被划分为了两个联通的区域 A 和 B 并且 A 和 B 之间无法到达。<br>为了使游戏尽可能公平，现在他们想让 A 和 B 的战略能力之和的差值的绝对值最小。</p><p>输入格式<br>第一行输入T代表数据组数。<br>接下来T组，对于每一组：<br>第一行输入n，接下来n−1行，每行输入两个数字u,v代表u和v之间的岛屿有一座桥梁，最后一行输入n个数，第i个数代表第i个岛屿的战略值wi。<br>(1≤T≤10,1≤n≤100000,1≤wi≤1e9,1≤u,v≤n)</p><p>输出格式<br>输出T组，对于每组输入，输出最小的差值的绝对值。</p><p>样例<br>input<br>2<br>4<br>1 2<br>2 3<br>2 4<br>2 5 7 3<br>2<br>1 2<br>1 2<br>output<br>3<br>1</p><p>Problem solving:<br>这道题我一开始以为要用类似于背包的处理方式，但是发现不可以。因为你不知道你分开的两堆能不能正好是割一下就能分开的。<br>还是安生的看学长的图论的方法做吧。<br>大致的意思就是一次dfs处理出来每个点往下的点的个数。根节点这个可以自己随便选，不影响结果的。假如我们以dis[i]代表i节点下面的所有节点的权值的总和，一次dfs处理完之后。在遍历每个节点，求出从这个点将原图分隔成两部分之后的权值的差值，每次取一次min，最后输出即可。<br>假设根节点我们找的是1，遍历的每个点用i表示<br>那么1下面的所有的节点的权值的和就是<code>dis[1]</code>，i下面的就是<code>dis[i]</code>，分开之后的差值就是<code>dis[1]-dis[i]-dis[i]</code>，但是有可能是负的，所以我们还要取一次绝对值</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5+10;typedef long long ll;ll dis[maxn],w[maxn];vector&lt;int&gt; ma[maxn];void dfs(int u,int par){    dis[u]=w[u];    for(int v=0;v&lt;ma[u].size();v++)    {//        cout&lt;&lt;ma[u][v]&lt;&lt;endl;        if(ma[u][v]==par)    continue;        dfs(ma[u][v],u);        dis[u]+=dis[ma[u][v]];    }}int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        memset(dis,0,sizeof(dis));        int n;        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++)    ma[i].clear();        int u,v;        for(int i=1;i&lt;=n-1;i++)        {            cin&gt;&gt;u&gt;&gt;v;            ma[u].push_back(v);            ma[v].push_back(u);        }        for(int i=1;i&lt;=n;i++)    cin&gt;&gt;w[i];        dfs(1,0);        long long ans=0x3f3f3f3f3f3f3f3f;        for(int i=2;i&lt;=n;i++)        {            ans=min(ans,abs(dis[1]-2*dis[i]));        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 200001;long long siz[N],w[N];vector&lt;int&gt; G[N];void dfs(int u,int par){    siz[u]=w[u];    for(int v:G[u]){        cout&lt;&lt;v&lt;&lt;endl;        if(v==par) continue;        dfs(v,u);        siz[u]+=siz[v];    }}int main(){    int T;cin&gt;&gt;T;    while(T--){        memset(siz,0,sizeof(siz));        int n;cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++) G[i].clear();        int u,v;        for(int i=1;i&lt;=n-1;i++){            cin&gt;&gt;u&gt;&gt;v;            G[u].push_back(v);            G[v].push_back(u);        }        for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i];        dfs(1,0);        long long ans=999999999999999999;        for(int i=2;i&lt;=n;i++){            ans=min(ans,abs(siz[1]-2*siz[i]));        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h2 id="Number-throry"><a href="#Number-throry" class="headerlink" title="Number throry"></a>Number throry</h2><p>Description:<br>steve 学完了快速幂，现在会他快速的计算：(i^j)%d , Alex 作为一个数学大师，给了 steve 一个问题：已知<br>i∈[1,n],j∈[1,m] ，计算满足 (i^j)%d=0 的 (i,j) 的对数。</p><p>输入格式<br>T组输入，对于每一组输入三个数n,m,d。<br>(1≤T≤1000,1≤n,m,d≤1e9)。</p><p>输出格式<br>对于每组输入，输出答案，每个答案占一行。</p><p>样例<br>input<br>4<br>3 10 7<br>3 5 3<br>10 30 6<br>100 100 8<br>output<br>0<br>5<br>30<br>4937</p><p>Problem solving:<br>这道题很有意思，用到了质因子分解。就是首先我们要知道2的30次方已经是大于1e9得了。<br>我们对d进行质因子分解。就像这样<br><code>d=p1^x1*p2^x2*...*pn^xn</code><br>我们要找的i是要满足<code>(i^j)%d</code>等于0的，所以假如说<br><code>g=p1^(x1/j)*p2^(x2/j)*...*pn^(xn/j)</code>为i的因子的话，那么i的j次方一定是可以整除d的。<br>所以这种情况下的满足条件的i跟j的对数就是n/g.<br>这里还有一个需要我们注意的地方就是指数的地方是需要向上取整的，这是为什么呢？我们举个例子就可以看出来了。</p><pre><code class="lang-txt">假如现在d=p1^5*p2^5j=2如果我们直接除，不向上取整的话g=p1^2*p2^2此时g的j次方就是=p1^4*p2^4他并不一定%d之后为0但是我们向上取整的话如果多了是没有影响的，因为在计算多余部分之前已经为0了，你再怎么乘也一直都是0</code></pre><p>我们已经说过，但是我们已经说过2的30次方已经是大于1e9得了。所以你可以知道，在m&gt;=30之后的情况每个j算出来的g都是一样的，所以这一部分我们只计算一次就够了，再乘以这个区间的大小<code>m-29</code>就是剩余这一部分所有的满足条件的对数。</p><p>因为计算的过程中我们是要计算除法的，所以要求一次逆元。</p><p>可以看一下代码注释理解理解</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll p[50];ll poww(ll x,ll y){    ll ans=1;    while(y)    {        if(y&amp;1)    ans*=x;        x*=x;        y/=2;    }    return ans;}   //快速幂，为了求逆元int main(){    ll t;ll n,m,d;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        map&lt;ll,ll&gt; ma;        scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;m,&amp;d);        ll pos=1;        for(ll i=2;i*i&lt;=d;i++)        {            if(d%i==0)    ma[i]=0,p[pos++]=i;            while(d%i==0)            {                ma[i]++;                d/=i;            }        }        ll ans=0;        if(d&gt;1)    p[pos++]=d,ma[d]=1;   //质因子分解，并且记录一下每个质因子的幂，这里我是用map存的，当然你也可以用别的//        for(map&lt;ll,ll&gt;::iterator it=ma.begin();it!=ma.end();it++)//            cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;        for(ll i=1;i&lt;=min(m,(ll)30);i++)//这个i代表的其实就是刚才解题思路里面的j，这个min处理的这一下很巧妙。        {            ll g=1;            for(ll j=1;j&lt;pos;j++)            {                g*=poww(p[j],ceil(ma[p[j]]*1.0/i));            }            if(i==30)    ans+=(m-29)*(n/g);            else    ans+=n/g;//分两种情况        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll qpow(ll a,ll b){    ll ans=1;    while(b){        if(b&amp;1) ans=(ans*a);        a=(a*a);        b&gt;&gt;=1;    }    return ans;}int main(){    int T;scanf(&quot;%d&quot;,&amp;T);    while(T--){        ll n,m,d;        scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;m,&amp;d);        vector&lt;pair&lt;ll,ll&gt; &gt; prs;        for(ll i=2;i*i&lt;=d;i++){            if(d%i==0){                long long cnt=0;                while(d%i==0){                    d/=i;cnt++;                }                prs.push_back({i,cnt});            }        }        ll res=0;        if(d!=1) prs.push_back({d,1});        for(auto v:prs)            cout&lt;&lt;v.first&lt;&lt;&quot; &quot;&lt;&lt;v.second&lt;&lt;endl;        for(ll j=1;j&lt;=min(m,1LL*30);j++){            ll g=1;            for(auto v:prs){                g*=qpow(v.first,(v.second+j-1)/j);            }            if(j==30) res+=(m-29)*(n/g);            else res+=n/g;        }        printf(&quot;%lld\n&quot;,res);    }    return 0;}</code></pre><h2 id="Steve的难题"><a href="#Steve的难题" class="headerlink" title="Steve的难题"></a>Steve的难题</h2><p>Description:<br>Steve参加了2019年的暑期集训，在集训最后一场积分赛时，Steve英勇AC，提交了几十发全A了。Steve顿时惊叹，这不都是水题吗，于是接下来碰到的问题却难倒了他。求1/(n!)模p意义下的值。</p><p>输入格式<br>多组输入，处理到文件结束。<br>每行输入两个数n,p,(1≤n≤1e5,n&lt;p≤1e9).<br>数据保证 p 是个质数。</p><p>输出格式<br>如题</p><p>样例<br>input<br>3 5<br>3 7<br>3 11<br>output<br>1<br>6<br>2</p><p>Problem solving:<br>这道题就直接暴力的写，求出n的阶乘中的每一个数的逆元乘起来即可。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+10;vector&lt;int&gt; vec[maxn];int step[maxn];bool vis[maxn];int n,m;void bfs(int x){    queue&lt;int&gt; que;    que.push(x);    vis[x]=1;step[x]=0;    while(!que.empty())    {        x=que.front();        que.pop();        for(int i=0;i&lt;vec[x].size();i++)        {            int y=vec[x][i];            for(int j=0;j&lt;vec[y].size();j++)            {                int z=vec[y][j];                if(vis[z])    continue;                vis[z]=1;                step[z]=step[x]+1;                que.push(z);                if(z==n)    return ;            }         }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    int u,v;    for(int i=0;i&lt;m;i++)    {        cin&gt;&gt;u&gt;&gt;v;        vec[u].push_back(v);        vec[v].push_back(u);    }    bfs(1);    if(step[n]==0)    puts(&quot;-1&quot;);    else    cout&lt;&lt;step[n]&lt;&lt;endl;    return 0;}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;const int maxn=1000000+10;const int INF=0x3f3f3f3f;ll niyuan(ll a,ll b,ll p){    ll res=1;    if(b&lt;=0) return res;    while(b){        if(b&amp;1) res=res*a%p;        a=a*a%p;        b&gt;&gt;=1;    }    return res;}void solve(){    ll n,p;    while(~scanf(&quot;%lld %lld&quot;,&amp;n,&amp;p)){        ll res=1;        for(ll i=1;i&lt;=n;i++){            res=res*niyuan(i,p-2,p)%p;        }        printf(&quot;%lld\n&quot;,res);    }}int main(){    solve();    return 0;}</code></pre><h2 id="Steve-39-s-Shortest-Path"><a href="#Steve-39-s-Shortest-Path" class="headerlink" title="Steve&#39;s Shortest Path"></a>Steve&#39;s Shortest Path</h2><p>Description:<br>Alex 和 Steve 来到了一个神奇的国度，这个国家有 n 个城市和 m 条道路。这 m 条道路都是双向的，而且这个国家的客车有个特点，每辆客车除出发城市和到达城市外有且仅可经过一个城市。</p><p>假设u城市到v有一条道路并且 v 到 p 有一条道路,那么客车从 u 出发不能到达 v 但是能到达 p，Steve 和 Alex 在编号为 1 的城市,他们想知道能不能到达编号为 n 的城市，如果能，最少需要坐几次客车？</p><p>输入格式<br>单组输入。<br>第一行输入 n 和 m 代表城市的个数和路径的条数。<br>接下来 m 行每行输入两个数 u 和 v 代表 u 到 v 之间有条路。(2≤n,m≤1e6,1≤u,v≤n)。</p><p>输出格式<br>如果 Steve 和 Alex 能够到达终点，输出最少需要坐几次车才能到达，否则输出−1。</p><p>样例<br>input<br>2 1<br>1 2<br>output<br>-1<br>input<br>3 2<br>1 2<br>2 3<br>output<br>1</p><p>Problem solving:<br>这道题比赛的时候没看懂，现在发现还是很简单的。<br>题意就是给你一个图，有一个起点，每次只能走两步，问你能否到达终点。！！语文老师的锅！！<br>直接bfs就行了，每次走两步并且累计上步数，如果最后终点的步数还是你初始化的值，说明无法到达，输出<code>-1</code>即可。繁殖直接输出到达终点的步数。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+10;vector&lt;int&gt; vec[maxn];int step[maxn];bool vis[maxn];int n,m;void bfs(int x){    queue&lt;int&gt; que;    que.push(x);    vis[x]=1;step[x]=0;    while(!que.empty())    {        x=que.front();        que.pop();        for(int i=0;i&lt;vec[x].size();i++)        {            int y=vec[x][i];            for(int j=0;j&lt;vec[y].size();j++)            {                int z=vec[y][j];                if(vis[z])    continue;                vis[z]=1;                step[z]=step[x]+1;                que.push(z);                if(z==n)    return ;            }         }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    int u,v;    for(int i=0;i&lt;m;i++)    {        cin&gt;&gt;u&gt;&gt;v;        vec[u].push_back(v);        vec[v].push_back(u);    }    bfs(1);    if(step[n]==0)    puts(&quot;-1&quot;);    else    cout&lt;&lt;step[n]&lt;&lt;endl;    return 0;}</code></pre><p>标程</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000+10;vector&lt;int&gt;vec[maxn];int step[maxn];bool vis[maxn];int n,m;void bfs(int x){    queue&lt;int&gt;que;    que.push(x);    vis[x]=1;    step[x]=0;    while(!que.empty()){        x=que.front();        que.pop();        for(int i=0;i&lt;vec[x].size();i++){            int y=vec[x][i];            for(int j=0;j&lt;vec[y].size();j++){                int z=vec[y][j];                if(vis[z]) continue;                vis[z]=1;                step[z]=step[x]+1;                que.push(z);                if(z==n) return ;            }        }    }}int main(){    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    int u,v;    for(int i=0;i&lt;m;i++){        scanf(&quot;%d %d&quot;,&amp;u,&amp;v);        vec[u].push_back(v);        vec[v].push_back(u);    }    bfs(1);    if(step[n]==0) printf(&quot;-1\n&quot;);    else printf(&quot;%d\n&quot;,step[n]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
            <tag> 快速幂 </tag>
            
            <tag> 逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 32（河南理工大学暑期第三十二天）</title>
      <link href="/2019/08/16/32/"/>
      <url>/2019/08/16/32/</url>
      
        <content type="html"><![CDATA[<p>把今天的这两个板子贴一下，完事了。</p><p>kmp</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;string s,t;int n,m;vector&lt;int&gt; cal_nxt(string s){    int n=(int)s.length();    vector&lt;int&gt; nxt(n);    for(int i=1;i&lt;n;i++){        int j=nxt[i-1];        while(s[i]!=s[j]&amp;&amp;j&gt;0) j=nxt[j-1];        if(s[i]==s[j]) j++;        nxt[i]=j;    }    return nxt;}int main(){    cin&gt;&gt;s&gt;&gt;t;    m=t.length();    n=s.length();    string T=t+&#39;#&#39;+s;    vector&lt;int&gt; nxt=cal_nxt(T);    for(int i=m+1;i&lt;(int)T.length();i++){        if(nxt[i]==m){            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;return 0;        }    }    cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    return 0;}</code></pre><p>hash</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace  std;typedef unsigned long long ull;const ull base = 2333;const ull mod = 1e9+9;const int N = 1e6+100;ull hashes[N],p[N];ull gethashes(int l,int r){    return (hashes[r]%mod-(hashes[l-1]%mod*p[r-l+1]%mod)%mod+mod)%mod;}char s[N],t[N];int main(){    int T;    scanf(&quot;%d&quot;,&amp;T);    while(T--){        scanf(&quot;%s %s&quot;,t+1,s+1);        int n=strlen(s+1);        int m=strlen(t+1);        p[0]=1;        for(int i=1;i&lt;=n;i++){            hashes[i]=(hashes[i-1]*base%mod+s[i]%mod)%mod;            p[i]=(p[i-1]%mod*base%mod)%mod;        }        ull ans=0;        for(int i=1;i&lt;=m;i++) ans=(ans*base%mod+t[i]%mod)%mod;        int res=0;        for(int i=m;i&lt;=n;i++){            if(gethashes(i-m+1,i)==ans){                res++;            }        }        printf(&quot;%d\n&quot;,res);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> kmp </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 31（河南理工大学暑期第三十一天)</title>
      <link href="/2019/08/15/31/"/>
      <url>/2019/08/15/31/</url>
      
        <content type="html"><![CDATA[<h2 id="Ekka-Dokka"><a href="#Ekka-Dokka" class="headerlink" title="Ekka Dokka"></a>Ekka Dokka</h2><p>Description:Ekka Dokka<br>Ekka and his friend Dokka decided to buy a cake. They both love cakes and that&#39;s why they want to share the cake after buying it. As the name suggested that Ekka is very fond of odd numbers and Dokka is very fond of even numbers, they want to divide the cake such that Ekka gets a share of N square centimeters and Dokka gets a share of M square centimeters where N is odd and M is even. Both N and M are positive integers.</p><p>They want to divide the cake such that N * M = W, where W is the dashing factor set by them. Now you know their dashing factor, you have to find whether they can buy the desired cake or not.</p><p>Input<br>Input starts with an integer T (≤ 10000), denoting the number of test cases.</p><p>Each case contains an integer W (2 ≤ W &lt; 2^63). And W will not be a power of 2.</p><p>Output<br>For each case, print the case number first. After that print &quot;Impossible&quot; if they can&#39;t buy their desired cake. If they can buy such a cake, you have to print N and M. If there are multiple solutions, then print the result where M is as small as possible.</p><p>Sample Input<br>3<br>10<br>5<br>12</p><p>Sample Output<br>Case 1: 5 2<br>Case 2: Impossible<br>Case 3: 3 4</p><p>Problem solving:<br>这道题跟前几天讲质因数分解的时候的一道题一模一样，就不说了。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    int n;    ll a;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a;        ll ans=1;        if(a%2==1)        {            printf(&quot;Case %d: Impossible\n&quot;, i);            continue;        }        while(a%2==0)        {            a/=2;            ans*=2;        }        printf(&quot;Case %d: %lld %lld\n&quot;,i,a,ans);    }}</code></pre><h2 id="How-many-integers-can-you-find"><a href="#How-many-integers-can-you-find" class="headerlink" title="How many integers can you find"></a>How many integers can you find</h2><p>Description:<br> Now you get a number N, and a M-integers set, you should find out how many integers which are small than N, that they can divided exactly by any integers in the set. For example, N=12, and M-integer set is {2,3}, so there is another set {2,3,4,6,8,9,10}, all the integers of the set can be divided exactly by 2 or 3. As a result, you just output the number 7.<br>Input<br>  There are a lot of cases. For each case, the first line contains two integers N and M. The follow line contains the M integers, and all of them are different from each other. 0&lt;N&lt;2^31,0&lt;M&lt;=10, and the M integer are non-negative and won’t exceed 20.<br>Output<br>  For each case, output the number.<br>Sample Input<br>12 2<br>2 3<br>Sample Output<br>7<br>Problem solving:<br>这道题的意思是先输入两个数，一个是代表需要查询的范围。一个是某数组的大小（数的个数）。问你在查询的范围内，有多少数是可以只被给的数组中的数整除。</p><p>这道题用到了二进制枚举和容斥定理。</p><p>用二进制枚举得出每一个状态，然后用到容斥定理的<code>奇加偶减</code>，有一个需要注意的地方就是容斥定理算的时候，总范围除以的是两个数的lcm而不是直接相除。这个应该还挺好理解的，因为两个数相乘不一定是两个数的lcm。<br>lcm = 最小公倍数</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,m,a[21];ll lcm(ll x,ll y){    return x*y/__gcd(x,y);}int main(){    while(cin&gt;&gt;n&gt;&gt;m)    {        int pos=0;        for(int i=0;i&lt;m;i++)        {            cin&gt;&gt;a[pos];            if(a[pos])  pos++;        }        ll sum=0;        for(int i=1;i&lt;(1&lt;&lt;pos);i++)        {            ll res=1,tot=0;            for(int j=0;j&lt;pos;j++)            {                if(i&amp;(1&lt;&lt;j))                {                    res=lcm(res,a[j]);                    tot++;                }            }            if(tot&amp;1)   sum+=(n-1)/res;            else    sum-=(n-1)/res;        }        cout&lt;&lt;sum&lt;&lt;endl;    }}</code></pre><h2 id="Co-prime"><a href="#Co-prime" class="headerlink" title="Co-prime"></a>Co-prime</h2><p>Description:<br>Given a number N, you are asked to count the number of integers between A and B inclusive which are relatively prime to N.<br>Two integers are said to be co-prime or relatively prime if they have no common positive divisors other than 1 or, equivalently, if their greatest common divisor is 1. The number 1 is relatively prime to every integer.<br>Input<br>The first line on input contains T (0 &lt; T &lt;= 100) the number of test cases, each of the next T lines contains three integers A, B, N where (1 &lt;= A &lt;= B &lt;= 1e15) and (1 &lt;=N &lt;= 1e9).<br>Output<br>For each test case, print the number of integers between A and B inclusive which are relatively prime to N. Follow the output format below.<br>Sample Input<br>2<br>1 10 2<br>3 15 5<br>Sample Output<br>Case #1: 5<br>Case #2: 10</p><p>Hint<br>In the first test case, the five integers in range [1,10] which are relatively prime to 2 are {1,3,5,7,9}.<br>Problem solving:<br>这道题的意思就是给了你一个区间，让你求区间内与另一个数互质的数有多少。</p><p>用到的有容斥定理，质因子分解和二进制枚举。</p><p>假设让我们找的是与n互质的数，那我们找到与n互质的然后用总个数减去这个数就是互质的数了。怎么求互质的数呢，我们可以先求出n的每个质因子。然后用容斥定理求出互质的数的总个数。容斥定理：奇加偶减。</p><p>还有一点就是这个题他不是从一开始的区间，他是从a到b，计算的时候同时计算a-1区间内的和b区间内的，最后相减即可。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n,t,a,b;    ll p[105];    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a&gt;&gt;b&gt;&gt;t;        memset(p,0,sizeof(p));        ll pos=0;        for(int i=2;i*i&lt;=t;i++)        {            if(t%i==0)  pos++,p[pos]=i;            while(t%i==0)   t/=i;        }        if(t!=1) pos++,p[pos]=t;        ll ans=0;        for(int i=1;i&lt;(1&lt;&lt;pos);i++)        {            ll mid=0,miid=1;            for(int j=0;j&lt;pos;j++)            {                if(1&amp;(i&gt;&gt;j))                {                    mid++;                    miid*=p[j+1];                }            }            if(mid%2==1)            {                ans+=b/miid;                ans-=(a-1)/miid;//这里就是因为我们计算的是a到b的，所以得减去a-1之内的            }            else            {                ans-=b/miid;                ans+=(a-1)/miid;//与上面同理            }        }        printf(&quot;Case #%d: %lld\n&quot;,i,b-a+1-ans);    }}</code></pre><h2 id="Find-a-multiple"><a href="#Find-a-multiple" class="headerlink" title="Find a multiple"></a>Find a multiple</h2><p>Description:<br>The input contains N natural (i.e. positive integer) numbers ( N &lt;= 10000 ). Each of that numbers is not greater than 15000. This numbers are not necessarily different (so it may happen that two or more of them will be equal). Your task is to choose a few of given numbers ( 1 &lt;= few &lt;= N ) so that the sum of chosen numbers is multiple for N (i.e. N * k = (sum of chosen numbers) for some natural number k).<br>Input<br>The first line of the input contains the single number N. Each of next N lines contains one number from the given set.<br>Output<br>In case your program decides that the target set of numbers can not be found it should print to the output the single number 0. Otherwise it should print the number of the chosen numbers in the first line followed by the chosen numbers themselves (on a separate line each) in arbitrary order.</p><p>If there are more than one set of numbers with required properties you should print to the output only one (preferably your favorite) of them.<br>Sample Input<br>5<br>1<br>2<br>3<br>4<br>1<br>Sample Output<br>2<br>2<br>3</p><p>Problem solving:<br>这道题用到的是鸽巢原理。</p><p>还是去看学长的题解吧：<a href="https://blog.csdn.net/qq_42757965/article/details/99060042" target="_blank" rel="noopener">https://blog.csdn.net/qq_42757965/article/details/99060042</a></p><p>Code:</p><pre><code class="lang-c++">#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 21314;int a[maxn],sum[maxn];int main(){    int n;    map&lt;int,int&gt; ma;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i];        sum[i]=(sum[i-1]+a[i])%n;    }    for(int i=1;i&lt;=n;i++)    {        if(sum[i]==0)        {            cout&lt;&lt;i&lt;&lt;endl;            for(int j=1;j&lt;=i;j++)                cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;;            break;        }        if(!ma[sum[i]]) ma[sum[i]]=1;        else if(ma[sum[i]])        {            cout&lt;&lt;i-ma[sum[i]]&lt;&lt;endl;            for(int j=1+ma[sum[i]];j&lt;=i;j++)                cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;;            break;        }    }    cout&lt;&lt;endl;}</code></pre><h2 id="吃糖果"><a href="#吃糖果" class="headerlink" title="吃糖果"></a>吃糖果</h2><p>Description:<br>HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。<br>Input<br>第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;=1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;=1000000)。<br>Output<br>对于每组数据，输出一行，包含一个&quot;Yes&quot;或者&quot;No&quot;。<br>Sample Input<br>2<br>3<br>4 1 1<br>5<br>5 4 3 2 1<br>Sample Output<br>No<br>Yes</p><p>Problem solving:<br>这道题的意思就是说有一个小孩子喜欢吃糖但是他不喜欢一直吃一种每次都吃一样的，给你每种糖果的个数问你可不可以满足他每次吃一种的习惯。<br>这道题用到的也是鸽巢原理。我们考虑这种情况，有一堆糖果是最多的，多到什么地步呢，就是多到每一次吃了一个糖换口味的时候选的都是它。所以如果这个数小于等于总糖数的一半，显然你是可以满足他的习惯，反之既不可以。这样就可以了。</p><p>证明的话我也证明不来哈。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll a,n,sum,maxn,c;    cin&gt;&gt;n;    for(ll i=0;i&lt;n;i++)    {        maxn=0,sum=0;        cin&gt;&gt;a;        for(ll i=0;i&lt;a;i++)        {            cin&gt;&gt;c;            maxn=max(c,maxn);            sum+=c;        }        if((sum-maxn)&gt;=(maxn-1))   puts(&quot;Yes&quot;);        else    puts(&quot;No&quot;);    }}</code></pre><h2 id="Teacher-Bo"><a href="#Teacher-Bo" class="headerlink" title="Teacher Bo"></a>Teacher Bo</h2><p>Description:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/J5F9SVD8%5B4%7D9%606C%7B2_P0LPO.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/J5F9SVD8%5B4%7D9%606C%7B2_P0LPO.webp" class="img-shadow img-margin"></center></a><br>Problem solving:<br>这道题就是给了你n个点问你存不存在每两个点之间的曼哈顿距离是相等的情况。</p><p>直接暴力就能过。<br>好像可以用鸽巢定理来个小优化，是暴力就能过就不优化了吧。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5+10;struct node{    int x,y;}p[maxn];bool flag[maxn];int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        memset(flag,0,sizeof(flag));        int n,m;        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        }        int f=0;        for(int i=0;i&lt;n;i++)        {            for(int j=i+1;j&lt;n;j++)            {                int mid=(abs(p[i].x-p[j].x)+abs(p[i].y-p[j].y));                if(flag[mid])                {                    puts(&quot;YES&quot;);                    f=1;                }                flag[mid]=1;                if(f)   break;            }            if(f)   break;        }        if(!f)  puts(&quot;NO&quot;);    }}</code></pre><h2 id="跳蚤"><a href="#跳蚤" class="headerlink" title="跳蚤"></a>跳蚤</h2><p>Description:<br>Z城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。<br>比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。<br>当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。<br>Input<br>两个整数N和M(N &lt;= 15 , M &lt;= 100000000)。<br>Output<br>可以完成任务的卡片数。<br>Sample Input<br>2 4<br>Sample Output<br>12<br>Hint<br>这12张卡片分别是：<br>(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4),<br>(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4)<br>Problem solving:<br>这道题确实是一道好题，虽然我也没做出来。</p><p>这道题的意思是给你一个数代表跳蚤跳的最远距离，然后给你一个数n代表跳蚤可以走的不同步数的个数。问你有几种选择的方案可以让跳蚤走到左边距离为1的地方</p><p>这道题用到的有</p><ol><li>快速幂</li><li>扩展gcd</li><li>容斥定理</li><li>二进制枚举</li></ol><p>我们可以通过题意得知每种步数以及这个步数的个数的乘积之和为1，所以就可以用扩展gcd推出来每一项的系数的gcd为1的时候才会存在。但是找gcd为1的情况并不好找，所以我们找不为一得，总数减去为1的，就是答案。</p><p>因为总共有n个位置，我们找出来那个最大值的质因子，然后用容斥定理求出gcd不为1的总个数。这个还是看代码吧，我也说不清。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[50];ll poww(ll x,ll y){    ll ans=1;    while(y)    {        if(y&amp;1)    ans*=x;        x*=x;        y/=2;    }    return ans;}int main(){    ll n,m,pos=0,mm;    cin&gt;&gt;n&gt;&gt;m;    mm=m;    for(int i=2;i&lt;=m/i;i++)//质因子分解    {        if(m%i==0)        {            a[pos++]=i;            while(m%i==0)    m/=i;        }    }    if(m&gt;1)    a[pos++]=m;    ll ans=0;    for(int i=1;i&lt;(1&lt;&lt;pos);i++)//二进制枚举查找gcd不为1的情况的总个数。    {        ll mid=1,miid=0;        for(int j=0;j&lt;pos;j++)        {            if(i&amp;(1&lt;&lt;j))            {                miid++;                mid*=a[j];            }        }        if(miid&amp;1)    ans+=poww(mm/mid,n);//n个位置        else    ans-=poww(mm/mid,n);    }    cout&lt;&lt;poww(mm,n)-ans&lt;&lt;endl;}</code></pre><p>好吧，我这波强行解释不太清楚。<br>可以参考一下这篇博客：<br><a href="https://blog.csdn.net/gyhguoge01234/article/details/77434631" target="_blank" rel="noopener">https://blog.csdn.net/gyhguoge01234/article/details/77434631</a></p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 容斥定理 </tag>
            
            <tag> 鸽巢原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 30（河南理工大学暑期第三十天）</title>
      <link href="/2019/08/14/30/"/>
      <url>/2019/08/14/30/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h2><p>Description:<br>度熊手上有一本字典存储了大量的单词，有一次，他把所有单词组成了一个很长很长的字符串。现在麻烦来了，他忘记了原来的字符串都是什么，神奇的是他竟然记得原来那些字符串的哈希值。一个字符串的哈希值，由以下公式计算得到：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/5Q~83I4%60%5D%7B6C6%5B~AN1X%282VK.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/5Q~83I4%60%5D%7B6C6%5B~AN1X%282VK.webp" class="img-shadow img-margin"></center></a><br>请帮助度熊计算大字符串中任意一段的哈希值是多少。</p><p>Input<br>多组测试数据，每组测试数据第一行是一个正整数N，代表询问的次数，第二行一个字符串，代表题目中的大字符串，接下来N行，每行包含两个正整数a和b，代表询问的起始位置以及终止位置。</p><p>1≤N≤1,000</p><p>1≤len(string)≤100,000</p><p>1≤a,b≤len(string)<br>Output<br>对于每一个询问，输出一个整数值，代表大字符串从 a 位到 b 位的子串的哈希值。<br>Sample Input<br>2<br>ACMlove2015<br>1 11<br>8 10<br>1<br>testMessage<br>1 1<br>Sample Output<br>6891<br>9240<br>88</p><p>Problem solving:<br>这道题的意思就是每个字符串都有一个对应的哈希值并且告诉了你求哈希值的公式，每次查询给你两个数a，b问你a到b的子串对应的哈希值。</p><p>这个不能直接暴力的，1e3*1e5的复杂度会超时。所以你需要每次存进去一个字符串就处理出每一个位置对应的子串的哈希值，有点类似于前缀和的思想。<br>我们定义s[i]就是你处理的从第0位到第i位的哈希值。<br>如果查找从a到b的子串的哈希值，直接s[b]/s[a-1]即可。<br>这也是用到了逆元的地方，这里是对9973取模，9973是质数，所以可以直接用快速幂求逆元，然后就很简单了。<br>这道题注意那个符号是连乘。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 1e5+10;ll xiaozhu[maxn];const ll mod=9973;ll poww(ll x,ll y){    ll ans=1;    while(y)    {        if(y&amp;1) ans=(ans*x)%mod;        x=(x*x)%mod;        y/=2;    }    return ans;}int main(){    ll n,a,b;    string s;    while(cin&gt;&gt;n&gt;&gt;s)    {        ll x,y;        xiaozhu[0]=1;        for(ll i=0;i&lt;s.size();i++)            xiaozhu[i+1]=((s[i]-28)*xiaozhu[i])%9973;        // for(lli=0;i&lt;=s.size();i++)        //     cout&lt;&lt;xiaozhu[i]&lt;&lt;&quot;?\n&quot;;        while(n--)        {            cin&gt;&gt;a&gt;&gt;b;            cout&lt;&lt;(xiaozhu[b]%mod)*(poww(xiaozhu[a-1],mod-2))%mod&lt;&lt;endl;;        }    }}</code></pre><h2 id="A-B"><a href="#A-B" class="headerlink" title="A/B"></a>A/B</h2><p>Description:<br>要求(A/B)%9973，但由于A很大，我们只给出n(n=A%9973)(我们给定的A必能被B整除，且gcd(B,9973) = 1)。<br>Input<br>数据的第一行是一个T，表示有T组数据。<br>每组数据有两个数n(0 &lt;= n &lt; 9973)和B(1 &lt;= B &lt;= 10^9)。<br>Output<br>对应每组数据输出(A/B)%9973。<br>Sample Input<br>2<br>1000 53<br>87 123456789<br>Sample Output<br>7922<br>6060</p><p>Problem solving:<br>这道题给出了你n和b，让你求(n/b)对9973取模的值<br>这道题就是一个板子题。<br>可以用扩展gcd写，也可以用快速幂写。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int exgcd(int a,int b,int &amp;x,int &amp;y){    if(b==0)    {        x=1,y=0;        return a;    }    int r=exgcd(b,a%b,x,y);    int t=y;    y=x-(a/b)*y;    x=t;    return r;}int main(){    int n,a,b,x,y;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;a&gt;&gt;b;        exgcd(b,9973,x,y);        cout&lt;&lt;((x*a)%9973+9973)%9973&lt;&lt;endl;    }}</code></pre><h2 id="Fansblog"><a href="#Fansblog" class="headerlink" title="Fansblog"></a>Fansblog</h2><p>Description:<br>Farmer John keeps a website called ‘FansBlog’ .Everyday , there are many people visited this blog.One day, he find the visits has reached P , which is a prime number.He thinks it is a interesting fact.And he remembers that the visits had reached another prime number.He try to find out the largest prime number Q ( Q &lt; P ) ,and get the answer of Q! Module P.But he is too busy to find out the answer. So he ask you for help. ( Q! is the product of all positive integers less than or equal to n: n! = n * (n-1) * (n-2) * (n-3) *… * 3 * 2 * 1 . For example, 4! = 4 * 3 * 2 * 1 = 24 )<br>Input<br>First line contains an number T(1&lt;=T&lt;=10) indicating the number of testcases.<br>Then T line follows, each contains a positive prime number P (1e9≤p≤1e14)<br>Output<br>For each testcase, output an integer representing the factorial of Q modulo P.<br>Sample Input<br>1<br>1000000007<br>Sample Output<br>328400734</p><p>Problem solving:<br>这道题的意思就是给了你一个素数，素数的范围是1e9到1e14。问你小于所给的素数的最大的素数的阶乘对所给的素数取模的结果。</p><p>我在分析之前先贴出来一篇巨佬的博客<br>川巨带你拿金牌：<a href="https://blog.csdn.net/cloudy_happy/article/details/99571628" target="_blank" rel="noopener">https://blog.csdn.net/cloudy_happy/article/details/99571628</a></p><p>这道题用到的知识有</p><ol><li>逆元</li><li>素数判断(更快地素数判断(可选))</li><li>快速乘</li><li>快速幂</li><li>威尔逊定理</li><li>快速幂</li></ol><p>首先由威尔逊定理我们可以知道如果p是素数，那么<code>(p-1)!%p=p-1</code>，即p-1的阶乘对p取模的结果是p-1.<br>若输入中给的素数是p，我们找到了小于p的最大素数是q，那么我们就可以结合威尔逊定理得出<br><code>q!\*(q+1)\*(q+2)\*.......\*(p-1)  %  p = p-1</code><br>并且两个相邻素数相差一般不会太大，所以说我们只需要用<code>p-1</code>除以从p到q的每一个数就是q的阶乘。这是用到了逆元的地方。因为是素数，所以可以直接快速幂求逆元。<br>为什么还会用到快速乘呢？<br>因为p最大是1e14，即使你再乘之前就取模，在你相乘之后也会爆long long，所以就需要用到快速乘来处理。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool check(ll x){    for(ll i=2;i&lt;=sqrt(x);i++)        if(x%i==0)    return 0;    return 1;}ll ksc(ll a,ll b,ll p){    return (a*b-(ll)((long double)a/p*b)*p+p)%p;}ll poww(ll a,ll b,ll p){    ll ans=1;    while(b)    {        if(b&amp;1)    ans=ksc(ans,a,p);        b/=2;        a=ksc(a,a,p);    }    return ans;}ll inv(ll x,ll p){    return poww(x,p-2,p);}int main(){    ios::sync_with_stdio(0);    int n;    cin&gt;&gt;n;    ll p;    while(n--)    {        cin&gt;&gt;p;        ll ans=p-1;        for(ll i=p-2;;i-=2)        {            if(check(i))            {                for(ll j=i+1;j&lt;p;j++)                {                    ans=ksc(ans,inv(j,p),p);                }                cout&lt;&lt;ans%p&lt;&lt;endl;                break;            }        }    }}</code></pre><p>这里数据范围很小，但是如果n增大范围，该怎么提速呢？<br>我们可以优化一下素数的判断，这里有个贼快的素数判断的板子，当然也是来自我们能带你拿金牌的川巨啦</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll ksc(ll a,ll b,ll p){    return (a*b-(ll)((long double)a/p*b)*p+p)%p;}ll prime[5] = {2, 5, 3, 233, 331};ll qpow(ll a,ll b,ll p){    ll ans = 1;    while (b)    {        if (b &amp; 1) ans = ksc(ans,a,p);        b &gt;&gt;= 1;        a = ksc(a,a,p);    }    return ans;}bool Miller_Rabin(ll p){    if(p &lt; 2) return 0;    if(p != 2 &amp;&amp; p % 2 == 0) return 0;    ll s = p - 1;    while(! (s &amp; 1)) s &gt;&gt;= 1;    for(int i = 0; i &lt; 3; ++i)    {        if(p == prime[i]) return 1;        ll t = s, m = qpow(prime[i], s, p);        while(t != p - 1 &amp;&amp; m != 1 &amp;&amp; m != p - 1)        {            m = ksc(m, m, p);            t &lt;&lt;= 1;        }        if(m != p - 1 &amp;&amp; !(t &amp; 1)) return 0;    }    return 1;}ll inv(ll x,ll p){    return qpow(x,p-2,p);}int main(){    ios::sync_with_stdio(false);    int t;    cout&lt;&lt;(12 %(-7))&lt;&lt;endl;    cin&gt;&gt;t;    while (t --)    {        ll p;        cin&gt;&gt;p;        ll ans = p-1;        for (ll x = p - 2;;x -= 2)        {            if (Miller_Rabin(x))            {                for (ll i = x + 1;i &lt; p;i ++)                    ans = ksc(ans,inv(i,p),p);                cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;                break;            }        }    }    return 0;}</code></pre><p>这里直接贴出来他的代码啦啦啦。</p><h2 id="Romantic"><a href="#Romantic" class="headerlink" title="Romantic"></a>Romantic</h2><p>Description:<br>The Sky is Sprite.<br>The Birds is Fly in the Sky.<br>The Wind is Wonderful.<br>Blew Throw the Trees<br>Trees are Shaking, Leaves are Falling.<br>Lovers Walk passing, and so are You.<br>................................Write in English class by yifenfei<br>Girls are clever and bright. In HDU every girl like math. Every girl like to solve math problem!<br>Now tell you two nonnegative integer a and b. Find the nonnegative integer X and integer Y to satisfy X*a + Y*b = 1. If no such answer print &quot;sorry&quot; instead.<br>Input<br>The input contains multiple test cases.<br>Each case two nonnegative integer a,b (0&lt;a, b&lt;=2^31)<br>Output<br>output nonnegative integer X and integer Y, if there are more answers than the X smaller one will be choosed. If no answer put &quot;sorry&quot; instead.<br>Sample Input<br>77 51<br>10 44<br>34 79<br>Sample Output<br>2 -3<br>sorry<br>7 -3<br>Problem solving:<br>这个题就是给你a，b，让你求ax+by=1的时候的x和y，x还必须是非负整数。如果没有的话就输出<code>sorry</code></p><p>直接用扩展gcd求就可以啦<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y){    if(b==0)    {        x=1,y=0;        return a;    }    ll r=exgcd(b,a%b,x,y),t=y;    y=x-(a/b)*y,x=t;    return r;}int main(){    ll a,b;    while(cin&gt;&gt;a&gt;&gt;b)    {        ll g=__gcd(a,b);        ll x,y;        exgcd(a,b,x,y);        if(a*x+b*y!=1)        {              puts(&quot;sorry&quot;);              continue;        }        if(b&lt;0) b=-b;        x%=b;        while(x&lt;0)        {            x+=b;        }        y=(1-a*x)/b;     cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;    }}</code></pre><p>扩展gcd我也不是很懂，但是套板子就行了嘛。</p><h2 id="Integer-Divisibility"><a href="#Integer-Divisibility" class="headerlink" title="Integer Divisibility"></a>Integer Divisibility</h2><p>Description:<br>If an integer is not divisible by 2 or 5, some multiple of that number in decimal notation is a sequence of only a digit. Now you are given the number and the only allowable digit, you should report the number of digits of such multiple.</p><p>For example you have to find a multiple of 3 which contains only 1&#39;s. Then the result is 3 because is 111 (3-digit) divisible by 3. Similarly if you are finding some multiple of 7 which contains only 3&#39;s then, the result is 6, because 333333 is divisible by 7.</p><p>Input<br>Input starts with an integer T (≤ 300), denoting the number of test cases.</p><p>Each case will contain two integers n (0 &lt; n ≤ 1e6 and n will not be divisible by 2 or 5) and the allowable digit (1 ≤ digit ≤ 9).</p><p>Output<br>For each case, print the case number and the number of digits of such multiple. If several solutions are there; report the minimum one.</p><p>Sample Input<br>3<br>3 1<br>7 3<br>9901 1</p><p>Sample Output<br>Case 1: 3<br>Case 2: 6<br>Case 3: 12</p><p>Problem solving:<br>翻译：<br>如果整数不能被2或5整除，则十进制表示法中该数字的某个倍数只是一个数字的序列。现在您将获得数字和唯一允许的数字，您应该报告此数字的位数。<br>例如，您必须找到仅包含1的3的倍数。然后结果是3，因为111（3位）可被3整除。同样，如果你发现7的多数只包含3的那么，结果是6，因为333333可以被7整除。<br>翻译来自：<a href="https://blog.csdn.net/A_B_C_D_E______/article/details/81205687" target="_blank" rel="noopener">https://blog.csdn.net/A_B_C_D_E______/article/details/81205687</a></p><p>所以可以用大数取模来写，这个是真的不太好想。<br>假如输入时a，b<br>你每次给当前数加上一个a，答案加1，然后对b取模，直接当前值为0，退出循环。<br>可以看一下代码实现，还是很清晰的</p><p>Code:</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;int main(){    int n;    ll a,b;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a&gt;&gt;b;        int ans=0,mid=0;        ll p=1;        while(p)        {            mid=(mid*10+b)%a;            ans++;            p=mid;        }        printf(&quot;Case %d: %d\n&quot;,i,ans);    }}</code></pre><h2 id="Large-Division"><a href="#Large-Division" class="headerlink" title="Large Division"></a>Large Division</h2><p>Description:<br>Given two integers, a and b, you should check whether a is divisible by b or not. We know that an integer a is divisible by an integer b if and only if there exists an integer c such that a = b * c.</p><p>Input<br>Input starts with an integer T (≤ 525), denoting the number of test cases.</p><p>Each case starts with a line containing two integers a (-10^200 ≤ a ≤ 10^200) and b (|b| &gt; 0, b fits into a 32 bit signed integer). Numbers will not contain leading zeroes.</p><p>Output<br>For each case, print the case number first. Then print &#39;divisible&#39; if a is divisible by b. Otherwise print &#39;not divisible&#39;.</p><p>Sample Input<br>6<br>101 101<br>0 67<br>-101 101<br>7678123668327637674887634 101<br>11010000000000000000 256<br>-202202202202000202202202 -101</p><p>Sample Output<br>Case 1: divisible<br>Case 2: divisible<br>Case 3: divisible<br>Case 4: not divisible<br>Case 5: divisible<br>Case 6: divisible</p><p>Problem solving:<br>这道题就是给你两个数a，b，问你a能否整除b，但是数据范围很大，所以要用到大数取模，还是很巧妙地</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n,a;    string s;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;s&gt;&gt;a;        printf(&quot;Case %d: &quot;,i);        ll mid=0;        for(int i=0;i&lt;s.size();i++)        {            if(s[i]==&#39;-&#39;)   continue;            mid=(mid*10+s[i]-&#39;0&#39;)%a;        }        if(mid) puts(&quot;not divisible&quot;);        else    puts(&quot;divisible&quot;);    }}</code></pre><h2 id="青蛙的约会"><a href="#青蛙的约会" class="headerlink" title="青蛙的约会"></a>青蛙的约会</h2><p>Description:<br>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。<br>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。<br>Input<br>输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt; 2100000000。<br>Output<br>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行&quot;Impossible&quot;<br>Sample Input<br>1 2 3 4 5<br>Sample Output<br>4<br>Problem solving:<br>暂无<br>Code:</p><pre><code class="lang-c++"></code></pre><h2 id="Candy-Distribution"><a href="#Candy-Distribution" class="headerlink" title="Candy Distribution"></a>Candy Distribution</h2><p>Description:<br>Kids like candies, so much that they start beating each other if the candies are not fairly distributed. So on your next party, you better start thinking before you buy the candies.</p><p>If there are K kids, we of course need K⋅X candies for a fair distribution, where X is a positive natural number. But we learned that always at least one kid looses one candy, so better be prepared with exactly one spare candy, resulting in (K⋅X)+1 candies.</p><p>Usually, the candies are packed into bags with a fixed number of candies C. We will buy some of these bags so that the above constraints are fulfilled.</p><p>Input<br>The first line gives the number of test cases t (0&lt;t&lt;100). Each test case is specified by two integers K and C on a single line, where K is the number of kids and C the number of candies in one bag (1≤K,C≤1e9). As you money is limited, you will never buy more than 1e9 candy bags.</p><p>Output<br>For each test case, print one line. If there is no such number of candy bugs to fulfill the above constraints, print “IMPOSSIBLE” instead. Otherwise print the number of candy bags, you want to buy. If there is more than one solution, any will do.</p><p>Sample Input 1    Sample Output 1<br>5<br>10 5<br>10 7<br>1337 23<br>123454321 42<br>999999937 142857133<br>IMPOSSIBLE<br>3<br>872<br>14696943<br>166666655</p><p>Problem solving:<br>这道题就是给两个数，第一个数代表人数，第二个数代表每篮子放的糖果个数，问你需要买几蓝可以给每个人分的糖果数一样并且还剩余一个。</p><p>其实就是让你求ax-by=1的时候x的值。<br>{a代表的是每蓝糖果的个数，x代表的是买了几蓝，b代表的是热人数，y代表的是每个人分到的糖果的个数}</p><p>用扩展gcd就可以求出来。</p><p>还是对扩展gcd不够理解所以这道题理解起来和做起来都有点吃力8，扩展gcd啊，嘤嘤嘤。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y){    if (!b)    {        x = 1,y = 0;        return a;    }    int r = exgcd(b,a%b,x,y);    int tmp = y;    y = x - (a / b) * y;    x = tmp;    return r;}int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        ll a,b;        ll x,y;        cin&gt;&gt;a&gt;&gt;b;        ll mid=exgcd(a,b,x,y);        if(mid!=1)    puts(&quot;IMPOSSIBLE&quot;);        else        {            if(b==1)            {                cout&lt;&lt;a+1&lt;&lt;endl;                continue;            }            while(y&lt;=0)    y+=a;            cout&lt;&lt;y&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 扩展gcd </tag>
            
            <tag> inv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 29（河南理工大学暑期第二十九天）</title>
      <link href="/2019/08/13/29/"/>
      <url>/2019/08/13/29/</url>
      
        <content type="html"><![CDATA[<h2 id="小L的项链切割"><a href="#小L的项链切割" class="headerlink" title="小L的项链切割"></a>小L的项链切割</h2><p>Description:<br>题目描述<br>小T送给了小L了一串项链。为了方便，我们把项链上形态不同钻石用不同的字母表示。这样小L的项链就变成了一个字符串。小L忽然想把这串项链优美地切割一下，她想把它切割成尽量少的回文项链，啊也就是回文串。求最少的切割次数。<br>输入<br>第一行一个整数T 表示数据组数<br>下面T组数据，每一组数据:<br>只有一行，一个只有小写英文字母的字符串，字符串长度 &lt;= 1000。<br>输出<br>对于每一组数据，输出将这个字符串能切割成最少的回文串所需切割的次数。<br>样例输入<br>2<br>abaacca<br>abcd<br>样例输出<br>1<br>3<br>Problem solving:<br>这道题毫无思路，据说是个dp，会了再补。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;     bool IsPalindRome(string str){//回文判断        int end=str.length()-1;        int start=0;        while(start&lt;end){            if(str[start]==str[end]){                start++;                end--;            }else{                return false;            }        }        return true;    }    int minCut(string s) {        int len=s.length();        vector&lt;int&gt; dp(len,0);//初始化为0        for(int i=0;i&lt;len;i++){            dp[i]=IsPalindRome(s.substr(0,i+1)) ? 0 : i;//初始化            if(dp[i]==0)                continue;            else{                for(int j=1;j&lt;=i;j++){                    if(IsPalindRome(s.substr(j,i-j+1)))                        dp[i]=min(dp[i],dp[j-1]+1);                    else{                        dp[i]=min(dp[i],dp[j-1]+i-j+1);                    }                }            }        }        return dp[len-1];    }int main(){    string str;    int n;    cin&gt;&gt;n;    while(n--){        cin&gt;&gt;str;        cout&lt;&lt;minCut(str)&lt;&lt;endl;    }}</code></pre><p>代码来自：<a href="https://blog.csdn.net/weixin_30953169/article/details/98876748" target="_blank" rel="noopener">weixin_30953169</a></p><h2 id="小L的试卷"><a href="#小L的试卷" class="headerlink" title="小L的试卷"></a>小L的试卷</h2><p>Description:<br>小L期末考试结束，高高兴兴放假回家了，可是那么多试卷，老师还要加班批改，有n份试卷由k个老师批改，n份试卷进行了密封编号，由于试卷上的做题情况和书写的规范程序不一样，批改不同的试卷用时也可能不一样，每个老师批改试卷的编号顺序是连续的，每位老师批改完分配给自己的试卷就可以离开，问最后离开的老师，最短可能的用时是多少，假定一份试卷让任何一位老师批改用时都是一样的。现在请你设计一种分配方案，使得最后离开的老师用时最短。<br>输入<br>第一行两个整数n，k；（0&lt;k≤n≤1000）<br>第二行n个整数，第i个整数表示批改第i份试卷的用时。<br>输出<br>输出一个整数，表示最后离开的老师所用的最短时间<br>样例输入<br>9 3<br>1 2 3 4 5 6 7 8 9<br>样例输出<br>17<br>Problem solving:<br>这道题的意思就是有k个老师在改卷子。每张卷子耗费的时间都是不一样的，问你怎么分卷子给老师可以让最晚走的老师的时间是最早的。<br>这道题当时是真的是毫无思路，根本没有想到可以用二分写。。。其实想到最晚的最早就该能想到二分的。<br>难点就是在二分中间的判断，这道题要求的是每个老师改的卷子的序号是相邻的，所以直接找最大值看跟要判断的值得大小关系就行啦。<br>二分函数中可以直接从第一个卷子开始加，然后如果当前累加的值大于了要判断的值，就让总人数加一。不是很好说这里，看代码注释、<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;const int maxn = 1e5+10;int n,k;ll a[maxn];bool isok(int x)//判断x是否满足条件{    int flag=0;    int num=0;ll temp=0;//num就是需要的改卷老师的人数    for(int i=0;i&lt;n;i++)    {        if(a[i]&gt;x)    return 0;//如果有一张卷子自己一张的时间已经大于当前要判断的值，说明x不满足条件。直接返回0        temp+=a[i];//这个累加的是第num个老师所需要的时间        if(temp&gt;x)//如果所需要的时间大于当前要判断的值。        {            num++;就在多一个老师，            temp=a[i];并且把当前这张卷子归给下一个老师        }    }    if(temp&gt;0)    num++;//这个处理必须要有，因为你有可能全部加起来的时间还没到达这个x，但此时老师个数还是要加一的    if(num&lt;=k)    return 1; //如果需要的老师人数小于k说明这个值满足条件，返回1    else    return 0;}int main(){    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];    ll l=0,r=INF;    while(l&lt;=r)    {        int mid=(l+r)/2;        if(isok(mid))    r=mid-1;        else    l=mid+1;    }    cout&lt;&lt;l&lt;&lt;endl;    return 0;}</code></pre><p>这道题现在看来当时写不出来也太亏了，二分这个思想还是掌握的不够熟练啊！</p><h2 id="小L记单词"><a href="#小L记单词" class="headerlink" title="小L记单词"></a>小L记单词</h2><p>Description:<br>小L最近在努力学习英语，但是对一些词组总是记不住，小L小把这些词组中每一个单词的首字母都记一下，这样形成词组的缩写，通过这种方式小L的学习效率明显提高。<br>输入<br>输入有多行，每组测试数据占一行，每行有一个词组，每个词组由一个或多个单词组成；每组的单词个数不超过10个，每个单词由大、小写字母组成；<br>单词长度不超过10，由一个空格分隔这些单词。<br>输出<br>对应每一个词组，输出词组的缩写，缩写都用大写字母，每组输出占一行。<br>样例输入<br>end of file<br>样例输出<br>EOF<br>Problem solving:<br>这是一道签到题，就是给你几串字符串，让你输出字符串中每个单词的首字母的大写形式。<br>用getline输入，然后判断前一个是不是空格，如果是，输出大写形式就行了。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    string s;    while(getline(cin,s))    {        if(s[0]&gt;=&#39;a&#39;&amp;&amp;s[0]&lt;=&#39;z&#39;)            printf(&quot;%c&quot;,s[0]-32);        else            cout&lt;&lt;s[0];        for(int i=1;i&lt;s.size();i++)        {            if(s[i-1]==&#39; &#39;)            {                if(s[i]&gt;=&#39;a&#39;&amp;&amp;s[i]&lt;=&#39;z&#39;)                    printf(&quot;%c&quot;,s[i]-32);                else                    cout&lt;&lt;s[i];            }        }        puts(&quot;&quot;);    }}</code></pre><h2 id="小L的取膜算式"><a href="#小L的取膜算式" class="headerlink" title="小L的取膜算式"></a>小L的取膜算式</h2><p>Description:<br>小L想请你帮忙计算一下这个式子的结果<br>(a+b)^p MOD p，其中p是质数。<br>输入<br>多组数据<br>第一行一个T表示数据组数<br>接下来T行，每行3个正整数a, b, p且保证p是质数 ，输入数据都是long long范围内的正整数。特别的: p &lt;= 2^62<br>输出<br>对于每一组输入数据，输出正确结果<br>样例输入<br>1<br>1 2 3<br>样例输出<br>0<br>提示<br>注意p是质数，结合二项式定理可以很容易推得一个结论但是不一定能在时限内通过本题，但稍微再往后推一下就会发现一个非常优美的结论并AC此题<br>输入数据都是long long范围内的正整数。特别的: p &lt;= 2^62<br>Problem solving:<br>这道题就是给你三个数，a,b,p,让你输出(a+b)的p次方对p取模的结果。<br>一开始想着用快速幂，但是不知道为啥会WA。然后就看到了提示，非常优美的结论，我突然就想到了我们学长卡我们的时候的<del>丑恶</del>意味深长的笑容。然后就想着直接输出(a+b)对p取模的结果，wa了一次，因为a+b可能爆long long，所以要先取模再相加再取模。。。这道题坑的也是够可以。</p><p>现在我知道了，因为费马小定理可以得到<code>(a^(p-1))%p=1</code>,所以我们可以将<code>((a+b)^p)%p</code>化简成<code>((a+b)^(p-1))%p*((a+b)%p)</code>，前半部分为1，所以答案就是(a+b)%p</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll t,a,b,p;int main(){    scanf(&quot;%lld&quot;,&amp;t);    while(t--)    {        scanf(&quot;%lld %lld %lld&quot;,&amp;a,&amp;b,&amp;p);        printf(&quot;%lld\n&quot;,(a%p+b%p)%p);    }}</code></pre><h2 id="小L玩滚球游戏"><a href="#小L玩滚球游戏" class="headerlink" title="小L玩滚球游戏"></a>小L玩滚球游戏</h2><p>Description:<br>小L正在玩滚球游戏，有n个水晶球在轨道上以不同开始位置和速度从近往远的方向滚动，如果两个水晶球在滚动过程中相遇，它们就会融合成一个水晶球，然后以速度较慢的水晶球的速度继续向前滚动， 问经过时间t后，轨道上还有多少水晶球。<br>输入<br>第一行输入两个整数n、t，n代表水晶球的数量（1 &lt;= n &lt;= 1e5, 0&lt;t&lt;2^31），t代表时间。<br>接下来n行，每行两个整数，按位置从近到远的顺序给出水晶球的初始位置和速度。<br>输出<br>输出一个整数表示经过时间t后水晶球的数量。<br>样例输入<br>5 3<br>0 1<br>1 2<br>2 3<br>3 2<br>6 1<br>样例输出<br>3<br>Problem solving:<br>这个题的意思就是给你n个小球，还给出了他们的初始位置以及速度。问你在t秒后还剩几个小球。如果在运动过程中有两个小球撞在一起了，那么他俩就以他俩的最小速度继续走下去。<br>我以为这个题是模拟。但是也没模拟出来</p><p>其实这个可以这样<br>根据题意，移动速度快的球可能会追上在他前面移动速度慢的球，并且追上后合并在一起会变成前面速度慢的球。<br>可以将题意理解为，后面移动速度快的球碰到前面移动速度慢的球则会消失。<br>而且t是固定的值，直接计算每个位置在t秒后移动到的位置，逆向维护一个最靠后的值，检测当前球是否超过这个值。<br>如果超过则说明追上了后面的球当前球会消失。<br>题解转载于： <a href="https://blog.csdn.net/CaprYang/article/details/88572379" target="_blank" rel="noopener">CaprYang</a></p><p>原来是个思维的问题<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef  long long ll;const ll INF = 0x3f3f3f3f3f3f3f3f;const int maxn  =  1e5+10;ll a[maxn],b[maxn];int main(){    int n,t,m=0;    cin&gt;&gt;n&gt;&gt;t;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i]&gt;&gt;b[i];        a[i]+=b[i]*t;    }    ll mid=INF;    for(int i=n;i&gt;0;i--)    {        if(a[i]&gt;=mid)    m++;        mid=min(mid,a[i]);    }    cout&lt;&lt;n-m&lt;&lt;endl;    return 0;}</code></pre><h2 id="小L的区间求和"><a href="#小L的区间求和" class="headerlink" title="小L的区间求和"></a>小L的区间求和</h2><p>Description:<br>在给定的一个整数序列中，小L希望找到一个连续的区间，这个区间的和能够被k整除，请你帮小L算一下满足条件的最长的区间长度是多少。<br>输入<br>第一行输入两个整数n、k。（1 &lt;= n &lt;= 1e5,1&lt;=k&lt;100）<br>接下来一行输入n个整数，表示序列中的数。<br>输出<br>输出一个整数，满足条件区间的最长长度，如果不存在，输出0<br>样例输入<br>5 7<br>1 2 4 1 1<br>样例输出<br>3<br>Problem solving:<br>这道题就是给你一个序列，如果存在连续的几个数的和能整除k，求出这个连续的序列的最大的长度。</p><p>一开始没思路，又想到了前缀后缀和数组，最后用了暴力都没过。然后我就想到了这样写。出现k的倍数范围太大，可以输入的时候用一个前缀和数组并且对k取模。然后我们只需要在一个for循环查找是否有取模之后结果相等的两个值。如果有就说明这之间数的和是k的倍数。</p><p>举个栗子</p><pre><code class="lang-txt">3 103%7=3 == 10%3=7(10-3)%7==0</code></pre><p>所以我们只需要每次找到取模之后的前缀和相等的两个位置的最大值就是答案</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int a[100005], s[100005];map&lt;int, int&gt; ma;int main(){    int n, k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i=1; i&lt;=n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);        s[i] = (s[i-1]+a[i])%k;        ma[s[i]] = -1;    }    int ans = 0;    ma[s[0]] = 0;    for(int i=1; i&lt;=n; i++)    {        if(ma[s[i]] == -1)        {            ma[s[i]] = i;        }        else        {            ans = max(ans, i-ma[s[i]]);        }    }    printf(&quot;%d\n&quot;, ans);    return 0;}</code></pre><h2 id="小L的随机数"><a href="#小L的随机数" class="headerlink" title="小L的随机数"></a>小L的随机数</h2><p>Description:<br>随机数是生成随机算法的基础，小L准备使用线性同余法（Linear Congruential Method）来生成一个随机数列，这种方法需要设置四个非负整数参数m, a, c, x0按照下面的公式生成出一系列随机数 : Xn+1 = (a * Xn + c) mod m ,小L现在想知道这个数列第n个数是多少，由于他只需要生成小于g的随机数，所以你只需要告诉他Xn mod g的结果即可。<br>输入<br>输入一行6个整数，分别表示m, a, c, X0, n, g 。(n ≤ 1e6，1 ≤ m, a, c, X0 , g ≤2^31 − 1)<br>输出<br>一行一个整数表示Xn<br>样例输入<br>233 3 3 3 3 333<br>样例输出<br>120<br>Problem solving:<br>这道题给了你一个递推式以及第一项的值，问你第n项的值对g取模的结果。</p><p>这道题挺简单的，直接暴力就可以过。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll m,a,c,xo,x[1000005],n,g;int main(){    cin&gt;&gt;m&gt;&gt;a&gt;&gt;c&gt;&gt;xo&gt;&gt;n&gt;&gt;g;    ll ans=xo;    for(int i=1;i&lt;=n;i++)    {        ans=(a*ans+c)%m;    }    cout&lt;&lt;ans%g&lt;&lt;endl;}</code></pre><h2 id="小L的直线"><a href="#小L的直线" class="headerlink" title="小L的直线"></a>小L的直线</h2><p>Description:<br>小学时期的小L发现自己很有艺术细胞，于是买了一块画板，但是他的绘画水平使得他只能连接两点画出一条线段。有一天他决定在一张有n个点的图上作画，即他可以把这n个点任意连接。大家认为平行线是非常不美观的，于是他想知道自己最多能画多少条直线使整张画不出现平行线。<br>输入<br>第一行输入一个整数n （1 &lt;= n &lt;= 200）<br>接下来n行每行两个整数代表每个点的坐标x, y  （-1000 &lt;= x, y &lt;= 1000）<br>输出<br>一行一个整数为能画出最多的两两不平行的直线条数<br>样例输入<br>4<br>-1 1<br>-2 0<br>0 0<br>1 1<br>样例输出<br>4<br>Problem solving:<br>这道题就是给你n个点，问你最多构成几条没有平行情况出现的直线。</p><p>数据范围不大，直接暴力计算每条直线的斜率，得出不同斜率的个数就是答案。</p><p>这道题跟之前积分赛有一道题很像，我还是用set套pair做的，不知道直接算斜率会不会卡精度。不过还是直接用pair表示斜率来得舒服，注意存的时候要进行约分。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 521;int x[maxn],y[maxn];int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)        cin&gt;&gt;x[i]&gt;&gt;y[i];    set&lt;pair&lt;int,int&gt; &gt; se;    for(int i=0;i&lt;n;i++)    {        for(int j=i+1;j&lt;n;j++)        {            int m=x[i]-x[j],mm=y[i]-y[j];            int gg=__gcd(m,mm);            if(gg!=0)                m/=gg,mm/=gg;            se.insert(make_pair(m,mm));        }    }    cout&lt;&lt;se.size()&lt;&lt;endl;}</code></pre><h2 id="小L的长方形"><a href="#小L的长方形" class="headerlink" title="小L的长方形"></a>小L的长方形</h2><p>Description:<br>在数学课上，老师发给小L一根铁丝，让小L将这根铁丝围成一个长方形。要求这个长方形的长是宽的3倍，并且计算它的面积。<br>输入<br>仅一个整数a，表示铁丝的长度(a≤10000)。<br>输出<br>输出三个数，分别表示长方形的长、宽、面积。如果计算结果是整数，则输出整数结果（没有小数部分）；如果不是，则保留三位小数。每个数之间用一个空格隔开。<br>样例输入<br>36<br>样例输出<br>13.500 4.500 60.750<br>Problem solving:<br>这道题就是给了你一个长方形的周长以及它的长和宽的关系，问你它的面积。</p><p>周长除了8就是宽，宽乘以3就是长，长乘宽就是面积。<br>有一个需要注意的地方是他的输出，题目要求如果是整数就不输出小数部分，否则保留三位小数。只需要判断长跟宽是不是整数就行，用一个<code>ceil</code>(向上取整)来判断就行.</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    double a,b,c;    cin&gt;&gt;a;    b=a/8,c=b*3;    if(ceil(b)==b&amp;&amp;ceil(c)==c)    {        printf(&quot;%.0lf %.0lf %.0lf&quot;,c,b,c*b);    }    else    printf(&quot;%.3lf %.3lf %.3lf&quot;,c,b,c*b);}</code></pre><p>今天的题大多不难，就是思维问题。体验还是不错的。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
            <tag> 费马小定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 28（河南理工大学暑期第二十八天）</title>
      <link href="/2019/08/12/28/"/>
      <url>/2019/08/12/28/</url>
      
        <content type="html"><![CDATA[<h2 id="Smith-Numbers"><a href="#Smith-Numbers" class="headerlink" title="Smith Numbers"></a>Smith Numbers</h2><p>Description:<br>While skimming his phone directory in 1982, Albert Wilansky, a mathematician of Lehigh University,noticed that the telephone number of his brother-in-law H. Smith had the following peculiar property: The sum of the digits of that number was equal to the sum of the digits of the prime factors of that number. Got it? Smith&#39;s telephone number was 493-7775. This number can be written as the product of its prime factors in the following way:<br>4937775= 3*5*5*65837</p><p>The sum of all digits of the telephone number is 4+9+3+7+7+7+5= 42,and the sum of the digits of its prime factors is equally 3+5+5+6+5+8+3+7=42. Wilansky was so amazed by his discovery that he named this kind of numbers after his brother-in-law: Smith numbers.<br>As this observation is also true for every prime number, Wilansky decided later that a (simple and unsophisticated) prime number is not worth being a Smith number, so he excluded them from the definition.<br>Wilansky published an article about Smith numbers in the Two Year College Mathematics Journal and was able to present a whole collection of different Smith numbers: For example, 9985 is a Smith number and so is 6036. However,Wilansky was not able to find a Smith number that was larger than the telephone number of his brother-in-law. It is your task to find Smith numbers that are larger than 4937775!<br>Input<br>The input file consists of a sequence of positive integers, one integer per line. Each integer will have at most 8 digits. The input is terminated by a line containing the number 0.<br>Output<br>For every number n &gt; 0 in the input, you are to compute the smallest Smith number which is larger than n,and print it on a line by itself. You can assume that such a number exists.<br>Sample Input<br>4937774<br>0<br>Sample Output<br>4937775<br>Problem solving:<br>这道题的意思就是如果一个数的每一位的和跟它所有的质因子的每一位的和相等就叫这个Smith Numbers。并且Smith Numbers不能是质数。给你一个数，问你第一个大于它的Smith Number。</p><p>直接暴力就行了，需要用的质因子的分解，这个是有模板的，可以直接套。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;ll a[10005];bool ju(ll x){    for(ll i=2;i&lt;=sqrt(x);i++)        if(x%i==0)    return 0;    return 1;}bool judge(ll x){    map&lt;ll,ll&gt; ma;    ll mid,miid,ans=0;    mid=x,miid=x;    while(mid)    {        ans+=mid%10;        mid/=10;    }    int pos=0;    for(ll i=2;i*i&lt;=miid;i++)    {        if(miid%i==0)    a[pos++]=i;        while(miid%i==0)        {            ma[i]++;            miid/=i;        }    }    if(miid&gt;1)    a[pos++]=miid,ma[miid]++;    int ans2=0;    mid=0;    for(int i=0;i&lt;pos;i++)    {        int sijia,xiaozhu=0;    sijia=ma[a[i]];        while(a[i])        {            xiaozhu+=a[i]%10;            a[i]/=10;        }        ans2+=(xiaozhu*sijia);    }    return ans==ans2;}int main(){    ll n;    while(cin&gt;&gt;n&amp;&amp;n)    {        for(int i=n+1;;i++)        {            if(judge(i)&amp;&amp;!ju(i))            {                cout&lt;&lt;i&lt;&lt;endl;                break;            }        }    }}</code></pre><h2 id="Pairs-Forming-LCM"><a href="#Pairs-Forming-LCM" class="headerlink" title="Pairs Forming LCM"></a>Pairs Forming LCM</h2><p>Description:<br>Find the result of the following code:</p><p>long long pairsFormLCM( int n ) {<br>    long long res = 0;<br>    for( int i = 1; i &lt;= n; i++ )<br>        for( int j = i; j &lt;= n; j++ )<br>           if( lcm(i, j) == n ) res++; // lcm means least common multiple<br>    return res;<br>}</p><p>A straight forward implementation of the code may time out. If you analyze the code, you will find that the code actually counts the number of pairs (i, j) for which lcm(i, j) = n and (i ≤ j).</p><p>Input<br>Input starts with an integer T (≤ 200), denoting the number of test cases.</p><p>Each case starts with a line containing an integer n (1 ≤ n ≤ 1e14).</p><p>Output<br>For each case, print the case number and the value returned by the function &#39;pairsFormLCM(n)&#39;.</p><p>Sample Input<br>15<br>2<br>3<br>4<br>6<br>8<br>10<br>12<br>15<br>18<br>20<br>21<br>24<br>25<br>27<br>29</p><p>Sample Output<br>Case 1: 2<br>Case 2: 2<br>Case 3: 3<br>Case 4: 5<br>Case 5: 4<br>Case 6: 5<br>Case 7: 8<br>Case 8: 5<br>Case 9: 8<br>Case 10: 8<br>Case 11: 5<br>Case 12: 11<br>Case 13: 3<br>Case 14: 4<br>Case 15: 2</p><p>Problem solving:<br>这道题就是让你输出n以内的两个数最小公倍数为n的对数。我已开始以为是找规律，然后找了半个上午也没找到。还是百度大法好。</p><p>网上代码的思路就是也是用到了求两个数的lcm的一个公式。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/QQ%E5%9B%BE%E7%89%8720190812180106.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/QQ%E5%9B%BE%E7%89%8720190812180106.webp" class="img-shadow img-margin"></center></a></p><p>注意还要用到素数打表。这里也是见到了一种新的打表方式，很强。直接筛的时候就存。</p><p>关于这道题的具体解法我也说不清，还有很复杂的证明啊什么的，可以参考一下这篇博客。<br><a href="https://blog.csdn.net/acvay/article/details/47333871" target="_blank" rel="noopener">virgoDd</a></p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e7;typedef long long ll;int p[maxn/10],m;//素数的数组开始1e7会REbool vis[maxn];void init(){    m=0;    for(int i=2;i&lt;maxn;i++)    {        if(!vis[i])    p[m++]=i;        for(int j=0;j&lt;m&amp;&amp;p[j]*i&lt;maxn;j++)        {            vis[p[j]*i]=1;            if(i%p[j]==0)    break;        }    }}int main(){    init();    ll n,ans,c;    int t,f=0;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;n;        ans=1;        for(int i=0;i&lt;m;i++)        {            if(p[i]*p[i]&gt;n)    break;            c=0;            while(n%p[i]==0)            {                n/=p[i];                ++c;            }            if(c)    ans*=c*2+1;        }        if(n&gt;1)    ans*=1*2+1;        printf(&quot;Case %d: %lld\n&quot;,++f,ans/2+1);    }}</code></pre><h2 id="Ekka-Dokka"><a href="#Ekka-Dokka" class="headerlink" title="Ekka Dokka"></a>Ekka Dokka</h2><p>Description:<br>Ekka and his friend Dokka decided to buy a cake. They both love cakes and that&#39;s why they want to share the cake after buying it. As the name suggested that Ekka is very fond of odd numbers and Dokka is very fond of even numbers, they want to divide the cake such that Ekka gets a share of N square centimeters and Dokka gets a share of M square centimeters where N is odd and M is even. Both N and M are positive integers.</p><p>They want to divide the cake such that N * M = W, where W is the dashing factor set by them. Now you know their dashing factor, you have to find whether they can buy the desired cake or not.</p><p>Input<br>Input starts with an integer T (≤ 10000), denoting the number of test cases.</p><p>Each case contains an integer W (2 ≤ W &lt; 2^63). And W will not be a power of 2.</p><p>Output<br>For each case, print the case number first. After that print &quot;Impossible&quot; if they can&#39;t buy their desired cake. If they can buy such a cake, you have to print N and M. If there are multiple solutions, then print the result where M is as small as possible.</p><p>Sample Input<br>3<br>10<br>5<br>12</p><p>Sample Output<br>Case 1: 5 2<br>Case 2: Impossible<br>Case 3: 3 4<br>Problem solving:<br>这道题还是很轻松的。意思就是给你一个数问你能不能把它分成一个奇数和一个偶数的乘积的形式。如果答案有多种输出奇数最小的形式。</p><p>偶数是很好找的，我们对这个数一直除以2直到除不尽的时候，剩下的那个数就是最小的奇数，因为此时分出来的偶数是最大的。如果这个数本来就是个奇数，就是输出&#39;Impossible&#39;就行了。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6;ll a[maxn];int main(){    int t;    cin&gt;&gt;t;    for(int i=1;i&lt;=t;i++)    {        ll n,pos=0,a=1;        cin&gt;&gt;n;            printf(&quot;Case %d: &quot;,i);        if(n%2!=0)    puts(&quot;Impossible&quot;);        else        {            while(n%2==0)            {                n/=2;                a*=2;            }            cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl;                    }    }}</code></pre><h2 id="Sum-of-Consecutive-Integers"><a href="#Sum-of-Consecutive-Integers" class="headerlink" title="Sum of Consecutive Integers"></a>Sum of Consecutive Integers</h2><p>Description:<br>Given an integer N, you have to find the number of ways you can express N as sum of consecutive integers. You have to use at least two integers.</p><p>For example, N = 15 has three solutions, (1+2+3+4+5), (4+5+6), (7+8).</p><p>Input<br>Input starts with an integer T (≤ 200), denoting the number of test cases.</p><p>Each case starts with a line containing an integer N (1 ≤ N ≤ 1e14).</p><p>Output<br>For each case, print the case number and the number of ways to express N as sum of consecutive integers.</p><p>Sample Input<br>5<br>10<br>15<br>12<br>36<br>828495</p><p>Sample Output<br>Case 1: 1<br>Case 2: 3<br>Case 3: 1<br>Case 4: 2<br>Case 5: 47<br>Problem solving:<br>这道题好像需要求得是质数因子的个数。<br>证明太麻烦，还是直接上链接啊。<a href="https://blog.csdn.net/u011412840/article/details/80040686" target="_blank" rel="noopener">oliveQ</a></p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e7+10;ll n,p[maxn/10];bool is[maxn];int t,ca,pos;void init(){    for(int i=2;i&lt;maxn;i++)    {        if(!is[i])    p[pos++]=i;        for(int j=0;j&lt;pos&amp;&amp;i*p[j]&lt;maxn;j++)        {            is[i*p[j]]=1;            if(i%p[j]==0)    break;        }    }}int main(){    cin&gt;&gt;t;    init();    while(t--)    {        ll ans=1;        cin&gt;&gt;n;        for(int i=0;i&lt;pos&amp;&amp;p[i]*p[i]&lt;=n;i++)        {            ll cnt=0;a            while(n%p[i]==0)    cnt++,n/=p[i];            if(i)    ans*=cnt+1;        }        if(n&gt;2)    ans*=2;        printf(&quot;Case %d: %lld\n&quot;,++ca,ans-1);    }}</code></pre><h2 id="Aladdin-and-the-Flying-Carpet"><a href="#Aladdin-and-the-Flying-Carpet" class="headerlink" title="Aladdin and the Flying Carpet"></a>Aladdin and the Flying Carpet</h2><p>Description:<br>It&#39;s said that Aladdin had to solve seven mysteries before getting the Magical Lamp which summons a powerful Genie. Here we are concerned about the first mystery.</p><p>Aladdin was about to enter to a magical cave, led by the evil sorcerer who disguised himself as Aladdin&#39;s uncle, found a strange magical flying carpet at the entrance. There were some strange creatures guarding the entrance of the cave. Aladdin could run, but he knew that there was a high chance of getting caught. So, he decided to use the magical flying carpet. The carpet was rectangular shaped, but not square shaped. Aladdin took the carpet and with the help of it he passed the entrance.</p><p>Now you are given the area of the carpet and the length of the minimum possible side of the carpet, your task is to find how many types of carpets are possible. For example, the area of the carpet 12, and the minimum possible side of the carpet is 2, then there can be two types of carpets and their sides are: {2, 6} and {3, 4}.</p><p>Input<br>Input starts with an integer T (≤ 4000), denoting the number of test cases.</p><p>Each case starts with a line containing two integers: a b (1 ≤ b ≤ a ≤ 1e12) where a denotes the area of the carpet and b denotes the minimum possible side of the carpet.</p><p>Output<br>For each case, print the case number and the number of possible carpets.</p><p>Sample Input<br>2<br>10 2<br>12 2</p><p>Sample Output<br>Case 1: 1<br>Case 2: 2<br>Problem solving:<br>这道题的意思就是输入两个数a，b。问你a分解成两个数相乘的形式且每个数都不小于b的情况有多少种。</p><p>可以先求b的，然后减去a的。<br>我是真的说不清：<a href="https://blog.csdn.net/FEATHER2016/article/details/78109559" target="_blank" rel="noopener">莫若诩殇</a></p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6;typedef long long ll;ll p[maxn],pos,vis[maxn];void init(){    pos=0;    for(int i=2;i&lt;maxn;i++)    {        if(!vis[i])    p[pos++]=i;        for(int j=0;j&lt;pos&amp;&amp;p[j]*i&lt;maxn;j++)        {            vis[p[j]*i]=1;            if(i%p[j]==0)    break;        }    }}int main(){    ll t,a,b,l=0;    scanf(&quot;%lld&quot;,&amp;t);    init();    while(t--)    {        ll now=0,ans=1,aa,net=0;        scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);        if(b*b&gt;=a)        {            printf(&quot;Case %d: 0\n&quot;,++l);            continue;        }        aa=a;        for(int i=0;i&lt;pos&amp;&amp;p[i]&lt;=a;i++)        {            int c=0;            while(a%p[i]==0)            {                a/=p[i];                c++;            }            ans*=(c+1);        }            if(a&gt;1)    ans*=2;            ans/=2;        for(ll i=1;i&lt;b;i++)        {            if(aa%i==0)                        ans--;        }        printf(&quot;Case %lld: %lld\n&quot;,++l,ans);    }}</code></pre><h2 id="Minimum-Sum-LCM"><a href="#Minimum-Sum-LCM" class="headerlink" title="Minimum Sum LCM"></a>Minimum Sum LCM</h2><p>PDF题面: <a href="https://vj.ti12z.cn/4dad60af114a82d493eb5c0cd36d0d56?v=1565490425" target="_blank" rel="noopener">Minimum Sum LCM </a><br>Description:<br>LCM (Least Common Multiple) of a set of integers is defined as the minimum number, which is a<br>multiple of all integers of that set. It is interesting to note that any positive integer can be expressed<br>as the LCM of a set of positive integers. For example 12 can be expressed as the LCM of 1, 12 or<br>12, 12 or 3, 4 or 4, 6 or 1, 2, 3, 4 etc.<br>In this problem, you will be given a positive integer<br>N. You have to find out a set of at least two positive integers<br>whose LCM is N. As infinite such sequences are<br>possible, you have to pick the sequence whose summation<br>of elements is minimum. We will be quite happy<br>if you just print the summation of the elements of this<br>set. So, for N = 12, you should print 4+3 = 7 as<br>LCM of 4 and 3 is 12 and 7 is the minimum possible<br>summation.<br>Input<br>The input file contains at most 100 test cases. Each<br>test case consists of a positive integer N (1 ≤ N ≤<br>2^31 − 1).<br>Input is terminated by a case where N = 0. This<br>case should not be processed. There can be at most<br>100 test cases.<br>Output<br>Output of each test case should consist of a line starting with ‘Case #: ’ where # is the test case<br>number. It should be followed by the summation as specified in the problem statement. Look at the<br>output for sample input for details.<br>Sample Input<br>12<br>10<br>5<br>0<br>Sample Output<br>Case 1: 7<br>Case 2: 7<br>Case 3: 6<br>Problem solving:<br>这道题就是给你一个n，问你以n为最小公倍数的几个数的和的最小值。</p><p>答案就是n分解质因数之后的幂级数的和。</p><p>如何证明:<a href="https://blog.csdn.net/baoli1008/article/details/43525197" target="_blank" rel="noopener">Baoli1008</a></p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n,cas=1;    while(cin&gt;&gt;n&amp;&amp;n)    {        ll ans=0,cnt=0,x=n;        for(ll i=2;i*i&lt;=n;i++)        {            ll mid=1;            if(n%i==0)            {                cnt++;                while(n%i==0)                {                    n/=i;                    mid*=i;                }                ans+=mid;            }        }        if(n==x)    ans=x+1;        else if(n!=1 || cnt == 1)    ans+=n;        printf(&quot;Case %lld: %lld\n&quot;,cas++,ans);    }}</code></pre><h2 id="GCD-and-LCM"><a href="#GCD-and-LCM" class="headerlink" title="GCD and LCM"></a>GCD and LCM</h2><p>Description:<br>Given two positive integers G and L, could you tell me how many solutions of (x, y, z) there are, satisfying that gcd(x, y, z) = G and lcm(x, y, z) = L?<br>Note, gcd(x, y, z) means the greatest common divisor of x, y and z, while lcm(x, y, z) means the least common multiple of x, y and z.<br>Note 2, (1, 2, 3) and (1, 3, 2) are two different solutions.<br>Input<br>First line comes an integer T (T &lt;= 12), telling the number of test cases.<br>The next T lines, each contains two positive 32-bit signed integers, G and L.<br>It’s guaranteed that each answer will fit in a 32-bit signed integer.<br>Output<br>For each test case, print one line with the number of solutions satisfying the conditions above.<br>Sample Input<br>2<br>6 72<br>7 33<br>Sample Output<br>72<br>0<br>Problem solving:<br>这道题就是给你两个数a，b，问你以a为最大公约数并且以b为最小公倍数的有多少种情况。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll solve(ll n){    ll ans=1;    for(int i=2;i*i&lt;=n;i++)    {        if(n%i==0)        {            int t=0;            while(n%i==0)            {                t++;                n/=i;            }            ans*=t*6;        }    }    if(n&gt;1)    ans*=6;    return ans;}int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        ll n,m;        cin&gt;&gt;n&gt;&gt;m;        if(m%n)        {            puts(&quot;0&quot;);            continue;        }        ll t=m/n;        cout&lt;&lt;solve(t)&lt;&lt;endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 算数基本原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 27（河南理工大学暑期第二十七天）</title>
      <link href="/2019/08/11/27/"/>
      <url>/2019/08/11/27/</url>
      
        <content type="html"><![CDATA[<p>今天早上睡醒继续搞这个新的主题搞到了大中午。然后下午就跟小伙伴们一起出去玩了。</p><p>去看了哪吒，虽然它已经上映了好久了，但是我今天才抽出时间来看，确实挺不错的，很搞笑也很催泪。挺喜欢哪吒的性格，外面坚强，所有事情都留给自己。有自己想要守护以及誓死也要守护的东西。挺不错的电影，推荐去看一下。</p><p>20号集训就提前结束了，从明天开始，可能就会变得很忙很忙了。加油！</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> movie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河南理工大学算法协会暑期集训积分赛（四） Day26</title>
      <link href="/2019/08/11/jf4/"/>
      <url>/2019/08/11/jf4/</url>
      
        <content type="html"><![CDATA[<h2 id="wzy的大冒险——出发前的清理"><a href="#wzy的大冒险——出发前的清理" class="headerlink" title="wzy的大冒险——出发前的清理"></a>wzy的大冒险——出发前的清理</h2><p>Description:<br>由于上次学弟们没有ak，导致许多蚂蚁被留下了。wzy在出发冒险前请来了一只食蚁兽帮忙清理。<br>现在出现了一只食蚁兽。每个蚂蚁都有wzy给它的一个编号，食蚁兽要吃蚂蚁必须要确认蚂蚁的编号X是否满足要求，如下：</p><p>X的质因子的种类不超过13种<br>X的食蚁数是个素数(食蚁数的定义见最下方提示)<br>X的食蚁数是个回文数<br>如果都满足则输出 YES ,否则输出 NO</p><p>输入格式<br>第一行给定一个T,(1≤T≤1e5)<br>接下来T行，每行给出数字X,(1≤X≤1e17)</p><p>输出格式<br>每行输出 YES 或者 NO</p><p>样例<br>input<br>3<br>121666<br>111666<br>1312333<br>output<br>NO<br>NO<br>YES<br>提示<br>补充：</p><ol><li>回文数至少为两位数，如 131 、 22</li><li>如果X的长度为 len1 ，令 len2=⌊len12⌋，则 X 的前 len2 位形成的数是它的食蚁数</li></ol><p>Problem solving:<br>挺好的一道题，但是我没做出来，先放上学长代码把，以后会了在补上思路。</p><p>Code:</p><pre><code class="lang-c++">//---JQM---////#pragma GCC optimize(3)#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef unsigned long long ull;const int MAXN = 1e7+7;int prime[MAXN];int visit[MAXN];void Prime(){   //网上随便找了个素筛板子，好像visit[i]==0表示素数（为什么两个数组不反过来用    memset(visit,0, sizeof(visit));    memset(prime, 0, sizeof(prime));    for (int i = 2;i &lt;= MAXN; i++) {        // cout&lt;&lt;&quot; i = &quot;&lt;&lt;i&lt;&lt;endl;        if (!visit[i]) {            prime[++prime[0]] = i;      //纪录素数， 这个prime[0] 相当于 cnt，用来计数        }        for (int j = 1; j &lt;=prime[0] &amp;&amp; i*prime[j] &lt;= MAXN; j++) {            visit[i*prime[j]] = 1;            if (i % prime[j] == 0) {                break;            }        }    }}char s[20];char w[20];int main(){    Prime();    int i, k, flag, n;    ll a, b;    int t;    cin&gt;&gt;t;    while(t--)    {        scanf(&quot;%lld&quot;, &amp;a);        if(a&lt;=1000) //食蚁数长度在两位及以上，所以a的长度在四位及以上        {            printf(&quot;NO\n&quot;);            continue;        }        b = a;        k = 0;        flag = 1;        while(b)  //统计a的长度并且转换为字符串        {            s[k++] = b%10;            b/=10;        }        n = k;  //长度        if(n&gt;=16)   //a长度为16、17位，食蚁数长度为8位；或者a==100000000000000000，食蚁数==100000000        {            printf(&quot;NO\n&quot;);            continue;        }        for(i=0; i&lt;k/2; i++)  //取食蚁数字符串            w[i] = s[k-i-1];        k/=2;   //k为食蚁数位数        if(!(k%2))   //一个回文数如果位数为偶数位那么它一定不是素数（11除外）        {            if(a/100==11 || a/1000==11) printf(&quot;YES\n&quot;);            else printf(&quot;NO\n&quot;);            continue;        }        for(i=0; i&lt;k/2; i++)  //检查回文串        {            if(w[i] != w[k-i-1])            {                flag = 0;                break;            }        }        n = a/pow(10, n-k);        if(flag &amp;&amp; !visit[n]) printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    }    return 0;}</code></pre><h2 id="wzy的大冒险——出发咯QAQ"><a href="#wzy的大冒险——出发咯QAQ" class="headerlink" title="wzy的大冒险——出发咯QAQ"></a>wzy的大冒险——出发咯QAQ</h2><p>Description:<br>wzy踏上了冒险的旅程。<br>现在他从地精手里买了一份地图，地图上有n个城镇。<br>他从第一个城镇出发，走向（没钱只能走）第n个城镇，现在，请你帮wzy找到一条最短的路径，并倒序（从n到1）输出一条最短路径。<br>举个栗子:如果有两条路径6 4 3 1和6 5 2 1，我们选择6 4 3 1这条。<br>地精小提示：路是单向的QAQ。</p><p>输入格式<br>第一行两个数n,m ，(1≤n≤1e3,1≤m≤1e3)</p><p>接下来m行，每行三个数x,y,z，表示点 x 与点 y 之间有一条权值为 z 的有向边 (1≤x,y,z≤1e3).</p><p>输出格式<br>第一行一个整数表示 1 到 n 的最短距离；<br>第二行倒序输出这条路径。</p><p>input<br>5 7<br>1 2 69<br>1 3 87<br>1 4 79<br>2 5 94<br>2 3 10<br>3 5 79<br>4 5 43</p><p>output<br>122<br>5 4 1</p><p>Problem solving:<br>这道题题意就是给你一个图的信息，让你求出最短路径的长度以及最短路。</p><p>这道题我就是直接套的最短路的板子，但是板子里面没有记录路径，我就想到了离散数学讲到的最短路径的输出使用一个f数组记录，试了一下，还真过了。<br>其实就是记录一下，然后输出的时候是一个查找的过程，可以看代码注释。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e3+10;const int INF=0x3f3f3f3f;int a[maxn][maxn],dis[maxn],f[maxn];bool vis[maxn];int n,m,u,v,w;struct node{    int d,id;};bool operator&lt;(node a,node b){    return a.d&gt;b.d;}priority_queue&lt;node&gt; q;void solve(){    for(int i=1;i&lt;=n;i++)    dis[i]=INF;    dis[1]=0;    q.push(node{dis[1],1});    while(!q.empty())    {        node p=q.top();        q.pop();        int mid=p.id;        if(vis[mid]==1)    continue;        vis[mid]=1;        for(int i=1;i&lt;=n;i++)        {            if(dis[i]&gt;dis[mid]+a[mid][i])            {                dis[i]=dis[mid]+a[mid][i];                f[i]=mid;//这就是记录路径所用到的数组                q.push(node{dis[i],i});            }        }    }    cout&lt;&lt;dis[n]&lt;&lt;endl;}int main(){    cin&gt;&gt;n&gt;&gt;m;    f[1]=1;    for(int i=1;i&lt;=n;i++)    for(int j=1;j&lt;=n;j++)    a[i][j]=INF;    for(int i=1;i&lt;=m;i++)    {        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        a[u][v]=w;    }    solve();    cout&lt;&lt;n&lt;&lt;&quot; &quot;;    while(f[n]!=n)//输出最短路径所用到的查找    {        cout&lt;&lt;f[n]&lt;&lt;&quot; &quot;;        n=f[n];    }}</code></pre><h2 id="wzy的大冒险——数学王国"><a href="#wzy的大冒险——数学王国" class="headerlink" title="wzy的大冒险——数学王国"></a>wzy的大冒险——数学王国</h2><p>Description:<br>wzy这一次来到了数学王国，加号国王为了考验他，找来了一个数字n，告诉了wzy这个数字的阶乘的末尾零的个数Q，猜错的话就要把wzy赶出去。现在请你帮帮wzy求这个数最小为多少。<br>若不存在输出&quot;impossible&quot;(输出不带引号)。</p><p>输入格式<br>输入数据包含T组(1≤T≤10000)<br>每一组数据包含一个数字Q (0≤Q≤1e8)</p><p>输出格式<br>对于每一组数据请输出这个数字n,否则输出&quot;impossible&quot;(输出不带引号)。</p><p>样例<br>input<br>3<br>1<br>2<br>5</p><p>output<br>5<br>10<br>impossible</p><p>input<br>1<br>10000000<br>output<br>40000010</p><p>Problem solving:<br>这道题题意就是给你一个数n，让你求是否存在一个数，它的阶乘后面有n个0.<br>这个问题很经典了，就是看这个数里面有几个5，因为出现0的话只有2*5才会出现，而2的个数有很多，所以说出现5的个数就是0的个数。<br>这道题用到的是二分，我觉得这道题挺好的</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF= 0x3f3f3f3f;ll solve(ll x){    ll ans=0;    while(x)    {        ans+=x/5;        x/=5;    }    return ans;}int main(){    ll n,a;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;a;        ll ans=INF;        ll l=5,r=INF,mid;        while(l&lt;=r)        {            mid=(l+r)/2;            if(solve(mid)==a)            {                ans=min(ans,mid);                r=mid-1;            }            else if(solve(mid)&gt;a)            {                r=mid-1;            }            else    l=mid+1;        }        if(ans==INF)    puts(&quot;impossible&quot;);        else        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h2 id="wzy的大冒险——a-b问题"><a href="#wzy的大冒险——a-b问题" class="headerlink" title="wzy的大冒险——a+b问题"></a>wzy的大冒险——a+b问题</h2><p>Description:<br>每个ACMer都是从a+b问题开始的，今天wzy翻到了他的第一个a+b程序，并想让你来输出它</p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<stdio.h></stdio.h></h1><p>int main()<br>{<br>int a,b;<br>scanf(&quot;%d %d&quot;,&amp;a,&amp;b);<br>int c=a+b;<br>printf(&quot;%d\n&quot;,c);<br>return 0;<br>}<br>输入格式<br>本题无输入</p><p>输出格式<br>将上面代码输出<br>Problem solving:<br>一道签到题，注意输出的时候里面有些神奇的地方需要注意一下。<br>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    puts(&quot;#include&lt;stdio.h&gt;&quot;);    puts(&quot;int main()&quot;);    puts(&quot;{&quot;);    puts(&quot;int a,b;&quot;);    puts(&quot;scanf(\&quot;%d %d\&quot;,&amp;a,&amp;b);&quot;);    puts(&quot;int c=a+b;&quot;);    puts(&quot;printf(\&quot;%d\\n\&quot;,c);&quot;);    puts(&quot;return 0;&quot;);    puts(&quot;}&quot;);}</code></pre><h2 id="wzy的大冒险——炉石传说"><a href="#wzy的大冒险——炉石传说" class="headerlink" title="wzy的大冒险——炉石传说"></a>wzy的大冒险——炉石传说</h2><p>Description:<br>wzy 来到了炉石传说的世界。<br>他发现他现在有n个攻击力为ai的随从，每个随从只能攻击一次。<br>对面的boss有m个血量为bi的具有嘲讽的随从（嘲讽即为你必须先把这些怪物击败才可攻击boss）。<br>当我方随从攻击力大于等于敌方随从血量时，敌方随从死亡。<br>由于boss的强力技能，对方的随从只能受到一次攻击，受到攻击后无法再一次受到攻击。(你无法使两个随从都攻击对方的同一个的随从)。<br>wzy必须先干掉对方的所有随从才能使用剩下的随从攻击boss本身。<br>对方boss有k的血量，现在请问wzy能否干掉敌方boss回归现实世界？</p><p>输入格式<br>第一行为三个数n，m，k。n 为wzy拥有的随从数量，m为boss拥有的随从数量，k为boss血量。<br>第二行为n个数，分别是wzy随从的攻击力;<br>第三行为m个数，分别是boss随从的血量。<br>以上数据范围均在[1,100]范围内</p><p>输出格式<br>如果胜利输出Win，否则输出Lose</p><p>样例<br>input<br>4 3 2<br>2 4 6 8<br>3 5 7<br>output<br>Win</p><p>Problem solving:<br>这道题的意思就是给你你的仆从的攻击力以及boss的仆从的攻击力，攻击力大的能杀死攻击力小的，问你最后剩下的仆从是不是能击败boss。每个普通都只能被击败一次，打boss的时候可以上多个仆从。</p><p>简单的模拟一下即可。把用来打败怪物的仆从标记一下，然后看标记的个数与boss仆从的个数是否相等，并看未标记的仆从的攻击力与boss血量的大小关系。然后就可以输出了。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;int a[maxn],b[maxn];int main(){    int n,m,k,ans=0;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];    for(int i=0;i&lt;m;i++)    cin&gt;&gt;b[i];    sort(a,a+n),sort(b,b+m);    int pos=0,flag=0,s=0;    for(int i=0;i&lt;m;i++)    {        while(a[pos]&lt;b[i])        {            pos++;            if(pos&gt;=n)            {                    s=1;break;            }        }        if(s)    break;        a[pos]=0;        flag++;    }    for(int i=0;i&lt;n;i++)    ans+=a[i];    if(ans&gt;=k&amp;&amp;flag==m)    puts(&quot;Win&quot;);    else    puts(&quot;Lose&quot;);}</code></pre><h2 id="wzy的大冒险——接龙红包"><a href="#wzy的大冒险——接龙红包" class="headerlink" title="wzy的大冒险——接龙红包"></a>wzy的大冒险——接龙红包</h2><p>Description:<br>最近QQ更新了一个新的功能–“接龙红包”，会长作为算协的土豪，便开始在群里发红包,wzy总是抢的又快又准，现在他开始研究成语接龙的奥秘。<br>现在QQ的词库里面有n种成语，每种成语由一个只由小写字母组成的字符串表示，现在wzy发现了一个问题，如果有个同学说了一个成语，但是在词库里找不到可以接在它后面的成语（即找不到一个成语的首字母和该成语的尾字母相同），这样的成语被称为死局成语，现在zy想知道在词库里面有多少这样的死局成语。</p><p>输入格式<br>第一行输入n，接下来n行每行输入一个字符串代表一个成语s。<br>(1≤n≤100,1≤|s|≤20)</p><p>输出格式<br>第一行输出死局成语的个数m。<br>接下来m行每行输出一个死局成语，输出顺序应和输入顺序保持一致。</p><p>样例<br>input<br>3<br>aaa<br>bab<br>abc<br>output<br>1<br>abc<br>input<br>3<br>a<br>b<br>c<br>output<br>0<br>提示<br>一血通过本题奖励5毛红包(手动滑稽)。<br>Problem solving:<br>接龙红包，就是看每个字符串的最后一个字母有没有在第一个位置出现过。简单模拟一下，让当前的字符串的最后一个字母分别于所有字符串的第一个字母比较，如果出现相等的就直接判断下一个。复杂度是N^2，但是题目的数据范围也很小，不用考虑超时。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;string s[105];int main(){    int n,ans=0,flag=0;    cin&gt;&gt;n;    queue&lt;string&gt; que;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;s[i];    for(int i=0;i&lt;n;i++)    {        flag=0;        char mid=s[i][s[i].size()-1];        for(int j=0;j&lt;n;j++)        {            if(s[j][0]==mid)            {                flag=1;                break;            }        }        if(flag)    continue;        ans++;        que.push(s[i]);    }    cout&lt;&lt;ans&lt;&lt;endl;    while(!que.empty())    {        cout&lt;&lt;que.front()&lt;&lt;endl;        que.pop();    }}</code></pre><h2 id="大树的水塘"><a href="#大树的水塘" class="headerlink" title="大树的水塘"></a>大树的水塘</h2><p>Description:<br>那一天，世界上所有的人类都……变成了石头！</p><p>3700年后，千空和大树从石头中苏醒过来，但是世界发生了翻天覆地的变化，人类文明已经不复存在</p><p>天才少年千空立志用自己的科学知识在这个「石之世界」中重建文明</p><p>为了生存，淡水是必不可少的，每次都用海水进行蒸馏会比较麻烦，所以千空决定让大树建造一个水塘来存储雨水</p><p>水塘建造在一个无限长，高度不超过100，宽度为1的峡谷里，所以只需要往里面填石头，即可达到蓄水的目的</p><p>当大树建造好水塘让千空去检查的时候，千空一口老血喷了出来：因为大树是一个体力笨蛋，所以建造的水塘底部是参差不齐的，这使得建造蓄水相同体积的水塘，大树多用了好多石头</p><p>已知每块石头中的规格是1×1×1，水塘的长度为N，宽度为1，在第i位置，大树放了ai个石头</p><p>设大树建造的水塘蓄水量为V</p><p>请你求出在长度和宽度不变的情况下，建造一个蓄水量不小于V的水塘最多可以节约多少石头</p><p>输入格式<br>单组输入</p><p>第一行一个数N  (1≤N≤1e7)表示水塘的长度</p><p>第二行有N个非负数xi  (0≤xi≤100)，表示第i个位置上放的石头数</p><p>输出格式<br>输出有两行</p><p>第一行输出大树建造的水塘的蓄水量V</p><p>第二行输出最多可以节约多少石头</p><p>样例<br>input<br>5<br>2 1 3 1 3<br>output<br>3<br>8<br>提示<br>大树的水塘长这样：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190811094947.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190811094947.webp" class="img-shadow img-margin"></center></a><br>最节约石头的水塘长这样：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190811094959.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190811094959.webp" class="img-shadow img-margin"></center></a><br>Problem solving:<br>这道题看提示应该就能明白了。就是宽度是固定的为1，然后告诉你每个地方石头的高度，问你它的存水量以及能节省的最大的石头数。</p><p>这道题我们可以直接考虑每个位置的蓄水量然后累加。找到当前位置左右两边分别能达到的最高的位置，两个最高位置的最小值减去当前位置的高度就是当前位置可以达到的蓄水量。但是1e7的数据，如果直接暴力N^2的复杂度，两秒也会超时。所以我们可以构建一个前n项最大值的数组和后n项最大值的数组，然后以O(N)的复杂度处理这个问题。</p><p>这个数组跟前缀和数组是一种思想，因为当我们计算当前位置的蓄水量的时候所需要的时从当前位置分别到最左端和最右端的最大值，现在假设l[i]是前n个数的最大值，r[i]存的是后n个数的最大值，那么i位置两边所能达到的最大高度就是l[i]和r[i]。所以当前位置的蓄水量v就等于v=min(l[i],r[i])-a[i]，a[i]就是当前位置的高度。</p><p>蓄水量求出来了，节省的最多的石头个数也就简单了。这也有一点贪心的思想，我们只在两边放石头，中间全部用来存水。求出这种情况下需要的石头个数，用之前的石头的总个数减去这个需要的石头个数就是最大能节省的石头个数。</p><p>还有一个坑点就是计算需要石头的个数的时候别忘了向上取整。</p><p>Code:</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 1e7 + 10;ll       a[maxn], l[maxn], r[maxn];int main(){    ll n, sum = 0;    scanf(&quot;%lld&quot;, &amp;n);    for (ll i = 0; i &lt; n; i++)    {        scanf(&quot;%lld&quot;, &amp;a[i]);        sum += a[i];    }    l[0] = a[0]; r[n - 1] = a[n - 1];    for (int i = 1; i &lt; n; i++)        l[i] = max(l[i - 1], a[i]);    for (int i = n - 2; i &gt;= 0; i--)        r[i] = max(a[i], r[i + 1]);    int ans = 0;    for (int i = 0; i &lt; n; i++)    {            ans += min(l[i], r[i]) - a[i];    }    int ans2 = ceil(ans * 1.0 / (n - 2));    printf(&quot;%d\n%d&quot;, ans, sum - ans2 * 2);}</code></pre><p>这道题卡了我2个小时也没做出来，后来才知道题意理解错了，我。。。</p><h2 id="幸运素数"><a href="#幸运素数" class="headerlink" title="幸运素数"></a>幸运素数</h2><p>Description:<br>跳皮筋 我第一，马兰开花二十一；</p><p>二五六 二五七，二八二九三十一；</p><p>三五六 三五七，三八三九四十一；</p><p>......</p><p>童谣《马兰花》作为建国以来最大的数学难题，里面数字的含义困扰了全国人民几十年，并且一直未解</p><p>难道这些数字真的只是为了押韵生搬硬凑的数字吗？</p><p>并！不！是！</p><p>经过wzy的多年研究，他发现了里面潜藏的惊天大秘密（并没有）：</p><p>28=256，而257是离256最近的素数</p><p>28是第二个完美数，29是离28最近的素数</p><p>31是第四个幸运素数</p><p>仅仅这一句话中，就出现了二进制、素数、完美数、幸运数！</p><p>这哪里是童谣？这分明就是中国版的达芬奇密码！</p><p>今天wzy就来考考你《马兰花》里出现的数学知识：</p><p>幸运数是经由类似埃拉托斯特尼筛法的演算法后留下的整数集合，是在1955年波兰数学家乌拉姆提出。</p><p>由一组由1开始的数列为例：</p><p>1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25, …<br>先将所有偶数删去，只留下奇数：</p><p>1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25,…<br>然后把数列中的第 2 个数字(设该数字为 x )的倍数对应的数删除，即把所有第 nx,x∈Z+ 个数删除，例如上述例子中，第 2 数字是 3 ，所以删去所有第 3n 个数：</p><p>1, 3, 7, 9, 13, 15, 19, 21, 25,…<br>新数列的第 3 项(每次都加上 1 )为 7 ，因此将新数列的第 7n 个数删除：</p><p>1, 3, 7, 9, 13, 15, 21, 25,…<br>若一直重复上述的步骤，最后剩下的数就是幸运数</p><p>（以上内容来自维基百科幸运数）</p><p>我们将既是幸运数又是素数的数叫做幸运素数</p><p>现在给你一个数N，请判断N是否是一个幸运素数</p><p>输入格式<br>第一行一个数T，代表有T个数(1≤T≤2×1e5)</p><p>第1∼T行，每行一个正整数N(1≤N≤2×1e5)</p><p>输出格式<br>对于每个输入的数N，如果N是幸运素数，输出Yes，否则输出No</p><p>样例<br>input<br>3<br>1<br>2<br>3<br>output<br>No<br>No<br>Yes<br>Problem solving:<br>这道题的难点就在于模拟那个幸运数的生成过程吧。涉及到删除操作，本来我也想到用标记解决，但是没实现出来，就放弃了。</p><p>看了学长代码。发现学长用了vector来写，因为vector中有个函数叫erase。还是很方便的。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;vector&lt;int&gt; ve;int vis[maxn],via[maxn];void init()//生成幸运数{    ve.push_back(0);    for(int i=1;i&lt;maxn;i+=2)        ve.push_back(i);    int res=ve[2];    int len=ve.size(),cnt=2;    while(res&lt;=len)    {        for(int i=1;i*res&lt;=len;i++)            ve[i*res]=0;        for(auto it=ve.begin()+1;it!=ve.end();)        {            if(*it==0)  it=ve.erase(it);            else    it++;        }        len=ve.size();        if(res==ve[cnt])            cnt++;        res=ve[cnt];    }    for(int i=0;i&lt;ve.size();i++)        via[ve[i]]=1;}void init2()//素数打表{    vis[0]=vis[1]=1;    for(int i=2;i&lt;=maxn;i++)    {        if(!vis[i])        for(int j=2;j*i&lt;=maxn;j++)            vis[i*j]=1;    }}int main(){    init();init2();    int t,n;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d&quot;,&amp;n);        if(!vis[n]&amp;&amp;via[n])            puts(&quot;Yes&quot;);        else            puts(&quot;No&quot;);    }}</code></pre><h2 id="NO-GAME-NO-Life"><a href="#NO-GAME-NO-Life" class="headerlink" title="NO GAME NO Life"></a>NO GAME NO Life</h2><p>Description:<br>空白，永不败北！</p><p>作为世界的唯一神灵，游戏之神特图的日常就是改变自己的外表，在世界各地游荡</p><p>在被空和白在一次网上的国际象棋比赛击败后，他以拯救人类种的名义将兄妹二人召唤到迪斯博德</p><p>来到迪斯博德的空白，常常因为在游戏上找不到对手而感到无聊</p><p>在风和日丽的一个下午，空白出门视察国情，在路上偶遇了扮成人类种闲逛的特图，特图为了打发时间，决定向空白发起挑战，游戏内容如下：</p><p>在一棵有着N个节点的树上，第i个节点上有xi颗钻石，由最先开始的一方选择一个节点进行标记，标记完成后，双方轮流进行如下操作：拿走标记节点的一颗钻石，并将标记移至与当前节点直接相连的节点，至到出现无法拿石子的一方停止。</p><p>空白兄妹听完游戏规则后，立刻做出了回应，但前提是空白作为先手选择节点</p><p>特图自认为这是一个特别公平的游戏，所以就答应了这个要求</p><p>每当一棵树出现后，空白凭借超人的数学能力，能够在一秒内快速判断出能否获胜</p><p>输入格式<br>单组输入，第一行一个正整数N (2≤N≤1e6)，表示这棵树有N个节点</p><p>第二行有N个正整数xi (1≤xi≤100)，表示i节点上有xi颗钻石</p><p>接下来N−1行，每行两个整数x,y (1≤x,y≤N)，表示节点x与节点y相连</p><p>输出格式<br>如果空白可以获胜，输出Blank</p><p>否则输出Teto</p><p>样例<br>input<br>2<br>1 1<br>1 2<br>output<br>Teto<br>input<br>2<br>1 2<br>1 2<br>output<br>Blank</p><p>Problem solving:<br>这道题的意思就是有一个树，每个节点都有一个值代表这个地方的硬币个数，先手的那个人选择一个节点并拿走一枚硬币，然后下一个人就需要从这个节点能直接到达的节点拿走一颗硬币，最后无法再拿硬币的人获胜。</p><p>这算是个思维题把，学长不讲也想不到原来是这样写的，就是如果每个节点d的值都相等的话，先手是必败的，反之先手必胜。</p><p>Code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,a,sum,u,v,flag=0,now;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    {        scanf(&quot;%d&quot;,&amp;a);        sum+=a;        if(!i) now=a;        else if(a!=now)            flag=1;    }    for(int i=0;i&lt;n-1;i++)    {        scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    }    if(!flag)    puts(&quot;Teto&quot;);    else    puts(&quot;Blank&quot;);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Thinking </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 25（河南理工大学暑期第二十五天）</title>
      <link href="/2019/08/11/newthe/"/>
      <url>/2019/08/11/newthe/</url>
      
        <content type="html"><![CDATA[<p>早就有换主题的想法，但是因为之前魔改的太多，换主题的话会非常麻烦。</p><p>可我终究还是没有抵挡住这个主题的诱惑，顺便直接取消了之前的引导页。</p><p>总结一下。</p><p>2019.8.10  16:00    看上了这个主题，并开始着手了解下载</p><p>2019.8.10  19:00    除文章外，已基本修改好了自己想要的亚子</p><p>2019.8.11  2:00     把所有文章修改完并放入文章列表。</p><p>2019.8.11  3:50     取消了原来的引导页，直接将主题设为了主页。</p><p>目前还未实现的功能</p><ol><li>本地搜索还未实现。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10 or Win7 下下载并配置gcc/g++编译环境</title>
      <link href="/2019/08/10/super/"/>
      <url>/2019/08/10/super/</url>
      
        <content type="html"><![CDATA[<p><center>前排提示<br>————————————————————————————————<br>本文更于2019.8.7，如果某些地方与最新的某些东西细节上有出入，请自行圆润的解决。若无法解决，请联系我。</center></p><h3 id="安装gcc-g"><a href="#安装gcc-g" class="headerlink" title="安装gcc/g++"></a>安装gcc/g++</h3><p>无论是win7还是win10，在前面都是一样的<br>首先你需要去官网下载<code>mingw-get-setup.exe</code><br>点此前去下载: <a href="https://osdn.net/projects/mingw/releases/" target="_blank" rel="noopener">MinGW-download</a><br>如图，点击这个下载即可。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/VJWYNHL47%25SQZ%29C_BC0X%25%606.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/VJWYNHL47%25SQZ%29C_BC0X%25%606.webp" class="img-shadow img-margin"></center></a><br>下载之后直接打开会出现这样的框框<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/05%7DL~@%28G$_%296FGD9N4GR3WX.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/05%7DL~@%28G$_%296FGD9N4GR3WX.webp" class="img-shadow img-margin"></center></a><br>接下来这一步就很简单，无脑install或者无脑next就行啦。<br>但是这一步必须得说一下<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/UJF%60YGEW~4%608PF%7BL%281%5BUN1R.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/UJF%60YGEW~4%608PF%7BL%281%5BUN1R.webp" class="img-shadow img-margin"></center></a><br>这个安装路径如果要修改的话，一定要记住你修改到哪里了，路径一定要清楚。如果是真小白，推荐不修改直接无脑next。</p><p>然后就是一波等待，等到进度条跑完的时候，点continue。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lm.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lm.webp" class="img-shadow img-margin"></center></a></p><p>然后就会自己弹出来<code>MinGW Installation Manager</code>的窗口。<br>如果你只是为了配置gcc/g++的编译环境，选上<code>mingw32-gcc-g++-bin</code>,或者右键选择&#39;mark for installation&#39;.<br>这里因为我已经安装过了，所以显示的是已安装的样子。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/xz.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/xz.webp" class="img-shadow img-margin"></center></a></p><p>选择好之后，点击左上角的Installation，然后选择apply changes.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/ins.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/ins.webp" class="img-shadow img-margin"></center></a></p><p>这一步直接apply即可。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/AN4X6$%29YPFF4%5DDM9%7DHC74WF.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/AN4X6$%29YPFF4%5DDM9%7DHC74WF.webp" class="img-shadow img-margin"></center></a></p><p>然后就又是等待进度条啦,等他全部安装完，这一步就结束了。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>这一步很重要。确实也有很多人会卡在这里</p><h4 id="Win7版本"><a href="#Win7版本" class="headerlink" title="Win7版本"></a>Win7版本</h4><p>右键我的电脑点击属性，然后找到左上角的高级系统设置，点开之后点击右下角的环境变量。如图：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/hj1.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/hj1.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/hj2.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/hj2.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/hj3.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/hj3.webp" class="img-shadow img-margin"></center></a><br>在环境变量的下面的系统变量里面找到&#39;path&#39;,点击编辑<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/hj4.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/hj4.webp" class="img-shadow img-margin"></center></a><br>然后会弹出这样的框框<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/hj5.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/hj5.webp" class="img-shadow img-margin"></center></a><br>如果你之前没有配置过的话，后面是不会有<code>C:\MinGW\bin</code>的，你要做的就是把这个加上去。<br><code>C:\MinGW\bin</code>把这个加到最后面，如果你是换了安装路径的话这里就填上你的路径，路径就是你的MinGW文件夹下的bin文件夹。这里还有一点需要注意的是，Win7的系统变量里面是以<code>;</code>分隔得，所以如果你在加之前发现最后面没有分号，一定要加上个自己分号，再加上自己的路径。注意：分号很重要<font color="red">!!!</font><br>加好之后无脑确认就好了。<br>然后出来可以去cmd检测一下有没有配置成功。<br>快捷键<code>Win+r</code>打开运行框框输入<code>cmd</code><br>然后在cmd中输入<code>gcc -v</code>，如果成功的出现了版本信息，就说明这一步你已经成功了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/hj6.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/hj6.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/hj7.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/hj7.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/hj8.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/hj8.webp" class="img-shadow img-margin"></center></a></p><h4 id="Win10-版本"><a href="#Win10-版本" class="headerlink" title="Win10 版本"></a>Win10 版本</h4><p>win10的话其实跟win7差不多。唯一不一样的就是添加环境变量的时候比win7方便很多。<br>可以直接添加而不用加分号什么的了。<br>如图直接点击添加即可。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190807221820.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190807221820.webp" class="img-shadow img-margin"></center></a><br>其余的就都一样啦。</p><p>如果失败了，请仔细检查以下几点</p><ol><li>MinGW/bin的文件夹路径是否正确</li><li>添加环境变量的地方分号有没有加(Win7的情况下)<br>如果这几步都是正确的却还是配置失败，欢迎联系我。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果上面两步你都已经配置好了，那么恭喜你，你已经可以使用绚丽的文本编辑器作为你写c/c++的IDE了。只需要下载各种编辑器对应的插件然后进行配置就行啦。新世界等着你。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> atom </tag>
            
            <tag> MinGW </tag>
            
            <tag> gcc </tag>
            
            <tag> g++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU算法协会一二年级联合训练赛(Day 24)</title>
      <link href="/2019/08/09/sadcon/"/>
      <url>/2019/08/09/sadcon/</url>
      
        <content type="html"><![CDATA[<p>13道题，全是英文题，懒得没拿词典，后来才知道可以用电子词典(当然正经比赛里面是不可以的。先写一下我做出来的题解在总结吧。</p><h3 id="MaratonIME-helps-Pablito"><a href="#MaratonIME-helps-Pablito" class="headerlink" title="MaratonIME helps Pablito"></a>MaratonIME helps Pablito</h3><p>Description:<br>♬ Caloventor tiene miedo... ♬<br>Benedetto, Nathan<br>As is well known by any cultured person, rats are the smartest beings on earth. Followed directly by dolphins.</p><p>MaratonIME knows about the species hierarchy and uses this knowledge in it&#39;s regard. Usually, when they need some resource, they know it&#39;s always useful to have a smart rat available. Unfortunately, rats are not very fond of us, primates, and will only help us if they owe us some favour.</p><p>With that in mind, MaratonIME decided to help a little rat called Pablito. Pablito is studying rat&#39;s genealogy, to help with cloning and genetic mapping. luckily, the way rats identify themselves make the job much easier.</p><p>The rat society is, historically, matriarchal. At first, there were little families, each of which had it&#39;s own leading matriarch. At that time, it was decided that rats would organize themselves according to the following rules:</p><p>Each martiarch had an id number greater than one.<br>Each of these ids were chosen in a way such that they would have the least amount of divisors possible.<br>Each family member had the same id as the matriarch.<br>The id of any newborn rat would be the product of its parents id&#39;s.<br>For instance, the offspring of a rat with id 6 and another with id 7 is 42.</p><p>Pablito needs to know if two given rats have a common ancestor, but his only tool is the id number of each of the two rats, which is always a positive integer greater than 1 with no more than 16 digits. Can you help him?</p><p>Create a program that decides if a pair of rats have some common ancestor.</p><p>Input</p><blockquote><p>The input begins with a positive integer t ≤ 105, the number of test cases.<br>After that, follows t lines, each with two integers ai e bi identifying two rats.<br>Every rat&#39;s id is a positive integer greater than 1 and with no more than 16 digits.</p></blockquote><p>Output</p><blockquote><p>For each test case, print &quot;Sim&quot; if the rats ai and bi share a common ancestor and &quot;Nao&quot; otherwise.</p></blockquote><p>Example<br>Input</p><blockquote><p>2<br>2 4<br>3 5</p></blockquote><p>Output</p><blockquote><p>Sim<br>Nao</p></blockquote><p>Problem solving:<br>这道题我没看太懂意思。<br>题意好像就是如果两个数gcd不为1的话就说明有相同的祖先。</p><p>看着样例感觉像是简单题，看了一下一血时间，准备试一下gcd，然后，就过了。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){    long long n,a,b;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;a&gt;&gt;b;        if(__gcd(a,b)==1)    puts(&quot;Nao&quot;);        else    puts(&quot;Sim&quot;);    }}</code></pre><h3 id="MaratonIME-plays-Cirokime"><a href="#MaratonIME-plays-Cirokime" class="headerlink" title="MaratonIME plays Cîrokime"></a>MaratonIME plays Cîrokime</h3><p>Description:<br>Have you ever seen flavored vodka?<br>Everaldo, Glauber<br>The MaratonIME members like to have fun. As they enjoy having fun so much, they have invented a game named &quot;Cîrokime&quot;. The game works as follows:</p><p>First, n cups with Cîroc1 are lined up. In front of the i-th cup a number ai is written. It is guaranteed that ai &lt; ai + 1, for all 1 ≤ i &lt; n. Then, the numbers are covered and the game starts.</p><p>The player must then find the cup that has a certain number x. It is guaranteed that this cup exists. For this, he has to choose a cup i and drink the beverage. Then, the cup&#39;s number ai is revealed and if this number is equal to x the game finished. Otherwise, the player has to choose another cup and so on.</p><p>&quot;Cîrokime&quot; is a traditional game among MaratonIME members, they play it every party. At the last party, Sussu had to drink all of the n cups because he found the right cup only at the end. He got sick for drinking so much and had to be carried home3</p><p>However, the DESMAME4 is scheduled for May 13 and Sussu wants to restore his dignity. For this, he wants to know, in the worst case, what is the maximum number of cups that he will have to drink if he plays in the optimal way.</p><p>Input</p><blockquote><p>The first line has a single integer n, the number of cups. The second line has n integers ai, the values hidden in each cup.<br>1 ≤ n ≤ 1e5<br>For all i, 1 ≤ ai ≤ 1e9<br>For i &lt; n, ai &lt; ai + 1</p></blockquote><p>Output</p><blockquote><p>The output has a single line with a single integer: the minimum number of cups that Sussu should drink, in the worst case, if he plays in the optimal way.</p></blockquote><p>Examples<br>Input</p><blockquote><p>3<br>2 5 7</p></blockquote><p>Output</p><blockquote><p>2</p></blockquote><p>Input</p><blockquote><p>8<br>1 2 3 4 5 6 7 8</p></blockquote><p>Output</p><blockquote><p>4</p></blockquote><p>Note</p><blockquote><p>1: Cîroc is a vodka brand made in France, known by its high sales price in market2<br>2: Balalaika also works<br>3: Based on real facts<br>4: Pre-BIFE5 party<br>5: University games that IME6 attends<br>6: Institute of Mathematics and Statistics</p></blockquote><p>Problem solving:<br>这道题其实就是个猜数问题。问你在最差的情况下需要猜几次。</p><p>题意知道了，就很简单了，答案只跟n有关，中间的数都没用。看n可以除以2几次，就是答案。<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n,a;    scanf(&quot;%lld&quot;,&amp;n);    for(int i=0;i&lt;n;i++)    scanf(&quot;%lld&quot;,&amp;a);    ll ans=0;    while(n)    {        n/=2;        ans++;    }    printf(&quot;%lld\n&quot;,ans);}</code></pre><h3 id="MaratonIME-plays-Nim"><a href="#MaratonIME-plays-Nim" class="headerlink" title="MaratonIME plays Nim"></a>MaratonIME plays Nim</h3><p>Description:<br>Ai Fox!<br>UnionFind, Germano<br>You open your eyes, but everything remains dark. The world is dark, and everything shakes. You realize you are locked in, but before desperation takes hold, you hear the door opening and the light invades your sight and blinds you for a few moments.</p><p>They help you out, you had been locked inside a trunk. You don&#39;t know the masked faces before you, but remember that in the last competitive programming practice they told you that &quot;the beginning is yet to come&quot;. &quot;So this is the fabled MaratonIME&#39;s initiation challenge&quot;, you had heard rumors of this event, and you feel honored to be chosen.</p><p>After walking into and abandoned building, they sit you on an old chair. The first test is to watch a soccer game without any show of excitement. Easy. The second is to install Linux on a notebook in less than 5 minutes. You were prepared, carrying the Arch Linux pendrive as usual, just in case. You face more tests, and manage to pass all of them despite a few difficulties.</p><p>Hours go by, the members remove their masks, and each take a coin out of their pocket. &quot;I won! And I even got rich&quot; you think, but realize they place the coins in a table in front of you, divided in two piles. Renzo, MaratonIME&#39;s great boss, takes a chair and sits in front of you. You will play a match of Nim, and if you win you will become an honorary member of MaratonIME, that is, you win a balloon.</p><p>Nim is a game of two players, alternating their turns. Two piles of coins are placed on a table and in each turn you can remove any non zero quantity of coins from one of the piles. The last player to take their turn (leaving both piles empty) wins.</p><p>You start the game. So it would not be unfair, it is guaranteed that it is possible for you to win. Write a program than beats Renzo 100% of the time.</p><p>Input</p><blockquote><p>In the first line, two integers, x and y, the size of the piles, such that 0 ≤ x, y ≤ 1e4. It is guaranteed that you can win the game.</p></blockquote><p>Interaction</p><blockquote><p>In your turn, print two integers, i and x, where i is the number of the pile from which you will remove the coins (), and x is the number of coins you will remove (x ≥ 1, such that i has at least x coins).<br>In Renzo&#39;s turn, read two integers, in the same format as in your turn.</p></blockquote><p>Example<br>Input</p><blockquote><p>2 1<br>1 1</p></blockquote><p>Output</p><blockquote><p>1 1<br>2 1</p></blockquote><p>Note</p><blockquote><p>Of course we do not do an initiation challenge like this :P<br>In the example, we have a pile with 2 coins and another with 1. You remove 1 coin from the first pile, and now no matter what coin Renzo removes, you can remove the other and win.<br>Remember, after printing your play, flush the output, like: fflush(stdout); in C, cout.flush(); in C++, or sys.stdout.flush() in Python.</p></blockquote><p>Problem solving:<br>据说是nim博弈，毫无思路。<br>以后再补吧。。。</p><p>Code:</p><pre><code>/** *　　　　　　　　┏┓　　 　┏┓ * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　 　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　... 　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛ */// warm heart, wagging tail,and a smile just for you!////                            _ooOoo_//                           o8888888o//                           88&quot; . &quot;88//                           (| -_- |)//                           O\  =  /O//                        ____/`---&#39;\____//                      .&#39;  \|     |//  `.//                     /  \|||  :  |||//  \//                    /  _||||| -:- |||||-  \//                    |   | \\  -  /// |   |//                    | \_|  &#39;&#39;\---/&#39;&#39;  |   |//                    \  .-\__  `-`  ___/-. ///                  ___`. .&#39;  /--.--\  `. . __//               .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |//              \  \ `-.   \_ __\ /__ _/   .-` /  ///         ======`-.____`-.___\_____/___.-`____.-&#39;======//                            `=---=&#39;//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//</code></pre><h3 id="MaratonIME-plays-Chess"><a href="#MaratonIME-plays-Chess" class="headerlink" title="MaratonIME plays Chess"></a>MaratonIME plays Chess</h3><p>Description:<br>This problem is boring as duck.<br>Kawakami, Marcos<br>Our dear Nathan, when a little child, used to like chess a lot, but this was a long time ago. One of these days he was challenged by @luisgust to a chess match and, as he is a guy that likes hard challenges, he accepted it. The problem is that Nathan keeps forgetting the rules of the game, so he asked you to help him determine if a given opponent&#39;s piece can be captured in one move.</p><p>Chess, in MaratonIME, is represented as a matrix of characters. Instead of playing with black and white pieces, they play with uppercase and lowercase letters. Nathan has chosen to play with the lowercase letters.</p><p>Besides that, as usual, the positions on the matrix are given in the following coordinates system: Each position is a pair with a character between a and h (inclusive), representing the column, and an integer between 1 and 8 (inclusive), representing the row. For exemple, the position d2 refers to the fourth column (from left to right) and second row (from bottom to top), and the position f6 refers to the sixth column and sixth row. Lowercase letters start on the bottom of the grid, on lines 1 and 2.</p><p>Here position A is adjacent position B if A shares a vertex with B, that is, if the distance between their rows is at most one and the distance between their columns is at most one. For example, the position c4 is adjacent to 8 positions: b3, b4, b5, c3, c5, d3, d4 and d5.</p><p>They decided to play a simplified version of chess. To help you, they gave you the following manual on how to play it:</p><p>The pawn, represented by p or P, can capture pieces that share a diagonal and is in front of it, that is, the lowercase pawn on c4 can capture pieces at b5 or d5.<br>The knight, represented by c or C, makes L-shaped moves in any of the 8 possible directions, that is, it moves two positions in any direction and after that one position in a direction that is perpenticular to the first one. A knight on c4 can capture, in one move, pieces on positions a3, a5, b2, b6, d2, d6, e3 and e5.<br>The rook, represented by t or T, can capture pieces that are on the same row or the same column as it, as long as no other piece lies between them. For example, a rook on c4 can capture any piece on column c or row 4, as long as there is no other piece in between. If the rook is on c4 and there is another piece on c6, the rook can&#39;t capture pieces on c7 and c8.<br>The bishop, represented by b or B, can capture any piece on one of its diagonals as long as there are no piece between them (diagonaly). For example, the bishop on c4 can capture a piece on f7 as long as there are no piece on d5 and e6.<br>The queen, represented by r or R, can capture any piece that lies on the same row, column or diagonal, given there are no pieces in between, as if it were a bishop and a rook at the same time.<br>The king, represented by k or K, can capture any piece that is adjacent to it.<br>The character . represents an empty position.<br>Given a matrix representing a chess board and an opponent&#39;s piece, your program needs to determine whether you can capture it with one of your pieces. It is guaranteed that each player has at most two bishops, two rooks, two knights, eight pawns, one king and one queen.</p><p>Input</p><blockquote><p>The input begins with 8 lines with 8 characters each, representing the chess board. The first line contains the characters on the positions a8, b8, ... , h8. The second line contains the characters on positions a7, b7, ... , h7, and so on. After that follows a line containing the position of the opponent&#39;s piece you wish to capture.</p></blockquote><p>Output</p><blockquote><p>Print a single line containing the word Sim if it is possible to capture the piece or Nao otherwise.</p></blockquote><p>Examples<br>Input</p><blockquote><p>TCBRKBCT<br>PPPPPPPP<br>........<br>........<br>........<br>........<br>pppppppp<br>tcbrkbct<br>d8</p></blockquote><p>Output</p><blockquote><p>Nao</p></blockquote><p>Input</p><blockquote><p>........<br>........<br>........<br>..R.....<br>...p....<br>........<br>........<br>........<br>c5</p></blockquote><p>Output</p><blockquote><p>Sim</p></blockquote><p>Problem solving:<br>毫无思路题。</p><p>Code:</p><pre><code>/** *　　　　　　　　┏┓　　 　┏┓ * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　 　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　... 　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛ */// warm heart, wagging tail,and a smile just for you!////                            _ooOoo_//                           o8888888o//                           88&quot; . &quot;88//                           (| -_- |)//                           O\  =  /O//                        ____/`---&#39;\____//                      .&#39;  \|     |//  `.//                     /  \|||  :  |||//  \//                    /  _||||| -:- |||||-  \//                    |   | \\  -  /// |   |//                    | \_|  &#39;&#39;\---/&#39;&#39;  |   |//                    \  .-\__  `-`  ___/-. ///                  ___`. .&#39;  /--.--\  `. . __//               .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |//              \  \ `-.   \_ __\ /__ _/   .-` /  ///         ======`-.____`-.___\_____/___.-`____.-&#39;======//                            `=---=&#39;//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//</code></pre><h3 id="MaratonIME-rides-the-university-bus"><a href="#MaratonIME-rides-the-university-bus" class="headerlink" title="MaratonIME rides the university bus"></a>MaratonIME rides the university bus</h3><p>Description:<br>If we organize it correctly, ...<br>Unknown<br>To make the trip to the subway less boring and tiring, the SPSU, Sao Paulo State University, tried one of its most famous inventions: buses with Infinite Inner Length! In such a modern engineering wonder, there&#39;s always a couple of empty seats for the students to sit and chat during the trip.</p><p>MaratonIME crew is very popular, so popular that they have friends at every SPSU institute. Like everyone else from this university, they need to take the bus after a long day learning how to fix the Wi-Fi network. Because they don&#39;t practice sports like rowing, every SPSU student sits right after entering the bus, making pairs whenever possible. Thinking about that, Gi, an ICPC expert, comes with a problem to think on the way to the subway: given a number n which indicates the number of institutes at SPSU and n integers ai representing the amount of people waiting for the bus at the institute i, Gi wants to know for m pairs lj, rj (lj ≤ rj) if all the people waiting for the bus at any point between lj e rj (inclusive) took an empty bus, they could sit together in pairs (nobody would sit alone).</p><p>Input</p><blockquote><p>The input consist in one line with two integers n and m, the number of institutes and the number of Gi&#39;s questions. In the second line there are n integers ai, the number of people waiting for the bus at the ith institute. Then follows m lines with two integers each, li and ri, the first and last institute of Gi&#39;s question.<br>1 ≤ n, m ≤ 1e5<br>0 ≤ ai ≤ 1e5<br>1 ≤ li ≤ ri ≤ n</p></blockquote><p>Output</p><blockquote><p>Output &quot;Sim&quot; if it is possible to organize all the pairs in a way nobody sits alone or &quot;Nao&quot; otherwise.</p></blockquote><p>Example<br>Input</p><blockquote><p>5 2<br>1 4 10 3 2<br>3 5<br>2 3</p></blockquote><p>Output</p><blockquote><p>Nao<br>Sim</p></blockquote><p>Note</p><blockquote><p>In the first sample we have 5 institutes with 1, 4, 10, 3 and 2 students. Gi asks if it is possible to form only couples if the ones between the 3rd and the 5th institutes takes an empty bus and the ones between the 2nd and the 3rd. For the first we have 15 so we can&#39;t and for the second we have 14 so we can.</p></blockquote><p>Problem solving:<br>这道题的意思就是给你一组数，问你第i个数到第j个数的和的奇偶。</p><p>不知道直接查询会不会超时，但是我用了前缀和数组。也算是个简单题吧。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[213344],b[213344];int main(){    ll n,m,x,y;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];    b[0]=a[0];    for(int i=1;i&lt;n;i++)    b[i]=b[i-1]+a[i];    while(m--)    {        cin&gt;&gt;x&gt;&gt;y;        x--,y--;        if((b[y]-b[x-1])%2!=0)    puts(&quot;Nao&quot;);        else    puts(&quot;Sim&quot;);    }}</code></pre><h3 id="MaratonIME-attends-the-lecture-or-not"><a href="#MaratonIME-attends-the-lecture-or-not" class="headerlink" title="MaratonIME attends the lecture (or not)"></a>MaratonIME attends the lecture (or not)</h3><p>Description:<br>Has the prof taken attendance yet?<br>Student, IME&#39;s<br>In MaratonIME, as many other groups, some students want to attend lectures just enough to not be flunked by frequency (as we know, in USP, University of Sao Paulo, it is necessary to have 70 percent frequency), however some others are dedicated and try to accomplish the most frequency percent possible, going to school even when they are ill or tired. Curiously, there is not any other kind of students in MaratonIME.</p><p>Wood, an old MaratonIME&#39;s member, needs help. He is taking the course MAC4815162342, and attended k of m lectures that were given. Consider that MAC4815162342 has n lectures in total per semester. He ask you to help finding the best way to accomplish his objectives, but, as you are new in MaratonIME, you don&#39;t know the kind of student that he is. Embarassed to ask more, you decide to solve two problems, so there is not way to go wrong.</p><p>Input</p><blockquote><p>The input consists of a just one line. In this line, you are given three integers n, m and k, with 1 ≤ n ≤ 1e7 and 0 ≤ k ≤ m ≤ n.<br>n is the number of lectures of MAC4815162342 per semester, m is the quantity of lectures that were given and k is the number of lectures attended by Wood.</p></blockquote><p>Output</p><blockquote><p>In the first line, print the minimum number of lectures that Wood needs to attend to accomplish at least 70% frequency, or  - 1 if it is impossible to accomplish 70% frequency.<br>In the second line, print the maximum frequency percent that Wood can accomplish, if he goes to all of the lectures from the next lecture. This value has to be rounded down to the closest integer. Don&#39;t print &#39;%&#39;.</p></blockquote><p>Examples<br>Input</p><blockquote><p>10 5 2</p></blockquote><p>Output</p><blockquote><p>5<br>70</p></blockquote><p>Input</p><blockquote><p>11 2 1</p></blockquote><p>Output</p><blockquote><p>7<br>90</p></blockquote><p>Note</p><blockquote><p>On the second example, the maximum percentage that Wood can get is 90.9090.</p></blockquote><p>Problem solving:<br>这道题意思就是有一门课本学期只上n节，现在已经上了m节，这个同学m节里面只去了k节，问你他还能不能达到70%的出勤率，如果不能输出-1，如果可以输出他最少再去上几次课就可以达到70%，然后输出他能达到的最大的出勤率。</p><p>题挺简单的，最大出勤率也好算，就是(n-m+k)/n<br>还有个坑点就是你需要先判断一下他现在的出勤率是不是已经够了。这个也可以不处理，就像我用的那个max一样也行。</p><p>但是这道题我WA了n发，因为这个题它对精度要求比(ka)较(jing)高(du)。</p><p>这里涉及到高精度，我就想到用python写了，其实c++一样的</p><p>Code:</p><pre><code class="lang-python">a,b,c=input().split()a=eval(a)b=eval(b)c=eval(c)x=a-by=int((a*70+99)/100)   #精度问题z=y-cif x&lt;z:    print(&quot;-1&quot;)else:    print(max(0,int(y)-c)) #处理如果当前出勤率已经到了%70的情况ans=int((x+c)*100/a)print(ans)</code></pre><h3 id="MaratonIME-goes-rowing"><a href="#MaratonIME-goes-rowing" class="headerlink" title="MaratonIME goes rowing"></a>MaratonIME goes rowing</h3><p>Description:<br>Speed down, Colombooo!!!<br>rowing coach, Gabi<br>As common sense tells us, competitive programmers excel at rowing. The olympic lane is a wonderful place to row, run and work out. What few take their time to appreciate are the capybaras that inhabit the region. Capybaras are fascinating animals! Aside from their beauty, they possess many interesting behaviours. Did you know that capybaras can live in packs as big as 100 individuals?</p><p>In a pleasant sunny morning, Yan was running, as usual. Watching the capybaras, he noticed that they would line up to sunbath. Each capybara was paired with another one, and only another one. Two capybaras can be paired if and only if both see each other. A capybara sees everything in the direction it is looking.</p><p>Curious, Yan decided to represent the capybaras by the letters A and B, where A indicates that the capybara is looking right, and B indicates that the capybara is looking left.</p><p>For example, the sequence AABABB accurately represents capybaras sunbathing, because it is possible to pair every capybara according to the rules above. Yan was so fascinate by this that he slipped and felt into the water, messing his representations. He was able to recover some, but now they are all messed up with each other. Can you help him and find out if a given sequence represent capybaras sunbathing?</p><p>Input</p><blockquote><p>Every instance contains a sequence S of characters, composed only of &#39;A&#39; and &#39;B&#39; – Yan&#39;s representation. You may assume that 1 ≤ |S| ≤ 105.</p></blockquote><p>Output</p><blockquote><p>The output should contain a single line. Print &quot;Sim&quot; if the sequence represents capybaras sunbathing, or &quot;Nao&quot; otherwise.</p></blockquote><p>Example<br>Input</p><blockquote><p>AABABB</p></blockquote><p>Output</p><blockquote><p>Sim</p></blockquote><p>Problem solving:<br>这道题的意思就是一个a能和一个b能配对。但必须是a在左面b在右面，给你一串字符串问你可不可以全部配对。</p><p>这道题跟括号匹配很像，用一个栈实现就行了。</p><p>然后，，我比赛时候没想到，也不知道咋想到一个很zz的贪心算法，现在仔细一想才发现是错的，关键是。。还过了。。。数据水了吧。(我打败了它，滑稽</p><p>Code:<br>这是我的水过的代码</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    string s;    int x=0,y=0;    cin&gt;&gt;s;    if(s[0]==&#39;B&#39;||s[s.size()-1]==&#39;A&#39;)        puts(&quot;Nao&quot;);    else    {        for(int i=0;i&lt;s.size();i++)        {            if(s[i]==&#39;A&#39;)x++;            else y++;        }        if(x!=y)    puts(&quot;Nao&quot;);        else    puts(&quot;Sim&quot;);    }    return 0;}</code></pre><p>这是一血大佬<a href="https://blog.csdn.net/cloudy_happy" target="_blank" rel="noopener">cloudy_happy</a>的代码</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longtypedef pair&lt;int,int&gt; pii;int main(){    ios::sync_with_stdio(false);    string s;    cin&gt;&gt;s;    stack&lt;int&gt; st;    for (int i = 0;i &lt; s.size();i ++)    {        if (s[i] == &#39;A&#39;)            st.push(1);        else        {            if (!st.empty()) st.pop();            else            {                cout&lt;&lt;&quot;Nao&quot;&lt;&lt;&#39;\n&#39;;                return 0;            }        }    }    if (st.empty()) cout&lt;&lt;&quot;Sim&quot;&lt;&lt;&#39;\n&#39;;    else cout&lt;&lt;&quot;Nao&quot;&lt;&lt;&#39;\n&#39;;    return 0;}</code></pre><h3 id="MaratonIME-goes-to-the-movies"><a href="#MaratonIME-goes-to-the-movies" class="headerlink" title="MaratonIME goes to the movies"></a>MaratonIME goes to the movies</h3><p>Description:<br>Better than &quot;Fifth Wave&quot;<br>in the World, Everyone<br>Believe it if you can, studies show that we in MaratonIME live not only out of competitive programming.</p><p>In a saturday, after taking part in a virtual contest, our heroes decide to enjoy the afternoon watching a movie session. But they didn&#39;t choose any movie, but an n-D movie, that is, a movie with n dimensions.</p><p>During a chase scene, the main character jumps over a chain in the parking lot. Of course this was done in a very athletic way, and for some reason that drove Yan, one of the competitive programmers, mad.</p><p>&quot;Hollywood makes everything seem easy, but jumping over a chain is really hard!&quot;</p><p>The rest of the crowd, after the movie, argued with Yan that the actor surely jumped over the chain, but Yan disagreed, saying that it was done by some camera trick or by special effects.</p><p>To prove his point, he bought another ticket for the movie and this time he took highly precise measuring instruments to the session. Yan&#39;s plan was to show that the distance from the actor&#39;s foot to the floor was smaller than the distance from the chain to the floor, and that would prove that the actor didn&#39;t actually jump over the chain.</p><p>But math in n dimensions is hard. Everyone knows that distance in the 2D plane between two points (x0, y0) and (x1, y1) is given by the formula<br><a href="sakura" data-fancybox="images" data-caption="主人没有描述我哦~"><center><img src="sakura" class="img-shadow img-margin"></center></a><br>Most people also know that distance between two points (x0, y0, z0) e (x1, y1, z1) in 3D space is given by the formula<br><a href="sakura" data-fancybox="images" data-caption="主人没有描述我哦~"><center><img src="sakura" class="img-shadow img-margin"></center></a><br>Both formulas describe the euclidean distance, in the 2 and 3 dimensional case. Your task is, given three points in an n dimensional space, tell if the the closest ones are the foot and the floor or the chain and the flooor, according to euclidean distance.</p><p>Input</p><blockquote><p>The input begins with an integer n, followed by three lines, each with the representation of a point in an n-dimensional space.<br>Dimensions confuse us, humans, so you can assume that 1 ≤ n ≤ 1e5.<br>The second line represents the coordinates of the floor, and contains n integers a1, ..., an.<br>The third line represents the coordinates of the foot of the main character, and contains n integers b1, ..., bn.<br>The fourth line represents the coordinates of the chain, and contains n integers c1, ..., cn.<br>The movie theather is not arbitrarily large, so you can assume that the absolute value of these coordinates are not greater than 1e4.</p></blockquote><p>Output</p><blockquote><p>Print who wins the argument, that is, print &quot;Yan&quot; if the distance between the floor and the foot is not greater than the distance between the floor and the chain, or &quot;MaratonIME&quot; otherwise.</p></blockquote><p>Examples<br>Input</p><blockquote><p>2<br>0 0<br>1 1<br>2 2</p></blockquote><p>Output</p><blockquote><p>Yan</p></blockquote><p>Input</p><blockquote><p>4<br>0 0 0 0<br>2 2 2 2<br>1 1 1 1</p></blockquote><p>Output</p><blockquote><p>MaratonIME</p></blockquote><p>Problem solving:<br>这道题如果看懂了也不难。就是问你两个点的距离的大小，然后再比较一下，只不过是n维的，跟二维三维的公式一样，往里面套就行了。一个for循环，然后最后在开根号。</p><p>输入三行对应着三个点，比较的是第二个和第三个点相对于第一个点的距离的大小。<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int sijia = 211314;typedef long long ll;ll f[sijia],m[sijia],gj[sijia];int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;f[i];    for(int i=0;i&lt;n;i++)    cin&gt;&gt;m[i];    for(int i=0;i&lt;n;i++)    cin&gt;&gt;gj[i];    double x,y;    x=y=0;    for(int i=0;i&lt;n;i++)    {        x+=(m[i]-f[i])*(m[i]-f[i]);        y+=(gj[i]-f[i])*(gj[i]-f[i]);    }    if(x&lt;=y)        puts(&quot;Yan&quot;);    else    puts(&quot;MaratonIME&quot;);}</code></pre><h3 id="MaratonIME-goes-to-a-japanese-restaurant"><a href="#MaratonIME-goes-to-a-japanese-restaurant" class="headerlink" title="MaratonIME goes to a japanese restaurant"></a>MaratonIME goes to a japanese restaurant</h3><p>Description:<br>Matsu?<br>Member, MaratonIME&#39;s<br>Nathan and Yan are very dedicated programmers. They apply their knowledge in algorithms in problems beyond the programming competitions themselves, optimizing even the most trivial every day things.</p><p>Some question if they aren&#39;t just crazy, and if it wouldn&#39;t be better to just do what has to be done.</p><p>Anyhow, eventually some conflicts happen when their approaches differ about what has to be done. That always happens when they decide to go to japanese restaurants.</p><p>Everybody knows that the objective in an all-you-can eat it to try to eat many distinct kinds of food. Nathan and Yan differ in opinions on how to achieve that. Both competitors, when sitting to eat an asian delicacy, eat until nothing is left on their plates.</p><p>The difference is that Yan, respecting the wisdom of the nipponic masters, eats in the order the food arrives, whereas Nathan claims that the food is better the latter it arrives, to spare the most expensive ingredients, and so asks that his plates come in inverted order.</p><p>Given the default order the dishes will arrive and the time Nathan and Yan will stay at the restaurant, determine who is going to eat the most different kinds of food, or if both ate the same number of different kinds of food, given that Yan eats the food in order and Nathan in inverted order.</p><p>Input</p><blockquote><p>The first line of input has two integers: 0 &lt; n ≤ 1e5, how many plates will be served and 0 &lt; T ≤ 1e6, how long (in minutes) Yan and Nathan will stay at the restaurant.<br>In the following line, n integers 0 &lt; ti ≤ 1e3, ti is how long it takes to eat the i-th dish (in minutes).<br>The restaurants are very well administrated, so you can assume that when one of the competitors finishes his dish, the following dish is already on the table.</p></blockquote><p>Output</p><blockquote><p>If Yan is going to taste more dishes than Nathan, print &quot;Yan&quot;. If Nathan is going to taste more dishes than Yan, print &quot;Nathan&quot;. Otherwise, if we have a tie, print &quot;Empate&quot;.</p></blockquote><p>Examples<br>Input</p><blockquote><p>10 45<br>1 2 3 4 5 6 7 8 9 10</p></blockquote><p>Output</p><blockquote><p>Yan</p></blockquote><p>Input</p><blockquote><p>10 45<br>10 2 3 4 5 6 7 8 9 1</p></blockquote><p>Output</p><blockquote><p>Nathan</p></blockquote><p>Problem solving:<br>这道题的意思就是给你一个序列代表每个菜吃完需要用的时间，然后给你一个整数，代表你总共可以用的时间。现在有两个顺序，一个是正序一个是倒序，问你在那种情况下，可以吃到菜的种类比较多。并且每个菜都必须吃完。</p><p>所以用两次for循环遍历直到给的整数不大于当前菜所需要的时间退出循环。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[211314];int main(){    ll n,m;    cin&gt;&gt;n&gt;&gt;m;    for(ll i=0;i&lt;n;i++)        cin&gt;&gt;a[i];    ll x,y,s1=0,s2=0;    x=m,y=m;    for(ll i=0;i&lt;n;i++)    {        if(x&gt;=a[i])        {            x-=a[i];            s1++;        }        else    break;    }    for(ll i=n-1;i&gt;=0;i--)    {        if(y&gt;=a[i])        {            y-=a[i];            s2++;        }        else break;    }    if(s1&gt;s2)    puts(&quot;Yan&quot;);    else if(s1&lt;s2)    puts(&quot;Nathan&quot;);    else    puts(&quot;Empate&quot;);}</code></pre><h3 id="MaratonIME-goes-to-the-japanese-restaurant-again"><a href="#MaratonIME-goes-to-the-japanese-restaurant-again" class="headerlink" title="MaratonIME goes to the japanese restaurant (again)"></a>MaratonIME goes to the japanese restaurant (again)</h3><p>Description:<br>Nakato?<br>from MaratonIME, Members<br>After a long day of hard training, MaratonIME (マラトニメ) members decided to go to a Japanese restaurant. Yeah, we love Japanese food.</p><p>After a lot of sushi boats, when everyone was more than satisfied, they asked the sushi-man Sussushi (ススシ) for the last boat. Sussushi felt challenged and answered:</p><p>– You want one more boat? You shall have one more boat...</p><p>The sushi boat that he brought was the biggest that any contestant had ever seen. Some contestants even dare saying that was the biggest sushi boat that ever existed, exceeding the previous limit of 105 sushis made by the suhiwoman Gioza (ジョザ) in 742, in a festival for the king that year, Carlos-sama (カーロス様).</p><p>Besides that the contestants accepted the challenge, and together they managed to eat all the sushis. After that, the contestants we&#39;re so full that they couldn&#39;t touch each other. They couldn&#39;t even think about programming problems. Help them find what pair of friends are touching themselves, so they can move away from each other.</p><p>The contestant are represented as circles in plane, and two contestants touch each other if the circles touch each other. It&#39;s guaranteed that the intersection area of any two circles is null.</p><p>Input</p><blockquote><p>In the first line there is a single integer, n indicating the number of contestants (2 ≤ n ≤ 1000).<br>Each one of the next n lines has 3 integers xi, yi e ri, the (i + 1)-th line describes the ith contestant. (xi, yi) are the coordinates of the center of the circle, and ri is the radius. ( - 1e4 ≤ xi, yi ≤ 1e4, 1 ≤ ri ≤ 2·1e4)<br>It is guaranteed that the intersection area of any two circles is null.</p></blockquote><p>Output</p><blockquote><p>For each pair of circles that touch each other, print in one line the indexes of these circles. The collisions can be printed in any order, the indexes of both circles can also be printed in any order.<br>Don&#39;t print the collisions more than once, that means, if i intersects with j, print i j or j i, but not both.</p></blockquote><p>Example<br>Input</p><blockquote><p>3<br>0 0 2<br>5 0 3<br>10 10 1</p></blockquote><p>Output</p><blockquote><p>1 2</p></blockquote><p>Problem solving:<br>这道题的意思就是给你几个圆的圆心以及半径，问你哪几个圆是相交的，有的话输出。</p><p>输入的时候我用了结构体直接存的，然后两个for进行查找，因为n最大时1000，所以不会超时。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;struct node{    int x,y,r;}a[1314];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)        cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].r;    for(int i=1;i&lt;=n;i++)    {        for(int j=i+1;j&lt;=n;j++)        {            if(sqrt((a[j].y-a[i].y)*(a[j].y-a[i].y)+(a[j].x-a[i].x)*(a[j].x-a[i].x))&lt;=(a[i].r+a[j].r))                cout&lt;&lt;i &lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;        }    }    return 0;}</code></pre><h3 id="MaratonIME-goes-to-the-karaoke"><a href="#MaratonIME-goes-to-the-karaoke" class="headerlink" title="MaratonIME goes to the karaoke"></a>MaratonIME goes to the karaoke</h3><p>Description:<br>♬ Hit me, lock me up, do anything with me, ... ♬<br>and Marrone, Bruno<br>After thousands of years repeating the title of this problem statement, always with an excited and inviting tone, Nathan finally persuaded his colleagues to go to the karaoke. He is feeling radiant with this achievement.</p><p>But there is a problem. After so much time trying to make his friends go to the karaoke, Nathan is afraid of embarrassing himself when he goes to sing the following classics of Brazilian music:</p><p>Waitress – Reginaldo Rossi<br>Blue Nightclub – Joaquim and Manuel<br>Paper Heart – Sérgio Kings<br>Love Bubble – Fagner<br>You did not teach me to forget – Fernando Mendes<br>To avoid the humiliation, and to not discourage his fellows in future hang outs at the karaoke, Nathan decided to print all the song’s ciphers that are available in the karaoke, to check while he sings. However, this resulted in a colossal amount of paper, that he is not able to carry.</p><p>But the perseverance and ingenuity of an envious programmer is not something you should underestimate.</p><p>Nathan realized that, after all, there were only 7 musical notes. The specialists in this matter used to represent this notes with the letters A, B, C, D, E, F and G. Even more, it’s common that the same note appears several times in sequence. He decided then, to compress the songs, changing every occurrence of repeated notes with the note followed by how many times it occurs.</p><p>For instance, given the sequence</p><p>[(A,A,A,B,B,B,C,G,G,G,G,G,G,G,G,G,G,G)] the compressed version is [A3B3C1G11]</p><p>Unfortunately, Nathan also needs to pack his floral suit and to comb his beard – two homeric jobs – and he is out of time to compress the notes. Help him to not embarrass himself by writing a program that can solve this task.</p><p>Input</p><blockquote><p>Each input consist of a single line, a sequence of caracteres S such as |S| ≤ 105, formed only by the letters A, B, C, D, E, F and G.</p></blockquote><p>Output</p><blockquote><p>For each input, print in a single line, such as each sequence of similar notes are replaced by the note that occurs and how many times it occurs, as showed in the example.</p></blockquote><p>Examples</p><p>Input</p><blockquote><p>ABBGA</p></blockquote><p>Output</p><blockquote><p>A1B2G1A1</p></blockquote><p>Input</p><blockquote><p>AAABBBCGGGGGGGGGGG</p></blockquote><p>Output</p><blockquote><p>A3B3C1G11</p></blockquote><p>Problem solving:<br>这道题我没看题，直接看的样例哈哈。<br>这道题是给你一个字符串问你这个字符串中连续出现的字符以及个数。我用结构体存了一下，然后输出。<br>注意：同一个字母如果没有连着出现是不能算在一起的，这个看样例应该就可以看出来。</p><p>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;iostream&gt;const int xiaozhu=1e5+10;struct node{    char s;    int ti;}sijia[xiaozhu];using namespace std;int main(){    string s;    cin&gt;&gt;s;    sijia[0].s=s[0];sijia[0].ti=1;    int pos=0;    for(int i=1;i&lt;s.size();i++)    {        if(s[i]==sijia[pos].s)        {            sijia[pos].ti++;        }        else        {            pos++;            sijia[pos].s=s[i];            sijia[pos].ti=1;        }    }    for(int i=0;i&lt;=pos;i++)    {        cout&lt;&lt;sijia[i].s&lt;&lt;sijia[i].ti;    }    return 0;}</code></pre><h3 id="MaratonIME-goes-karting"><a href="#MaratonIME-goes-karting" class="headerlink" title="MaratonIME goes karting"></a>MaratonIME goes karting</h3><p>Description:<br>Yan, it&#39;s red!!!<br>desperate, Passengers<br>Once after a contest, the competitive programmers were sad because of bad results. Seeing the situation, Renzo, MaratonIME&#39;s coach, suggested they should do something fun to relax. After a big discussion, they decided to go karting. Looking for a place that was viable to all students, they found Kartforces, a kart track near Cidade Universitária. However, the track was too small and only fitted two racers by race. As passionate competitive programmers, they organised a fair tournament where everyone raced against everyone, two by two, only once. In each race, the winner got one point on the scoreboard. Draws were allowed and no one scored in this case. The winner was the biggest scorer. There were N competitive programmers present and:</p><p>Each competitive programmer had a skill hi.<br>If hi &gt; hj where 1 ≤ i, j ≤ N and i ≠ j, then the competitive programmer i won the race against j.<br>You had access to the skills of all competitive programmers and now asks who was the champion.</p><p>Input</p><blockquote><p>The first line consists on a single integer N, the number of competitive programmers. The second line contains N integers hi, the skill of the i - th competitive programmer.<br>1 ≤ N ≤ 1e5<br>0 ≤ hi ≤ 1e9</p></blockquote><p>Output</p><blockquote><p>The output consists in a single integer i, the champion competitive programmer. If it&#39;s not possible to determine the champion, print  - 1.</p></blockquote><p>Example</p><p>Input</p><blockquote><p>3<br>2 4 6</p></blockquote><p>Output</p><blockquote><p>3</p></blockquote><p>Problem solving:<br>这道题的题意我没看很懂，但是就是给你一组数据问是否能确定一个冠军出来。</p><p>什么情况下才不会产生冠军呢？就是如果有两个人得分相等的时候就不会产生冠军。而且题目说的是相邻两个人的比赛，所以只需要一个for循环比较一下看相邻的有没有相等的，如果有直接输出-1，没有的话直接输出最大值即可。</p><p>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;struct node{    ll x,id;}a[100005];bool cmp(node a,node b){    return a.x&gt;b.x;}int main(){    ll n;    scanf(&quot;%lld&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i].x);        a[i].id=i;    }    for(int i=1;i&lt;n;i++)    {        if(a[i].x==a[i+1].x)        {            puts(&quot;-1&quot;);            return 0;        }    }    sort(a+1,a+n+1,cmp);    printf(&quot;%lld\n&quot;,a[1].id);}</code></pre><h3 id="MaratonIME-returns-home"><a href="#MaratonIME-returns-home" class="headerlink" title="MaratonIME returns home"></a>MaratonIME returns home</h3><p>Description:<br>♬ Renzo, they&#39;re calling. Renzo, pick up the phone ♬<br>Ringtones, Top<br>Popular among the most traditional coders, the Summer Camp is famous for its fancy parties. After each party all attendees must return to their homes, but the way back home is not always easy: mildly drunk coders walk weird and often find or lose money along the way. However, MaratonIME always has a sober member in the group, who assures no one will lose money, except when they are robbed.</p><p>On its way back MaratonIME knows that they can call their coach, Renzo, who will pick them up immediately. Instead of doing that right after the party, they want to know what is the maximum amount of money they can carry back to their homes.</p><p>Your task is to write a program that solves this problem. Consider the following facts:</p><p>The city map can be seen as an N by M grid;<br>Members of MaratonIME are initially at the top left corner, and start walking right, carrying no money;<br>Whenever they reach the end of a row, they walk to the row below and start walking in the opposite direction (if they were walking right, they walk left the next row, and vice-versa);<br>They cannot go past the last row;<br>Whenever they meet a burglar, they lose all their money;<br>They can call Renzo at anytime, and he will pick them up instantly.<br>Input</p><blockquote><p>The first line of the input contains two integers N and M (1 ≤ N, M ≤ 103), respectively, the number of rows and columns of the grid. Then follows N lines, each containing M characters, representing the city map. Each cell of the city map can be either:<br>, <code>_</code> meaning there is nothing at this cell of the grid;<br>, &#39;.&#39;  meaning there is a coin worth 1 unit of money at this cell;<br>, &#39;L&#39; meaning there is a burglar at that cell.</p></blockquote><p>Output</p><blockquote><p>The output must contain a single integer: the maximum amount of money MaratonIME can carry back home.</p></blockquote><p>Example<br>Input</p><pre><code>3 3__._._L._</code></pre><p>Output</p><blockquote><p>2</p></blockquote><p>Note</p><blockquote><p>In the example above, MaratonIME follows the following path: (1, 1)  (1, 2)  (1, 3)  (2, 3)  (2, 2)  (2, 1)  (3, 1)  (3, 2)  (3, 3). When they reach (2, 2) or (2, 1) they will have 2 coins, and that is the highest value they can get before calling Renzo.</p></blockquote><p>Problem solving:</p><p>这道题就是给你一个图，问你在走的过程中能够拿到的最多的金币数。但是图里会有强盗，用L表示，如果你经过强盗，那么金币清零。但是因为方向是固定的，所以可以直接特殊的遍历一下图就行，或者可以像我一样构建一个新的字符串。<br>然后遍历整个字符串取每个状态下金币数的最大值就是答案。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int xiao =1314;const int zhu =1314;char sijia[xiao][zhu];int n,m,ans,flag;int main(){    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;n;i++)        scanf(&quot;%s&quot;,sijia[i]);    string s;    for(int i=0;i&lt;n;i++)    {        if(i%2==0)        {            for(int j=0;j&lt;m;j++)                s+=sijia[i][j];        }        else        {            for(int j=m-1;j&gt;=0;j--)                s+=sijia[i][j];        }    }    int now=0;    for(int i=0;i&lt;s.size();i++)    {        if(s[i]==&#39;.&#39;)    now++;        if(s[i]==&#39;L&#39;)    now=0;        ans=max(ans,now);    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><p>最后再总结一下吧，今天好多题都没读懂，于是有了罚时换题意。。。英语能力需要提升！</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day23(河南理工大学暑期第二十三天)</title>
      <link href="/2019/08/08/23/"/>
      <url>/2019/08/08/23/</url>
      
        <content type="html"><![CDATA[<h3 id="Nearest-Common-Ancestors"><a href="#Nearest-Common-Ancestors" class="headerlink" title="Nearest Common Ancestors"></a>Nearest Common Ancestors</h3><p>Description:<br>A rooted tree is a well-known data structure in computer science and engineering. An example is shown below:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/cxz.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/cxz.webp" class="img-shadow img-margin"></center></a><br>In the figure, each node is labeled with an integer from {1, 2,...,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is.</p><p>For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y.</p><p>Write a program that finds the nearest common ancestor of two distinct nodes in a tree.</p><p>Input</p><blockquote><p>The input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000. The nodes are labeled with integers 1, 2,..., N. Each of the next N -1 lines contains a pair of integers that represent an edge --the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed.</p></blockquote><p>Output</p><blockquote><p>Print exactly one line for each test case. The line should contain the integer that is the nearest common ancestor.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>16<br>1 14<br>8 5<br>10 16<br>5 9<br>4 6<br>8 4<br>4 10<br>1 13<br>6 15<br>10 11<br>6 7<br>10 2<br>16 3<br>8 1<br>16 12<br>16 7<br>5<br>2 3<br>3 4<br>3 1<br>1 5<br>3 5</p></blockquote><p>Sample Output</p><blockquote><p>4<br>3</p></blockquote><p>Problem solving:<br>这道题的意思就是给你一个图，让你求某两个点的最近公共祖先啦。</p><p>是个板子题，我用的是倍增法，所以有一点需要注意的就是，根节点的确定。这个不能随便选的，我们可以统计输入中第二个点的出现，如果没有在第二次出现过说明没有指向它的边，当成根节点处理即可。</p><p>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long bit[30];const int xiaozhu = 52121;void init(){    bit[0]=1;    for(int i=1;i&lt;=29;i++)    bit[i]=bit[i-1]*2;}vector&lt;int&gt; sijia[xiaozhu];int dep[xiaozhu],p[xiaozhu],f[xiaozhu][30],ai[xiaozhu];void dfs(int x,int p){    dep[x]=dep[p]+1;    f[x][0]=p;    for(int i=1;i&lt;=29;i++)    f[x][i]=f[f[x][i-1]][i-1];    for(int i=0;i&lt;sijia[x].size();i++)    {        if(sijia[x][i]!=p)    dfs(sijia[x][i],x);    }}int lca(int x,int y){    if(dep[x]&lt;dep[y])    swap(x,y);    int dif=dep[x]-dep[y];    for(int i=29;i&gt;=0;i--)    {        if(dif&gt;=bit[i])        {            x=f[x][i];            dif-=bit[i];        }    }    if(x==y)    return x;    for(int i=29;i&gt;=0;i--)    {        if(dep[x]&gt;=bit[i]&amp;&amp;f[x][i]!=f[y][i])        {            x=f[x][i];            y=f[y][i];        }    }    return f[x][0];}int main(){    int n,m,u,v;    init();    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        memset(f,0,sizeof(f));        memset(dep,0,sizeof(dep));        memset(p,0,sizeof(p));        memset(sijia,0,sizeof(sijia));        memset(ai,0,sizeof(ai));        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;m;i++)        {            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);            sijia[u].push_back(v);            sijia[v].push_back(u);            ai[v]=1;        }        for(int i=1;i&lt;=m;i++)        {            if(ai[i]==0)            {                dfs(i,0);                break;            }        }        scanf(&quot;%d %d&quot;,&amp;u,&amp;v);        printf(&quot;%d\n&quot;,lca(u,v));//        cout&lt;&lt;&quot;?&quot;;    }}</code></pre><h3 id="Distance-Queries"><a href="#Distance-Queries" class="headerlink" title="Distance Queries"></a>Distance Queries</h3><p>Description:<br>Farmer John&#39;s cows refused to run in his marathon since he chose a path much too long for their leisurely Lifestyle. He therefore wants to find a path of a more reasonable length. The input to this problem consists of the same input as in &quot;Navigation Nightmare&quot;,followed by a line containing a single integer K, followed by K &quot;distance queries&quot;. Each distance query is a line of input containing two integers, giving the numbers of two farms between which FJ is interested in computing distance (measured in the length of the roads along the path between the two farms). Please answer FJ&#39;s distance queries as quickly as possible!<br>Input</p><ul><li>Lines 1..1+M: Same format as &quot;Navigation Nightmare&quot;</li><li>Line 2+M: A single integer, K. 1 &lt;= K &lt;= 10,000</li><li>Lines 3+M..2+M+K: Each line corresponds to a distance query and contains the indices of two farms.</li></ul><p>Output</p><ul><li>Lines 1..K: For each distance query, output on a single line an integer giving the appropriate distance.</li></ul><p>Sample Input</p><blockquote><p>7 6<br>1 6 13 E<br>6 3 9 E<br>3 5 7 S<br>4 1 3 N<br>2 4 20 W<br>4 7 2 S<br>3<br>1 6<br>1 4<br>2 6</p></blockquote><p>Sample Output</p><blockquote><p>13<br>3<br>36</p></blockquote><p>Hint</p><blockquote><p>Farms 2 and 6 are 20+3+13=36 apart.</p></blockquote><p>Problem solving:<br>这个题的意思就是给你一个图，边的权值也都告诉你了。问你两个点到他们最大公共祖先的距离之和。</p><p>这个也是个板子题。但是我们在计算的过程中，要记录一下当前点到达根节点的距离。方便一会计算的时候使用。这是我是用了链式前向星，这样处理距离的话会比较方便。</p><p>另外需要注意的就是最后距离的计算是这样计算的，假设两个点事u,v，那么最后的距离是这样计算的</p><pre><code>ans=dis[u]+dis[v]-2*dis[lca(u,v)]</code></pre><p>dis数组代表的是当前点到根节点的距离</p><p>这个应该还是很好理解的，u到根节点的距离和v到根节点的距离加上之后，他们的最大公共祖先到根节点的距离相当于加了两次，所以减去这个就是两个点到他们最大公共祖先的距离之和了。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int sijia=1e5;int f[sijia][30],dis[sijia],dep[sijia],head[sijia];int n,m,tot=0;long long bit[30];void init(){    bit[0]=1;    for(int i=1;i&lt;=29;i++)        bit[i]=2*bit[i-1];}struct node{    int to,next,w;}edge[sijia];void add(int u,int v,int w){    edge[tot].to=v;    edge[tot].next=head[u];    edge[tot].w=w;    head[u]=tot++;}void dfs(int x,int y){    f[x][0]=y;    for(int i=1;i&lt;=29;i++)        f[x][i]=f[f[x][i-1]][i-1];    for(int i=head[x];i!=-1;i=edge[i].next)    {        if(edge[i].to!=y)        {            dis[edge[i].to] = dis[x]+edge[i].w;//这个就是处理距离的过程，最后dis数组就是第i个点到根节点的距离            dep[edge[i].to] = dep[x] + 1;            dfs(edge[i].to,x);        }    }}int lca(int x,int y){    int xx=x,yy=y;    if(dep[x]&lt;dep[y])   swap(x,y);    int dif=dep[x]-dep[y];    for(int i=29;i&gt;=0;i--)    {        if(dif&gt;=bit[i])        {            x=f[x][i];            dif-=bit[i];        }    }    if(x==y)    return dis[xx]+dis[yy]-2*dis[x];    for(int i=29;i&gt;=0;i--)    {        if(dep[x]&gt;=bit[i]&amp;&amp;f[x][i]!=f[y][i])        {            x=f[x][i];            y=f[y][i];        }    }    return dis[xx]+dis[yy]-2*dis[f[x][0]];//这就是那个计算公式}int main(){    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)    {        tot=0;        memset(f,0,sizeof(f));        memset(head,-1,sizeof(head));        memset(dis,0,sizeof(dis));        memset(dep,0,sizeof(dep));        init();        int u,v,w;        char s;        for(int i=0;i&lt;m;i++)        {            scanf(&quot;%d %d %d %c&quot;,&amp;u,&amp;v,&amp;w,&amp;s);            add(u,v,w);            add(v,u,w);        }        dep[0]=0;        dfs(1,0);        int k;        scanf(&quot;%d&quot;,&amp;k);        for(int i=0;i&lt;k;i++)        {            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);            printf(&quot;%d\n&quot;,lca(u,v));        }    }}</code></pre><h3 id="Closest-Common-Ancestors"><a href="#Closest-Common-Ancestors" class="headerlink" title="Closest Common Ancestors"></a>Closest Common Ancestors</h3><p>Description:<br>Write a program that takes as input a rooted tree and a list of pairs of vertices. For each pair (u,v) the program determines the closest common ancestor of u and v in the tree. The closest common ancestor of two nodes u and v is the node w that is an ancestor of both u and v and has the greatest depth in the tree. A node can be its own ancestor (for example in Figure 1 the ancestors of node 2 are 2 and 5)</p><p>The data set starts with the tree description, in the form:</p><p>nr_of_vertices<br>vertex:(nr_of_successors) successor1 successor2 ... successorn<br>......</p><p>where vertices are represented as integers from 1 to n. The tree description is followed by a list of pairs of vertices, in the form:</p><p>nr_of_pairs<br>(u v) (x y) ...</p><p>The input contents several data sets (at least one).</p><p>Note that white-spaces (tabs, spaces and line breaks) can be used freely in the input.</p><p>For each common ancestor the program prints the ancestor and the number of pair for which it is an ancestor. The results are printed on the standard output on separate lines, in to the ascending order of the vertices, in the format: ancestor:times</p><p>For example, for the following tree:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/cxz1.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/cxz1.webp" class="img-shadow img-margin"></center></a><br>the program input and output is:</p><p>Input</p><blockquote><p>5<br>5:(3) 1 4 2<br>1:(0)<br>4:(0)<br>2:(1) 3<br>3:(0)<br>6<br>(1,5) (1,4) (4,2)<br>(2,3)<br>(1,3) (4,3)</p></blockquote><p>Output</p><blockquote><p>2:1<br>5:5</p></blockquote><p>Problem solving:<br>这道题就是给你一个图，问你某两个点的最大公共祖先。</p><p>板子题，但是输入算是个小难点吧。可以直接用scanf的格式控制，美滋滋。</p><p>好久没用scanf的多组输入，TLE三次，我可真是个弟弟。<br>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;long long bit[30];const int xiaozhu = 52121;void init(){    bit[0]=1;    for(int i=1;i&lt;=29;i++)    bit[i]=bit[i-1]*2;}vector&lt;int&gt; sijia[xiaozhu];int flag[xiaozhu],ans[xiaozhu],dep[xiaozhu],p[xiaozhu],f[xiaozhu][30];void dfs(int x,int p){    dep[x]=dep[p]+1;    f[x][0]=p;    for(int i=1;i&lt;=29;i++)    f[x][i]=f[f[x][i-1]][i-1];    for(int i=0;i&lt;sijia[x].size();i++)    {        if(sijia[x][i]!=p)    dfs(sijia[x][i],x);    }}int lca(int x,int y){    if(dep[x]&lt;dep[y])    swap(x,y);    int dif=dep[x]-dep[y];    for(int i=29;i&gt;=0;i--)    {        if(dif&gt;=bit[i])        {            x=f[x][i];            dif-=bit[i];        }    }    if(x==y)    return x;    for(int i=29;i&gt;=0;i--)    {        if(dep[x]&gt;=bit[i]&amp;&amp;f[x][i]!=f[y][i])        {            x=f[x][i];            y=f[y][i];        }    }    return f[x][0];}int main(){    int n,a,b,c;    init();    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(flag,0,sizeof(flag));        memset(ans,0,sizeof(ans));        memset(p,0,sizeof(p));        memset(f,0,sizeof(f));        memset(sijia,0,sizeof(sijia));        for(int i=0;i&lt;n;i++)        {            scanf(&quot;%d:(%d)&quot;,&amp;a,&amp;b);            while(b--)            {                scanf(&quot;%d&quot;,&amp;c);                sijia[a].push_back(c);                sijia[c].push_back(a);                flag[c]=1;            }        }        for(int i=1;i&lt;=n;i++)        {            if(!flag[i])            {                dep[i]=0;                dfs(i,0);                break;            }        }        int m,u,v;        char s;        scanf(&quot;%d&quot;,&amp;m);        for(int i=0;i&lt;m;i++)        {            scanf(&quot; (%d,%d)&quot;,&amp;u,&amp;v);            ans[lca(u,v)]++;        }        for(int i=1;i&lt;=n;i++)        {            if(ans[i])  printf(&quot;%d:%d\n&quot;,i,ans[i]);        }    }}</code></pre><h3 id="How-far-away-？"><a href="#How-far-away-？" class="headerlink" title="How far away ？"></a>How far away ？</h3><p>Description:<br>There are n houses in the village and some bidirectional roads connecting them. Every day peole always like to ask like this &quot;How far is it if I want to go from house A to house B&quot;? Usually it hard to answer. But luckily int this village the answer is always unique, since the roads are built in the way that there is a unique simple path(&quot;simple&quot; means you can&#39;t visit a place twice) between every two houses. Yout task is to answer all these curious people.<br>Input</p><blockquote><p>First line is a single integer T(T&lt;=10), indicating the number of test cases.<br>  For each test case,in the first line there are two numbers n(2&lt;=n&lt;=40000) and m (1&lt;=m&lt;=200),the number of houses and the number of queries. The following n-1 lines each consisting three numbers i,j,k, separated bu a single space, meaning that there is a road connecting house i and house j,with length k(0&lt;k&lt;=40000).The houses are labeled from 1 to n.<br>  Next m lines each has distinct integers i and j, you areato answer the distance between house i and house j.</p></blockquote><p>Output</p><blockquote><p>For each test case,output m lines. Each line represents the answer of the query. Output a bland line after each test case.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3 2<br>1 2 10<br>3 1 15<br>1 2<br>2 3<br>2 2<br>1 2 100<br>1 2<br>2 1</p></blockquote><p>Sample Output</p><blockquote><p>10<br>25<br>100<br>100</p></blockquote><p>Problem solving:<br>这道题跟B题很像，题意我也没搞懂，但是一看样例。就知道跟b一样。。。<br>就不多说了吧。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int sijia=1e5;int f[sijia][30],flag[sijia],dis[sijia],dep[sijia],head[sijia];int n,m,tot=0;long long bit[30];void init(){    bit[0]=1;    for(int i=1;i&lt;=29;i++)        bit[i]=2*bit[i-1];}struct node{    int to,next,w;}edge[sijia];void add(int u,int v,int w){    edge[tot].to=v;    edge[tot].next=head[u];    edge[tot].w=w;    head[u]=tot++;}void dfs(int x,int y){    f[x][0]=y;    for(int i=1;i&lt;=29;i++)        f[x][i]=f[f[x][i-1]][i-1];    for(int i=head[x];i!=-1;i=edge[i].next)    {        if(edge[i].to!=y)        {            dis[edge[i].to] = dis[x]+edge[i].w;            dep[edge[i].to] = dep[x] + 1;            dfs(edge[i].to,x);        }    }}int lca(int x,int y){    int xx=x,yy=y;    if(dep[x]&lt;dep[y])   swap(x,y);    int dif=dep[x]-dep[y];    for(int i=29;i&gt;=0;i--)    {        if(dif&gt;=bit[i])        {            x=f[x][i];            dif-=bit[i];        }    }    if(x==y)    return dis[xx]&gt;dis[yy]?(dis[xx]-dis[yy]):(dis[yy]-dis[xx]);    for(int i=29;i&gt;=0;i--)    {        if(dep[x]&gt;=bit[i]&amp;&amp;f[x][i]!=f[y][i])        {            x=f[x][i];            y=f[y][i];        }    }    return dis[xx]+dis[yy]-2*dis[f[x][0]];}int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        tot=0;        memset(f,0,sizeof(f));        memset(head,-1,sizeof(head));        memset(dis,0,sizeof(dis));        memset(dep,0,sizeof(dep));        init();        int u,v,w,mm,p;        scanf(&quot;%d %d&quot;,&amp;mm,&amp;p);        for(int i=1;i&lt;mm;i++)        {            scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);            add(u,v,w);            add(v,u,w);        }        dep[0]=0;        dfs(1,0);        for(int i=0;i&lt;p;i++)        {            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);            printf(&quot;%d\n&quot;,lca(u,v));        }    }}</code></pre><h3 id="Equivalent-Sets"><a href="#Equivalent-Sets" class="headerlink" title="Equivalent Sets"></a>Equivalent Sets</h3><p>Description:<br>To prove two sets A and B are equivalent, we can first prove A is a subset of B, and then prove B is a subset of A, so finally we got that these two sets are equivalent.<br>You are to prove N sets are equivalent, using the method above: in each step you can prove a set X is a subset of another set Y, and there are also some sets that are already proven to be subsets of some other sets.<br>Now you want to know the minimum steps needed to get the problem proved.<br>Input</p><blockquote><p>The input file contains multiple test cases, in each case, the first line contains two integers N &lt;= 20000 and M &lt;= 50000.<br>Next M lines, each line contains two integers X, Y, means set X in a subset of set Y.</p></blockquote><p>Output</p><blockquote><p>For each case, output a single integer: the minimum steps needed.</p></blockquote><p>Sample Input</p><blockquote><p>4 0<br>3 2<br>1 2<br>1 3</p></blockquote><p>Sample Output</p><blockquote><p>4<br>2</p></blockquote><p>Problem solving:</p><p>Code:</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> LCA </tag>
            
            <tag> 强连通分量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day22(河南理工大学暑期第二十二天)</title>
      <link href="/2019/08/07/22/"/>
      <url>/2019/08/07/22/</url>
      
        <content type="html"><![CDATA[<h3 id="Genealogical-tree"><a href="#Genealogical-tree" class="headerlink" title="Genealogical tree"></a>Genealogical tree</h3><p>Description:<br>The system of Martians&#39; blood relations is confusing enough. Actually, Martians bud when they want and where they want. They gather together in different groups, so that a Martian can have one parent as well as ten. Nobody will be surprised by a hundred of children. Martians have got used to this and their style of Life seems to them natural.<br>And in the Planetary Council the confusing genealogical system leads to some embarrassment. There meet the worthiest of Martians, and therefore in order to offend nobody in all of the discussions it is used first to give the floor to the old Martians, than to the younger ones and only than to the most young childless assessors. However, the maintenance of this order really is not a trivial task. Not always Martian knows all of his parents (and there&#39;s nothing to tell about his grandparents!). But if by a mistake first speak a grandson and only than his young appearing great-grandfather, this is a real scandal.<br>Your task is to write a program, which would define once and for all, an order that would guarantee that every member of the Council takes the floor earlier than each of his descendants.<br>Input</p><blockquote><p>The first line of the standard input contains an only number N, 1 &lt;= N &lt;= 100 — a number of members of the Martian Planetary Council. According to the centuries-old tradition members of the Council are enumerated with the natural numbers from 1 up to N. Further, there are exactly N lines, moreover, the I-th line contains a list of I-th member&#39;s children. The list of children is a sequence of serial numbers of children in a arbitrary order separated by spaces. The list of children may be empty. The list (even if it is empty) ends with 0.</p></blockquote><p>Output</p><blockquote><p>The standard output should contain in its only line a sequence of speakers&#39; numbers, separated by spaces. If several sequences satisfy the conditions of the problem, you are to write to the standard output any of them. At least one such sequence always exists.</p></blockquote><p>Sample Input</p><blockquote><p>5<br>0<br>4 5 1 0<br>1 0<br>5 3 0<br>3 0</p></blockquote><p>Sample Output</p><blockquote><p>2 4 5 3 1</p></blockquote><p>Problem solving:<br>题意就是给你n个人，然后分别告诉你n个人后面有几个人，让你输出一种排列方式。</p><p>一开始没看懂题意WA了一次。</p><p>这道题就是拓扑排序的一道板子题。直接写就行了。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int sijia[105];vector&lt;int&gt; xiaozhu[105];int main(){    int n,m,nn,mid;    cin&gt;&gt;n;    nn=n;    for(int i=1;i&lt;=n;i++)    {        while(cin&gt;&gt;m&amp;&amp;m)        {                sijia[m]++;                xiaozhu[i].push_back(m);                continue;        }    }    queue&lt;int&gt; q;    for(int i=1;i&lt;=nn;i++)    {        if(sijia[i]==0)        {             q.push(i);        }    }    while(!q.empty())    {        int qixi=q.front();        q.pop();        cout&lt;&lt;qixi&lt;&lt;&quot; &quot;;        for(int i=0;i&lt;xiaozhu[qixi].size();i++)        {            sijia[xiaozhu[qixi][i]]--;            if(sijia[xiaozhu[qixi][i]]==0)                q.push(xiaozhu[qixi][i]);        }    }}</code></pre><h3 id="Window-Pains"><a href="#Window-Pains" class="headerlink" title="Window Pains"></a>Window Pains</h3><p>Description:<br>Boudreaux likes to multitask, especially when it comes to using his computer. Never satisfied with just running one application at a time, he usually runs nine applications, each in its own window. Due to limited screen real estate, he overlaps these windows and brings whatever window he currently needs to work with to the foreground. If his screen were a 4 x 4 grid of squares, each of Boudreaux&#39;s windows would be represented by the following 2 x 2 windows:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/xiao%20%282%29.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/xiao%20%282%29.webp" class="img-shadow img-margin"></center></a><br>When Boudreaux brings a window to the foreground, all of its squares come to the top, overlapping any squares it shares with other windows. For example, if window 1 and then window 2 were brought to the foreground, the resulting representation would be:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/xiao%20%281%29.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/xiao%20%281%29.webp" class="img-shadow img-margin"></center></a><br>Unfortunately, Boudreaux&#39;s computer is very unreliable and crashes often. He could easily tell if a crash occurred by looking at the windows and seeing a graphical representation that should not occur if windows were being brought to the foreground correctly. And this is where you come in . . .<br>Input</p><blockquote><p>Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets.<br>A single data set has 3 components:<br>Start line - A single line:<br>START<br>Screen Shot - Four lines that represent the current graphical representation of the windows on Boudreaux&#39;s screen. Each position in this 4 x 4 matrix will represent the current piece of window showing in each square. To make input easier, the list of numbers on each line will be delimited by a single space.<br>End line - A single line:<br>END<br>After the last data set, there will be a single line:<br>ENDOFINPUT<br>Note that each piece of visible window will appear only in screen areas where the window could appear when brought to the front. For instance, a 1 can only appear in the top left quadrant.</p></blockquote><p>Output</p><blockquote><p>For each data set, there will be exactly one line of output. If there exists a sequence of bringing windows to the foreground that would result in the graphical representation of the windows on Boudreaux&#39;s screen, the output will be a single line with the statement:<br>THESE WINDOWS ARE CLEAN<br>Otherwise, the output will be a single line with the statement:<br>THESE WINDOWS ARE BROKEN</p></blockquote><p>Sample Input</p><blockquote><p>START<br>1 2 3 3<br>4 5 6 6<br>7 8 9 9<br>7 8 9 9<br>END<br>START<br>1 1 3 3<br>4 1 3 3<br>7 7 9 9<br>7 7 9 9<br>END<br>ENDOFINPUT</p></blockquote><p>Sample Output</p><blockquote><p>THESE WINDOWS ARE CLEAN<br>THESE WINDOWS ARE BROKEN</p></blockquote><p>Problem solving:<br>这道题的题意有点恶心。而且也不太好想+好写。</p><p>这道题也是要用拓扑排序做的。反正我是绝对想不到的，先预处理，把4*4的矩阵初始化成这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/B1.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/B1.webp" class="img-shadow img-margin"></center></a></p><p>这个我还是放大佬链接吧，自认为莫得能力讲清楚。。。<br>点这里进行传送：<a href="https://blog.csdn.net/wang_123_zy/article/details/81391510" target="_blank" rel="noopener">某学姐</a></p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;cstring&gt;using namespace std;int ma[10][10],sijia[10];int dr[]={0,1,0,1},dc[]={0,0,1,1};vector&lt;int&gt; ve[10][10];bool solve(){    queue&lt;int&gt; q;    for(int i=0;i&lt;9;i++)        if(sijia[i]==0) q.push(i);    int sum=0;    while(!q.empty())    {        int u=q.front();        q.pop();        for(int v=0;v&lt;9;v++)        {            if(ma[u][v])            {                ma[u][v]=0;                sijia[v]--;                if(sijia[v]==0)   q.push(v);            }        }        sum++;    }    return sum==9;}int main(){    for(int i=0;i&lt;9;i++)    {        int r=i/3,c=i%3;        for(int j=0;j&lt;4;j++)        {            int nr=r+dr[j],nc=c+dc[j];            ve[nr][nc].push_back(i);        }    }    string s;    while(cin&gt;&gt;s&amp;&amp;s[0]!=&#39;E&#39;)    {        memset(ma,0,sizeof(ma));        memset(sijia,0,sizeof(sijia));        for(int i=0;i&lt;4;i++)        {            for(int j=0;j&lt;4;j++)            {                int v;                cin&gt;&gt;v;                v--;                for(int k=0;k&lt;ve[i][j].size();k++)                {                    if(ve[i][j][k]!=v)                    {                        int x=ve[i][j][k];                        if(ma[x][v]==0)                        {                            sijia[v]++;                            ma[x][v]=1;                        }                    }                }            }        }        if(solve()) puts(&quot;THESE WINDOWS ARE CLEAN&quot;);        else    puts(&quot;THESE WINDOWS ARE BROKEN&quot;);        cin&gt;&gt;s;    }}</code></pre><h3 id="确定比赛名次"><a href="#确定比赛名次" class="headerlink" title="确定比赛名次"></a>确定比赛名次</h3><p>Description:</p><blockquote><p>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p></blockquote><p>Input</p><blockquote><p>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p></blockquote><p>Output</p><blockquote><p>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。<br>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p></blockquote><p>Sample Input</p><blockquote><p>4 3<br>1 2<br>2 3<br>4 3</p></blockquote><p>Sample Output</p><blockquote><p>1 2 4 3</p></blockquote><p>Problem solving:<br>给出n个队伍以及队伍的胜负关系，让你输出他们的排名。</p><p>也是一个简单的拓扑排序的板子题，注意以下输出，最后一个数后面没有空格，就行了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int sijiaxiaozhu=521;int qixikuaile[sijiaxiaozhu];vector&lt;int&gt; yongyuan[sijiaxiaozhu];int main(){  int n,m,x,y;  while(cin&gt;&gt;n&gt;&gt;m)  {    memset(qixikuaile,0,sizeof(qixikuaile));    for(int i=0;i&lt;=n;i++) yongyuan[i].clear();    for(int i=0;i&lt;m;i++)    {      cin&gt;&gt;x&gt;&gt;y;      qixikuaile[y]++;      yongyuan[x].push_back(y);    }  priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q ;    int flag=1;    for(int i=1;i&lt;=n;i++)    {      if(qixikuaile[i]==0)  q.push(i);    }    while(!q.empty())    {      int mid=q.top();      q.pop();      if(flag)      {        cout&lt;&lt;mid;        flag=0;      }      else  cout&lt;&lt;&quot; &quot;&lt;&lt;mid;      for(int i=0;i&lt;yongyuan[mid].size();i++)      {        qixikuaile[yongyuan[mid][i]]--;        if(qixikuaile[yongyuan[mid][i]]==0) q.push(yongyuan[mid][i]);      }    }    cout&lt;&lt;endl;  }  return 0;}</code></pre><h3 id="产生冠军"><a href="#产生冠军" class="headerlink" title="产生冠军"></a>产生冠军</h3><p>Description:<br>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br>球赛的规则如下：<br>如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br>如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br>根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。<br>Input</p><blockquote><p>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。</p></blockquote><p>Output</p><blockquote><p>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>Alice Bob<br>Smith John<br>Alice Smith<br>5<br>a c<br>c d<br>d e<br>b e<br>a d<br>0</p></blockquote><p>Sample Output</p><blockquote><p>Yes<br>No</p></blockquote><p>Problem solving:<br>这道题跟上一题很像。也是给了你胜负关系，问你能不能确定冠军。但是胜负关系是通过字符串给出的。</p><p>想一下这就是可以用拓扑排序写，但是胜负关系是以字符串给出的，如果直接套我们的板子会发现一个很尴尬的问题，存图的时候字符串不可以做下标。但是这个时候可以用map给每个字符串赋一个值，然后套板子。讲道理，这个应该是可以实现的(虽然我没成功。</p><p>然后想一下，这道题可以这样做。确定冠军的话，就是有一个人一场都没输过。所以我们只需要比较出现的总人数以及输过的总人数的关系即可。如果差一个就说明有一个人一场都没输过。这就能确定冠军了。反之就不能。这样的话一个set就能解决了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n;    string x,y;    while(cin&gt;&gt;n&amp;&amp;n)    {        set&lt;string&gt; sijia;        set&lt;string&gt; xiaozhu;        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;x&gt;&gt;y;            sijia.insert(x),sijia.insert(y);            xiaozhu.insert(y);        }            if(sijia.size()-xiaozhu.size()==1)  puts(&quot;Yes&quot;);            else    puts(&quot;No&quot;);    }}</code></pre><h3 id="Legal-or-not"><a href="#Legal-or-not" class="headerlink" title="Legal or not"></a>Legal or not</h3><p>Description:<br>ACM-DIY is a large QQ group where many excellent acmers get together. It is so harmonious that just like a big family. Every day,many &quot;holy cows&quot; like HH, hh, AC, ZT, lcc, BF, Qinz and so on chat on-line to exchange their ideas. When someone has questions, many warm-hearted cows like Lost will come to help. Then the one being helped will call Lost &quot;master&quot;, and Lost will have a nice &quot;prentice&quot;. By and by, there are many pairs of &quot;master and prentice&quot;. But then problem occurs: there are too many masters and too many prentices, how can we know whether it is legal or not?</p><p>We all know a master can have many prentices and a prentice may have a lot of masters too, it&#39;s legal. Nevertheless，some cows are not so honest, they hold illegal relationship. Take HH and 3xian for instant, HH is 3xian&#39;s master and, at the same time, 3xian is HH&#39;s master,which is quite illegal! To avoid this,please help us to judge whether their relationship is legal or not.</p><p>Please note that the &quot;master and prentice&quot; relation is transitive. It means that if A is B&#39;s master ans B is C&#39;s master, then A is C&#39;s master.<br>Input</p><blockquote><p>The input consists of several test cases. For each case, the first line contains two integers, N (members to be tested) and M (relationships to be tested)(2 &lt;= N, M &lt;= 100). Then M lines follow, each contains a pair of (x, y) which means x is y&#39;s master and y is x&#39;s prentice. The input is terminated by N = 0.<br>TO MAKE IT SIMPLE, we give every one a number (0, 1, 2,..., N-1). We use their numbers instead of their names.</p></blockquote><p>Output</p><blockquote><p>For each test case, print in one line the judgement of the messy relationship.<br>If it is legal, output &quot;YES&quot;, otherwise &quot;NO&quot;.</p></blockquote><p>Sample Input</p><blockquote><p>3 2<br>0 1<br>1 2<br>2 2<br>0 1<br>1 0<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>YES<br>NO</p></blockquote><p>Problem solving:<br>题意就是告诉你n个关系，问你会不会产生矛盾。</p><p>一道拓扑排序的板子题，判断是否成环就行。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int sijia[521];vector&lt;int&gt; xiaozhu[521];int main(){    int n,m,a,b;    while(cin&gt;&gt;n&gt;&gt;m)    {        memset(sijia,0,sizeof(sijia));        for(int i=0;i&lt;=n;i++  )    xiaozhu[i].clear();        if(n==0&amp;&amp;m==0)  break;        for(int i=0;i&lt;m;i++)        {            cin&gt;&gt;a&gt;&gt;b;            sijia[b]++;            xiaozhu[a].push_back(b);        }        queue&lt;int&gt; q;        for(int i=0;i&lt;n;i++)        {            if(sijia[i]==0)            q.push(i);        }        while(!q.empty())        {            int mid=q.front();            q.pop();            n--;            for(int i=0;i&lt;xiaozhu[mid].size();i++)            {                sijia[xiaozhu[mid][i]]--;                if(sijia[xiaozhu[mid][i]]==0)                    q.push(xiaozhu[mid][i]);            }        }        if(n)   puts(&quot;NO&quot;);//如果n不为0，说明成环        else    puts(&quot;YES&quot;);    }}</code></pre><h3 id="Reward"><a href="#Reward" class="headerlink" title="Reward"></a>Reward</h3><p>Description:<br>Dandelion&#39;s uncle is a boss of a factory. As the spring festival is coming , he wants to distribute rewards to his workers. Now he has a trouble about how to distribute the rewards.<br>The workers will compare their rewards ,and some one may have demands of the distributing of rewards ,just like a&#39;s reward should more than b&#39;s.Dandelion&#39;s unclue wants to fulfill all the demands, of course ,he wants to use the least money.Every work&#39;s reward will be at least 888 , because it&#39;s a lucky number.<br>Input</p><blockquote><p>One line with two integers n and m ,stands for the number of works and the number of demands .(n&lt;=10000,m&lt;=20000)<br>then m lines ,each line contains two integers a and b ,stands for a&#39;s reward should be more than b&#39;s.</p></blockquote><p>Output</p><blockquote><p>For every case ,print the least money dandelion &#39;s uncle needs to distribute .If it&#39;s impossible to fulfill all the works&#39; demands ,print -1.</p></blockquote><p>Sample Input</p><blockquote><p>2 1<br>1 2<br>2 2<br>1 2<br>2 1</p></blockquote><p>Sample Output</p><blockquote><p>1777<br>-1</p></blockquote><p>Problem solving:<br>这道题还是很有意思的，告诉你每个人的最低工资是888，然后给你大小关系，告诉你大小关系大于后者的工资也得比后者的多，问你老板做少需要支付多少工资。</p><p>虽然也是一道拓扑排序的板子题。但是中间的一些处理还是很难搞得。<br>我们把初始没经过处理的时候的入度为0的顶点的工资都设为888，然后在拓扑排序的过程中，送入队列的点的工资比他前一个加1就行，因为要求的是最少。<br>最后全布累加在一起，输出即可。</p><p>这道题还有一个坑点就是。存图的时候跟输出是反着来的。这个坑到我了。</p><p>注意还有输出-1的情况，就是出现了环的时候。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 10000queue&lt;int&gt; q;vector&lt;int&gt;t[10005];int in[10005],sum[10005],cnt,u,v,ans;void Init()   {    for(int i=0;i&lt;maxn;i++)      t[i].clear();    while(!q.empty())      q.pop();    memset(in,0,sizeof(in));    ans=0;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m)    {        Init();        for(int i=0;i&lt;m;i++)        {            cin&gt;&gt;u&gt;&gt;v;            u--;v--;            in[u]++;            t[v].push_back(u);        }        for(int i=0;i&lt;n;i++)        {            if(!in[i])            {                q.push(i);                sum[i]=888;            }        }        cnt=0;             while(!q.empty())        {            cnt++;                int p=q.front();            q.pop();            for(int i=0;i&lt;t[p].size();i++)               {                in[t[p][i]]--;                    if(in[t[p][i]]==0)                     {                    q.push(t[p][i]);                         sum[t[p][i]]=sum[p]+1;    //对工资的处理                }            }        }        for(int i=0;i&lt;n;i++)          ans+=sum[i];        if(cnt!=n)          ans=-1;        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h3 id="Ordering-Tasks"><a href="#Ordering-Tasks" class="headerlink" title="Ordering Tasks"></a>Ordering Tasks</h3><p>PDF题面:<a href="https://vj.ti12z.cn/10b4efc19562fa67c26851fd2b184af3?v=1565051545" target="_blank" rel="noopener">七夕快乐</a><br>Description:<br>John has n tasks to do. Unfortunately, the tasks are not independent and the execution of one task is<br>only possible if other tasks have already been executed.<br>Input</p><blockquote><p>The input will consist of several instances of the problem. Each instance begins with a line containing<br>two integers, 1 ≤ n ≤ 100 and m. n is the number of tasks (numbered from 1 to n) and m is the<br>number of direct precedence relations between tasks. After this, there will be m lines with two integers<br>i and j, representing the fact that task i must be executed before task j.<br>An instance with n = m = 0 will finish the input.</p></blockquote><p>Output</p><blockquote><p>For each instance, print a line with n integers representing the tasks in a possible order of execution.</p></blockquote><p>Sample Input</p><blockquote><p>5 4<br>1 2<br>2 3<br>1 3<br>1 5<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>1 4 2 5 3</p></blockquote><p>Problem solving:<br>题意就是有n个工作，但是有的工作需要在另一个工作完成的基础上才能完成，问你一个合理的顺序。</p><p>拓扑排序板子题啦，输出就行。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int sijia[105];vector&lt;int&gt; xiaozhu[105];int n,m,x,y;int main(){    while(cin&gt;&gt;n&gt;&gt;m)    {        memset(sijia,0,sizeof(sijia));        for(int i=0;i&lt;=n;i++)   xiaozhu[i].clear();        if(n==0&amp;&amp;m==0)  break;        for(int i=0;i&lt;m;i++)        {            cin&gt;&gt;x&gt;&gt;y;            sijia[y]++;            xiaozhu[x].push_back(y);        }        queue&lt;int&gt; qixi;        for(int i=1;i&lt;=n;i++)        {            if(sijia[i]==0) qixi.push(i);        }        while(!qixi.empty())        {            int kuaile=qixi.front();            qixi.pop();            cout&lt;&lt;kuaile&lt;&lt;&quot; &quot;;            for(int i=0;i&lt;xiaozhu[kuaile].size();i++)            {                sijia[xiaozhu[kuaile][i]]--;                if(sijia[xiaozhu[kuaile][i]]==0)                    qixi.push(xiaozhu[kuaile][i]);            }        }        cout&lt;&lt;endl;    }}</code></pre><h3 id="Rank-of-Tetris"><a href="#Rank-of-Tetris" class="headerlink" title="Rank of Tetris"></a>Rank of Tetris</h3><p>Description:<br>自从Lele开发了Rating系统，他的Tetris事业更是如虎添翼，不久他遍把这个游戏推向了全球。</p><p>为了更好的符合那些爱好者的喜好，Lele又想了一个新点子：他将制作一个全球Tetris高手排行榜，定时更新，名堂要比福布斯富豪榜还响。关于如何排名，这个不用说都知道是根据Rating从高到低来排，如果两个人具有相同的Rating，那就按这几个人的RP从高到低来排。</p><p>终于，Lele要开始行动了，对N个人进行排名。为了方便起见，每个人都已经被编号，分别从0到N-1,并且编号越大，RP就越高。<br>同时Lele从狗仔队里取得一些（M个）关于Rating的信息。这些信息可能有三种情况，分别是&quot;A &gt; B&quot;,&quot;A = B&quot;,&quot;A &lt; B&quot;，分别表示A的Rating高于B,等于B,小于B。</p><p>现在Lele并不是让你来帮他制作这个高手榜，他只是想知道，根据这些信息是否能够确定出这个高手榜，是的话就输出&quot;OK&quot;。否则就请你判断出错的原因，到底是因为信息不完全（输出&quot;UNCERTAIN&quot;），还是因为这些信息中包含冲突（输出&quot;CONFLICT&quot;）。<br>注意，如果信息中同时包含冲突且信息不完全，就输出&quot;CONFLICT&quot;。<br>Input</p><blockquote><p>本题目包含多组测试，请处理到文件结束。<br>每组测试第一行包含两个整数N,M(0&lt;=N&lt;=10000,0&lt;=M&lt;=20000),分别表示要排名的人数以及得到的关系数。<br>接下来有M行，分别表示这些关系</p></blockquote><p>Output</p><blockquote><p>对于每组测试，在一行里按题目要求输出</p></blockquote><p>Sample Input</p><blockquote><p>3 3<br>0 &gt; 1<br>1 &lt; 2<br>0 &gt; 2<br>4 4<br>1 = 2<br>1 &gt; 3<br>2 &gt; 0<br>0 &gt; 1<br>3 3<br>1 &gt; 0<br>1 &gt; 2<br>2 &lt; 1</p></blockquote><p>Sample Output</p><blockquote><p>OK<br>CONFLICT<br>UNCERTAIN</p></blockquote><p>Problem solving:<br>题意就是告诉你n个人的rating大小关系。问你给的信息能否确定一个高手榜。如果信息不完全就输出<code>UNCERTAIN</code>，如果有冲突了就输出<code>CONFLICT</code>,如果可以就输出<code>OK</code>。并且如果rating相同的话，比较两个人的RP值，RP值的大小就是编号的大小。</p><p>如果只有大小关系的话，就是一个简单板子题，但是它这里还存在着一种等于的关系。这就很麻烦了。我们需要用到并查集来处理。只要出现等于号，就把那两个人join(合并函数)起来，放在一起处理。然后在存图的过程中如果是等于的关系直接跳过就行，否则就先找一下两个点的父节点，用父节点存图，这样就完美的解决了出现等号的情况——这点可能不是很清楚，自己在脑子里模拟一下想一下就可以了。接下来就是拓扑排序了。</p><p>再说一下三种输出。OK的话当然就是可以构建出来高手榜的时候输出，但是CONFLICT和UNCERTAIN有什么区别呢？</p><p>CONFLICT就是有了冲突，有了冲突是什么情况呢？就是存的图里面出现了有环存在的情况，也就是最后还有入度不为0的结点存在。<br>UNCERTAIN就是不确定，不确定是什么情况呢？就是有两个节点的大小关系不知道，也就是存着入度为0的节点的队列中存在两个以上的节点，这个应该还挺好理解的，如果在同一次循环中出现了两个入度为0的节点，说明这两个点之间没有任何边连接着，所以他俩的大小关系自然是不确定了。</p><p>到这里我们发现并没有处理rating相同然后比较RP的问题，这是为什么呢？<br>因为如果出现了等于关系，那么按照题意来说我们应该比较两者的RP值，但是RP值得大小关系是和和编号的大小一样的，而编号每个人都是不一样的，所以就算出现了相等的情况，在不考虑别的情况下一定能比较出大小。所以不需要考虑这个问题。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;int n,m,sijia[52121],p[52121],sum;vector&lt;int&gt; ma[52121];struct node{    int x,y;    char s;}xiaozhu[52121];int find(int x){    return p[x]!=x?p[x]=find(p[x]):x;//并查集的查找函数}bool join(int x,int y)//并查集的合并函数，这里设置成bool类型是为了下面方便{    x=find(x),y=find(y);    if(x==y)//如果x和y的父节点已经相等了，就不用在处理了        return 0;    p[x]=y;    return 1;}void solve()//拓扑排序{    queue&lt;int&gt; q;    for(int i=0;i&lt;n;i++)    {        if(p[i]==i&amp;&amp;sijia[i]==0)    q.push(i);    }    int flag=0;    while(!q.empty())    {        if(q.size()&gt;1)  flag=1;   //入度为0的点同时出现了两个        int mid=q.front();        q.pop();sum--;        for(int i=0;i&lt;ma[mid].size();i++)        {            sijia[ma[mid][i]]--;            if(sijia[ma[mid][i]]==0)    q.push(ma[mid][i]);        }    }    if(sum&gt;0)   puts(&quot;CONFLICT&quot;);  //有环存在    else if(flag)   puts(&quot;UNCERTAIN&quot;);//sum大于0说明同一等级上不是只有唯一的一个    else    puts(&quot;OK&quot;);}int main(){    while(cin&gt;&gt;n&gt;&gt;m)    {        memset(sijia,0,sizeof(sijia));        memset(ma,0,sizeof(ma));        sum=n;        for(int i=0;i&lt;n;i++)    p[i]=i;        for(int i=0;i&lt;m;i++)        {            cin&gt;&gt;xiaozhu[i].x&gt;&gt;xiaozhu[i].s&gt;&gt;xiaozhu[i].y;            if(xiaozhu[i].s==&#39;=&#39;)//如果出现了等号，就把两个合并            {                if(join(xiaozhu[i].x,xiaozhu[i].y))                {                    sum--;//因为合并起来了两个，所以总的拓扑排序用到的节点数减一                }            }        }        for(int i=0;i&lt;m;i++)//存图        {            if(xiaozhu[i].s==&#39;=&#39;)   continue;            int xx=find(xiaozhu[i].x),yy=find(xiaozhu[i].y);            if(xiaozhu[i].s==&#39;&gt;&#39;)            {                ma[xx].push_back(yy);                sijia[yy]++;            }            else            {                ma[yy].push_back(xx);                sijia[xx]++;            }        }        solve();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> BFS </tag>
            
            <tag> 邻接表 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day21(河南理工大学暑期第二十一天)</title>
      <link href="/2019/08/06/21/"/>
      <url>/2019/08/06/21/</url>
      
        <content type="html"><![CDATA[<p>今天讲了最短路，可能是个人原因我觉得什么都没学到。做题也没做出来几道。就这吧，想补了再补，反正是没怎么写。</p><p>然后老师和会长组织我们在计蒜客上打了2018的ECNA的重现赛，一言难尽，自闭就完事了。。。</p><p>今天我被封了一个月还多的谷歌广告的账号回来了！！！然后我又加了几个广告(确实有点多了，但是我真的不知道怎么减少，等我前端学的不错了再说8)</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 20(河南理工大学暑期第二十天)</title>
      <link href="/2019/08/05/20/"/>
      <url>/2019/08/05/20/</url>
      
        <content type="html"><![CDATA[<h3 id="The-Suspects"><a href="#The-Suspects" class="headerlink" title="The Suspects"></a>The Suspects</h3><p>Description:<br>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.<br>Input</p><blockquote><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p></blockquote><p>Output</p><blockquote><p>For each case, output the number of suspects in one line.</p></blockquote><p>Sample Input</p><blockquote><p>100 4<br>2 1 2<br>5 10 13 11 12 14<br>2 0 1<br>2 99 2<br>200 2<br>1 5<br>5 1 2 3 4 5<br>1 0<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>4<br>1<br>1</p></blockquote><p>Problem solving:<br>这道题的意思就是编号为0的学生是有病的，然后告诉你几个组，并且知道如果组里面有一个人是确定有病的，那个这一个组的人都是有病的，问你有病的总共有几个人。</p><p>题意理解了题就简单了，就是一个简单的并查集模板问题。但是为了保证你连接的时候用到的最大的那个节点是0，在join(合并函数)里面要加一个判断，保证每次选的最大的父节点是最小的，如果有的话，就可以保证是0了。最后输出父节点是0的个数即可。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int sijiaxiaozhu=3e4+10;int p[sijiaxiaozhu],n,m,k,mi,mii;int find(int x){    return p[x]!=x?p[x]=find(p[x]):x;}void join(int x,int y){    x=find(x),y=find(y);    if(x&lt;y)    p[y]=x;    else    p[x]=y;}int main(){    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        if(n==0&amp;&amp;m==0)  break;        for(int i=0;i&lt;n;i++)    p[i]=i;        for(int i=0;i&lt;m;i++)        {            scanf(&quot;%d %d&quot;,&amp;k,&amp;mi);            for(int i=0;i&lt;k-1;i++)            {                cin&gt;&gt;mii;                join(mi,mii);            }        }        int ans=1;        for(int i=1;i&lt;n;i++)        {            find(i);            // cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;            if(p[i]==0) ans++;        }        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h3><p>Description:<br>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？<br>Input</p><blockquote><p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p></blockquote><p>Sample Input</p><blockquote><p>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0</p></blockquote><p>Sample Output</p><blockquote><p>1<br>0<br>2<br>998       </p></blockquote><p>Huge input, scanf is recommended.</p><p>Problem solving:<br>题意就是告诉你村庄的个数以及哪些村庄之间是通路的。问你现在还需要修几条路才可以使每个村庄都可以连通，无论拐几个弯。</p><p>就是一个简单的并查集，有一点难的就是修几条路才可以使村庄全部连通。举个栗子，现在总共四个村庄，1,2是连通的，3,4是连通的。所以现在四个村庄总共被分成了2个部分，此时再多修一条路就可以全部连通了。所以所需修的路的个数就是分成的部分数-1.当一个节点的父节点就是他本身的时候说明这是一个区域。统计父节点与它本身相等的点的个数就是区域的个数。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int sijiaxiaozhu=1e5;int p[sijiaxiaozhu];int find(int x){    return p[x]!=x?p[x]=find(p[x]):x;}void join(int x,int y){    x=find(x),y=find(y);    if(x!=y)    p[x]=y;}int main(){    int n,m,a,b;    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)&amp;&amp;n)    {        int ans=0;        for(int i=1;i&lt;=n;i++)   p[i]=i;        for(int i=0;i&lt;m;i++)        {            cin&gt;&gt;a&gt;&gt;b;            join(a,b);        }        for(int i=1;i&lt;=n;i++)   if(p[i]==i) ans++;        cout&lt;&lt;ans-1&lt;&lt;endl;    }}</code></pre><h3 id="还是畅通工程"><a href="#还是畅通工程" class="headerlink" title="还是畅通工程"></a>还是畅通工程</h3><p>Description:<br>某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。<br>Input</p><blockquote><p>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，在1行里输出最小的公路总长度。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1 2 1<br>1 3 2<br>2 3 4<br>4<br>1 2 1<br>1 3 4<br>1 4 1<br>2 3 3<br>2 4 2<br>3 4 5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>3<br>5     </p></blockquote><p>Huge input, scanf is recommended.<br>Problem solving:<br>题意就是给了你n个村庄，并且给了你N(N-1)/2条路。问你如果想让村庄之间互相连通所需要修的路的最短长度是多少。就是一个简单的最小生成树的模板题。用的Kruscal算法。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;struct node{    int a,b,c;}r[maxn];int p[maxn];bool cmp(node a,node b){    return a.c&lt;b.c;}int find(int x){    return p[x]!=x?p[x]=find(p[x]):x;}void join(int x,int y){    x=find(x),y=find(y);    if(x!=y)    p[x]=y;}int main(){    int n;    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)    {        int sum=0;        for(int i=1;i&lt;=n;i++)   p[i]=i;        for(int i=0;i&lt;n*(n-1)/2;i++)            scanf(&quot;%d %d %d&quot;,&amp;r[i].a,&amp;r[i].b,&amp;r[i].c);        sort(r,r+n*(n-1)/2,cmp);        for(int i=0;i&lt;n*(n-1)/2;i++)        {            if(find(r[i].a)!=find(r[i].b))            {                sum+=r[i].c;                join(r[i].a,r[i].b);            }        }        cout&lt;&lt;sum&lt;&lt;endl;    }}</code></pre><h3 id="Ubiquitous-Religions"><a href="#Ubiquitous-Religions" class="headerlink" title="Ubiquitous Religions"></a>Ubiquitous Religions</h3><p>Description:<br>There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.</p><p>You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.<br>Input</p><blockquote><p>The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.</p></blockquote><p>Output</p><blockquote><p>For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.</p></blockquote><p>Sample Input</p><blockquote><p>10 9<br>1 2<br>1 3<br>1 4<br>1 5<br>1 6<br>1 7<br>1 8<br>1 9<br>1 10<br>10 4<br>2 3<br>4 5<br>4 8<br>5 8<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 1<br>Case 2: 7</p></blockquote><p>Hint<br>Huge input, scanf is recommended.</p><p>Problem solving:<br>题意就是n个学生，m个组，每个组两个人，两个人的宗教信仰是一样的，问你n个学生总共有多少个不同的宗教信仰。简单并查集模板题。</p><p>最后查找父节点就是他本身的个数就是答案。<br>查找的时候别忘了find(i)因为你有可能遇见没有分组的时候对它find的情况，所以你需要在这里find一下避免出现这样的情况导致WA。</p><p>Code:</p><pre><code>#include&lt;cstdio&gt;using namespace std;int n,m,a,b;const int sijiaxiaozhu=5e4+10;int p[sijiaxiaozhu];int find(int x){    return p[x]!=x?p[x]=find(p[x]):x;}void join(int x,int y){    x=find(x),y=find(y);    if(x!=y)    p[x]=y;}int main(){    int flag=1;    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        if(n==0&amp;&amp;m==0)  break;        for(int i=1;i&lt;=n;i++)   p[i]=i;        for(int i=0;i&lt;m;i++)        {            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);            join(a,b);        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            find(i);            if(p[i]==i) ans++;        }        printf(&quot;Case %d: %d\n&quot;,flag++,ans);    }}</code></pre><h3 id="Cube-Stacking"><a href="#Cube-Stacking" class="headerlink" title="Cube Stacking"></a>Cube Stacking</h3><p>Description:<br>Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:<br>moves and counts.</p><ul><li>In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.</li><li>In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.</li></ul><p>Write a program that can verify the results of the game.<br>Input</p><blockquote><ul><li>Line 1: A single integer, P</li><li>Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a &#39;M&#39; for a move operation or a &#39;C&#39; for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.<br>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.</li></ul></blockquote><p>Output</p><blockquote><p>Print the output from each of the count operations in the same order as the input file.</p></blockquote><p>Sample Input</p><blockquote><p>6<br>M 1 6<br>C 1<br>M 2 4<br>M 2 6<br>C 3<br>C 4</p></blockquote><p>Sample Output</p><blockquote><p>1<br>0<br>2</p></blockquote><p>Problem solving:<br>题意就是会有n次操作，每次操作可能有两种情况，一种是M a b就是把第a列的所有方块放在b的上面。另一种就是C a，就是需要输出a下面有几个方块。</p><p>带权值的并查集。</p><p>这里我用了两个数组进行维护。ans[i]表示i下面方块的个数，now[i]表示i所处的当前列的方块个数。然后如果遇见M这个操作，就把now[a]全部加到now[b]上然后now[a]归零。并且此时ans[find(a)]应该加上now[find(b)].这就实现了把第a列的所有方块放在b上的操作了。</p><p>还有就是find函数的写法，在find的过程中，每次查找到的中间的节点的ans的值都应该加到查找开始的ans的值里面。这个不太好解释，也不太好想通。可以在脑子里过一下并查集的操作，并且结合着这道题的做法，好好想想为什么需要加上去。<br>等我对这个的理解加深的时候再来补上自己成熟的理解。</p><p>下面这个图来解释一下这个样例<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/unf.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/unf.webp" class="img-shadow img-margin"></center></a></p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int sijiaxiaozhu=31314;int p[sijiaxiaozhu],ans[sijiaxiaozhu],now[sijiaxiaozhu];int find(int x){    if(p[x]==x) return p[x];    int mid=p[x];    p[x]=find(p[x]);    ans[x]+=ans[mid];    return p[x];}void join(int x,int y){    int fx=find(x),fy=find(y);    if(fx==fy)  return ;    p[fx]=fy;    ans[fx]+=now[fy];    now[fy]+=now[fx];    now[fx]=0;}int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=sijiaxiaozhu;i++)    {        now[i]=1;        p[i]=i;        ans[i]=0;    }    for(int i=0;i&lt;n;i++)    {        char s;        int a,b;        cin&gt;&gt;s;        if(s==&#39;M&#39;)        {            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);            join(a,b);        }        else        {            scanf(&quot;%d&quot;,&amp;a);            find(a);            printf(&quot;%d\n&quot;,ans[a]);        }    }}</code></pre><h3 id="Dragon-Balls"><a href="#Dragon-Balls" class="headerlink" title="Dragon Balls"></a>Dragon Balls</h3><p>Description:<br>Five hundred years later, the number of dragon balls will increase unexpectedly, so it&#39;s too difficult for Monkey King(WuKong) to gather all of the dragon balls together.<br>His country has N cities and there are exactly N dragon balls in the world. At first, for the ith dragon ball, the sacred dragon will puts it in the ith city. Through long years, some cities&#39; dragon ball(s) would be transported to other cities. To save physical strength WuKong plans to take Flying Nimbus Cloud, a magical flying cloud to gather dragon balls.<br>Every time WuKong will collect the information of one dragon ball, he will ask you the information of that ball. You must tell him which city the ball is located and how many dragon balls are there in that city, you also need to tell him how many times the ball has been transported so far.<br>Input</p><blockquote><p>The first line of the input is a single positive integer T(0 &lt; T &lt;= 100).<br>For each case, the first line contains two integers: N and Q (2 &lt; N &lt;= 10000 , 2 &lt; Q &lt;= 10000).<br>Each of the following Q lines contains either a fact or a question as the follow format:<br>  T A B : All the dragon balls which are in the same city with A have been transported to the city the Bth ball in. You can assume that the two cities are different.<br>  Q A : WuKong want to know X (the id of the city Ath ball is in), Y (the count of balls in Xth city) and Z (the tranporting times of the Ath ball). (1 &lt;= A, B &lt;= N)</p></blockquote><p>Output</p><blockquote><p>For each test case, output the test case number formated as sample output. Then for each query, output a line with three integers X Y Z saparated by a blank space.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3 3<br>T 1 2<br>T 3 2<br>Q 2<br>3 4<br>T 1 2<br>Q 1<br>T 1 3<br>Q 1</p></blockquote><p>Sample Output</p><blockquote><p>Case 1:<br>2 3 0<br>Case 2:<br>2 2 1<br>3 3 2</p></blockquote><p>Problem solving:<br>这道题最毒瘤的地方绝对是题意。<br>题目的意思大概就是有n个城市，初始的时候每个城市都有一个龙珠。<br>现在给你输入几个操作，一种是move，一种是count。move后面有两个数，代表着把第一个数代表的城市的所有的龙珠转移到第二个数代表的城市里面。然后count i的时候需要输出3个数。第一个数代表的是编号为i的龙珠当前所在的城市，第二个数是编号为i的龙珠当前所在城市拥有的龙珠个数，第三个数代表的是编号为i的龙珠移动的次数。</p><p>这道题一看就是并查集的问题(如果今天专题不是并查集我可能也想不到)，但这个并不是简单普通的并查集。他要求我们输出的数需要一些巧妙地想法去记录一下。</p><p>我们这里用sum[i]来表示第i个城市当前所具有的龙珠个数，p[i]还是并查集里面的p[i]，刚开始的时候初始化每个点的父节点都是自己，每个城市具有的龙珠个数都是1.</p><p>在join(合并)的过程中注意，题目要求的是把x的龙珠全部放到y，所以sum[y]+=sum[x],sum[x]=0,这一步这样就挺好理解的了。</p><p>然后i所在的城市我们直接输出p[i]就行，i所在的城市的龙珠个数输出sum[i]就行。编号为i的龙珠的移动个数不太好求，那我们怎么求呢？</p><p>我们想一下并查集的，就是有点类似于构建一个图的过程。那么每个龙珠移动的次数就正好是它的初始节点距离最大的那个父节点的距离。这道题里面正好每个龙珠的标号就是它的初始节点的编号，所以类似于find函数的查找再查找一遍就能找出它的移动次数了。</p><p>（还有一点坑了我就是，不要路径压缩。。。我记得板子是压缩了路径的，然后一直WA，一直WA。。。你需要一个查找距离的过程，如果路径压缩了，那每个移动距离都是1了，会破坏原本的构图。这毒瘤样例也没体现这个坑点。太坑了！！！</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int sijiaxiaozhu = 1e5;int p[sijiaxiaozhu],sum[sijiaxiaozhu];int find(int x){   return p[x]!=x?find(p[x]):x;}int xiaozhu(int x)//这个就是那个查找移动次数的函数{    int ans=0;    while(p[x]!=x)//其实跟并查集的find是差不多的的    {        x=p[x];        ans++;//没查找答案一次加一    }    return ans;}void join(int x,int y){    int fx=find(x),fy=find(y);    if(fx!=fy)    {        p[fx]=fy;        sum[fy]+=sum[fx];//这个就是龙珠转移的过程        sum[fx]=0;    }}int main(){    int t,nu=0;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        int n,m;        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            p[i]=i;sum[i]=1;        }        printf(&quot;Case %d:\n&quot;,++nu);        while(m--)        {            char s[2];            scanf(&quot;%s&quot;,s);            if(s[0]==&#39;T&#39;)            {                int a,b;                scanf(&quot;%d %d&quot;,&amp;a,&amp;b);                join(a,b);            }            if(s[0]==&#39;Q&#39;)            {                int a;                scanf(&quot;%d&quot;,&amp;a);                printf(&quot;%d %d %d\n&quot;,find(a),sum[find(a)],xiaozhu(a));            }        }    }}</code></pre><p>这个好像是叫带权并查集吧，挺难理解的。但是只要想做，就没有做不出来的题！</p><h3 id="Zjnu-Stadium"><a href="#Zjnu-Stadium" class="headerlink" title="Zjnu Stadium"></a>Zjnu Stadium</h3><p>Description:<br>In 12th Zhejiang College Students Games 2007, there was a new stadium built in Zhejiang Normal University. It was a modern stadium which could hold thousands of people. The audience Seats made a circle. The total number of columns were 300 numbered 1--300, counted clockwise, we assume the number of rows were infinite.<br>These days, Busoniya want to hold a large-scale theatrical performance in this stadium. There will be N people go there numbered 1--N. Busoniya has Reserved several seats. To make it funny, he makes M requests for these seats: A B X, which means people numbered B must seat clockwise X distance from people numbered A. For example: A is in column 4th and X is 2, then B must in column 6th (6=4+2).<br>Now your task is to judge weather the request is correct or not. The rule of your judgement is easy: when a new request has conflicts against the foregoing ones then we define it as incorrect, otherwise it is correct. Please find out all the incorrect requests and count them as R.<br>Input</p><blockquote><p>There are many test cases:<br>For every case:<br>The first line has two integer N(1&lt;=N&lt;=50,000), M(0&lt;=M&lt;=100,000),separated by a space.<br>Then M lines follow, each line has 3 integer A(1&lt;=A&lt;=N), B(1&lt;=B&lt;=N), X(0&lt;=X\&lt;300) (A!=B), separated by a space.</p></blockquote><p>Output</p><blockquote><p>For every case:<br>Output R, represents the number of incorrect request.</p></blockquote><p>Sample Input</p><blockquote><p>10 10<br>1 2 150<br>3 4 200<br>1 5 270<br>2 6 200<br>6 5 80<br>4 7 150<br>8 9 100<br>4 8 50<br>1 7 100<br>9 2 100</p></blockquote><p>Sample Output</p><blockquote><p>2</p></blockquote><p>Hint<br>Hint:<br>（PS： the 5th and 10th requests are incorrect）</p><p>Problem solving:<br>也是一道带权并查集的题，但是我不会。。。代码先贴上来啦，以后再补题解。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int sijia=52113;int f[sijia],sijiaxiaozhu[sijia],n,m;int find(int x){    if(x==f[x])    return f[x];    int t=f[x];    f[x]=find(f[x]);    sijiaxiaozhu[x] += sijiaxiaozhu[t];    return f[x];}bool Union(int x,int y,int m){    int a=find(x),b=find(y);    if(a==b)    {        if(sijiaxiaozhu[x]+m!=sijiaxiaozhu[y])            return 0;        return 1;    }    f[b]=a;    sijiaxiaozhu[b]=sijiaxiaozhu[x]+m-sijiaxiaozhu[y];    return 1;}int main(){    int a,b,x;    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        for(int i=0;i&lt;=n;i++)            f[i]=i,sijiaxiaozhu[i]=0;        int cnt=0;        for(int i=0;i&lt;m;i++)        {            scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;x);            if(!Union(a,b,x))   cnt++;        }        printf(&quot;%d\n&quot;,cnt);    }}</code></pre><h3 id="How-Many-Tables"><a href="#How-Many-Tables" class="headerlink" title="How Many Tables"></a>How Many Tables</h3><p>Description:<br>Today is Ignatius&#39; birthday. He invites a lot of friends. Now it&#39;s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.</p><p>One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.</p><p>For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.<br>Input</p><blockquote><p>The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.</p></blockquote><p>Output</p><blockquote><p>For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>5 3<br>1 2<br>2 3<br>4 5<br>5 1<br>2 5</p></blockquote><p>Sample Output</p><blockquote><p>2<br>4</p></blockquote><p>Problem solving:<br>题意我也懒得分析了，就是一个简单并查集，套板子就行了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int sijiaxiaozhu=1e4;int p[sijiaxiaozhu];int find(int x){    return p[x]!=x?p[x]=find(p[x]):x;}void join(int x,int y){    x=find(x),y=find(y);    if(x!=y) p[x]=y;}int main(){    int t,n,m,a,b;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        int ans=0;        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)   p[i]=i;        for(int i=0;i&lt;m;i++)        {            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);            join(a,b);        }        for(int i=1;i&lt;=n;i++)        {            if(p[i]==i) ans++;        }        printf(&quot;%d\n&quot;,ans);    }}</code></pre><h3 id="Highways"><a href="#Highways" class="headerlink" title="Highways"></a>Highways</h3><h3 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h3><h3 id="Highways-1"><a href="#Highways-1" class="headerlink" title="Highways"></a>Highways</h3><h3 id="Agri-Net"><a href="#Agri-Net" class="headerlink" title="Agri-Net"></a>Agri-Net</h3><h3 id="Jungle-Roads"><a href="#Jungle-Roads" class="headerlink" title="Jungle Roads"></a>Jungle Roads</h3><h3 id="Truck-History"><a href="#Truck-History" class="headerlink" title="Truck History"></a>Truck History</h3><h3 id="畅通工程再续"><a href="#畅通工程再续" class="headerlink" title="畅通工程再续"></a>畅通工程再续</h3><h3 id="Constructing-Roads"><a href="#Constructing-Roads" class="headerlink" title="Constructing Roads"></a>Constructing Roads</h3>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 并查集 </tag>
            
            <tag> kruscal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stringstream(常见函数及其常见用法)</title>
      <link href="/2019/08/05/stringstream/"/>
      <url>/2019/08/05/stringstream/</url>
      
        <content type="html"><![CDATA[<h3 id="Some-common-usage"><a href="#Some-common-usage" class="headerlink" title="Some common usage"></a>Some common usage</h3><h4 id="Data-type-conversion-数据类型的转换"><a href="#Data-type-conversion-数据类型的转换" class="headerlink" title="Data type conversion(数据类型的转换)"></a>Data type conversion(数据类型的转换)</h4><p>For example:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    string       a = &quot;521&quot;, b;    int          c, d = 1314;    stringstream x, y;    x &lt;&lt; a;   y &lt;&lt; d;    x &gt;&gt; c;   y &gt;&gt; b;    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl &lt;&lt; c &lt;&lt; d &lt;&lt; endl;    cout &lt;&lt; &quot;The size of b is &quot; &lt;&lt; sizeof(b) &lt;&lt; &quot;\nThe size of c is &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;}</code></pre><p>Output:</p><blockquote><p>5211314<br>5211314<br>The size of b is 24<br>The size of c is 4</p></blockquote><p>In this case,we transform a string to int and an int to string through stringstream.</p><h4 id="Can-be-used-to-split-strings-separated-by-spaces-etc-可以分割被空格分割的字符串"><a href="#Can-be-used-to-split-strings-separated-by-spaces-etc-可以分割被空格分割的字符串" class="headerlink" title="Can be used to split strings separated by spaces etc.(可以分割被空格分割的字符串)"></a>Can be used to split strings separated by spaces etc.(可以分割被空格分割的字符串)</h4><p>For example:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    string       s = &quot;521 1314&quot;,mid;    stringstream x(s);    while (x &gt;&gt; mid)    {        cout &lt;&lt; mid &lt;&lt; endl;    }}</code></pre><p>Output:</p><blockquote><p>521<br>1314</p></blockquote><p>This part is always useful in some type.</p><h3 id="Official-explanation"><a href="#Official-explanation" class="headerlink" title="Official explanation"></a>Official explanation</h3><p>CPP: <a href="https://www.cplusplus.com/reference/sstream/stringstream/" target="_blank" rel="noopener">https://www.cplusplus.com/reference/sstream/stringstream/</a></p><p>As far as I know,If you can grasp the common usage,it&#39;s enough in ACM.</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 19(河南理工大学暑期第十九天)</title>
      <link href="/2019/08/04/19/"/>
      <url>/2019/08/04/19/</url>
      
        <content type="html"><![CDATA[<p>早上五点左右醒来。癔症一会发现睡不着了，六点开始玩手机，玩到七点。<br>到了七点，开始了今天最重要的一件事，给我的图片换一下外链。之前所有的外链都是通过sm.ms弄得，也不能说它不好，就是时间久了的图片加载会很慢很慢，进而拖慢我整个博客的速度。前几天从学长那白嫖了了一个备案过的域名。有时会到了七牛云作图床的时代。不过人家七牛云是真的快。</p><p>换外链换到十一点多，出去吃了个饭直接去机房了。在机房水题水到两点做不下去了就去打了会球，打球回来四点多。</p><p>然后就开始了今天第二重要的事，做一个相册。之前做过，但是因为访问速度直接是弃用了，现在用的这个七牛云可以说是很舒服了。在网上找了个模板，套了一下，就到八点了。<br>想看我得新相册?<br>我帅不帅？<br><a href="https://blog.cndrew.cn/album/" target="_blank" rel="noopener">一般帅</a> <a href="https://blog.cndrew.cn/album/" target="_blank" rel="noopener">帅的惊天动地</a> <a href="https://blog.cndrew.cn/album/" target="_blank" rel="noopener">帅的无法形容</a></p><p>选对了就能进哦</p><p>我的假期就这样没了，没了。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的直径以及邻接表，链式前向星的存图</title>
      <link href="/2019/08/04/mapsave/"/>
      <url>/2019/08/04/mapsave/</url>
      
        <content type="html"><![CDATA[<p>先来了解一下什么是树：<br>树（tree）是包含n（n&gt;0）个结点的有穷集，其中：</p><ul><li>每个元素称为结点（node）；</li><li>有一个特定的结点被称为根结点或树根（root）；</li><li>除根结点之外的其余数据元素被分为m（m≥0）个互不相交<br>的集合T1，T2，…Tm-1，其中每一个集合Tm-1（1≤i≤m）<br>本身也是一棵树，被称作原树的子树（subtree）。</li></ul><p>树中距离最大的两个结点之间的距离称为树的直径。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101208.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101208.webp" class="img-shadow img-margin"></center></a></p><p>树的直径的求法：</p><p>两次dfs或bfs。第一次任意选一个点进行dfs(bfs)找到离它最远的<br>点，此点就是最长路的一个端点，再以此点进行dfs（bfs），找到<br>离它最远的点，此点就是最长路的另一个端点，于是就找到了树<br>的直径。</p><p>证明：<br>假设此树的最长路径是从s到t,我们选择的点为u。<br>反证法：假设搜到的点是v。<br>1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s],显然矛<br>盾。<br>2、v不在这条最长路径上，我们在最长路径上选择一个点为po，<br>则dis[u,v]&gt;dis[u,po]+dis[po,t]，那么有dis[s,v]=dis[s,po]+dis[po,u]<br>+dis[u,v]&gt;dis[s,po]+dis[po,t]=dis[s,t],即dis[s,v]&gt;dis[s,t],矛盾。<br>也许你想说u本身就在最长路径，或则其它的一些情况，但其实<br>都能用类似于上面的反证法来证明的。<br>综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路<br>径长度。        以上内容参考与学长的PDF</p><p>其实证明看不太懂得话问题不大，就是随便找一个位置先进行dfs或者bfs到达一个端点，再以这个端点为起点dfs或者bfs到达另一个端点即可。</p><p>有的题它让你处理的就是字符串组成的图，但是有的题就不会这么好心了，他会给出你节点，边，甚至有的还会给你出权值。此时我们就需要自己存图。</p><p>说到存图，一般都有三种方法。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>用二维数组进行存图，这个是最普通的办法，但是有一个致命的缺点就是当题目数据中的点比较多的时候有极高的空间复杂度，会爆内存。不过数据范围小的时候用二维数组来存图。还是很简单的。<br>举个栗子：<br>5个点 4条边<br>对每条边输入三个数，两个端点以及这条边的权值<br>1 2 2<br>2 3 4<br>4 5 1<br>1 4 2<br>1 5 3</p><pre><code>char s[maxn][maxn];for(int i=0;i&lt;n;i++){    cin&gt;&gt;x&gt;&gt;y&gt;&gt;p;    s[x][y]=p;    s[y][x]=p;//如果是有向图的话，就不需要这一句了    }</code></pre><p>访问的时候直接s[i][j]就行了</p><h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p>邻接表法就是用vector来进行存储，这个也挺好理解，跟二维数组可以一样的理解。<br>举个栗子：<br>5个点 4条边<br>对每条边输入三个数，两个端点以及这条边的权值<br>1 2 2<br>2 3 4<br>4 5 1<br>1 4 2<br>1 5 3</p><pre><code>//无权值vector&lt;int&gt; v[maxn];for(int i=0;i&lt;n;i++){    cin&gt;&gt;x&gt;&gt;y;    v[x].push_back(y);    v[y].push_back(x);//有向边的话不需要者一句}</code></pre><pre><code>//有权值vector&lt;pair&lt;int,int&gt; &gt; v[maxn]；fot(int i=0;i&lt;n;i++){    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;    v[x].push_back(make_pair(y,z));    v[y].push_back(make_pair(x,z));//有向边的话不需要者一句}</code></pre><p>访问每条边的时候需要这样写</p><pre><code>for(int i=0;i&lt;n;i++){    for(int j=0;j&lt;v[i].size();j++)    {        cout&lt;&lt;v[i][j].first&lt;&lt;&quot;-&gt;&quot;&lt;&lt;v[i][j].second;    }}</code></pre><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>链式前向星是一种很巧妙地方法。<br>首先建立一个结构体</p><pre><code>struct Edge{    int e;//表示第i条边的终点    int w;//权值    int next;//表示同起点的下一条边};</code></pre><p>加边</p><pre><code>cnt=0,head=-1;void add ( int u, int v, int w){edge [cnt ].w = w;edge [cnt ]. to = v;edge [cnt ]. next = head [u];head [u] = cnt ++;}</code></pre><p>边的遍历</p><pre><code>for (int i= head [u];~i;i= edge [i]. next ){cout &lt;&lt;u&lt;&lt;&quot; -&gt;&quot; &lt;&lt;edge [i].e&lt;&lt; endl ;}</code></pre><p>链式前向星不会遍历到不存在的边。<br>内存利用率高，相比vector实现的邻接表而言，可以准确开辟最多边数的内存，不像vector实现的邻接表有爆内存的风险。</p><p>如果有兴趣深入理解存图的话可以参考一下这几篇博客：<a href="https://blog.csdn.net/acdreamers/article/details/16902023" target="_blank" rel="noopener">https://blog.csdn.net/acdreamers/article/details/16902023</a></p><p><a href="https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/</a></p><p>三种存图方式的介绍就到这里了，我最喜欢用的是第二种，好理解又方便写，但是不得不承认链式前向星的优秀，还是应该会用的。</p><p>说完了存图，我还想说一下用邻接表存了图之后该如何进行搜索（这里以bfs为例）。</p><p>我们只需要对每个顶点进行搜索即可，即bfs传递的参数为邻接表中的第一个元素。<br>直接上代码吧<br>无权值得</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+10;int dis[maxn],ans,vis[maxn],n,a,b;vector&lt;int&gt; v[maxn];int bfs(int x){    memset(vis,0,sizeof(vis));    memset(dis,0,sizeof(dis));    queue&lt;int&gt; q;    q.push(x);    vis[x]=1,dis[x]=0;    int point;    while(!q.empty())    {        x=q.front();        q.pop();        if(dis[x]&gt;ans)        {            ans=dis[x];            point=x;        }        for(int i=0;i&lt;v[x].size();i++)        {            if(!vis[v[x][i]])            {                vis[v[x][i]]=1;                dis[v[x][i]]=dis[x]+1;                q.push(v[x][i]);            }        }    }    return point;}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;n;i++)    {        cin&gt;&gt;a&gt;&gt;b;        v[a].push_back(b);        v[b].push_back(a);    }    ans=0;    int point=bfs(1);    ans=0;    bfs(point);    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><p>有权值的</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int a,b,c,ans;const int maxn = 1e5+10;int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pairint bfs(int x){    memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组    memset(dis,0,sizeof(dis));    vis[x]=1;//已经访问过的节点标记为1    int point=0;//用来储存当前所能走到的最远的点    queue&lt;int&gt; q;//用来实现bfs的队列    q.push(x);    while(!q.empty())    {        x=q.front();        q.pop();        if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值        {            ans=dis[x];            point=x;        }        pair&lt;int,int&gt; mid;        for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs        {            mid=v[x][i];            if(!vis[mid.first])//没访问过就继续            {                vis[mid.first]=1;//标记成已经访问过的                dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x]                q.push(mid.first);//放进队列以进行bfs            }        }    }    return point;//把当前走到的最远的点返回}int main(){    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)    {        v[a].push_back(make_pair(b,c));//存图        v[b].push_back(make_pair(a,c));    }    ans=0;//初始化    int point=bfs(1);    ans=0;    bfs(point);//第二次以某一端点位起点的bfs    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><p>这里只需要看一下对邻接表中vector下标的使用即可。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BFS </tag>
            
            <tag> 邻接表 </tag>
            
            <tag> 树的直径 </tag>
            
            <tag> “链式前向星” </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 18(河南理工大学暑期第十八天)</title>
      <link href="/2019/08/03/18/"/>
      <url>/2019/08/03/18/</url>
      
        <content type="html"><![CDATA[<p>今天又是一场积分赛，虽然知道了明天要休息一天了，刚刚结束比赛的我现在心里还是高兴不起来。<br>一开始心态就崩了，第一题看不懂，第二题看不懂，第三题太麻烦，第四题，不会，第五题，哦哦，可算是看到个能看懂的题了，这一看就是个规律题啊，盘它。然后WA了，看看榜，一堆人都做出来了第一题。可我还是题都看不懂，emm<br>然后就这个碎了一地的心态做完了整场比赛，有一道感觉可以搞出来的没搞出来，还是很亏的。&lt;/br&gt;<br>今天了解到一个贼逗比的<del>~学姐</del>~小猪。靠它保佑也过了不少题哈哈哈哈。<br>明天放假。<del>~high起来</del>~其实我准备把博客所有图片放在七牛云上，应该能提速不少。说到这里还是要谢谢学长的，帮我搞了一个备案的域名，谢谢谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河南理工大学算法协会暑期集训积分赛（三）</title>
      <link href="/2019/08/03/jifen3/"/>
      <url>/2019/08/03/jifen3/</url>
      
        <content type="html"><![CDATA[<h3 id="蚂蚁觅食（一）"><a href="#蚂蚁觅食（一）" class="headerlink" title="蚂蚁觅食（一）"></a>蚂蚁觅食（一）</h3><p>Description:<br>一只饥饿的小蚂蚁外出觅食，幸运的小蚂蚁发现了好多食物，但是它只有一次搬食物的机会。<br>可因为力气太小了，它不能搬走重量超过自己体重的食物,且只能搬走位置相邻的两个食物，或者只搬走其中一个。<br>食物的位置不会改变。<br>这可难住了这只蚂蚁，它不知道它最多能搬走多重的食物。请帮小蚂蚁计算。</p><p>输入格式</p><blockquote><p>第一行一个正整数n，(n&gt;=0并且n&lt;=1000)<br>第二行n个正整数 A[1].....A[n]，A[i] 表示在第i 个位置上食物的重量。A[i]&lt;=1e9.<br>第三行一个正整数m，表示蚂蚁的体重。(m&lt;=1e9).</p></blockquote><p>输出格式</p><blockquote><p>一个整数表示小蚂蚁能带走的食物的重量。</p></blockquote><p>样例<br>input</p><blockquote><p>3<br>1 3 3<br>4</p></blockquote><p>output</p><blockquote><p>4</p></blockquote><p>Problem solving:<br>神TM签到题，愣是没看懂是啥意思。。。<br>最后看懂了，就是找一个跟m尽量接近的一个数或者相邻两个数的和尽量接近m的。<br>我是把每个数和相邻的数的和存进一个数组然后O(N)查找<br>找到输出就行</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2005;long long a[maxn],m;int main(){    int n,ans=0;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];    for(int i=n;i&lt;2*n-1;i++)    a[i]=a[i-n]+a[i-n+1];    sort(a,a+2*n-1);    cin&gt;&gt;m;    for(int i=0;i&lt;2*n-1;i++)    {        if(a[i]&gt;m)    break;        ans=a[i];    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>Description:<br>一只饥饿的小蚂蚁外出觅食，幸运的的小蚂蚁发现了好多食物。<br>但是这些食物位于一个N∗M的方格魔法阵的右下角，而小蚂蚁位于方格法阵的左上角。<br>并且小蚂蚁被施展了魔法，它只能向下或者向右走。<br>请你帮助小蚂蚁计算一下，它一共有多少条路可以走到有食物的方格。</p><p>输入格式</p><blockquote><p>多组输入，<br>每一组两个正整数N， M （N,M≤30）。表示一个方格魔法阵。</p></blockquote><p>输出格式</p><blockquote><p>一个整数表示一共有多少条路。</p></blockquote><p>样例<br>input</p><blockquote><p>2 3</p></blockquote><p>output</p><blockquote><p>3</p></blockquote><p>Problem solving:<br>这道题据说可以用排列数做（高中知识。）<br>倒是我哪会高中知识啊，就推呗。<br>然后找到了递推式，我们用dp[x][y]来表示（x，y）位置到终点有几条路。那么可以得到dp[x][y]=dp[i-1][j]+dp[i][j-1]<br>边界条件是，当x或者y等于1的时候只有一条路，因为只能往右或者往下走。<br>推理过程：<br>首先看一下图吧<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/jifen1.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/jifen1.webp" class="img-shadow img-margin"></center></a><br>假设我们现在要求(4,3)这个位置到终点(1,1)的路径条数，从(4,3)走出来只有两种选择，向右或者向下，所以我们走到了(4,2),(3,3),这时我们只需要求(4,2)(3,3)到终点的路径条数然后求和就行了。以此类推，就可以得到上面的递推式了。</p><p>然后就是注意这个是多组输入。。！！！<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;ll ans[32][32];int main(){    for(int i=1;i&lt;=31;i++)    {        for(int j=1;j&lt;=31;j++)        {            if(i==1||j==1)    ans[i][j]=1;            else ans[i][j]=ans[i-1][j]+ans[i][j-1];        }    }    ll n,m;    while(cin&gt;&gt;n&gt;&gt;m)    {        cout&lt;&lt;ans[n][m]&lt;&lt;endl;    }}</code></pre><h3 id="蚂蚁觅食（三）"><a href="#蚂蚁觅食（三）" class="headerlink" title="蚂蚁觅食（三）"></a>蚂蚁觅食（三）</h3><p>Description:<br>马上就要冬天了，勤劳的小蚂蚁需要储存足够多的食物才能安全过冬。<br>今天，这只小蚂蚁走出巢穴寻找食物，但是这次蚁巢周围只有很少的食物，它需要去别的地方。<br>不幸的是小蚂蚁的体力很有限，而且每走一个单位长度就要消耗一点体力，不能找的时间太久，所以想让你帮忙计算一下它是否能用剩下的体力把足够多的食物搬回蚁巢。<br>由于蚂蚁的嘴太小，每次最多只能衔起一个食物。</p><p>输入格式</p><blockquote><p>输入t组, t≤20<br>第一行三个数n,E,V表示食物的个数，蚂蚁剩余的体力，安全过冬需要的最少食物体积, 0&lt;n≤100,0&lt;E,V≤10000。<br>接下来n行，每行两个数pi,vi,表示第i个食物的位置和体积,0&lt;p[i],v[i]≤1000。<br>初始蚂蚁和蚁巢均在坐标轴原点。</p></blockquote><p>输出格式</p><blockquote><p>每个输出占一行。<br>如果蚂蚁能安全过冬，输出 “YES”,否则输出”NO”。</p></blockquote><p>样例<br>input</p><blockquote><p>2<br>1 2 2<br>1 2<br>1 2 2<br>2 1</p></blockquote><p>output</p><blockquote><p>YES<br>NO</p></blockquote><p>Problem solving:<br>一道简单的01背包题，背包容量是蚂蚁当前剩余的体力值。<br>每个物品的价值就是食物的体积，所占的背包容量的大小就是距离乘2（因为还要回来）。<br>然后比较最多能达到的食物体积，与需要的最少的食物体积进行标比较就行了。01背包的部分套板子写的<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;int n,e,v;const int maxn=100005;int si[maxn],jia[maxn],dp[100005];using namespace std;int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        memset(dp,0,sizeof(dp));        cin&gt;&gt;n&gt;&gt;e&gt;&gt;v;        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;si[i]&gt;&gt;jia[i];            si[i]*=2;        }        for(int i=0;i&lt;n;i++)        {            for(int j=e;j&gt;=si[i];j--)            {                dp[j]=max(dp[j],dp[j-si[i]]+jia[i]);            }        }        if(dp[e]&gt;=v)    puts(&quot;YES&quot;);        else    puts(&quot;NO&quot;);    }}</code></pre><h3 id="蚂蚁平面"><a href="#蚂蚁平面" class="headerlink" title="蚂蚁平面"></a>蚂蚁平面</h3><p>Description:<br>平面上有 n只蚂蚁，它走过的路径可以看作一条直线</p><p>由这n 条直线定义的某些区域是无界的，而另一些区域则是有界的。</p><p>有界区域的最大个数是多少？</p><p>比如现在有4条直线，只有下面最左边的图中直线定义的有界区域是最多的</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/jay.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/jay.webp" class="img-shadow img-margin"></center></a><p>输入格式</p><blockquote><p>T 组输入, (1≤T≤100)<br>每组一个数 n ，(1≤n≤109)</p></blockquote><p>输出格式</p><blockquote><p>对于每组数据，输出一个整数表示有界区域的最大个数。</p></blockquote><p>样例</p><p>input</p><blockquote><p>1<br>4</p></blockquote><p>output</p><blockquote><p>3</p></blockquote><p>Problem solving:<br>这道题就是一个公式，n条线能组成的有界区域的最大个数是从1加到n。<br>比赛时候谁知道这是公式啊，画图画到5条线的时候发现的规律写了一遍交了，嘿，还真过了。<br>佩服用矩快的同学，我是真的不知道咋构建矩阵。<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n,t;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;n;        ll ans;        ans=(n-1)*(n-2)/2;        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="蚂蚁和斐波那契"><a href="#蚂蚁和斐波那契" class="headerlink" title="蚂蚁和斐波那契"></a>蚂蚁和斐波那契</h3><p>Description:<br>聪明的小蚂蚁最近学习了斐波那契数列,但是它想到了一个问题：<br>从L到R之间斐波那契数列和的奇偶是什么呢？<br>其中Fib[1]=1,Fib[2]=1 .</p><p>输入格式</p><blockquote><p>单组输入:<br>每组输入两个以空格隔开的数字 L 和 R<br>其中 (0&lt;L&lt;=R&lt;1e18)</p></blockquote><p>输出格式</p><blockquote><p>从 L 到 R 斐波那契数列和的奇偶，如果是奇数输出 &quot;1&quot; (不带引号) ，否则输出 &quot;0&quot; (不带引号)</p></blockquote><p>样例<br>input</p><blockquote><p>1 2</p></blockquote><p>output</p><blockquote><p>0</p></blockquote><p>Problem solving:<br>这道题就是个找规律的题没啥好说的，看代码自行体会吧。（我可能写的麻烦了）</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[55];int main(){    ll mid,miid,l,r;    cin&gt;&gt;l&gt;&gt;r;    mid=l%3,miid=r%3;    if(mid==0&amp;&amp;miid==0)    puts(&quot;0&quot;);    else if(mid==miid)    puts(&quot;1&quot;);    else if(mid==0&amp;&amp;miid==1)    puts(&quot;1&quot;);    else if(mid==0&amp;&amp;miid==2)    puts(&quot;0&quot;);    else if(mid==1&amp;&amp;miid==0)        puts(&quot;0&quot;);    else if(mid==2&amp;&amp;miid==0)        puts(&quot;1&quot;);    else if(mid==2&amp;&amp;miid==1)        puts(&quot;0&quot;);    else if(mid==1&amp;&amp;miid==2)        puts(&quot;0&quot;);    return 0;}</code></pre><h3 id="蚂蚁装修"><a href="#蚂蚁装修" class="headerlink" title="蚂蚁装修"></a>蚂蚁装修</h3><p>Description:<br>还有一个月就开学了，爱学习的小蚂蚁想庆祝一下！于是它要把它的“家”装修一下。<br>首先要做的就是贴地板。<br>小蚂蚁“家”的地面可以看成一个2∗N 的方格 ，它拥有无数块1∗2 和 2∗1的地板。<br>请你帮下蚂蚁计算一下一共有多少种方法能把地面给放满 。<br>地板不能切割，也不能重叠。</p><p>输入格式</p><blockquote><p>单组输入：<br>只有一个数字 N<br>其中 (0&lt;N&lt;1e18)</p></blockquote><p>输出格式</p><blockquote><p>输出放法数对1e9+7取模的结果</p></blockquote><p>样例<br>input</p><blockquote><p>2</p></blockquote><p>output</p><blockquote><p>2</p></blockquote><p>input</p><blockquote><p>1</p></blockquote><p>output</p><blockquote><p>1</p></blockquote><p>Problem solving:<br>手动画了几个状态，发现这个个数就是斐波那契数列，但是要求的最大的是1e18项，所以正好可以用矩快解决。注意用long long</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int  mod=1e9+7;typedef long long ll;struct node{    ll m[2][2];};node mul(node a,node b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(ll i=0;i&lt;2;i++)    {        for(ll j=0;j&lt;2;j++)        {            for(ll k=0;k&lt;2;k++)            {                ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%mod;            }        }    }    return ans;}node poww(node a,ll b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(ll i=0;i&lt;2;i++)    ans.m[i][i]=1;    while(b)    {        if(b&amp;1)    ans=mul(ans,a);        a=mul(a,a);        b/=2;    }    return ans;}node si,jia;int main(){    si.m[0][0]=2,si.m[1][0]=1,si.m[0][1]=0,si.m[1][1]=0;    jia.m[0][0]=1,jia.m[1][0]=1,jia.m[0][1]=1,jia.m[1][1]=0;    ll n;    cin&gt;&gt;n;    if(n==1)    {        cout&lt;&lt;1%mod&lt;&lt;endl;return 0;    }    if(n==2)    {        cout&lt;&lt;2%mod&lt;&lt;endl;return 0;    }    node xiaozhu=poww(jia,n-2);    xiaozhu=mul(xiaozhu,si);    cout&lt;&lt;xiaozhu.m[0][0]&lt;&lt;endl;}</code></pre><h3 id="蚂蚁的镜像串"><a href="#蚂蚁的镜像串" class="headerlink" title="蚂蚁的镜像串"></a>蚂蚁的镜像串</h3><p>Description:</p><p>Problem solving:<br>这道题，，是真的坑啊。<br>把可以组成镜像串的字母列出来，判断每一个字符，如果出现了不可以组成镜像串的直接就不是镜像串了。如果你也是这样想的这么单纯，恭喜你你会WA很多次。WA到怀疑人生那种。<br>因为bdpq他们也是可以组成镜像串的。<br>知道了这一点就可以很简单的解决这个问题了</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int t;    string s;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;s;        int flag=1;         string mid=s;         reverse(mid.begin(),mid.end());        for(int i=0;i&lt;s.size();i++)        {            if((s[i]==&#39;b&#39;&amp;&amp;mid[i]==&#39;d&#39;)||(s[i]==&#39;d&#39;&amp;&amp;mid[i]==&#39;b&#39;)||(s[i]==&#39;p&#39;&amp;&amp;mid[i]==&#39;q&#39;)||(s[i]==&#39;q&#39;&amp;&amp;mid[i]==&#39;p&#39;)||(s[i]==mid[i]&amp;&amp;(s[i]==&#39;A&#39;||s[i]==&#39;H&#39;||s[i]==&#39;I&#39;||s[i]==&#39;i&#39;||s[i]==&#39;l&#39;||s[i]==&#39;M&#39;||s[i]==&#39;m&#39;||s[i]==&#39;n&#39;||s[i]==&#39;O&#39;||s[i]==&#39;o&#39;||s[i]==&#39;T&#39;||s[i]==&#39;U&#39;||s[i]==&#39;u&#39;||s[i]==&#39;V&#39;||s[i]==&#39;v&#39;||s[i]==&#39;W&#39;||s[i]==&#39;w&#39;||s[i]==&#39;X&#39;||s[i]==&#39;x&#39;||s[i]==&#39;Y&#39;)))            {                continue;            }            else            {                flag=0;                break;            }        }        if(flag==1)    puts(&quot;YES&quot;);        else    puts(&quot;NO&quot;);    }}</code></pre><h3 id="蚂蚁赛跑"><a href="#蚂蚁赛跑" class="headerlink" title="蚂蚁赛跑"></a>蚂蚁赛跑</h3><p>Description:<br>小白和小黑非常喜欢养蚂蚁，他们每个人都养了n只蚂蚁。<br>有一天，他们想比一比谁养蚂蚁的本领更强，于是就举办了一场蚂蚁赛跑比赛。假设蚂蚁都是匀速直线奔跑。<br>比赛的规则是这样的：每只蚂蚁必须且最多比一场，赢一场得10分，输一场扣10分。平局都不得分也不扣分。<br>狡猾的小黑同学为了赢得比赛，提前偷到了小白所有蚂蚁得速度，请你帮小黑算一算，他在比赛中最多得多少分。</p><p>输入格式</p><blockquote><p>有多组测试案例，最多有100组，对于每一组案例：<br>第一行以正整数n ,（n≤1000），即每个人的蚂蚁数量。<br>第二行的n个整数是小黑的蚂蚁的速度。<br>第三行的n整数是小白的蚂蚁速度。<br>蚂蚁的速度小于100</p></blockquote><p>输出格式</p><blockquote><p>对于每个输入案例，输出一个整数，这是小黑能够获得的最大分数。</p></blockquote><p>样例<br>input</p><blockquote><p>2<br>10 10<br>10 10<br>2<br>10 1<br>100 8</p></blockquote><p>output</p><blockquote><p>0<br>0</p></blockquote><p>Problem solving:<br>贪心，但是我们贪出来，等到我够贪心了再补上</p><p>Code:</p><pre><code>/** *　　　　　　　　┏┓　　 　┏┓ * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　 　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　... 　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛ */// warm heart, wagging tail,and a smile just for you!////                            _ooOoo_//                           o8888888o//                           88&quot; . &quot;88//                           (| -_- |)//                           O\  =  /O//                        ____/`---&#39;\____//                      .&#39;  \|     |//  `.//                     /  \|||  :  |||//  \//                    /  _||||| -:- |||||-  \//                    |   | \\  -  /// |   |//                    | \_|  &#39;&#39;\---/&#39;&#39;  |   |//                    \  .-\__  `-`  ___/-. ///                  ___`. .&#39;  /--.--\  `. . __//               .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |//              \  \ `-.   \_ __\ /__ _/   .-` /  ///         ======`-.____`-.___\_____/___.-`____.-&#39;======//                            `=---=&#39;//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//</code></pre><h3 id="蚂蚁上树"><a href="#蚂蚁上树" class="headerlink" title="蚂蚁上树"></a>蚂蚁上树</h3><p>Description:<br>蚂蚁上树（Sauteed Vermicelli with minced Pork），又名肉末粉条，是四川省及重庆市的特色传统名菜之一。因肉末贴在粉丝上，形似蚂蚁爬在树枝上而得名。这道菜具体的历史，已不可考。但在四川省、重庆市一带，该菜很常见。</p><p>蚂蚁上树通常由粉丝（或者粉条）、肉末为主料，辅以胡萝卜、姜、葱、豆瓣酱等辅料制作而成。成菜后，口味清淡，爽滑美味，色泽红亮，食之别有风味。</p><p>蚂蚁想知道这棵树上距离最远的两个点之间的距离</p><p>给你一个具有 n 个节点的树</p><p>求这棵树上距离最远的两个点之间的距离</p><p>输入格式</p><blockquote><p>第一行一个整数 n ，(1≤n≤1e4)<br>接下来 n−1 行，每行三个整数 x,y,z 表示 x 与 y 之间有一条长度为 z 的边 (1≤x,y≤n,1≤z≤104)</p></blockquote><p>输出格式</p><blockquote><p>一个整数表示树上距离最远的两个点之间的距离</p></blockquote><p>样例<br>input</p><blockquote><p>5<br>1 2 9<br>1 3 3<br>1 5 2<br>2 4 10</p></blockquote><p>output</p><blockquote><p>22</p></blockquote><p>Problem solving:<br>求树的直径，套班子就行啦，别忘了long long</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e4+10;ll n,x,y,z,dis[maxn],vis[maxn];vector&lt;pair&lt;int,int&gt; &gt; v[maxn];void bfs(ll x){    queue&lt;int&gt; q;    q.push(x);    vis[x]=1;    dis[x]=0;    while(!q.empty())    {        x=q.front();        q.pop();        for(int i=0;i&lt;v[x].size();i++)        {            if(!vis[v[x][i].first])            {                q.push(v[x][i].first);                dis[v[x][i].first]=dis[x]+v[x][i].second;                vis[v[x][i].first]=1;            }        }    }}int main(){    cin&gt;&gt;n;    for(int i=0;i&lt;n-1;i++)    {        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;        v[x].push_back(make_pair(y,z));        v[y].push_back(make_pair(x,z));    }    bfs(1);    ll si=0,jia,ans=0;    for(int i=1;i&lt;=n;i++)    {        if(dis[i]&gt;si)        {            si=dis[i];            jia=i;        }    }    memset(vis,0,sizeof(vis));    memset(dis,0,sizeof(dis));    bfs(jia);    for(int i=1;i&lt;=n;i++)    {        ans=max(ans,dis[i]);    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h3 id="蚂蚁的游戏"><a href="#蚂蚁的游戏" class="headerlink" title="蚂蚁的游戏"></a>蚂蚁的游戏</h3><p>Description:<br>蚂蚁Bob和蚂蚁Alice是青梅竹蚁，Alice喜欢和Bob一起玩游戏，每当Alice想到新的游戏，都会找Bob一起玩</p><p>今天Alice的游戏是这样的：</p><p>n堆石子，两人轮流取。每次只能在1堆中取，不能不取，最先取完石子者胜</p><p>Alice先取石子，Alice和Bob都非常聪明，拿石子的过程中不会出现失误。</p><p>输入格式</p><blockquote><p>第一行有一个整数T，有T组输入数据(T≤50)<br>每组第一行有一个数n表示有n堆石子，(1≤n≤20000)<br>第二行有n个非零整数x，表示每堆石子的数量(x≤1e3)</p></blockquote><p>输出格式</p><blockquote><p>请你判断Alice能否在游戏中获胜，如果不能获胜，输出NO。<br>否则，输出YES，并输出第一次取石子的所有方法（具体参见样例和提示）</p></blockquote><p>样例<br>input</p><blockquote><p>2<br>2<br>45 45<br>5<br>5 7 8 9 10</p></blockquote><p>output</p><blockquote><p>NO<br>YES<br>3 1<br>4 0<br>5 3</p></blockquote><p>提示<br>对于第一组样例，不论Alice怎么取，Bob总能拿到最后一个石子，所以输出为NO</p><p>对于第二组样例，Alice可以第一次取石子有三种取法：</p><p>第3堆取出7个，剩下1个<br>第4堆全部取出，剩下0个<br>第5堆取出7个，剩下3个<br>对于每组输出，总是按照堆的编号顺序输出的<br>Problem solving:<br>博弈论的问题，好像有板子可以套，但是我并不会。学会了再补吧</p><p>Code:</p><pre><code>/** *　　　　　　　　┏┓　　 　┏┓ * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　 　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　... 　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛ */// warm heart, wagging tail,and a smile just for you!////                            _ooOoo_//                           o8888888o//                           88&quot; . &quot;88//                           (| -_- |)//                           O\  =  /O//                        ____/`---&#39;\____//                      .&#39;  \|     |//  `.//                     /  \|||  :  |||//  \//                    /  _||||| -:- |||||-  \//                    |   | \\  -  /// |   |//                    | \_|  &#39;&#39;\---/&#39;&#39;  |   |//                    \  .-\__  `-`  ___/-. ///                  ___`. .&#39;  /--.--\  `. . __//               .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |//              \  \ `-.   \_ __\ /__ _/   .-` /  ///         ======`-.____`-.___\_____/___.-`____.-&#39;======//                            `=---=&#39;//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> BFS </tag>
            
            <tag> dp </tag>
            
            <tag> 背包 </tag>
            
            <tag> 矩阵快速幂 </tag>
            
            <tag> Thinking </tag>
            
            <tag> Greedy </tag>
            
            <tag> 树的直径 </tag>
            
            <tag> HPUOJ </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 17(河南理工大学暑期第十七天)</title>
      <link href="/2019/08/02/17/"/>
      <url>/2019/08/02/17/</url>
      
        <content type="html"><![CDATA[<p>我喜欢欧文，喜欢德鲁大叔。也忘了这张图是在哪找到的，但是这也太和我胃口了。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/drew.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/drew.webp" class="img-shadow img-margin"></center></a><br>主体上是德鲁大叔的动漫头像，右手拿着个篮球，右手拿着个地球仪，这个地球仪说法可厉害了。当时欧文在接受采访时说道：我相信地球是平的。这就是欧文的“地平说”。把欧文的最耀眼的三个元素糅合在了一张图我是真的喜欢的没话说。以后怕是不会换头像了。<br>好看是好看，但毕竟是网上下载的，所以可能会有很多人跟我用一样的头像（虽然现在还没遇见。<br>然后我正好有时间，就给他P一下吧<br>P完之后的我的头像<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/dreww.webp" class="img-shadow img-margin"></center></a><br>第一步我在它衣服的左侧添加了一个ICPC的logo，表明了我<del>~JBer</del>~ACMer的身份。<br>然后你仔细看会发现右下角有一个若隐若现的德鲁大叔妆容二号骑士球衣的欧文扭头在看着你（不仔细看是看不见的）。我最喜欢的就是欧文在骑士的时候。所以这个设计我也是很满意。<br>最后我在左下角加了<code>@cndrew</code>宣告一下主权，哈哈这就结束了。我在ps的时候也是一步一百度，也是学到了不少东西。这次接触ps，让我对ps产生了浓厚的兴趣，以后还会深入学习的。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Photoshop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 16(河南理工大学暑期第十六天)</title>
      <link href="/2019/08/01/16/"/>
      <url>/2019/08/01/16/</url>
      
        <content type="html"><![CDATA[<h3 id="求递推序列的第N项"><a href="#求递推序列的第N项" class="headerlink" title="求递推序列的第N项"></a>求递推序列的第N项</h3><p>Description:<br>有一个序列是这样定义的：f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.<br>给出A，B和N，求f(n)的值。<br>输入</p><blockquote><p>输入3个数：A,B,N。数字之间用空格分割。(-10000 &lt;= A, B &lt;= 10000, 1 &lt;= N &lt;= 10^9)</p></blockquote><p>输出</p><blockquote><p>输出f(n)的值。</p></blockquote><p>输入样例</p><blockquote><p>3 -1 5</p></blockquote><p>输出样例</p><blockquote><p>6</p></blockquote><p>Problem solving:<br>这道题的意思是给你一个递推公式，求出第n项的值。</p><p>如果直接递推的话，1e9的n一定是会超时的。这时候矩阵快速幂大显身手。<br>只需要构造出来两个矩阵就行，板子题。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;struct node{    int m[5][5];};node mm,p;node mul(node a,node b){    node now;    memset(now.m,0,sizeof(now.m));    for(int i=1;i&lt;=2;i++)    {        for(int j=1;j&lt;=2;j++)        {            for(int k=1;k&lt;=2;k++)            {                now.m[i][j]=((now.m[i][j]+a.m[i][k]*b.m[k][j])+7)%7;            }        }    }    return now;}node poww(node a,int b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(int i=1;i&lt;=2;i++)    ans.m[i][i]=1;    while(b)    {        if(b&amp;1)    ans=mul(ans,a);        b/=2;        a=mul(a,a);    }    return ans;}int main(){    int a,b,k;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;k;    mm.m[1][1]=1,mm.m[2][1]=1;    mm.m[2][2]=0,mm.m[1][2]=0;//构造的一个矩阵    p.m[1][1]=a,p.m[1][2]=b,p.m[2][1]=1,p.m[2][2]=0;//构造的另一个矩阵    if(k==1||k==2)    {        puts(&quot;1&quot;);    }    else    {        node mid=poww(p,k-2);        mid=mul(mid,mm);        cout&lt;&lt;mid.m[1][1]&lt;&lt;endl;    }}</code></pre><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>Description:<br>给出一个N * N的矩阵，其中的元素均为正整数。求这个矩阵的M次方。由于M次方的计算结果太大，只需要输出每个元素Mod (10^9 + 7）的结果。</p><p>输入</p><blockquote><p>第1行：2个数N和M，中间用空格分隔。N为矩阵的大小，M为M次方。(2 &lt;= N &lt;= 100, 1 &lt;= M &lt;= 10^9)<br>第2 - N + 1行：每行N个数，对应N * N矩阵中的1行。(0 &lt;= N[i] &lt;= 10^9)</p></blockquote><p>输出</p><blockquote><p>共N行，每行N个数，对应M次方Mod (10^9 + 7)的结果。</p></blockquote><p>输入样例</p><blockquote><p>2 3<br>1 1<br>1 1</p></blockquote><p>输出样例</p><blockquote><p>4 4<br>4 4</p></blockquote><p>Problem solving:<br>这个就是个板子题，直接写就行了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e9+7;typedef long long ll;struct node{    ll m[105][105];};ll n,k;node mul(node a,node b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(ll i=0;i&lt;n;i++)    {        for(ll j=0;j&lt;n;j++)        {            for(ll k=0;k&lt;n;k++)            {                ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%maxn;//这里已经要先+再取模。坑点            }        }    }    return ans;}node poww(node a,ll b){    node now;    memset(now.m,0,sizeof(now.m));    for(ll i=0;i&lt;n;i++)    now.m[i][i]=1;    while(b)    {        if(b&amp;1)    now=mul(now,a);        b/=2;        a=mul(a,a);    }    return now;}int main(){    cin&gt;&gt;n&gt;&gt;k;    node ans;    for(ll i=0;i&lt;n;i++)        for(ll j=0;j&lt;n;j++)            cin&gt;&gt;ans.m[i][j];    ans=poww(ans,k);    for(ll i=0;i&lt;n;i++)    {        for(ll j=0;j&lt;n;j++)            cout&lt;&lt;ans.m[i][j]&lt;&lt;&quot; &quot;;        puts(&quot;&quot;);    }}</code></pre><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>Description:<br>给出2个N * N的矩阵M1和M2，输出2个矩阵相乘后的结果。<br>输入</p><blockquote><p>第1行：1个数N，表示矩阵的大小(2 &lt;= N &lt;= 100)<br>第2 - N + 1行，每行N个数，对应M1的1行(0 &lt;= M1[i] &lt;= 1000)<br>第N + 2 - 2N + 1行，每行N个数，对应M2的1行(0 &lt;= M2[i] &lt;= 1000)</p></blockquote><p>输出</p><blockquote><p>输出共N行，每行N个数，对应M1 * M2的结果的一行。</p></blockquote><p>输入样例</p><blockquote><p>2<br>1 0<br>0 1<br>0 1<br>1 0</p></blockquote><p>输出样例</p><blockquote><p>0 1<br>1 0</p></blockquote><p>Problem solving:<br>考察了矩阵相乘的实现<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;struct node{    int m[105][105];};node a,b;int n;node mul(node a,node b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(int i=0;i&lt;n;i++)    for(int j=0;j&lt;n;j++)    for(int k=0;k&lt;n;k++)    ans.m[i][j]=ans.m[i][j]+a.m[i][k]*b.m[k][j];//矩阵相乘就是通过这三个for循环实现的    return ans;}int main(){    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)        for(int j=0;j&lt;n;j++)            cin&gt;&gt;a.m[i][j];    for(int i=0;i&lt;n;i++)        for(int j=0;j&lt;n;j++)            cin&gt;&gt;b.m[i][j];    node ans=mul(a,b);    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;n;j++)            cout&lt;&lt;ans.m[i][j]&lt;&lt;&quot; &quot;;        puts(&quot;&quot;);    }}</code></pre><h3 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h3><p>Description:<br>菲波那契数列是指这样的数列: 数列的第一个是0和第二个数是1，接下来每个数都等于前面2个数之和。 给出一个正整数a，要求菲波那契数列中第a个数的后四位是多少。<br>Input</p><blockquote><p>多组数据 -1结束 范围1~10^9</p></blockquote><p>Output</p><blockquote><p>第x项的后4位</p></blockquote><p>Sample Input</p><blockquote><p>0<br>9<br>999999999<br>1000000000<br>-1</p></blockquote><p>Sample Output</p><blockquote><p>0<br>34<br>626<br>6875</p></blockquote><p>Problem solving:<br>然后毒瘤题意还是忽略了吧，直接看样例妥了<br>求斐波那契的第n项。其实就是给了你递推式，构造出来矩阵就行了。要求输出后四位其实就是对10000取模，每次计算出来都取模，就避免了爆精度的问题。<br>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int mod=10000;struct node{    int m[3][3];};typedef long long ll;node mm,p;node mul(node a,node b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(ll i=1;i&lt;=2;i++)        for(ll j=1;j&lt;=2;j++)            for(ll k=1;k&lt;=2;k++)                ans.m[i][j]=((ans.m[i][j]+a.m[i][k]*b.m[k][j])%mod)%mod;    return ans;}node poww(node a,ll b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(ll i=1;i&lt;=2;i++)    ans.m[i][i]=1;    while(b)    {        if(b&amp;1)    ans=mul(ans,a);        a=mul(a,a);        b/=2;    }    return ans;}int main(){    ll n;    p.m[1][1]=1,p.m[1][2]=1,p.m[2][1]=1,p.m[2][2]=0;    mm.m[1][1]=1,mm.m[2][1]=1,mm.m[2][2]=0,mm.m[1][2]=0;    while(cin&gt;&gt;n&amp;&amp;n!=-1)    {        if(n==0)        {            puts(&quot;0&quot;);            continue;        }        if(n==1||n==2)        {            puts(&quot;1&quot;);            continue;        }        node mid=poww(p,n-2);        mid=mul(mid,mm);        cout&lt;&lt;mid.m[1][1]&lt;&lt;endl;    }}</code></pre><h3 id="Tr-A"><a href="#Tr-A" class="headerlink" title="Tr A"></a>Tr A</h3><p>Description:<br>A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。<br>Input</p><blockquote><p>数据的第一行是一个T，表示有T组数据。<br>每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt; 10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。</p></blockquote><p>Output</p><blockquote><p>对应每组数据，输出Tr(A^k)%9973。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>2 2<br>1 0<br>0 1<br>3 99999999<br>1 2 3<br>4 5 6<br>7 8 9</p></blockquote><p>Sample Output</p><blockquote><p>2<br>2686</p></blockquote><p>Problem solving:<br>直接运用矩阵快速幂求出最后状态的矩阵，对角线相加就行了</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,k;struct node{    int m[15][15];};node now;node mul(node a,node b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;n;j++)        {            for(int k=0;k&lt;n;k++)            {                ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%9973;            }        }    }    return ans;}node poww(node a,int b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(int i=0;i&lt;n;i++)    ans.m[i][i]=1;    while(b)    {        if(b&amp;1)    ans=mul(ans,a);        a=mul(a,a);        b/=2;    }    return ans;}int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;n&gt;&gt;k;        for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;n;j++)                cin&gt;&gt;now.m[i][j];        }        node mid=poww(now,k);        int ans=0;        for(int i=0;i&lt;n;i++)        {            ans=(ans+mid.m[i][i])%9973;        }        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="A-Simple-Math-Problem"><a href="#A-Simple-Math-Problem" class="headerlink" title="A Simple Math Problem"></a>A Simple Math Problem</h3><p>Description:<br>Lele now is thinking about a simple function f(x).</p><p>If x &lt; 10 f(x) = x.<br>If x &gt;= 10 f(x) = a0 * f(x-1) + a1 * f(x-2) + a2 * f(x-3) + …… + a9 * f(x-10);<br>And ai(0&lt;=i&lt;=9) can only be 0 or 1 .</p><p>Now, I will give a0 ~ a9 and two positive integers k and m ,and could you help Lele to caculate f(k)%m.</p><p>Input</p><blockquote><p>The problem contains mutiple test cases.Please process to the end of file.<br>In each case, there will be two lines.<br>In the first line , there are two positive integers k and m. ( k&lt;2*10^9 , m &lt; 10^5 )<br>In the second line , there are ten integers represent a0 ~ a9.</p></blockquote><p>Output</p><blockquote><p>For each case, output f(k) % m in one line.</p></blockquote><p>Sample Input</p><blockquote><p>10 9999<br>1 1 1 1 1 1 1 1 1 1<br>20 500<br>1 0 1 0 1 0 1 0 1 0</p></blockquote><p>Sample Output</p><blockquote><p>45<br>104</p></blockquote><p>Problem solving:<br>题意就是给你一个递推式求出第n项。</p><p>难点就是递推式有点长，但是这个跟斐波那契那个其实是一样的，构造的常数矩阵是<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/ZXIQ1YJDQWHLY3QOP_DJXTE.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/ZXIQ1YJDQWHLY3QOP_DJXTE.webp" class="img-shadow img-margin"></center></a></p><p>常数矩阵都构造出来了，那么接下来的就是套版子了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct node{    ll m[15][15];};ll k,m;node now,p;node mul(node a,node b){    node now;    memset(now.m,0,sizeof(now.m));    for(int i=0;i&lt;10;i++)    {        for(int j=0;j&lt;10;j++)        {            for(int k=0;k&lt;10;k++)            {                now.m[i][j]=(a.m[i][k]*b.m[k][j]+now.m[i][j])%m;            }        }    }    return now;}node poww(node a,int b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(int i=0;i&lt;10;i++)    ans.m[i][i]=1;    while(b)    {        if(b&amp;1)    ans=mul(ans,a);        a=mul(a,a);        b/=2;    }    return ans;}int main(){    while(cin&gt;&gt;k&gt;&gt;m)    {        if(k&lt;=9)        {            cout&lt;&lt;k&lt;&lt;endl;            continue;        }        for(int i=0;i&lt;10;i++)        {            cin&gt;&gt;p.m[0][i];        }        for(int i=1;i&lt;10;i++)        {            for(int j=0;j&lt;10;j++)            {                if(i-1==j)                    p.m[i][j]=1;            }        }        for(int i=0;i&lt;10;i++)    now.m[i][0]=9-i;        node ans=poww(p,k-9);        ans=mul(ans,now);        cout&lt;&lt;ans.m[0][0]&lt;&lt;endl;    }}</code></pre><h3 id="Recursive-sequence"><a href="#Recursive-sequence" class="headerlink" title="Recursive sequence"></a>Recursive sequence</h3><p>Description:</p><p>Problem solving:<br>也是给了递推式求第n项的问题，但是这个就比较难了，因为构建常数矩阵的时候会发现一个严肃的问题，n^4与(n+1)^4找关系的时候会很爆炸。</p><p>这时候我们就需要化简了。<br>(n+1)^4=n^4+4*n^3+6*n^2+4*n+1<br>(n+1)^3=n^3+3*n^2+3*n+1<br>(n+1)^2=n^2+2*n+1<br>n+1=n+1</p><p>所以我们构建出来的常数矩阵就是<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/1.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/1.webp" class="img-shadow img-margin"></center></a></p><p>接下来就是计算了，套板子就行，一开始的矩阵是只有第一列有值得。<br>值分别为b,a,81,27,9,3,1</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,a,b;struct node{    ll m[7][7];};const ll mod=2147493647;node mm,p;node mul(node a,node b){    node now;    memset(now.m,0,sizeof(now.m));    for(ll i=0;i&lt;7;i++)    {        for(ll j=0;j&lt;7;j++)        {            for(ll k=0;k&lt;7;k++)            {                now.m[i][j]=(a.m[i][k]*b.m[k][j]+now.m[i][j])%mod;            }        }    }    return now;}node poww(node a,ll b){    node ans;    memset(ans.m,0,sizeof(ans.m));    for(ll i=0;i&lt;10;i++)    ans.m[i][i]=1;    while(b)    {        if(b&amp;1)    ans=mul(ans,a);        a=mul(a,a);        b/=2;    }    return ans;}int main(){    ll t;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;        if(n==1)        {            cout&lt;&lt;a&lt;&lt;endl;            continue;        }        if(n==2)        {            cout&lt;&lt;b&lt;&lt;endl;            continue;        }        memset(mm.m,0,sizeof(mm.m));        memset(p.m,0,sizeof(p.m));        mm.m[0][0]=b,mm.m[1][0]=a;        mm.m[2][0]=81,mm.m[3][0]=27,mm.m[4][0]=9,mm.m[5][0]=3,mm.m[6][0]=1;        p.m[0][0]=1,p.m[0][1]=2,p.m[0][2]=1;        p.m[1][0]=1;        p.m[2][2]=1,p.m[2][3]=4,p.m[2][4]=6,p.m[2][5]=4,p.m[2][6]=1;        p.m[3][3]=1,p.m[3][4]=3,p.m[3][5]=3,p.m[3][6]=1;        p.m[4][4]=1,p.m[4][5]=2,p.m[4][6]=1;        p.m[5][5]=1,p.m[5][6]=1;        p.m[6][6]=1;        node mid=poww(p,n-2);        mid=mul(mid,mm);        cout&lt;&lt;mid.m[0][0]&lt;&lt;endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> 51nod </tag>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 15(河南理工大学暑期第十五天)</title>
      <link href="/2019/07/31/15/"/>
      <url>/2019/07/31/15/</url>
      
        <content type="html"><![CDATA[<h3 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h3><p>Description:<br>涂奥最近迷上了吃鸡，房间有n个配件，每个配件有c(c&lt;=1e3)的重量和v(v&lt;=1e3)的价值，哇，涂奥捡了一个2级包，容量为s，所以涂奥最多当多肥的快递员呢？<br>Input</p><blockquote><p>输入的第一行是T, 表示有一共要打T场比赛.<br>每组数据由三行组成.<br>第1行包含两个整数n和s 第2行包含n个整数, 表示每一个配件的价值. 第3行包含n个整数, 表示每个配件的重量.</p></blockquote><p>Output</p><blockquote><p>对每一组数据, 输出涂奥可以多肥.</p></blockquote><p>Sample Input<br>1<br>10 10<br>1 3 5 7 9 11 13 15 17 19<br>19 17 15 13 11 9 7 5 3 1<br>Sample Output<br>51</p><p>Problem solving:<br>跟昨天那道题一样，不过就是换了描述。<br>提议就是给定你容量，然后告诉你每个物品的价值和体积，求你能拿到的最大的价值。<br>01背包问题，直接套板子即可</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int tx=1e6;int m[tx],M[tx],dp[tx];int main(){    int t,n,s;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;n&gt;&gt;s;        for(int i=0;i&lt;n;i++)    cin&gt;&gt;m[i];        for(int i=0;i&lt;n;i++)    cin&gt;&gt;M[i];        memset(dp,0,sizeof(dp));        for(int i=0;i&lt;n;i++)        {            for(int j=s;j&gt;=M[i];j--)            {                dp[j]=max(dp[j],dp[j-M[i]]+m[i]);            }        }        cout&lt;&lt;dp[s]&lt;&lt;endl;    }}</code></pre><h3 id="饭卡"><a href="#饭卡" class="headerlink" title="饭卡"></a>饭卡</h3><p>Description:<br>电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。<br>某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。<br>Input</p><blockquote><p>多组数据。对于每组数据：<br>第一行为正整数n，表示菜的数量。n&lt;=1000。<br>第二行包括n个正整数，表示每种菜的价格。价格不超过50。<br>第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。<br>n=0表示数据结束。</p></blockquote><p>Output</p><blockquote><p>对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>50<br>5<br>10<br>1 2 3 2 1 1 2 3 2 1<br>50<br>0</p></blockquote><p>Sample Output</p><blockquote><p>-45<br>32</p></blockquote><p>Problem solving:<br>题意就是让你尽可能多的花掉自己的钱，求余额。有一个特殊规定就是如果当前余额大于等于5，能买任何的菜，但是一旦n小于5，就什么都不能买了。<br>也是一道01背包的问题，这里还有一点贪心的感觉就是，为了最后能达到的是最小的余额，我们拿5元出来买最贵的菜。然后就是背包，背包容量是n-5，直接套板子求出n-5的容量下能花费最多钱的情况。<br>最后输出的时候减去最大的花费和最贵的菜即可。<br>但是还有一点就是输入的n就有可能是小于5的。这时直接输出n就行。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int tx=1005;int m[tx],dp[tx];int main(){    int t,n;    while(cin&gt;&gt;t&amp;&amp;t)    {        memset(dp,0,sizeof(dp));        for(int i=0;i&lt;t;i++)    cin&gt;&gt;m[i];        cin&gt;&gt;n;        if(n&lt;5)        {            cout&lt;&lt;n&lt;&lt;endl;            continue;        }        sort(m,m+t);        for(int i=0;i&lt;t-1;i++)        for(int j=n-5;j&gt;=m[i];j--)        {            dp[j]=max(dp[j],dp[j-m[i]]+m[i]);        }        cout&lt;&lt;n-dp[n-5]-m[t-1]&lt;&lt;endl;    }}</code></pre><h3 id="CD"><a href="#CD" class="headerlink" title="CD"></a>CD</h3><p>Description:<br>PDF题面:<a href="https://vj.ti12z.cn/f38ae0d246e80c425804db33c376c68a?v=1564526721" target="_blank" rel="noopener">戳我戳我</a><br>You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is on<br>CDs. You need to have it on tapes so the problem to solve is: you have a tape N minutes long. How<br>to choose tracks from CD to get most out of tape space and have as short unused space as possible.<br>Assumptions:<br>• number of tracks on the CD does not exceed 20<br>• no track is longer than N minutes<br>• tracks do not repeat<br>• length of each track is expressed as an integer number<br>• N is also integer<br>Program should find the set of tracks which fills the tape best and print it in the same sequence as<br>the tracks are stored on the CD<br>Input</p><blockquote><p>Any number of lines. Each one contains value N, (after space) number of tracks and durations of the<br>tracks. For example from first line in sample data: N = 5, number of tracks=3, first track lasts for 1<br>minute, second one 3 minutes, next one 4 minutes</p></blockquote><p>Output</p><blockquote><p>Set of tracks (and durations) which are the correct solutions and string ‘sum:’ and sum of duration<br>times.</p></blockquote><p>Sample Input</p><blockquote><p>5 3 1 3 4<br>10 4 9 8 4 2<br>20 4 10 5 7 4<br>90 8 10 23 1 2 3 4 5 7<br>45 8 4 10 44 43 12 9 8 2</p></blockquote><p>Sample Output</p><blockquote><p>1 4 sum:5<br>8 2 sum:10<br>10 5 4 sum:19<br>10 23 1 2 3 4 5 7 sum:55<br>4 10 12 9 8 2 sum:45</p></blockquote><p>Problem solving:<br>这道题的意思就是给你一个数，这个就是背包容量然后给你n个数，问你这n个数怎么放能使背包容量最小，并输出这个方法。</p><p>简单的01背包问题。不简单的输出方法。<br>在每次dp查找最优情况的时候进行标记，最后根据标记输出，并且题目要求的输出是出现在前面的就输出在前面，最后还有一点小优化，可以看一下代码注释理解。</p><p>关于这个输出路径，我也不是理解的很清楚，但是很关键的要理解的一点就是dp[j]这个数组的含义。也就是01背包中dp[i][j]的意思:从前i-1个物品中，选出来总重量不超过j的物品时，总价值的最大值</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,num;const int maxn=10005;int a[maxn],dp[maxn],flag[maxn][maxn];int main(){    ios::sync_with_stdio(0);    cin.tie(0);    while(cin&gt;&gt;n&gt;&gt;m)    {        for(int i=0;i&lt;m;i++)    cin&gt;&gt;a[i];        memset(flag,0,sizeof(flag));        memset(dp,0,sizeof(dp));        for(int i=m-1;i&gt;=0;i--)//这里倒序主要是在输出的时候方便        {            for(int j=n;j&gt;=a[i];j--)            {                if(dp[j]&lt;dp[j-a[i]]+a[i])//选上了a[i]的情况                {                    dp[j]=dp[j-a[i]]+a[i];                    flag[i][j]=1;//进行标记                }            }        }        for(int i=0,j=n;i&lt;m;i++)        {            if(flag[i][j])//标价到的就输出            {                cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;                j-=a[i];            }        }        cout&lt;&lt;&quot;sum:&quot;&lt;&lt;dp[n]&lt;&lt;endl;    }}</code></pre><h3 id="Piggy-Bank"><a href="#Piggy-Bank" class="headerlink" title="Piggy-Bank"></a>Piggy-Bank</h3><p>Description:<br>在 ACM 能够开展之前，必须准备预算，并获得必要的财力支持。该活动的主要收入来自于 Irreversibly Bound Money (IBM)。思路很简单。任何时候，某位 ACM 会员有少量的钱时，他将所有的硬币投入到小猪储钱罐中。这个过程不可逆，因为只有把小猪储钱罐打碎才能取出硬币。在足够长的时间之后，小猪储钱罐中有了足够的现金，用于支付 ACM 活动所需的花费。</p><p>但是，小猪储钱罐存在一个大的问题，即无法确定其中有多少钱。因此，我们可能在打碎小猪储钱罐之后，发现里面的钱不够。显然，我们希望避免这种不愉快的情况。唯一的可能是，称一下小猪储钱罐的重量，并尝试猜测里面的有多少硬币。假定我们能够精确判断小猪储钱罐的重量，并且我们也知道给定币种的所有硬币的重量。那么，我们可以保证小猪储钱罐中最少有多少钱。</p><p>你的任务是找出最差的情形，即判断小猪储钱罐中的硬币最少有多少钱。我们需要你的帮助。不能再贸然打碎小猪储钱罐了！</p><p>输入</p><blockquote><p>输入包含 T 组测试数据。输入文件的第一行，给出了 T 的值。<br>对于每组测试数据，第一行包含 E 和 F 两个整数，它们表示空的小猪储钱罐的重量，以及装有硬币的小猪储钱罐的重量。两个重量的计量单位都是 g (克)。小猪储钱罐的重量不会超过 10 kg (千克)，即 1 &lt;= E &lt;= F &lt;= 10000 。每组测试数据的第二行，有一个整数 N (1 &lt;= N &lt;= 500)，提供了给定币种的不同硬币有多少种。接下来的 N 行，每行指定一种硬币类型，每行包含两个整数 P 和 W (1 &lt;= P &lt;= 50000，1 &lt;= W &lt;=10000)。P 是硬币的金额 (货币计量单位)；W 是它的重量，以 g (克) 为计量单位。</p></blockquote><p>输出</p><blockquote><p>对于每组测试数据，打印一行输出。每行必须包含句子 “The minimum amount of money in the piggy-bank is X.” 其中，X 表示对于给定总重量的硬币，所能得到的最少金额。如果无法恰好得到给定的重量，则打印一行 “This is impossible.” 。</p></blockquote><p>示例输入</p><blockquote><p>3<br>10 110<br>2<br>1 1<br>30 50<br>10 110<br>2<br>1 1<br>50 30<br>1 6<br>2<br>10 3<br>20 4</p></blockquote><p>示例输出</p><blockquote><p>The minimum amount of money in the piggy-bank is 60.<br>The minimum amount of money in the piggy-bank is 100.<br>This is impossible.</p></blockquote><p>Problem solving:<br>这道题的意思是给你一个存钱罐的初始和末状态的质量，然后给定你每种硬币的质量和价值。要求这个存钱罐是否存在着能正好放满硬币的情况，如果有求出最小的情况。</p><p>每个硬币可以挑选任意次，所以这是一道完全背包的题。套板子就行，注意我们要求最小值，所以初始化成一个极大值，然后在dp的过程中取min。<br>还有一点就是dp[0]一定要初始化为0，因为这里我们dp[i]表示的就是在i的空间下，能放人的最小的硬币的值。空间为0即不能再放硬币了，所以价值就是0了。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int p[505],w[505],dp[10005];const int INF = 0x3f3f3f3f;int main(){    int t,s,e,n,cs;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;s&gt;&gt;e&gt;&gt;n;        cs=e-s;        for(int i=0;i&lt;=cs;i++)    dp[i]=INF;        for(int i=0;i&lt;n;i++)    cin&gt;&gt;p[i]&gt;&gt;w[i];        dp[0]=0;        for(int i=0;i&lt;n;i++)        {            for(int j=w[i];j&lt;=cs;j++)            {                dp[j]=min(dp[j],dp[j-w[i]]+p[i]);            }        }        if(dp[cs]!=INF)            cout&lt;&lt;&quot;The minimum amount of money in the piggy-bank is &quot;&lt;&lt;dp[cs]&lt;&lt;&quot;.&quot;;        else    cout&lt;&lt;&quot;This is impossible.&quot;;        puts(&quot;&quot;);    }}</code></pre><h3 id="Dividing-coins"><a href="#Dividing-coins" class="headerlink" title="Dividing coins"></a>Dividing coins</h3><p>Description:<br>PDF题面：<a href="https://vj.ti12z.cn/59ec771136a22cd223c44370a4f9b67c?v=1564459707" target="_blank" rel="noopener">戳我戳我</a><br>It’s commonly known that the Dutch have invented copper-wire. Two Dutch men were fighting over<br>a nickel, which was made of copper. They were both so eager to get it and the fighting was so fierce,<br>they stretched the coin to great length and thus created copper-wire.<br>Not commonly known is that the fighting started, after the two Dutch tried to divide a bag with<br>coins between the two of them. The contents of the bag appeared not to be equally divisible. The Dutch<br>of the past couldn’t stand the fact that a division should favour one of them and they always wanted<br>a fair share to the very last cent. Nowadays fighting over a single cent will not be seen anymore, but<br>being capable of making an equal division as fair as possible is something that will remain important<br>forever...<br>That’s what this whole problem is about. Not everyone is capable of seeing instantly what’s the<br>most fair division of a bag of coins between two persons. Your help is asked to solve this problem.<br>Given a bag with a maximum of 100 coins, determine the most fair division between two persons.<br>This means that the difference between the amount each person obtains should be minimised. The<br>value of a coin varies from 1 cent to 500 cents. It’s not allowed to split a single coin.<br>Input</p><blockquote><p>A line with the number of problems n, followed by n times:<br>• a line with a non negative integer m (m ≤ 100) indicating the number of coins in the bag<br>• a line with m numbers separated by one space, each number indicates the value of a coin.</p></blockquote><p>Output</p><blockquote><p>The output consists of n lines. Each line contains the minimal positive difference between the amount<br>the two persons obtain when they divide the coins from the corresponding bag.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3<br>2 3 5<br>4<br>1 2 4 6</p></blockquote><p>Sample Output</p><blockquote><p>0<br>1</p></blockquote><p>Problem solving:<br>这道题的意思就是给你n个硬币，让你分成两堆，求所有分法中两堆价值差值最小的情况。<br>这道题乍一看以为是要贪心，但是WA了。<br>然后想到今天讲的是背包诶，然后脑子里灵光一现(去百度了一下)，想到可以以硬币的总价值的一半为背包容量进行01背包的处理。假设总价值为s，这时我们求出的dp[s/2]就是分成差值最小的两堆中的其中一堆，然后另一堆的价值就是s-sp[s/2],两堆价值的差值就是s-2*dp[s/2]</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int tx=1e5+10;int m[tx],dp[tx];int main(){    int n,t;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;t;        memset(dp,0,sizeof(dp));        int sum=0;        for(int i=0;i&lt;t;i++)    cin&gt;&gt;m[i],sum+=m[i];        for(int i=0;i&lt;t;i++)        {            for(int j=sum/2;j&gt;=m[i];j--)            {                dp[j]=max(dp[j],dp[j-m[i]]+m[i]);            }        }        cout&lt;&lt;sum-dp[sum/2]-dp[sum/2]&lt;&lt;endl;    }    return 0;}</code></pre><h3 id="Robberies"><a href="#Robberies" class="headerlink" title="Robberies"></a>Robberies</h3><p>Description:<br>可怜的POIUYTREWQ最近想买下dota2的商品，但是手头缺钱。他想起了之前看过的一部大片，觉得抢银行也许是个不错的选择。他认为，坏人被抓是因为没有预先规划。于是他在之前的几个月对各大银行进行了一次评估； 评估内容包括安全性和可盗窃金额： 他想知道在在某个风险系数下可以偷窃的最大金额<br>Input</p><blockquote><p>第一行给出了一个整数T, 表示有T组测试数据. 对于每一组数据，第一行给出了一个浮点数P, 表示POIUYTREWQ允许被抓的最大概率, 和一个整数N，表示他计划去抢劫的N个银行. 接下来N行, 每行给出一个整数数Mj和浮点数Pj.<br>抢劫银行 j 可获得 Mj 百万美金, 被抓的概率是 Pj .</p></blockquote><p>Output</p><blockquote><p>对于每组数据，每行输出一个整数，表示POIUYTREWQ在被抓概率小于P的情况下，可抢到的最多的金钱。</p></blockquote><p>Notes and Constraints<br>0 &lt; T &lt;= 100<br>0.0 &lt;= P &lt;= 1.0<br>0 &lt; N &lt;= 100<br>0 &lt; Mj &lt;= 100<br>0.0 &lt;= Pj &lt;= 1.0<br>你可以认为每家银行都是独立的。<br>Sample Input</p><blockquote><p>3<br>0.04 3<br>1 0.02<br>2 0.03<br>3 0.05<br>0.06 3<br>2 0.03<br>2 0.03<br>3 0.05<br>0.10 3<br>1 0.03<br>2 0.02<br>3 0.05</p></blockquote><p>Sample Output</p><blockquote><p>2<br>4<br>6</p></blockquote><p>Problem solving:<br>这道题就是先给你一个实数代表这个可怜的孩子能允许的最大的被抓的概率，意思就是你被抓的概率不能超过这个值。然后给你n个银行的获利以及被抓的概率，求最大能偷多少钱。</p><p>这是一道01背包的问题，但是不太一样的是如果我们直接以概率为背包容量的话会出现一个很尴尬的问题就是实数并不可以当做数组的下标，然后我想到了对概率乘上一个较大的数（1e6之类的）然后进行背包的dp，但是这样会WA，由此可见这道题的精度还是很高的，所以这种方法我们行不通。就得换个方向</p><p>这里可以以偷到的美金的数量为背包容量进行01背包，然后求出获得(1~n)内每个美金数量所对应的不被抓住的概率。<br>背包容量就是可以偷到的美金的最大值——所有都偷到。<br>dp[i]表示的就是偷了i美金之后不被抓的概率</p><p>有一点还需要注意的就是dp[0]必须初始化为1，不然后面算出来的dp都是0了。可为什么初始化的是1呢，因为我们现在用的dp数组表示的是偷了i美金之后不被抓的概率，i等于0的意思就是一点美金都没偷，不被抓的概率当然就是1(100%)了。</p><p>为什么我们要求的是不被抓住的概率呢？<br>因为如果是被抓住的概率的话，算总的概率并不好求，可以自己想一下。如果第一次被抓住的概率是0.5，第二次被抓住的概率也是0.5~·~·~第n次被抓住的概率也是0.5，那么总共被抓住的几率并不好求，因为如果第一次被抓住了，后面的就都不用考虑了，以此类推易想到不好求。<br>但是如果是不被抓住的概率，我们直接累乘就行了。<br>最后我们求出对应的每个美金的数量对应的不被抓住的概率，直接O(n)查找到概率大于等于1-p(允许被抓的最大概率)的美金数量输出即可。</p><p>具体可以看一下代码在感受一下，涉及到01背包的直接套板子就行(对和我一样不太理解背包的小伙伴适用<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int m[maxn];double dp[100005],p[maxn];int main(){    ios::sync_with_stdio(0);    int t;    cin&gt;&gt;t;    while(t--)    {        memset(dp,0,sizeof(dp));        double pp;int n,sum=0;        cin&gt;&gt;pp&gt;&gt;n;        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;m[i]&gt;&gt;p[i];            sum+=m[i];            p[i]=1-p[i];        }        dp[0]=1;//这个初始化很重要        for(int i=0;i&lt;n;i++)        {            for(int j=sum;j&gt;=m[i];j--)            {                dp[j]=max(dp[j],dp[j-m[i]]*p[i]);            }        }        for(int i=sum;i&gt;=0;i--)        {            if(dp[i]&gt;=1-pp)            {                cout&lt;&lt;i&lt;&lt;endl;                break;            }        }    }    return 0;}</code></pre><h3 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h3><p>Description:<br>PDF题面:<a href="https://vj.ti12z.cn/0f4c5078f76f023eca12596dd1edb892?v=1564372407" target="_blank" rel="noopener">戳我戳我</a><br>Suppose there are 5 types of coins: 50-cent, 25-cent, 10-cent, 5-cent, and 1-cent. We want to make<br>changes with these coins for a given amount of money.<br>For example, if we have 11 cents, then we can make changes with one 10-cent coin and one 1-cent<br>coin, two 5-cent coins and one 1-cent coin, one 5-cent coin and six 1-cent coins, or eleven 1-cent coins.<br>So there are four ways of making changes for 11 cents with the above coins. Note that we count that<br>there is one way of making change for zero cent.<br>Write a program to find the total number of different ways of making changes for any amount of<br>money in cents. Your program should be able to handle up to 7489 cents.<br>Input</p><blockquote><p>The input file contains any number of lines, each one consisting of a number for the amount of money<br>in cents.</p></blockquote><p>Output</p><blockquote><p>For each input line, output a line containing the number of different ways of making changes with the<br>above 5 types of coins.</p></blockquote><p>Sample Input</p><blockquote><p>11<br>26</p></blockquote><p>Sample Output</p><blockquote><p>4<br>13</p></blockquote><p>Problem solving:<br>这道题的意思就是给你5种硬币，币值都给你了，在给你一个数问有几种方法可以拼出来这个数。</p><p>这是一道完全背包的题，直接套板子就行了。</p><p>这里我第一次不知道为啥TLE了，所以加上了一个记忆化搜索，也可能是cin/cout得锅。<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[7500];ll solve(ll x){    if(ans[x])    return ans[x];    int coins[13]  = { 1, 5, 10, 25, 50};    ll  dp[100005] = { 0 };    dp[0] = 1;    for (int i = 0; i &lt; 6; i++)    {        for (int j = coins[i]; j &lt;= x; j++)        {            dp[j] = dp[j] + dp[j - coins[i]];        }    }    return ans[x]=dp[x];}int main(){    ll t, a;    ios::sync_with_stdio(0);    cin.tie(0);    while (cin &gt;&gt; a)    {        cout &lt;&lt; solve(a)/2 &lt;&lt; endl;    }}</code></pre><h3 id="悼念512汶川大地震遇难同胞——珍惜现在，感恩生活"><a href="#悼念512汶川大地震遇难同胞——珍惜现在，感恩生活" class="headerlink" title="悼念512汶川大地震遇难同胞——珍惜现在，感恩生活"></a>悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</h3><p>Description:<br>急！灾区的食物依然短缺！<br>为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。<br>请问：你用有限的资金最多能采购多少公斤粮食呢？</p><p>后记：<br>人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。<br>月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——<br>感谢父母，他们给予我们生命，抚养我们成人；<br>感谢老师，他们授给我们知识，教我们做人<br>感谢朋友，他们让我们感受到世界的温暖；<br>感谢对手，他们令我们不断进取、努力。<br>同样，我们也要感谢痛苦与艰辛带给我们的财富～</p><p>Input</p><blockquote><p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p></blockquote><p>Output</p><blockquote><p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>8 2<br>2 100 4<br>4 100 2</p></blockquote><p>Sample Output</p><blockquote><p>400</p></blockquote><p>Problem solving:<br>这道题的意思就是给了你最大得经费，还给了你每包米的体积以及价格和这种米的个数，问你在最优的情况下可以买到的米的体积</p><p>这是一道多重背包的题，直接套板子即可。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int tx=1e3;int m[tx],p[tx],h[tx],c[tx];int main(){    int t,n,x;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;n&gt;&gt;x;        memset(m,0,sizeof(m));        for(int i=0;i&lt;x;i++)    cin&gt;&gt;p[i]&gt;&gt;h[i]&gt;&gt;c[i];        for(int i=0;i&lt;x;i++)        {            int mid=c[i];            for(int k=1;mid&gt;0;k*=2)            {                int miid=min(k,mid);                for(int j=n;j&gt;=p[i]*miid;j--)                {                    m[j]=max(m[j],m[j-p[i]*miid]+h[i]*miid);                }                mid-=miid;            }        }        cout&lt;&lt;m[n]&lt;&lt;endl;    }    return 0;}</code></pre><p>注意，这个背包问题中如果涉及到多组输入，dp数组的初始化是很重要的。<br>这些dp啊，背包的好多问题一看都感觉好像用贪心可以写，但是过一会你就会发现贪心并不能解决这些问题，还是老老实实学dp吧、、、</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> dp </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day x（河南理工大学暑期第x天）</title>
      <link href="/2019/07/31/dx/"/>
      <url>/2019/07/31/dx/</url>
      
        <content type="html"><![CDATA[<h3 id="Pseudoprime-numbers"><a href="#Pseudoprime-numbers" class="headerlink" title="Pseudoprime numbers"></a>Pseudoprime numbers</h3><p>Description:<br>Fermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, ap = a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)</p><p>Given 2 &lt; p ≤ 1000000000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime.</p><p>Input</p><blockquote><p>Input contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a.</p></blockquote><p>Output</p><blockquote><p>For each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;.</p></blockquote><p>Sample Input</p><blockquote><p>3 2<br>10 3<br>341 2<br>341 3<br>1105 2<br>1105 3<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>no<br>no<br>yes<br>no<br>yes<br>yes</p></blockquote><p>Problem solving:<br>First judge p is a prime number or not,if p is a prime number output &#39;no&#39;,else then judge a^p%p is equal to a or not,if not equal output &#39;no&#39;.We should use fast power to avoid TLE.<br>Code:</p><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int s(long long a){    if(a==2)        return 1;    for(int i=2;i*i&lt;=a;i++)        if(a%i==0)            return 0;    return 1;}long long f(long long a,long long b,long long c)//快速幂模板{    long long t=1;    a=a%c;    while(b&gt;0)    {        if(b%2==1)            t=t*a%c;        b=b/2;        a=a*a%c;    }    return t;}int main(){    long long  a,p;    while(~scanf(&quot;%lld%lld&quot;,&amp;p,&amp;a)&amp;&amp;!(a==0&amp;&amp;p==0))    {        if(s(p))        printf(&quot;no\n&quot;);        else        {            if(f(a,p,p)==a)            printf(&quot;yes\n&quot;);           else           printf(&quot;no\n&quot;);        }    }    return 0;}</code></pre><h3 id="Raising-Modulo-Numbers"><a href="#Raising-Modulo-Numbers" class="headerlink" title="Raising Modulo Numbers"></a>Raising Modulo Numbers</h3><p>Description:<br>People are different. Some secretly read magazines full of interesting girls&#39; pictures, others create an A-bomb in their cellar, others like using Windows, and some like difficult mathematical games. Latest marketing research shows, that this market segment was so far underestimated and that there is lack of such games. This kind of game was thus included into the KOKODáKH. The rules follow:</p><p>Each player chooses two numbers Ai and Bi and writes them on a slip of paper. Others cannot see the numbers. In a given moment all players show their numbers to the others. The goal is to determine the sum of all expressions Ai Bi from all players including oneself and determine the remainder after division by a given number M. The winner is the one who first determines the correct result. According to the players&#39; experience it is possible to increase the difficulty by choosing higher numbers.</p><p>You should write a program that calculates the result and is able to find out who won the game.</p><p>Input</p><blockquote><p>The input consists of Z assignments. The number of them is given by the single positive integer Z appearing on the first line of input. Then the assignements follow. Each assignement begins with line containing an integer M (1 &lt;= M &lt;= 45000). The sum will be divided by this number. Next line contains number of players H (1 &lt;= H &lt;= 45000). Next exactly H lines follow. On each line, there are exactly two numbers Ai and Bi separated by space. Both numbers cannot be equal zero at the same time.</p></blockquote><p>Output</p><blockquote><p>For each assingnement there is the only one line of output. On this line, there is a number, the result of expression</p></blockquote><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095342.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095342.webp" class="img-shadow img-margin"></center></a><p>Sample Input</p><blockquote><p>3<br>16<br>4<br>2 3<br>3 4<br>4 5<br>5 6<br>36123<br>1<br>2374859 3029382<br>17<br>1<br>3 18132</p></blockquote><p>Sample Output</p><blockquote><p>2<br>13195<br>13</p></blockquote><p>Problem solving:<br>I don&#39;t understand this problem clearly first time,and then I find a little hint in the output,so it&#39;s easy now.<br>Code:</p><pre><code>#include &lt;iostream&gt;using namespace std;typedef long long ll;ll poww(ll x, ll y, ll maxn){    ll res = 1;    while (y)    {        if (y % 2 != 0)            res = res * x % maxn;        x  = x * x % maxn;        y /= 2;    }    return res % maxn;}int main(){    ll n;    cin &gt;&gt; n;    ll a, b, c, d, e;    while (n--)    {        ll sum = 0;        cin &gt;&gt; a &gt;&gt; b;        while (b--)        {            cin &gt;&gt; d &gt;&gt; e;            sum += poww(d, e, a);            sum %= a;        }        cout &lt;&lt; sum &lt;&lt; endl;    }}</code></pre><h3 id="Wolf-and-Rabbit"><a href="#Wolf-and-Rabbit" class="headerlink" title="Wolf and Rabbit"></a>Wolf and Rabbit</h3><p>Description:<br>There is a hill with n holes around. The holes are signed from 0 to n-1.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095401.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095401.webp" class="img-shadow img-margin"></center></a><br>A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.<br>Input</p><blockquote><p>The input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0&lt;m,n&lt;2147483648).</p></blockquote><p>Output</p><blockquote><p>For each input m n, if safe holes exist, you should output &quot;YES&quot;, else output &quot;NO&quot; in a single line.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>1 2<br>2 2</p></blockquote><p>Sample Output</p><blockquote><p>NO<br>YES</p></blockquote><p>Problem solving:<br>Nothing to say,just judge the gcd of m and n is equal to 1 or not.<br>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int n,a,b;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);        if(__gcd(a,b)==1)    puts(&quot;NO&quot;);        else    puts(&quot;YES&quot;);    }}</code></pre><h3 id="Cake"><a href="#Cake" class="headerlink" title="Cake"></a>Cake</h3><p>Description:<br>一次生日Party可能有p人或者q人参加,现准备有一个大蛋糕.问最少要将蛋糕切成多少块(每块大小不一定相等),才能使p人或者q人出席的任何一种情况,都能平均将蛋糕分食.<br>Input</p><blockquote><p>每行有两个数p和q.</p></blockquote><p>Output</p><blockquote><p>输出最少要将蛋糕切成多少块.</p></blockquote><p>Sample Input</p><blockquote><p>2 3</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint</p><blockquote><p>将蛋糕切成大小分别为1/3,1/3,1/6,1/6的四块即满足要求.<br>当2个人来时，每人可以吃1/3+1/6=1/2 , 1/2块。<br>当3个人来时，每人可以吃1/6+1/6=1/3 , 1/3, 1/3块。</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int p, q;    while (~scanf(&quot;%d %d&quot;, &amp;p, &amp;q))    {        cout &lt;&lt; p + q - __gcd(p, q) &lt;&lt; endl;    }}</code></pre><h3 id="又见GCD"><a href="#又见GCD" class="headerlink" title="又见GCD"></a>又见GCD</h3><p>Description:<br>有三个正整数a,b,c(0&lt;a,b,c&lt;10^6)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。<br>Input</p><blockquote><p>第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。</p></blockquote><p>Output</p><blockquote><p>输出对应的c，每组测试数据占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>6 2<br>12 4</p></blockquote><p>Sample Output</p><blockquote><p>4<br>8</p></blockquote><p>Problem solving:<br>What we would like to find is the smallest c,so begin with 2*b.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int n, a, b;    cin &gt;&gt; n;    while (n--)    {        cin &gt;&gt; a &gt;&gt; b;        for (int i = b * 2; ; i += b)        {            if (__gcd(a, i) == b)            {                cout &lt;&lt; i &lt;&lt; endl; break;            }        }    }}</code></pre><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>Description:<br>给定两个正整数，计算这两个数的最小公倍数。<br>Input</p><blockquote><p>输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数.</p></blockquote><p>Output</p><blockquote><p>对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。</p></blockquote><p>Sample Input</p><blockquote><p>10 14</p></blockquote><p>Sample Output</p><blockquote><p>70</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n, a, b;    while (~scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))    {        cout &lt;&lt; a * b / __gcd(a, b) &lt;&lt; endl;    }}</code></pre><h3 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h3><p>Description:<br>对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。<br>Input</p><blockquote><p>输入数据有多组，每组占一行，由两个整数x，y组成，当x=0,y=0时，表示输入结束，该行不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个给定范围内的取值，如果表达式的值都为素数，则输出&quot;OK&quot;,否则请输出“Sorry”,每组输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>0 1<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>OK</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool check(ll x){    if (x == 2)        return 0;    for (int i = 2; i &lt; sqrt(x + 1); i++)    {        if (x % i == 0)            return 1;    }    return 0;}int main(){    ll n, a, b;    while (scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))    {        int flag = 0;        if (a == 0 &amp;&amp; b == 0)            break;        for (ll i = a; i &lt;= b; i++)        {            ll mid = i*i+ i + 41;            if (check(mid))            {                flag = 1;                break;            }        }        if (flag)            puts(&quot;Sorry&quot;);        else            puts(&quot;OK&quot;);    }}</code></pre><h3 id="分拆素数和"><a href="#分拆素数和" class="headerlink" title="分拆素数和"></a>分拆素数和</h3><p>Description:<br>把一个偶数拆成两个不同素数的和，有几种拆法呢？<br>Input</p><blockquote><p>输入包含一些正的偶数，其值不会超过10000，个数不会超过500，若遇0，则结束。</p></blockquote><p>Output</p><blockquote><p>对应每个偶数，输出其拆成不同素数的个数，每个结果占一行。</p></blockquote><p>Sample Input</p><blockquote><p>30<br>26<br>0</p></blockquote><p>Sample Output</p><blockquote><p>3<br>2</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e4 + 7;int       p[maxn];int main(){    for (int i = 0; i &lt; maxn; i++)        p[i] = 1;    p[0] = p[1] = 0;    for (int i = 2; i &lt;= sqrt(maxn + 1); i++)    {        for (int j = i + i; j &lt; maxn; j += i)        {            p[j] = 0;        }    }    ll n, a, b;    while (scanf(&quot;%lld&quot;, &amp;n))    {        if (n == 0)            break;        int ans = 0;        for (int i = 2; i &lt;n / 2; i++)        {            if (p[i] &amp;&amp; p[n - i])                ans++;        }        cout &lt;&lt; ans &lt;&lt; endl;    }}</code></pre><h3 id="美素数"><a href="#美素数" class="headerlink" title="美素数"></a>美素数</h3><p>Description:<br>小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。<br>　　问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。<br>　　给定一个区间，你能计算出这个区间内有多少个美素数吗？<br>Input</p><blockquote><p>第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。<br>接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。<br>每组数据占一行，具体输出格式参见样例。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1 100<br>2 2<br>3 19</p></blockquote><p>Sample Output</p><blockquote><p>Case #1: 14<br>Case #2: 1<br>Case #3: 4</p></blockquote><p>Problem solving:<br>Just By meter(打表).<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+7;typedef long long ll;ll p[maxn];ll a[maxn];bool check(ll x){    if(p[x])    return 0;    ll mid=0;    while(x)    {        mid+=x%10;x/=10;    }    if(p[mid])    return 0;    else    return 1;}int main(){    p[0]=p[1]=1;    for(ll i=2;i&lt;sqrt(maxn);i++)    {        for(ll j=i*2;j&lt;maxn;j+=i)        {            p[j]=1;        }    }    a[0]=0;    for(int i=1;i&lt;maxn;i++)    {        if(check(i))    a[i]=a[i-1]+1;        else    a[i]=a[i-1];    }    ll t,l,r;    while(~scanf(&quot;%lld&quot;,&amp;t))    {        for(int i=1;i&lt;=t;i++)        {            scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r);            printf(&quot;Case #%lld: %lld\n&quot;,i,a[r]-a[l-1]);        }    }    return 0;}</code></pre><h3 id="Key-Set"><a href="#Key-Set" class="headerlink" title="Key Set"></a>Key Set</h3><p>Description:<br>soda has a set S with n integers {1,2,…,n}. A set is called key set if the sum of integers in the set is an even number. He wants to know how many nonempty subsets of S are key set.<br>Input</p><blockquote><p>There are multiple test cases. The first line of input contains an integer T (1≤T≤1e5), indicating the number of test cases. For each test case:<br>The first line contains an integer n (1≤n≤1e9), the number of integers in the set.</p></blockquote><p>Output</p><blockquote><p>For each test case, output the number of key sets modulo 1000000007.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>1<br>2<br>3<br>4</p></blockquote><p>Sample Output</p><blockquote><p>0<br>1<br>3<br>7</p></blockquote><p>Problem solving:<br>The answer is 2^(a-1)-1<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1000000007;ll poww(ll x, ll y){    ll res = 1;    while (y)    {        if (y % 2 != 0)            res = res * x % maxn;        x  = x * x % maxn;        y /= 2;    }    return res % maxn;}int main(){    int n, a, b;    cin &gt;&gt; n;    while (n--)    {        cin &gt;&gt; a;        cout &lt;&lt; poww(2, a - 1) - 1 &lt;&lt; endl;    }}</code></pre><h3 id="人见人爱A-B"><a href="#人见人爱A-B" class="headerlink" title="人见人爱A^B"></a>人见人爱A^B</h3><p>Description:<br>求A^B的最后三位数表示的整数。<br>说明：A^B的含义是“A的B次方”<br>Input</p><blockquote><p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2 3<br>12 6<br>6789 10000<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>8<br>984<br>1</p></blockquote><p>Problem solving:<br>Fast power.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll poww(ll x, ll y, ll z){    ll ans = 1, base = x; while (y != 0)    {        if (y &amp; 1 != 0)            ans = ans * base % z;        base = (base % z) * (base % z) % z; y &gt;&gt;= 1;    }    return ans;}int main(){    ll a, b;    while (scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))    {        if (a == 0 &amp;&amp; b == 0)            break;        cout &lt;&lt; poww(a, b, 1000) &lt;&lt; endl;    }}</code></pre><h3 id="Rightmost-Digit"><a href="#Rightmost-Digit" class="headerlink" title="Rightmost Digit"></a>Rightmost Digit</h3><p>Description:<br>Given a positive integer N, you should output the most right digit of N^N.<br>Input</p><blockquote><p>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case contains a single positive integer N(1&lt;=N&lt;=1,000,000,000).</p></blockquote><p>Output</p><blockquote><p>For each test case, you should output the rightmost digit of N^N.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3<br>4</p></blockquote><p>Sample Output</p><blockquote><p>7<br>6</p></blockquote><p>Hint</p><blockquote><p>In the first case, 3 <em> 3 </em> 3 = 27, so the rightmost digit is 7.<br>In the second case, 4 <em> 4 </em> 4 * 4 = 256, so the rightmost digit is 6.</p></blockquote><p>Problem solving:<br>Fast power.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll poww(ll x, ll y, ll z){    ll ans = 1, base = x; while (y != 0)    {        if (y &amp; 1 != 0)            ans = ans * base % z;        base = (base % z) * (base % z) % z; y &gt;&gt;= 1;    }    return ans;}int main(){    ll n, a;    cin &gt;&gt; n;    while (n--)    {        cin &gt;&gt; a;        cout &lt;&lt; poww(a, a, 10) &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> math </tag>
            
            <tag> Fast power </tag>
            
            <tag> prime </tag>
            
            <tag> gcd </tag>
            
            <tag> lcm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Something about __gcd</title>
      <link href="/2019/07/31/sp-gcd/"/>
      <url>/2019/07/31/sp-gcd/</url>
      
        <content type="html"><![CDATA[<p>My past gcd aritical: <a href="https://cndrew.cn/blog/2019/03/26/GCD-LCM/" target="_blank" rel="noopener">https://cndrew.cn/blog/2019/03/26/GCD-LCM/</a><br>For example:</p><pre><code>#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int main(){    int a=199,b=199*2;    printf(&quot;%d\n&quot;,__gcd(a,b));}output:199</code></pre><p>The header file of __gcd is &#39;algorithm&#39;.<br>How about the Time complexity(时间复杂度) of it.<br>I found the source code for its implementation in the source file.Just like Division algorithm(辗转相除法).</p><pre><code>  /**   *  This is a helper function for the rotate algorithm specialized on RAIs.   *  It returns the greatest common divisor of two integer values.  */  template&lt;typename _EuclideanRingElement&gt;    _EuclideanRingElement    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)    {      while (__n != 0)    {      _EuclideanRingElement __t = __m % __n;      __m = __n;      __n = __t;    }      return __m;    }</code></pre><p>Now it&#39;s clear that the Time complexity(时间复杂度) of it is log(n).<br>About this function,many people say it&#39;s probably forbidden in some test,and gcd is not so hard to write,just get too know it.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 14(河南理工大学暑期第十四天)</title>
      <link href="/2019/07/30/14/"/>
      <url>/2019/07/30/14/</url>
      
        <content type="html"><![CDATA[<h3 id="Function-Run-Fun"><a href="#Function-Run-Fun" class="headerlink" title="Function Run Fun"></a>Function Run Fun</h3><p>Description:<br>We all love recursion! Don&#39;t we?</p><p>Consider a three-parameter recursive function w(a, b, c):</p><p>if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns:<br>1</p><p>if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns:<br>w(20, 20, 20)</p><p>if a &lt; b and b &lt; c, then w(a, b, c) returns:<br>w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)</p><p>otherwise it returns:<br>w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)</p><p>This is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.<br>Input</p><blockquote><p>The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result.</p></blockquote><p>Output</p><blockquote><p>Print the value for w(a,b,c) for each triple.</p></blockquote><p>Sample Input</p><blockquote><p>1 1 1<br>2 2 2<br>10 4 6<br>50 50 50<br>-1 7 18<br>-1 -1 -1</p></blockquote><p>Sample Output</p><blockquote><p>w(1, 1, 1) = 2<br>w(2, 2, 2) = 4<br>w(10, 4, 6) = 523<br>w(50, 50, 50) = 1048576<br>w(-1, 7, 18) = 1</p></blockquote><p>Problem solving:<br>这道题没什么好说的，按照题目上的要求来写一个递归就行了，因为是多组输入，所以要用到记忆化搜索。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll a,b,c,dp[21][21][21];ll dfs(ll m,ll t,ll x){    if(m&lt;=0||t&lt;=0||x&lt;=0)        return 1;    if(m&gt;20||t&gt;20||x&gt;20)        return    dfs(20,20,20);    if(dp[m][t][x])    return dp[m][t][x];    if(m&lt;t&amp;&amp;t&lt;x)        return dp[m][t][x]=dfs(m,t,x-1)+dfs(m,t-1,x-1)-dfs(m,t-1,x);    else        return dp[m][t][x]=dfs(m-1,t,x)+dfs(m-1,t-1,x)+dfs(m-1,t,x-1)-dfs(m-1,t-1,x-1);}int main(){    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)    {        if(a==-1&amp;&amp;b==-1&amp;&amp;c==-1)                    break;        printf(&quot;w(%lld, %lld, %lld) = %lld\n&quot;,a,b,c,dfs(a,b,c));    }}</code></pre><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><p>Description:<br>Glory非常喜欢玩滑滑梯游戏，下面给出了一个n,m的滑道，其中的数字表示滑道的高度。Glory可以从一个点出发向下滑行，每次只能滑行到相邻的位置(上下左右)中高度严格低于当前高度的地方，不能重复划行已经滑行过的地方，但他希望在这个滑道上滑行尽量远的距离，也即是找一条最长的滑道。</p><p>Input</p><blockquote><p>第一行输入两个数n,m代表滑梯范围行n和列m(1 &lt;= n,m &lt;= 100)。下面是n行，每行有m个整数，代表高度h，(0&lt;=h&lt;=20000)</p></blockquote><p>Output</p><blockquote><p>输出一个值，代表Glory能够在滑滑梯上面滑行的最长长度是多少</p></blockquote><p>Sample Input</p><blockquote><p>3 3<br>9 1 2<br>5 6 7<br>8 4 3</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Sample Input</p><blockquote><p>4 7<br>7 6 5 4 3 2 1<br>1 5 1 1 1 1 1<br>1 4 3 1 1 1 1<br>1 5 6 7 8 1 1</p></blockquote><p>Sample Output</p><blockquote><p>7</p></blockquote><p>hint</p><blockquote><p>样例1：7-&gt;6-&gt;4-&gt;3 长度为4</p></blockquote><p>Problem solving:<br>四个方向搜索就行了。记忆化搜索要用上，不然会超时。<br>ma[dx][dy]与ma[x][y]的大小关系判断的时候大于小于都是可以的，这个还是很好理解的吧，降序反过来就是升序。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;using namespace std;int n,m,ma[105][105],dp[105][105];int d[4][2]={1,0,0,1,0,-1,-1,0};int dfs(int x,int y){    int mid=1;    if(dp[x][y])    return dp[x][y];    for(int i=0;i&lt;4;i++)    {        int dx=x+d[i][0];        int dy=y+d[i][1];        if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;ma[dx][dy]&lt;ma[x][y])        {            mid=max(mid,dfs(dx,dy)+1);        }    }    return dp[x][y]=mid;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)        for(int j=0;j&lt;m;j++)            cin&gt;&gt;ma[i][j];    int ans=0;    for(int i=0;i&lt;n;i++)        for(int j=0;j&lt;m;j++)            ans=max(ans,dfs(i,j));    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h3 id="漫步校园"><a href="#漫步校园" class="headerlink" title="漫步校园"></a>漫步校园</h3><p>LL最近沉迷于AC不能自拔，每天寝室、机房两点一线。由于长时间坐在电脑边，缺乏运动。他决定充分利用每次从寝室到机房的时间，在校园里散散步。整个HDU校园呈方形布局，可划分为n*n个小方格，代表各个区域。例如LL居住的18号宿舍位于校园的西北角，即方格(1,1)代表的地方，而机房所在的第三实验楼处于东南端的(n,n)。因有多条路线可以选择，LL希望每次的散步路线都不一样。另外，他考虑从A区域到B区域仅当存在一条从B到机房的路线比任何一条从A到机房的路线更近(否则可能永远都到不了机房了…)。现在他想知道的是，所有满足要求的路线一共有多少条。你能告诉他吗?<br>Input</p><blockquote><p>每组测试数据的第一行为n(2=&lt;n&lt;=50)，接下来的n行每行有n个数，代表经过每个区域所花的时间t(0&lt;t&lt;=50)(由于寝室与机房均在三楼，故起点与终点也得费时)。</p></blockquote><p>Output</p><blockquote><p>针对每组测试数据，输出总的路线数(小于2^63)。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1 2 3<br>1 2 3<br>1 2 3<br>3<br>1 1 1<br>1 1 1<br>1 1 1</p></blockquote><p>Sample Output</p><blockquote><p>1<br>6</p></blockquote><p>Problem solving:<br>这道题的题意也太难懂了。。。<br>让你求最短路的条数，所以我们需要先求出最短路然后再求条数。<br>先用bfs求出每个点到终点的最短距离然后进行记忆化搜索。<br>（如果阁下真的是在看我的题解，当你看到这的时候，我衷心的给你道个歉，这道题为了你好还是百度吧</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;struct node{    int x,y,c;    bool friend operator &lt;(node a,node b)    {        return a.c&gt;b.c;    }}r,w;ll ma[305][305],vis[305][305],dis[305][305],dp[305][305];int d[4][2]={0,1,1,0,-1,0,0,-1};void bfs(){    priority_queue&lt;node&gt; q;    r.x=n-1,r.y=n-1;r.c=ma[n-1][n-1];    dis[n-1][n-1]=ma[n-1][n-1];    vis[n-1][n-1]=1;    q.push(r);    while(!q.empty())    {        r=q.top();        q.pop();        for(int i=0;i&lt;4;i++)        {            int dx=r.x+d[i][0];            int dy=r.y+d[i][1];            if(dx&lt;0||dy&lt;0||dx&gt;=n||dy&gt;=n||vis[dx][dy])    continue;            w.x=dx,w.y=dy,w.c=r.c+ma[dx][dy];            vis[dx][dy]=1;            q.push(w);            dis[dx][dy]=w.c;        }    }}ll dfs(ll x,ll y){    if(x==n-1&amp;&amp;y==n-1)    return 1;    if(dp[x][y]!=-1)    return dp[x][y];    dp[x][y]=0;    for(int i=0;i&lt;4;i++)    {        int dx=x+d[i][0];        int dy=y+d[i][1];        if(dx&lt;0||dy&lt;0||dx&gt;=n||dy&gt;=n||dis[dx][dy]&gt;=dis[x][y])    continue;        dp[x][y]+=dfs(dx,dy);    }    return dp[x][y];}int main(){    while(cin&gt;&gt;n)    {        for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;n;j++)                cin&gt;&gt;ma[i][j];        memset(vis,0,sizeof(vis));        memset(dp,-1,sizeof(dp));        bfs();        cout&lt;&lt;dfs(0,0)&lt;&lt;endl;    }}</code></pre><h3 id="Free-Candies"><a href="#Free-Candies" class="headerlink" title="Free Candies"></a>Free Candies</h3><p>Description:<br>PDF题面:<a href="https://uva.onlinejudge.org/external/101/p10118.pdf" target="_blank" rel="noopener">戳我戳我</a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/Description.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/Description.webp" class="img-shadow img-margin"></center></a><br>输入<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/f8bc32f9c3ed521ffc13c93ad058101e714e8250.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/f8bc32f9c3ed521ffc13c93ad058101e714e8250.webp" class="img-shadow img-margin"></center></a><br>输出<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/b2047ac146b5704d62c2c5a4274ff76ea8c1b57b.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/b2047ac146b5704d62c2c5a4274ff76ea8c1b57b.webp" class="img-shadow img-margin"></center></a><br>Problem solving:<br>题意就是有4个盒子，每个盒子里面都放着糖果，有个最多能放5个糖果的袋子，每次只能取盒子最上面的那个糖果，如果袋子里面有两个颜色相同的糖果可以自己拿走（这道题用数字代表颜色），问你最优情况下能拿走几对糖果，注意是对（2个算一对）。<br>我们这里可以用一个四维数组表示分别从四堆糖果中取出不同个数的糖果的时候的最优解，用一个now数组代表此时在第i堆数组拿到了第now[i]个糖果，用一个flag数组表示这个颜色的糖果是否在袋子里出现过。然后进行dfs查找，注意这里用到了很多回溯，还有记忆化搜索。可以看一下代码注释了解一下具体的dfs过程。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int dp[45][45][45][45],n,ma[4][45];int now[4],flag[45];int dfs(int x)//x代表的就是当前袋子里放入的糖果个数{    int ans=0;//初始化为0    if(dp[now[0]][now[1]][now[2]][now[3]]!=-1)//记忆化搜索        return dp[now[0]][now[1]][now[2]][now[3]];    if(x==5)    return 0;//袋子里有5个糖果了，不能放入更多，所以return 0    for(int i=0;i&lt;4;i++)//四堆糖果    {        if(now[i]==n)    continue;//在这一堆如果已经取到了第n个，即最后一个，就结束这一堆糖果中的查找        int mid=ma[i][now[i]];//代表的是当前取出的糖果的颜色        now[i]++;//下一次要放入的糖果的颜色        if(flag[mid])//如果现在要放入袋子里的糖果的颜色在袋子里已经存在        {            flag[mid]=0;//把袋子里的颜色相同的那个糖果取出来            ans=max(ans,dfs(x-1)+1);//当前的最优值更新一下，dfs(x-1)即取出颜色相同得糖果之后的最优解，加上的1就是取出的糖果和本来准备放进袋子却没放的糖果这一对            flag[mid]=1;//回溯，把从袋子里取出的糖果再放回去        }        else//现在要放入袋子里的糖果的颜色在袋子里不存在        {            flag[mid]=1;//把这个糖果放进去            ans=max(dfs(x+1),ans);//此时袋子里的糖果数加一            flag[mid]=0;//回溯，把放进去的再取出来        }        now[i]--;//回溯，考虑不放这一个糖果的情况    }    return dp[now[0]][now[1]][now[2]][now[3]]=ans;//记忆化}int main(){    while(cin&gt;&gt;n&amp;&amp;n)    {        memset(dp,-1,sizeof(dp));        memset(now,0,sizeof(now));        memset(flag,0,sizeof(flag));        for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;4;j++)                cin&gt;&gt;ma[j][i];        cout&lt;&lt;dfs(0)&lt;&lt;endl;                }}</code></pre><h3 id="Zipper"><a href="#Zipper" class="headerlink" title="Zipper"></a>Zipper</h3><p>Description:<br>Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.</p><p>For example, consider forming &quot;tcraete&quot; from &quot;cat&quot; and &quot;tree&quot;:</p><p>String A: cat<br>String B: tree<br>String C: tcraete</p><p>As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming &quot;catrtee&quot; from &quot;cat&quot; and &quot;tree&quot;:</p><p>String A: cat<br>String B: tree<br>String C: catrtee</p><p>Finally, notice that it is impossible to form &quot;cttaree&quot; from &quot;cat&quot; and &quot;tree&quot;.<br>Input</p><blockquote><p>The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.<br>For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.</p></blockquote><p>Output</p><blockquote><p>For each data set, print:<br>Data set n: yes<br>if the third string can be formed from the first two, or<br>Data set n: no<br>if it cannot. Of course n should be replaced by the data set number. See the sample output below for an example.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>cat tree tcraete<br>cat tree catrtee<br>cat tree cttaree</p></blockquote><p>Sample Output</p><blockquote><p>Data set 1: yes<br>Data set 2: yes<br>Data set 3: no</p></blockquote><p>Problem solving:<br>匹配的时候只会有两种情况</p><ol><li>第一个字符串当前位置的字符与第三个字符串当前位置的字符相等。</li><li>第二个字符串当前位置的字符与第三个字符串当前位置的字符相等。<br>只有这两种情况，所以我们可以直接用dfs进行暴搜。但是这道题需要用到记忆化搜索，用一个二维的标记数组即可。每次查找完当前的一对位置就标记起来，下次遇见的时候就不需要再查找了。</li></ol><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;string a,b,c;int vis[205][205],flag;void dfs(int x,int y,int z){    if(flag)    return ;    if(z==c.size())    {        flag=1;        return ;    }    if(vis[x][y])    return ;    vis[x][y]=1;    if(a[x]==c[z])    dfs(x+1,y,z+1);    if(b[y]==c[z])    dfs(x,y+1,z+1);}int main(){    int n,now=0;    cin&gt;&gt;n;    while(n--)    {        memset(vis,0,sizeof(vis));        flag=0;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        cout&lt;&lt;&quot;Data set &quot;&lt;&lt;++now&lt;&lt;&quot;: &quot;;        dfs(0,0,0);        if(flag)    puts(&quot;yes&quot;);        else    puts(&quot;no&quot;);    }}</code></pre><h3 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h3><p>Description:<br>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …<br>The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/bone.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/bone.webp" class="img-shadow img-margin"></center></a><br>Input</p><blockquote><p>The first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.</p></blockquote><p>Output</p><blockquote><p>One integer per line representing the maximum of the total value (this number will be less than 2 31).</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5 10<br>1 2 3 4 5<br>5 4 3 2 1</p></blockquote><p>Sample Output</p><blockquote><p>14</p></blockquote><p>Problem solving:<br>这就是一道背包问题，但是换了描述。<br>背包问题dp得写法我们还没学，今天学到的是用记忆化搜索解决的背包问题。<br>具体的解释请看代码注释</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[1050],b[1050],dp[1050][1050];int dfs(int x,int y)//x代表的是收集到的骨头的个数{                    //y代表的是当前背包剩余容量    if(x==n)    return 0;//没有更多骨头可供收集了    if(dp[x][y])    return dp[x][y];//已经搜索过一次了，直接调用    int ans;    if(y&lt;b[x])    ans=dfs(x+1,y);//当前骨头所占体积大于背包所剩体积，放不进去了，直接跳过    else    ans=max(dfs(x+1,y),dfs(x+1,y-b[x])+a[x]);//能放进去，要分两种情况，放或不放，取最大值    return dp[x][y]=ans;}int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        memset(dp,0,sizeof(dp));        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];        for(int i=0;i&lt;n;i++)    cin&gt;&gt;b[i];        cout&lt;&lt;dfs(0,m)&lt;&lt;endl;    }}</code></pre><h3 id="FatMouse-and-Cheese"><a href="#FatMouse-and-Cheese" class="headerlink" title="FatMouse and Cheese"></a>FatMouse and Cheese</h3><p>Description:<br>有一种游戏是的玩法是这样的：<br>有一个n*n的格子,每个格子有一个数字。<br>遵循以下规则:</p><ol><li>玩家每次可以由所在格子向上下左右四个方向进行直线移动，每次移动的距离不得超过m</li><li>玩家一开始在第一行第一列，并且已经获得该格子的分值</li><li>玩家获得每一次移动到的格子的分值</li><li>玩家下一次移动到达的格子的分值要比当前玩家所在的格子的分值要大。</li><li>游戏所有数字加起来也不大，保证所有数字的和不会超过int型整数的范围</li><li>玩家仅能在n*n的格子内移动，超出格子边界属于非法操作</li><li>当玩家不能再次移动时，游戏结束<br>现在问你，玩家所能获得的最大得分是多少？</li></ol><p>Input</p><blockquote><p>有多组测试数据<br>每组测试样例第一行是两个整数n,m (1≤n≤100)(1≤m≤100),当n和m都是-1时为程序结束标志，直接退出即可<br>之后n行，每行n个数字，描述n*n的格子里的数字</p></blockquote><p>Output</p><blockquote><p>对于每组测试数据输出一行，这一行仅有一个整数，代表玩家所能获得的最高得分</p></blockquote><p>Sample Input</p><blockquote><p>3 1<br>1 2 5<br>10 11 6<br>12 12 7<br>-1 -1</p></blockquote><p>Sample Output</p><blockquote><p>37</p></blockquote><p>Problem solving:<br>这道题跟滑雪那道题差不多，有一点不一样的就是这道题里面每次走的步数可以是不一样的并且范围给了我们。这样的话，仍然暴力搜索就行了。把每种步数都考虑进去可以这样实现</p><pre><code>int d[4][2]={0,1,1,0,0,-1,-1,0};for(int i=0;i&lt;m;i++){    for(int j=1;j&lt;=m;j++)    {        int dx=x+d[i][0]*j;        int dy=y+d[i][1]*j;    }}</code></pre><p>然后就跟滑雪那道题一样了。<br>主要要用到记忆化搜索，不然会TLE</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,ma[105][105],dp[105][105];int d[4][2]={1,0,0,1,-1,0,0,-1};int dfs(int x,int y){    if(dp[x][y])    return dp[x][y];    int ans=0;    for(int i=0;i&lt;4;i++)    {        for(int j=1;j&lt;=m;j++)        {            int dx=x+d[i][0]*j;            int dy=y+d[i][1]*j;            if(dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&lt;n&amp;&amp;ma[dx][dy]&gt;ma[x][y])            {                ans=max(ans,dfs(dx,dy));            }        }    }    return dp[x][y]=ans+ma[x][y];}int main(){    while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!=-1&amp;&amp;m!=-1)    {        memset(dp,0,sizeof(dp));        for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;n;j++)                cin&gt;&gt;ma[i][j];        cout&lt;&lt;dfs(0,0)&lt;&lt;endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> dp </tag>
            
            <tag> dfs </tag>
            
            <tag> 记忆化搜索 </tag>
            
            <tag> hdu </tag>
            
            <tag> UVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 13(河南理工大学暑期第十三天)</title>
      <link href="/2019/07/29/13/"/>
      <url>/2019/07/29/13/</url>
      
        <content type="html"><![CDATA[<p>今天的题很多都是需要灵光一现（或者百度解题的。具体的我也说不清，自己体会吧。（怎么能告诉你是因为我不会呢？</p><h3 id="The-King’s-Ups-and-Downs"><a href="#The-King’s-Ups-and-Downs" class="headerlink" title="The King’s Ups and Downs"></a>The King’s Ups and Downs</h3><p>Description:<br>The king has guards of all different heights. Rather than line them up in increasing or decreasing height order, he wants to line them up so each guard is either shorter than the guards next to him or taller than the guards next to him (so the heights go up and down along the line). For example, seven guards of heights 160, 162, 164, 166, 168, 170 and 172 cm. could be arranged as:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/YI$DPR%28_8~4%5DN$A2%5BLT%28%7DVU.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/YI$DPR%28_8~4%5DN$A2%5BLT%28%7DVU.webp" class="img-shadow img-margin"></center></a><br>or perhaps:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/YI$DPR%28_8~4%5DN$A2%5BLT%28%7DVU.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/YI$DPR%28_8~4%5DN$A2%5BLT%28%7DVU.webp" class="img-shadow img-margin"></center></a><br>The king wants to know how many guards he needs so he can have a different up and down order at each changing of the guard for rest of his reign. To be able to do this, he needs to know for a given number of guards, n, how many different up and down orders there are:</p><p>For example, if there are four guards: 1, 2, 3,4 can be arrange as:</p><p>1324, 2143, 3142, 2314, 3412, 4231, 4132, 2413, 3241, 1423</p><p>For this problem, you will write a program that takes as input a positive integer n, the number of guards and returns the number of up and down orders for n guards of differing heights.</p><p>Input</p><blockquote><p>The first line of input contains a single integer P, (1 &lt;= P &lt;= 1000), which is the number of data sets that follow. Each data set consists of single line of input containing two integers. The first integer, D is the data set number. The second integer, n (1 &lt;= n &lt;= 20), is the number of guards of differing heights.</p></blockquote><p>Output</p><blockquote><p>For each data set there is one line of output. It contains the data set number (D) followed by a single space, followed by the number of up and down orders for the n guards.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>1 1<br>2 3<br>3 4<br>4 20</p></blockquote><p>Sample Output</p><blockquote><p>1 1<br>2 4<br>3 10<br>4 740742376475050</p></blockquote><p>Problem solving:<br>这道题我是真的懵逼了。。。<br>看这个大佬的解释吧:<a href="https://blog.csdn.net/niuox/article/details/8866907" target="_blank" rel="noopener">niuox</a><br>题意是求1-n 的全排列中有多少呈现高低高低高低或者地高低高形式排列的个数。</p><p>这种排列叫做：alternating permutations 或者 Extremal Permutations 。</p><p>可以用DP做。</p><p>dp(n,k)表示：长度为n，最后一个数为k，最后两个数是递增的  排列的个数;</p><p>dp2(n,k)表示：长度为n,最后一个数为k,最后两个数是递减的 排列的个数;</p><p>那么：</p><p>dp(n,k) = dp2(n,n+1-k) ;</p><p>很好理解吧，比如说132(低高低)等价于312(高低高)，相对的位置加起来等于4.</p><p>那么我们针对dp[n][k]的最后一位进行如下考虑：</p><p>最后一位是k，因为dp[n][k]最后两个数字是递增的，所以第n-1位的最大值是k-1。那么我们很容易推导出DP方程：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/W6@LCEF1Z61%60%5DGPX%25Y%60_J$Q.hc" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/W6@LCEF1Z61%60%5DGPX%25Y%60_J$Q.hc" class="img-shadow img-margin"></center></a></p><p>又</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/68AW~3D2%7BH%25LMQ2Z140E3~R.hc" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/68AW~3D2%7BH%25LMQ2Z140E3~R.hc" class="img-shadow img-margin"></center></a><p>所以：dp(n,k) = dp(n-1,n+1-k) + dp(n,k-1)；<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=25;typedef long long ll;ll dp[maxn][maxn],ans[maxn];void init(){    dp[1][1]=1;ans[1]=1;    for(int i=2;i&lt;=20;i++)    {        for(int k=2;k&lt;=i;k++)        {            dp[i][k]=dp[i-1][i+1-k]+dp[i][k-1];            ans[i]+=dp[i][k];        }        ans[i]*=2;    }}int main(){    init();    int p,m,n;    cin&gt;&gt;p;    while(p--)    {        cin&gt;&gt;m&gt;&gt;n;        cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;ans[n]&lt;&lt;endl;    }}</code></pre><h3 id="数塔"><a href="#数塔" class="headerlink" title="数塔"></a>数塔</h3><p>Description:<br>在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：</p><p>有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/P40515CDJA5N%5B8NG5%2965K%287.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/P40515CDJA5N%5B8NG5%2965K%287.webp" class="img-shadow img-margin"></center></a><br>已经告诉你了，这是个DP的题目，你能AC吗?</p><p>Input</p><blockquote><p>输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5</p></blockquote><p>Sample Output</p><blockquote><p>30</p></blockquote><p>Problem solving:<br>挺简单的一道经典的dp的题。这道题我们可以倒着推，状态转移方程就是<br><code>a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j]</code><br>按照这个处理完之后直接输出a[1][1]即可</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int c,n,a[maxn][maxn],ans[maxn][maxn];int main(){    cin&gt;&gt;c;    while(c--)    {        memset(ans,0,sizeof(ans));        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=i;j++)                cin&gt;&gt;a[i][j];        }        for(int i=n-1;i&gt;=1;i--)        {            for(int j=1;j&lt;=i;j++)            {                a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j];            }        }        cout&lt;&lt;a[1][1]&lt;&lt;endl;    }}</code></pre><h3 id="母牛的故事"><a href="#母牛的故事" class="headerlink" title="母牛的故事"></a>母牛的故事</h3><p>Description:<br>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？<br>Input</p><blockquote><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n=0表示输入数据的结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>4<br>5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>2<br>4<br>6</p></blockquote><p>Problem solving:<br>经典题。每头小母牛从第四年开始就可以每年生一头小牛，所以第n年牛的个数即为<br><code>a[n]=a[n-1]+a[n-3]</code><br>即状态转移方程。a[n-1]代表的是上一年所有的母牛，a[n-3]代表的是上一年所有的母牛能生出来的小牛的个数。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[60];int main(){    ans[0]=0;ans[1]=1;ans[2]=2;ans[3]=3;ans[4]=4;    for(int i=5;i&lt;60;i++)        ans[i]=ans[i-1]+ans[i-3];    int n;    while(cin&gt;&gt;n&amp;&amp;n)    {        cout&lt;&lt;ans[n]&lt;&lt;endl;    }}</code></pre><h3 id="一只小蜜蜂"><a href="#一只小蜜蜂" class="headerlink" title="一只小蜜蜂..."></a>一只小蜜蜂...</h3><p>Description:<br>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。<br>其中，蜂房的结构如下所示。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/Z8H9%5B%60GY5~TQ_$GQL%25U%7B1HX.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/Z8H9%5B%60GY5~TQ_$GQL%25U%7B1HX.webp" class="img-shadow img-margin"></center></a><br>Input</p><blockquote><p>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>1 2<br>3 6</p></blockquote><p>Sample Output</p><blockquote><p>1<br>3</p></blockquote><p>Problem solving:<br>状态转移方程<br>ans[i]=ans[i-1]+ans[i-2]</p><p>要到达一个蜂房，如果这个蜂房在第一排，只能从它左边的蜂房或者左下方的蜂房过来；如果这个蜂房在第二排，只能从它左边的蜂房或者左上方的蜂房过来。（摘自<a href="https://blog.csdn.net/Artprog/article/details/69832070" target="_blank" rel="noopener">csdn</a>）</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[55];int main(){    int n,a,b;    cin&gt;&gt;n;    ans[1]=1,ans[2]=1,ans[3]=2;    for(int i=4;i&lt;50;i++)        ans[i]=ans[i-1]+ans[i-2];    while(n--)    {        cin&gt;&gt;a&gt;&gt;b;        cout&lt;&lt;ans[b-a+1]&lt;&lt;endl;    }}</code></pre><h3 id="超级楼梯"><a href="#超级楼梯" class="headerlink" title="超级楼梯"></a>超级楼梯</h3><p>Description:<br>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？<br>Input</p><blockquote><p>输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出不同走法的数量</p></blockquote><p>Sample Input</p><blockquote><p>2<br>2<br>3</p></blockquote><p>Sample Output</p><blockquote><p>1<br>2</p></blockquote><p>Problem solving:<br>每次能走一级台阶或者两级台阶。所以状态转移方程就是<br>ans[i]=ans[i-1]+ans[i-2]</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[45];int main(){    ans[1]=0;    ans[2]=1;    ans[3]=2;    for(int i=4;i&lt;=40;i++)        ans[i]=ans[i-1]+ans[i-2];    int n,m;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;m;        cout&lt;&lt;ans[m]&lt;&lt;endl;    }}</code></pre><h3 id="Tickets"><a href="#Tickets" class="headerlink" title="Tickets"></a>Tickets</h3><p>Description:<br>现在有n个人要买电影票，如果知道每个人单独买票花费的时间，还有和前一个人一起买花费的时间，问最少花多长时间可以全部买完票。<br>Input</p><blockquote><p>给出 N(1&lt;=N&lt;=10)，表示有N组样例 　　　　给出K (1&lt;=K&lt;=2000)，表示有K个人买票.. 　　　　给出K个数表示这个人单独买票会花的时间..保证每个数 (0s&lt;=Si&lt;=25s) 　　　　给出K-1个数，表示这个人和前面那个人一起买票会花的时间..保证每个数 (0s&lt;=Si&lt;=50s)</p></blockquote><p>Output</p><blockquote><p>对于每一组数据，你需要给出电影院售票结束的时间，售票开始的时间为 08:00:00 am. 时间格式为： HH:MM:SS am|pm. 具体看样例输出</p></blockquote><p>Sample Input</p><blockquote><p>2<br>2<br>20 25<br>40<br>1<br>8</p></blockquote><p>Sample Output</p><blockquote><p>08:00:40 am<br>08:00:08 am<br>Problem solving:<br>这道题也是只要找到状态转移方程就行。状态转移方程<br>ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);<br>s[i]是一个人单独买票用的时间，d[i]是两个人一起买票用的时间</p></blockquote><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2005;int s[maxn],d[maxn],ans[maxn];int main(){    int n,k;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;k;        for(int i=1;i&lt;=k;i++)    cin&gt;&gt;s[i];        for(int j=2;j&lt;=k;j++)    cin&gt;&gt;d[j];        ans[1]=s[1];                for(int i=2;i&lt;=k;i++)        {            ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);        }        int time=ans[k];int h,m,s;        h=time/3600;        m=time%3600/60;        s=time%3600%60;        h+=8;        if(h&lt;=12)        printf(&quot;%02d:%02d:%02d am\n&quot;,h,m,s);        else        printf(&quot;%02d:%02d:%02d pm\n&quot;,h-12,m,s);    }}</code></pre><h3 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h3><p>Description:<br>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。<br>Input</p><blockquote><p>每行只有一个正整数N，N小于32768。</p></blockquote><p>Output</p><blockquote><p>对应每个输入，输出兑换方法数。</p></blockquote><p>Sample Input</p><blockquote><p>2934<br>12553</p></blockquote><p>Sample Output</p><blockquote><p>718831<br>13137761</p></blockquote><p>Problem solving:<br>emm，这道题我之前在牛客上面遇见过一道类似的题。只不过那道题里面硬币的个数比这个多。直接套着板子写了、、、</p><p>这是个很基础的背包问题，怎么解释交给时间吧，等我理解了就把这个坑填上。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=35000;ll ans[maxn];ll co[4]={1,2,3};ll solve(ll x){    ans[0]=1;    for(int i=0;i&lt;3;i++)    {        for(int j=co[i];j&lt;=x;j++)        {            ans[j]=(ans[j]+ans[j-co[i]]);        }    }    return ans[x];}int main(){    ll n;    while(cin&gt;&gt;n)    {        memset(ans,0,sizeof(ans));        cout&lt;&lt;solve(n)&lt;&lt;endl;    }}</code></pre><h3 id="Ignatius-and-the-Princess-IV"><a href="#Ignatius-and-the-Princess-IV" class="headerlink" title="Ignatius and the Princess IV"></a>Ignatius and the Princess IV</h3><p>Description:<br>给你n个数字，请你找出出现至少(n+1)/2次的数字。<br>输入</p><blockquote><p>本题包含多组数据，请处理到EOF：<br>每组数据包含两行。<br>第一行一个数字N(1&lt;=N&lt;=999999) ，保证N为奇数。<br>第二行为N个用空格隔开的整数。</p></blockquote><p>输出</p><blockquote><p>对于每组数据，输出一行，表示要求找到的那个数</p></blockquote><p>样例输入</p><blockquote><p>5<br>1 3 2 3 3<br>11<br>1 1 1 1 1 5 5 5 5 5 5<br>7<br>1 1 1 1 1 1 1</p></blockquote><p>样例输出</p><blockquote><p>3<br>5<br>1</p></blockquote><p>Problem solving:<br>这道题没啥说的，找就完了，可以边输入边查找。<br>还有很多办法，比如说直接排序。还有dp的方法。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,flag[1000000];int main(){    while(cin&gt;&gt;n)    {        int ans,a;        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;a;            flag[a]++;            if(flag[a]&gt;=(n+1)/2)                ans=a;        }        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="最少拦截系统"><a href="#最少拦截系统" class="headerlink" title="最少拦截系统"></a>最少拦截系统</h3><p>Description:<br>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.<br>怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.<br>Input</p><blockquote><p>输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)</p></blockquote><p>Output</p><blockquote><p>对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.</p></blockquote><p>Sample Input</p><blockquote><p>8 389 207 155 300 299 170 158 65</p></blockquote><p>Sample Output</p><blockquote><p>2</p></blockquote><p>Problem solving:<br>这个题我一开始就没读懂。。。<br>以后每一发炮弹都不能超过前一发的高度，所以这个就是求最大上升子序列的长度。<br>给定排好序的一堆数列中，求其的LIS长度。它的LIS长度就是它非上升子序列的个数。<br>我比较喜欢用这种nlog(n)的写法</p><p>这道题还有一个坑点就是<br>如果此时一个数大于它前面那个数，那么拦截系统就要加一，但是并不代表前面那个系统就没用了。这样说比较抽象，举个栗子</p><pre><code>100 60 80 20 50</code></pre><p>我们来看一下，一开始我们选择100，大于60，换成了60，然后我们遇到了80，此时就需要一个新的系统了，然后现在是80，我们接着往下看遇到了20，再换成20，然后遇到了50，现在的50是大于20没错，但是上一个变成60的系统还可以使用，所以答案是2.</p><p>也就是因为这个所以不可以直接查找遇见大于前面那个数的情况就加一，这也是这个LIS以及dp的巧妙之处！</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;const int INF = 0x3f3f3f3f;int a[maxn],dp[maxn],n;int main(){    int pos;    while(cin&gt;&gt;pos)    {        fill(dp,dp+pos,INF);        for(int i=0;i&lt;pos;i++)    cin&gt;&gt;a[i];        for(int i=0;i&lt;pos;i++)        {            *lower_bound(dp,dp+pos,a[i])=a[i];        }        cout&lt;&lt;lower_bound(dp,dp+pos,INF)-dp&lt;&lt;endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> poj </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 12(河南理工大学暑期第十二天)</title>
      <link href="/2019/07/28/12/"/>
      <url>/2019/07/28/12/</url>
      
        <content type="html"><![CDATA[<h3 id="烤面包片"><a href="#烤面包片" class="headerlink" title="烤面包片"></a>烤面包片</h3><p>Description:<br>鸡尾酒最喜欢吃东北的烤面包片了。每次到东北地区的区域赛或者是秦皇岛的wannafly camp，鸡尾酒都会吃很多的烤面包片，即使比赛打铁也觉得不枉此行。</p><p>“我想吃烤面包片！！！”这不，半年没吃烤面包片的鸡尾酒看到大家都聚集在秦皇岛参加暑假camp，羡慕地发出了想要的声音。</p><p>当鸡尾酒“想要”的时候，他说的话会带三个感叹号来表示非常“想要”。至于有多“想要”，他给了你一个算式让你来体会。</p><p>给你两个整数 nn 和 modmod，输出 n!!!n!!! 对 modmod 求余的结果（每个!! 都代表一个阶乘符号）</p><p>输入描述</p><blockquote><p>输入共一行包含两个整数依序为 n 和 mod，意义如题面所示。（0≤n≤1e9，1≤mod≤1e9）</p></blockquote><p>输出描述</p><blockquote><p>输出一个小于 mod的非负整数表示答案。</p></blockquote><p>样例输入 1</p><blockquote><p>2 6324</p></blockquote><p>样例输出 1</p><blockquote><p>2</p></blockquote><p>样例输入 2</p><blockquote><p>3 999999999</p></blockquote><p>样例输出 2</p><blockquote><p>731393874</p></blockquote><p>提示</p><blockquote><p>在第一个样例中，由于 2! = 22!=2，所以 2!!! = (((2!)!)!) = ((2!)!) = (2!) = 22!!!=(((2!)!)!)=((2!)!)=(2!)=2。2模了6324还是2！所以答案为2。</p></blockquote><p>Problem solving:<br>这道题一看就吓着我了，阶乘的阶乘的阶乘，这个数可以很大的。我已开始甚至想到了大数打表，但是那样的话时间复杂度也很不乐观，可是这道题过的人还那么多。</p><p>在我的师父——著名acmer——cc的讲解下我知道了这道题的解法。</p><p>如果n是1，或者是2，那么他们阶乘的阶乘就是本身。可以直接输出它本身对mod取模。n是0的情况跟n为1是一样的，因为0的阶乘是1嘛。<br>如果n是3，按照题目中的方式计算即可。<br>如果n&gt;=4,就会出现一个很nb的现象，4!!!是大于1e9很多的，也就是说此时的答案为0.为什么为0呢，因为n大于1e9，mod最大才是1e9，n的阶乘算的过程中一定会乘到一个跟mod相等的数，相等的数取模为0,0乘任何数都为0，所以答案是0.</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,mod,nn=720;ll solve(){      if(n==0||n==1)    return 1%mod;      if(n==2)        return 2%mod;      if(n&gt;3)            return 0;    ll mid=1;    for(ll i=1;i&lt;=nn;i++)    {        mid*=i;        mid%=mod;    }    return mid;}int main(){    cin&gt;&gt;n&gt;&gt;mod;    n=solve();    cout&lt;&lt;n&lt;&lt;endl;}</code></pre><h3 id="幂次方"><a href="#幂次方" class="headerlink" title="幂次方"></a>幂次方</h3><p>Description:<br>任何一个正整数都可以用2的幂次方表示。例如：<br>137=2^7+2^3+2^0<br>同时约定方次用括号来表示，即ab可表示为a（b）。<br>由此可知，137可表示为：<br>2（7）+2（3）+2（0）<br>进一步：7=2^2+2+2^0（2^1用2表示）<br>3=2+2^0<br>所以最后137可表示为：<br>2（2（2）+2+2（0））+2（2+2（0））+2（0）<br>又如：<br>1315=2^10+2^8+2^5+2+1<br>所以1315最后可表示为：<br>2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）</p><p>输入描述:</p><blockquote><p>正整数（n ≤ 20000）</p></blockquote><p>输出描述:</p><blockquote><p>符合约定的n的0，2表示（在表示中不能有空格）</p></blockquote><p>示例1<br>输入</p><blockquote><p>1315</p></blockquote><p>输出</p><blockquote><p>2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</p></blockquote><p>Problem solving:<br>一开始想着用二进制形式表示，然后通过一些特殊的手段一直找1的位置，可以用bitset来实现，可是没写出来，希望如果有大佬会写的话教一下我，感激不尽。</p><p>然后我去百度了一下这道题，就被这道题巧妙地思路给震撼到了。通过递归实现。<br>思路大概就是先找到小于当前数的最大的2的次方数，然后查找下一个2的次方数，这道题用到了递归，就会很抽象一项（像某fs一样令人脱发。不太好理解，多看看代码吧。<br>说实话我也没很懂，啧啧啧</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;void solve(int n){    if(n&gt;4)    {        int t=1;        while(pow(2,t)&lt;=n)    t++;        cout&lt;&lt;&quot;2(&quot;;        solve(t-1);        cout&lt;&lt;&quot;)&quot;;        if(n!=pow(2,t-1))    cout&lt;&lt;&quot;+&quot;;        solve(n-pow(2,t-1));    }    else        switch(n)        {            case 0:return ;            case 1:cout&lt;&lt;&quot;2(0)&quot;; break;            case 2:cout&lt;&lt;&quot;2&quot;; break;            case 3:cout&lt;&lt;&quot;2+2(0)&quot;;break;            case 4:cout&lt;&lt;&quot;2(2)&quot;;        }}int main(){    int n;    cin&gt;&gt;n;    solve(n);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
            <tag> Thinking  </tag>
            
            <tag> comet oj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Day 11(河南理工大学暑期第十一天)</title>
      <link href="/2019/07/27/11/"/>
      <url>/2019/07/27/11/</url>
      
        <content type="html"><![CDATA[<p>开始集训的第十一天，举办了第二次积分赛，这次学长还开了网上的同步赛，打完也是挺自闭的。唉，好好学习，明天休息，收拾一下，没啥事还是敲代码吧。。。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河南理工大学算法协会暑期集训积分赛（二）</title>
      <link href="/2019/07/27/jf2/"/>
      <url>/2019/07/27/jf2/</url>
      
        <content type="html"><![CDATA[<p>欢迎访问我校oj：<a href="https://hpuoj.com/" target="_blank" rel="noopener">hpuoj</a><br>本场积分赛传送门: <a href="https://hpuoj.com/contest/23/" target="_blank" rel="noopener">Uncle_drew is so handsome</a></p><h3 id="再战斐波那契"><a href="#再战斐波那契" class="headerlink" title="再战斐波那契"></a>再战斐波那契</h3><p>Description:<br>小z 学会了斐波那契和 gcd 后，老师又给他出了个难题，求第N个和第M个斐波那契数的最大公约数，这可难倒了小z ，不过在小z 的再三请求下，老师又告诉他了个条件，gcd(N,M)∈[1,90]。<br>可是，笨拙的小z 还是不会，于是请求你帮他解答这个问题。</p><p>已知:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100226.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100226.webp" class="img-shadow img-margin"></center></a></p><p>输入格式<br>输入包括 T 组，T∈[1,10].<br>接下来 T 行,每行两个整数 N,M, 表示斐波那契的第 N 项和第 M 项，(N,M∈[1,1e18]).</p><p>输出格式<br>输出包含 T 行,每行输出一个整数.</p><p>样例<br>input</p><blockquote><p>3<br>1 2<br>2 3<br>3 4</p></blockquote><p>output</p><blockquote><p>1<br>1<br>1</p></blockquote><p>Problem solving:<br>神tm签到题。。。<br>这道题主要是有个规律斐波那契数列第M项和第N项的gcd就是斐波那契数列第gcd（m,n）项的值。即：<br>gcd(f(m),f(n)) = f(gcd(m,n))<br>顺便记一下<br>long long可以存到大概第92项斐波那契数，unsigned一下会再多一项。Ps：我之前一直以为50项就爆long long了。。。如果知道这个92，那猜这个规律应该就挺简单了吧。<br>而我是跑了N个循环找到的当时并不确定的规律。。。</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;unsigned long long a[100],x,y;int main(){    a[0]=0,a[1]=1;    for(int i=2;i&lt;=100;i++)    {    a[i]=a[i-1]+a[i-2];    }    int t;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;x&gt;&gt;y;        cout&lt;&lt;a[__gcd(x,y)]&lt;&lt;endl;    }}</code></pre><h3 id="恐怖的怪物"><a href="#恐怖的怪物" class="headerlink" title="恐怖的怪物"></a>恐怖的怪物</h3><p>Description:<br>一天早上，Dicer一觉醒来，发现自己来到了MineCraft的世界里面，身为MineCraft游戏爱好者的他欣喜不已，于是他在地下挖了一片长方体的空间作为秘密基地，可是他发现光照亮度小于等于7时，会有恐怖的怪物出现，并且他通过查阅资料发现光源方块产生光照每一米（方格）衰减1光照等级。</p><p>此规律在坐标轴的3个方向上（东西、南北、上下）均成立。换句话来说，对角线方向的光照衰减依照“曼哈顿距离”（两个点在坐标系上的绝对轴距总和）计算。这意味着，假如地上插着一支火把（光照等级14），则在水平面上与火把相邻的4个方向的方格上光照等级均为13，而在水平面上与火把对角的4个方格上光照等级均为12（譬如，西北方格的光照等级为14-向西1级-向北1级）。</p><p>上述这种衰减特性会在光源周围产生菱形的照明。该效果会在光源周围的光源扩散呈钻石状。如果被不透明方块阻挡，光照也可以沿着复杂而弯曲的路径扩散。</p><p>如下图所示，红色为光源（亮度等级为14）,黑色为秘密物品，其余各个位置光照强度如图所示。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100243.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100243.webp" class="img-shadow img-margin"></center></a></p><p>秘密基地为N∗M的空间，不考虑高度，初始地面光照强度为0。为了不生成恐怖的怪物，Dicer布置了一些光源，但他不知道是否仍会生成怪物，现在请你帮助Dicer判断。</p><p>注：光源及秘密物品均为不透明方块，且其上方均不会生成怪物。</p><p>输入格式<br>第一行是一个T。（1≤T≤100）<br>接下来有T组数据，每一组第一行是N,M,（1≤N,M≤1000）,接下来有N行，每行M个字符，代表秘密基地地面放置的方块，0代表空气，#代表秘密物品，Y代表萤石(光照等级为15)，H代表火把(光照等级为14)，F代表附魔台(光照等级为12)，R代表激活的红石火把(光照等级为7)。</p><p>输出格式<br>输出包含T行，每行如果仍会生成怪物，输出”Yes”,否则输出”No”。</p><p>样例<br>input</p><blockquote><p>2<br>2 3<br>0Y0<br>00#<br>3 4<br>R00#<br>00R0<br>0R00</p></blockquote><p>output</p><blockquote><p>No<br>Yes</p></blockquote><p>input</p><blockquote><p>2<br>1 5<br>0Y0R0<br>2 4<br>Y#0R<br>0000</p></blockquote><p>output</p><blockquote><p>Yes<br>No</p></blockquote><p>input</p><blockquote><p>1<br>5 4<br>Y0F0<br>0000<br>0000<br>0000<br>0000</p></blockquote><p>output</p><blockquote><p>No</p></blockquote><p>Problem solving:<br>简单？的bfs问题。就是条件有点多。。。比赛的时候写炸了</p><p>这道题给了5s，按理说只要查找写的对，就不会超时。我想了一下我的方法，应该是里面出现了死循环，咳咳。</p><p>这道题的难点就是每个点的亮度有可能源于两个点，而你肯定要取最大值。但是怎么取？我一开始直接用了max，然后就是一直tle，因为这样会出现死循环的情况，就是满足不了return的情况。后来看了学长的代码，吃了一惊，原来还可以这样写。</p><p>开三个队列，分别存储出现Y，H，F的位置。然后从存着Y的队列开始进行bfs，如果当前亮度是到了14，就把装有H的队列中的元素放入第一个队列继续bfs，12也是同理。这一点还挺好理解的。这样操作的话，每个点自然就是可以达到尽可能大的亮度。最后在判断有没有小于等于7的空地存在即可。</p><p>在今天之前我还一直以为我的bfs挺不错的。现在我觉得我连mc的资深玩家都不配当了。<br>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1010;int t,n,m,l[maxn][maxn];char s[maxn][maxn];int d[4][2]={1,0,0,1,-1,0,0,-1};struct node{    int x,y;};queue&lt;node&gt; wo,yao,meizi;bool bfs(){    while(!wo.empty())    {        int x=wo.front().x;        int y=wo.front().y;        wo.pop();        if(l[x][y]==8)    break;        for(int i=0;i&lt;4;i++)        {            int dx=x+d[i][0];            int dy=y+d[i][1];            if(dx&lt;0||dx&gt;=n||dy&lt;0||dy&gt;=m||s[dx][dy]!=&#39;0&#39;||l[dx][dy])                continue;            l[dx][dy]=l[x][y]-1;            wo.push({dx,dy});            while(l[dx][dy]==14&amp;&amp;(!yao.empty()))            {                wo.push(yao.front());                yao.pop();            }            while(l[dx][dy]==12&amp;&amp;(!meizi.empty()))            {                wo.push(meizi.front());                meizi.pop();            }//            cout&lt;&lt;l[dx][dy]&lt;&lt;endl;        }    }    for(int i=0;i&lt;n;i++)        for(int j=0;j&lt;m;j++)            if(l[i][j]&lt;=7&amp;&amp;s[i][j]==&#39;0&#39;)    return 0;    return 1;}int main(){    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;n&gt;&gt;m;        while(!wo.empty())    wo.pop();        while(!yao.empty())    yao.pop();        while(!meizi.empty())    meizi.pop();        memset(l,0,sizeof(l));        for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;m;j++)            {                cin&gt;&gt;s[i][j];                if(s[i][j]==&#39;Y&#39;)    wo.push({i,j}),l[i][j]=15;                if(s[i][j]==&#39;H&#39;)    yao.push({i,j}),l[i][j]=14;                if(s[i][j]==&#39;F&#39;)    meizi.push({i,j}),l[i][j]=12;            }                    }        if(bfs())    puts(&quot;No&quot;);        else    puts(&quot;Yes&quot;);    }}</code></pre><h3 id="连连看"><a href="#连连看" class="headerlink" title="连连看"></a>连连看</h3><p>Description:<br>众所周知，《连连看》是一个老少皆宜的游戏。<br>《连连看》是由黄兴武创作的一款PC端益智类游戏，只要将相同的两张牌用三根以内的线段连在一起就可以消除，规则简单容易上手。</p><p>现在呢，Boctorio学长突然想玩连连看了，但不是单纯的玩游戏，他想自己出一局连连看。<br>由于Boctorio学长是一个蒟蒻，他不知道自己出的连连看是否符合能够通过多次操作将其全部消除，所以想要你帮他检查一下他出的连连看是否符合规则。</p><p>输入格式<br>第一行输入个T,表示T组数据（1≤t≤100）<br>每组数据第一行两个数 n,m ,表示连连看棋盘的长和宽（1≤n,m≤100）<br>接下来 n 行，每行输入 m 个正整数aij，表示 m 个棋子 (1≤aij≤n∗m)。</p><p>每种棋子只会出现一对，因此数据保证只有一种有效结果。</p><p>输出格式<br>每组数据输出一行。<br>如果棋盘符合规定，输出”Yes”，否则，输出”No”（不包括引号）。</p><p>样例<br>input</p><blockquote><p>3<br>2 2<br>1 2<br>2 1<br>3 4<br>1 6 2 3<br>4 5 3 1<br>4 2 6 5<br>4 4<br>1 2 3 6<br>8 4 7 8<br>5 6 5 7<br>1 2 3 4</p></blockquote><p>output</p><blockquote><p>No<br>No<br>Yes</p></blockquote><p>Problem solving:<br>暂无(毫无思路题)</p><p>Code：</p><pre><code>/** *　　　　　　　　┏┓　　 　┏┓ * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　 　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　... 　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛ */// warm heart, wagging tail,and a smile just for you!////                            _ooOoo_//                           o8888888o//                           88&quot; . &quot;88//                           (| -_- |)//                           O\  =  /O//                        ____/`---&#39;\____//                      .&#39;  \|     |//  `.//                     /  \|||  :  |||//  \//                    /  _||||| -:- |||||-  \//                    |   | \\  -  /// |   |//                    | \_|  &#39;&#39;\---/&#39;&#39;  |   |//                    \  .-\__  `-`  ___/-. ///                  ___`. .&#39;  /--.--\  `. . __//               .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |//              \  \ `-.   \_ __\ /__ _/   .-` /  ///         ======`-.____`-.___\_____/___.-`____.-&#39;======//                            `=---=&#39;//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//</code></pre><h3 id="Points-in-rectangle"><a href="#Points-in-rectangle" class="headerlink" title="Points in rectangle"></a>Points in rectangle</h3><p>Description:<br>在二维平面中有一个矩形，它的四个坐标点分别为(0,a),(a,0),(n,n−a),(n−a,n)。你现在有m个点，现在你想知道有多少个点是在这个矩形内的(边上的也算)。</p><p>输入格式<br>第一行输入n,a(1≤a\&lt;n≤1e3)。<br>第二行一个正整数m(1≤m≤1e3),代表你拥有的点的个数，接下来m行，每行一个点的坐标xi,yi(1≤xi,yi≤1e3)。</p><p>输出格式<br>第一行输出在矩形内的点的个数，然后输出在矩形内点的坐标，横坐标大的优先，如果横坐标相同，则纵坐标大的优先。如果没有，输出−1。</p><p>样例<br>input</p><blockquote><p>6 1<br>5<br>1 2<br>1 3<br>2 3<br>3 4<br>4 5</p></blockquote><p>output</p><blockquote><p>4<br>4 5<br>3 4<br>2 3<br>1 2</p></blockquote><p>Problem solving:<br>也算是一道签到了吧，就是不太好想，不画一下的话。<br>我的思路是把四条边的表达式写出来，对每个输入的x找出y的边界值然后进行比较。</p><p>如图所示，将图分为三部分，然后我们可以这样判断<br>1.如果x，y中有一个大于n的，就说明这个点不会在矩形中<br>2.x\<a的时候，根据x的值求出直线表达式y1,y2所对应的值，此时y1的值就是下界，y2的值就是上界，如果y在y1和y2中间就说明这个点在矩阵中。 3.x>n-a的时候，跟上面一样不过此时上下界对应的值是y2和y4<br>4.x&gt;a &amp;&amp; x\&lt;n-a的时候，上下界对应的值是y3和y4</a的时候，根据x的值求出直线表达式y1,y2所对应的值，此时y1的值就是下界，y2的值就是上界，如果y在y1和y2中间就说明这个点在矩阵中。></p><p>关于y1，y2,y3,y4的表达式<br>本题中这个还是很好求得的<br>y1=-x+a                y2=x+a<br>y3=-x+2*n-a            y4=x-a</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100330.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100330.webp" class="img-shadow img-margin"></center></a><p>判断完用结构体排一下序输出即可。</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;struct node{    int x,y;}p[1005];bool cmp(node a,node b){    if(a.x==b.x)    return a.y&gt;b.y;    return a.x&gt;b.x;}int main(){    int n,a,m,x,y,pos=0;    double s,k,sx,sy;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;m;    for(int i=0;i&lt;m;i++)    {        cin&gt;&gt;x&gt;&gt;y;        if(x&gt;n||y&gt;n)    continue;        if(x&gt;=a&amp;&amp;x&lt;=n-a)        {            if(y&gt;x+a||y&lt;x-a)    continue;        }        if(x&lt;a)        {            if(y&gt;x+a||y&lt;-x+a)    continue;        }        if(x&gt;n-a)        {            if(y&lt;x-a||y&gt;-x+2*n-a)    continue;        }        p[pos].x=x,p[pos].y=y;        pos++;    }    if(pos==0)        puts(&quot;-1&quot;);    else    {        cout&lt;&lt;pos&lt;&lt;endl;        sort(p,p+pos,cmp);        for(int i=0;i&lt;pos;i++)        {            cout&lt;&lt;p[i].x&lt;&lt;&#39; &#39;&lt;&lt;p[i].y&lt;&lt;endl;        }            }}</code></pre><h3 id="Numbers-of-interval"><a href="#Numbers-of-interval" class="headerlink" title="Numbers of interval"></a>Numbers of interval</h3><p>Description:<br><a href="https:///2019/07/27/5d3c2d6a4a45986514.webp" data-fancybox="images" data-caption="sakura"><center><img src="https:///2019/07/27/5d3c2d6a4a45986514.webp" class="img-shadow img-margin"></center></a></p><p>输入格式<br>第一行输入n,k(1≤n,k≤1e6).<br>接下来输入n个数，第i个数为ai(1≤ai≤1e3).</p><p>输出格式<br>输出满足条件的区间个数</p><p>样例<br>input<br>3 5<br>2 3 5<br>output<br>4</p><p>Problem solving:<br>这道题做出来的人很多，我忘了lower_bound，用一个前缀和数组就行了。注意这道题的ans会爆int。<br>这道题看了学长的题解和标程之后觉得自己明白的很透彻。然后跟一个同学交流这道题的时候发现自己也是没那么明白。不过现在还是很透彻的，记录一下。</p><p>主要需要理解的就是在你构造的前缀和数组中第n项到第m项的和为<br>sum[m]-sum[n-1](注意是n-1，如果是n的话，那表示的就是第n+1项到第m项的和，因为你会把a[n]也减掉。</p><p>现在我们要查找区间和大于等于k的区间个数，因为是前缀和数组，所以构造出来的前缀和数组一定是有序的（升序。如果直接O(n*n)，1e6的数据范围肯定会超时。又正好看到数组是有序的，这时候就<del>~很自然</del>~的想到二分(虽然我并没有想到)。区间和大于等于k即a[m]-a[n-1]&gt;=k,所以我们先确定区间的左端点，然后二分查找到第一个使区间和大于等于k的右端点的值，此时我们找到的这个右端点的右面的每一个端点都可以跟那个确定的左端点组成一个区间和大于等于k的区间，查找所有点为左端点的情况，答案累加即可。<br>唯一有点绕的就是sum[n]-sum[m-1]&gt;=k换成了sum[m-1]+k&lt;=sum[n]<br>查找第一个符合要求的右端点可以这样写</p><pre><code>lower_bound(sum+1,sum+n+1,k+a[i-1])-sum</code></pre><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000050],p[1000050];int main(){    int n,k;    cin&gt;&gt;n&gt;&gt;k;    for(int i=1;i&lt;=n;i++)        cin&gt;&gt;a[i],p[i]=p[i-1]+a[i];    long long ans=0;    for(int i=1;i&lt;=n;i++)    {        int mid=lower_bound(p+1,p+1+n,p[i-1]+k)-p;        ans+=(n-mid+1);    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h3 id="剪纸"><a href="#剪纸" class="headerlink" title="剪纸"></a>剪纸</h3><p>Description:<br>中国剪纸是一种用剪刀或刻刀在纸上剪刻花纹，用于装点生活或配合其他民俗活动的民间艺术。在中国，剪纸具有广泛的群众基础，交融于各族人民的社会生活，是各种民俗活动的重要组成部分。其传承赓续的视觉形象和造型格式，蕴涵了丰富的文化历史信息，表达了广大民众的社会认以、道德观念、实践经验、生活理想和审美情趣，具有认知、教化、表意、抒情、娱乐、交往等多重社会价值。<br>2006年5月20日，剪纸艺术遗产经国务院批准列入第一批国家级非物质文化遗产名录 。2009年9月28日至10月2日举行的联合国教科文组织保护非物质文化遗产政府间委员会第四次会议上，中国申报的中国剪纸项目入选“人类非物质文化遗产代表作名录”。</p><p>剪窗花最基本的操作为将剪纸进行多次对折，然后对对折之后的纸进行裁剪，展开后就是一个精美的艺术品。现在我们对问题进行化简，我们利用如下方法将一张形状矩形的纸按照对阵轴进行对折：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100348.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100348.webp" class="img-shadow img-margin"></center></a><br>假设剪后的形状为一个三角形，则展开效果为：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100532.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100532.webp" class="img-shadow img-margin"></center></a><br>现在给你一个对折两次且剪切后的图形，请你给出展开的图形形状。</p><p>输入格式<br>多组输入，处理到文件结束。<br>每组输入第一行两个数字n,m（1≤n,m≤100)。<br>接下来n行，每行m个字符，表示对折且剪切后的图形。<br>保证输入字符只包含 ‘.’ 和 ‘*’ 。</p><p>输出格式<br>输出展开后的图形。</p><p>样例<br>input</p><pre><code>3 3**.*.....</code></pre><p>output</p><pre><code>........**...****..****...**........</code></pre><p>Problem solving:<br>签到题，搞清楚每个点的关系就行。（这个我写的可能是有点麻烦了，可以去看一下下面学长的标程</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;char a[405][405];int main(){    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        for(int i=n;i&lt;2*n;i++)            for(int j=m;j&lt;2*m;j++)                cin&gt;&gt;a[i][j];        for(int i=n;i&lt;2*n;i++)        {            for(int j=0;j&lt;m;j++)            {                a[i][j]=a[i][2*m-j-1];            }        }        for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;m;j++)            {                a[i][j]=a[2*n-i-1][j];            }        }        for(int i=0;i&lt;n;i++)        {            for(int j=m;j&lt;2*m;j++)            {                a[i][j]=a[2*n-i-1][j];            }        }        for(int i=0;i&lt;2*n;i++)        {                for(int j=0;j&lt;2*m;j++)                cout&lt;&lt;a[i][j];            puts(&quot;&quot;);        }    }}</code></pre><h3 id="Fake-hpuoj-predictor"><a href="#Fake-hpuoj-predictor" class="headerlink" title="Fake hpuoj predictor"></a>Fake hpuoj predictor</h3><p>Description:<br>总所周知，HPU(Harmonious and Peaceful University) Online Judge具有一个强大的的rating(积分)系统，它采用的是国际上权威的ELO等级分制度(ELO Rating System)，LOL，守望先锋,codeforces,topcoder等知名游戏的排行均是采用此制度。<br>具体算法为：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100820.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100820.webp" class="img-shadow img-margin"></center></a><br>其中R(A)和R(B)为选手A和B初始的rating，那么E(A)和E(B)即为这两者进行对战后A和B各自获胜的期望。<br>本场比赛的积分公式即为<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100845.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100845.webp" class="img-shadow img-margin"></center></a><br>RA代表上轮比赛结束后的积分。<br>K为积分系数,对于不同等级的选手的K是不同的。<br>SA代表比赛实际总得分，对于每局比赛来说，每赢一个人就会加1分,输了不扣分。<br>EAi代表A与第i个选手比赛获胜的期望。<br>对于HPU Online Judge，用户等级表为:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100927.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100927.webp" class="img-shadow img-margin"></center></a><br>codancer有一个成为Grand Master的梦想，已知他的初始rating为0，他总共参加了m场比赛，对于每场比赛有一个榜单，对于codancer来说，排在他前面的人都打败了他，排在他后面的人都输给了他，因此你可以通过和每个参加比赛的选手比较计算出总得分SA和总期望∑EAi。<br>那么最终codancer打完本场比赛后的rating为<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100941.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100941.webp" class="img-shadow img-margin"></center></a><br>现在他打完了这m场比赛后他迫切的想知道自己的rating变为了多少(因为管理员太懒了，已经鸽了m场的rating计算了)，现在他想让你帮他写一个预测器来预测一下。</p><p>输入格式<br>单组输入，第一行输入一个m(1≤m≤100)，代表codancer参加的比赛的数量。<br>接下来对于每场比赛：<br>第一行输入一个整数n代表有n(1≤n≤100)个人参加的比赛。<br>接下来n行每行输入一个字符串和数字，代表参赛选手的用户名和他的rating，codancer即为他自己的用户名(用户名长度不超过20)，假如输入的名字为codancer,则不用输入数字(其他参赛选手的rating是不会更新的，因为管理员太懒了)。</p><p>输出格式<br>输出codancer最终的rating，向上取整。</p><p>样例<br>input</p><blockquote><p>3<br>5<br>tourist 2000<br>capryang 1900<br>boctorio 1800<br>dicer 1800<br>codancer<br>2<br>codancer<br>rookie 200<br>2<br>wzy 1500<br>codancer</p></blockquote><p>output</p><blockquote><p>12</p></blockquote><p>提示<br>每计算完一场都需要向上取整，建议参与运算的变量都使用double。</p><p>Problem solving:<br>这道题的难点就是读题。读懂了之后直接模拟就行了。<br>学长说：写了就能过。。。<br>然后我无限wa。最后借了学长的代码看了一下。也没发现有啥不一样的，可能就是精度问题吧。</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;double find(double x){    if(x&lt;=1349)    return 15;    if(x&lt;=1499)    return 20;    if(x&lt;=1599)    return 25;    if(x&lt;=1699)    return 30;    if(x&lt;=1799)    return 35;    return 50;}int main(){    int t;    cin&gt;&gt;t;    string s;    double ra=0,rb;    while(t--)    {        int n;        cin&gt;&gt;n;        double ea=0,sum=0;        double k=find(ra),sa=0;        for(int i=1;i&lt;=n;i++)        {            cin&gt;&gt;s;            if(s==&quot;codancer&quot;)            {                sa=n-i;                continue;            }            cin&gt;&gt;rb;            ea=1.0/(1+pow(10,(rb-ra)/400));            sum+=ea;        }        ra=ceil(ra+k*(sa-sum));    }    printf(&quot;%.0lf\n&quot;,ra);}</code></pre><h3 id="花花与三猫Catlive"><a href="#花花与三猫Catlive" class="headerlink" title="花花与三猫Catlive"></a>花花与三猫Catlive</h3><p>Description:<br>“大佬”中分和“呆B”李白正在玩一个游戏，游戏规则是这样的：</p><ol><li>游戏刚开始的时候，中分和李白相距L步，相对而望。</li><li>老父亲和老母亲手中各有一个M个面的均匀骰子。（也就是说可以随机生成[1,m]内的任意一个数字，且概率均等）</li><li>在每个回合开始的时候，老父亲和老母亲都会掷一下手中的骰子。</li><li>当老父亲的骰子掷到1的时候，中分可以向李白走一步。</li><li>当老母亲的骰子掷到m的时候，李白可以向中分走一步。</li><li>当中分和李白相遇的时候，游戏结束。</li></ol><p>可是老父亲和老母亲刚刚拍完新节目，他们太累了，不想做这个游戏，但是他们还很想知道，这个游戏平均需要多少次才能结束。聪明的你，能告诉他们吗？</p><p>结果是一个实数s，可以证明s能被表示成一个分数 qp，请输出q⋅p−1，其中q−1表示q在模109+7意义下的逆元。</p><p>输入格式<br>第一行是一个正整数 T(1≤T≤1000)，表示测试样例的组数。<br>接下来T行，每行两个正整数L,M(1≤L,M≤1000)，含义如题面描述。</p><p>输出格式<br>输出包括T行，每行一个答案。</p><p>样例<br>input</p><blockquote><p>2<br>1 2<br>2 1</p></blockquote><p>output</p><blockquote><p>1<br>1</p></blockquote><p>提示<br>2在模109+7意义下的逆元是500000004<br>Problem solving:<br>这道题比赛的时候嫌题面太长我就没看。后来发现这就是一道水题。。。题意就是两个人的距离给出了是L，用一个m面的骰子掷一下，如果是1或者m，就会有人走一步，不用管是谁走，效果都是一样的。所以每次有人走一步的概率就是2/m，总共要走l步，让输出的就是l/（2/m），即l*m/2<br>表面上这道题还让你求逆元，实际上这里我们用到的只有2的逆元，而且还给出了2在模1e9+7意义下的逆元。所以，是个水题。以后这种看见题面太长就不想看的坏毛病必须得改一下了。</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int t;    cin&gt;&gt;t;    long long n,m;    while(t--)    {        cin&gt;&gt;n&gt;&gt;m;        cout&lt;&lt;n*m*500000004%1000000007&lt;&lt;endl;    }}</code></pre><h3 id="Same-String"><a href="#Same-String" class="headerlink" title="Same String"></a>Same String</h3><p>Description:<br>有两个只由小写字母组成的长度为n的字符串s1,s2和m组字母对应关系，每一组关系由两个字母c1和c2组成，代表c1可以直接变成c2,你需要判断s1是否可以通过这m组关系转换为s2。</p><p>输入格式<br>第一行输入一个n(1≤n≤100)，代表字符串的长度。<br>第二行和第三行输入两个字符串s1,s2。<br>第四行输入一个m(1≤m≤325)，代表有m组关系。<br>接下来m行，第i行两个字符ui,vi,代表ui可以直接变为vi。</p><p>输出格式<br>如果s1可以通过这些m组关系转化变为s2，输出”YES”，否则输出”NO”。</p><p>样例<br>input</p><blockquote><p>6<br>aabbcc<br>cdbcad<br>4<br>a c<br>c a<br>a d<br>b c</p></blockquote><p>output</p><blockquote><p>YES</p></blockquote><p>提示<br>可以转换多次，比如a可以转换为b，而b可以转换为c，则a可以转换为c。<br>样例一：aabbcc-&gt;cabbcc-&gt;cdbbcc-&gt;cdbccc-&gt;cdbcac-&gt;cdbcaa-&gt;cdbcad<br>Problem solving:<br>这道题我是用存图做的，跟昨天专练里面的一道题很像，就不详细讲了。<br>这道题还有另一种算法，可以看下面学长的标程<br>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int mmp[50][50],vis[50];bool bfs(int x,int y){    queue&lt;int&gt; q;    q.push(x);vis[x]=1;    while(!q.empty())    {        x=q.front();q.pop();        if(x==y)    return 1;        for(int i=0;i&lt;=26;i++)        {            if(mmp[x][i]&amp;&amp;vis[i]==0)            {                q.push(i);                vis[i]=1;            }        }    }    return 0;}int main(){    int n,m;string a,b;    char c,d;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;m;    for(int i=0;i&lt;m;i++)    {        cin&gt;&gt;c&gt;&gt;d;        int x=c-&#39;a&#39;,y=d-&#39;a&#39;;        mmp[x][y]=1;    }    int flag=0;    for(int i=0;i&lt;n;i++)    {        memset(vis,0,sizeof(vis));        if(bfs(a[i]-&#39;a&#39;,b[i]-&#39;a&#39;)==0)        {            flag=1;            break;        }    }    if(flag)    puts(&quot;NO&quot;);    else    puts(&quot;YES&quot;);}</code></pre><h3 id="学长标程和题解"><a href="#学长标程和题解" class="headerlink" title="学长标程和题解"></a>学长标程和题解</h3><h4 id="再战斐波那契-1"><a href="#再战斐波那契-1" class="headerlink" title="再战斐波那契"></a>再战斐波那契</h4><p>Problem solving:<br>打表找规律会发现GCD(F(N),F(M))=F(GCD(N,M))</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll f[10000];int main(){    ll n,m;    f[1]=f[2]=1;    for(int i=3;i&lt;=100;i++) f[i]=f[i-1]+f[i-2];    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--){        scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);        printf(&quot;%lld\n&quot;,f[__gcd(n,m)]);    }    return 0;}</code></pre><h4 id="恐怖的怪物-1"><a href="#恐怖的怪物-1" class="headerlink" title="恐怖的怪物"></a>恐怖的怪物</h4><p>Problem solving:<br>对于每个有光源的点暴力的BFS<br>每次BFS 更新各点光源的最大值<br>不透明方块不需要更新</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;const int inf=0x3f3f3f3f;const ll INF=0x3f3f3f3f3f3f3f3f;const int maxn=1000+10;int t,n,m;char mp[maxn][maxn];int vis[maxn][maxn];int d[4][2]={1,0,-1,0,0,1,0,-1};queue&lt;pii&gt;H,F;queue&lt;pii&gt;que;void init(){    while(!que.empty()) que.pop();    while(!H.empty()) H.pop();    while(!F.empty()) F.pop();    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)            vis[i][j]=0;}bool BFS(){    while(!que.empty()){        int x=que.front().first;        int y=que.front().second;        que.pop();        if(vis[x][y]==8) break;        for(int i=0;i&lt;4;i++){            int xx=x+d[i][0];            int yy=y+d[i][1];            if(xx&lt;=0 || xx&gt;n || yy&lt;=0 || yy&gt;m || vis[xx][yy] || mp[xx][yy]!=&#39;0&#39;) continue;            vis[xx][yy]=vis[x][y]-1;            que.push(pii(xx,yy));            while(vis[xx][yy]==14 &amp;&amp; (!H.empty())){                que.push(H.front());                H.pop();            }            while(vis[xx][yy]==12 &amp;&amp; (!F.empty())){                que.push(F.front());                F.pop();            }        }    }    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)            if(vis[i][j]&lt;=7 &amp;&amp; mp[i][j]==&#39;0&#39;) return false;    return true;}int main(){    scanf(&quot;%d&quot;,&amp;t);    while(t--){        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        init();        for(int i=1;i&lt;=n;i++){            scanf(&quot;%s&quot;,mp[i]+1);            for(int j=1;j&lt;=m;j++){                if(mp[i][j]==&#39;Y&#39;) que.push(pii(i,j)),vis[i][j]=15 ;//15                if(mp[i][j]==&#39;H&#39;) H.push(pii(i,j)),vis[i][j]=14;//14                if(mp[i][j]==&#39;F&#39;) F.push(pii(i,j)),vis[i][j]=12;//12            }        }        if(BFS()) printf(&quot;No\n&quot;);        else printf(&quot;Yes\n&quot;);    }    return 0;}</code></pre><h4 id="连连看-1"><a href="#连连看-1" class="headerlink" title="连连看"></a>连连看</h4><p>Problem solving:<br>dfs 瞎胡找即可，保存上一步的位置，上一步的方向，上一<br>步为止的拐角数，然后处理一些复杂的情况可。<br>由于只有三个条直线，只能拐两个弯，dfs 能够剪枝至很低<br>的复杂度，标程大约为0.3s。<br>（由于年代久远，其实出题人也不太记得这个题是不是有什<br>么坑了。</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint mp[200][200];int n,m;int sx,sy;int dir[4][2]={{1,0},{0,1},{0,-1},{-1,0}};//分别对应下，右，左，上int check(int x,int y){    if(x&lt;0 || x&gt;n+1 || y&lt;0 || y&gt;m+1)        return 1;    return 0;}bool judge(int x,int y,int step,int pos){//pos表示上一步方向    if(step&gt;3) return 0;//如果超过了三步，不符合规则    if(mp[x][y]==mp[sx][sy] &amp;&amp; pos!=-1){//如果两个字符相等并且不是同一个（由于下面有方向限制，所以两个值不可能相等）        mp[x][y]=0;//删去配对字符        mp[sx][sy]=0;        return 1;    }    if(mp[x][y]!=0 &amp;&amp; pos!=-1) return 0;//如果不相等并且不是通路，不符合规则    int i,x1,y1;    for(i=0;i&lt;4;i++){        if(i+pos==3) continue;//不能有正相反的方向 (0.下 3.上)   (1.右 2.左)        x1=x+dir[i][0];        y1=y+dir[i][1];        if(check(x1,y1)) continue;//检查是否越界        if(judge(x1,y1,step+(pos==i?0:1),i)){//找到一个就返回            return 1;        }    }    return 0;}int main(){    int t,times,sum;    int i,j;    scanf(&quot;%d&quot;,&amp;t);    while(t--){        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        memset(mp,0,sizeof(mp));        for(i=1;i&lt;=n;i++){            for(j=1;j&lt;=m;j++){                scanf(&quot;%d&quot;,&amp;mp[i][j]);            }        }        sum=0;        times=0;//times表示查找的次数，大于等于n*m相当于查找一遍还没有找到        i=j=1;        while(sum&lt;n*m &amp;&amp; times&lt;n*m){            for(i=1;i&lt;=n;i++){                for(j=1;j&lt;=m;j++){                    times++;                    sx=i,sy=j;                    if(mp[i][j]!=0 &amp;&amp; judge(i,j,0,-1)){                        sum+=2;                        times=0;                    }                }            }        }        if(sum==n*m){            printf(&quot;Yes\n&quot;);        }        else{            printf(&quot;No\n&quot;);        }    }    return 0;}</code></pre><h4 id="Points-in-rectangle-1"><a href="#Points-in-rectangle-1" class="headerlink" title="Points in rectangle"></a>Points in rectangle</h4><p>Problem solving:<br>对于给定的矩形，求出四个边的直线方程<br>对于给定的点判断和四条直线的关系即可O(1) 的判断是否<br>在矩形内<br>统计完直接排序即可</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3+100;struct point{    long long x,y;    bool friend operator&lt;(point a,point b){        if(a.x==b.x) return a.y&gt;b.y;        return a.x&gt;b.x;    }}p[N];long long n,a;bool check(point P){    return -P.x+a&lt;=P.y&amp;&amp;-P.x+2*n-a&gt;=P.y&amp;&amp;P.x-a&lt;=P.y&amp;&amp;P.x+a&gt;=P.y;}int main(){    //freopen(&quot;17.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;17.out&quot;,&quot;w&quot;,stdout);    vector&lt;point&gt; re;    cin&gt;&gt;n&gt;&gt;a;    int m;    cin&gt;&gt;m;    for(int i=1;i&lt;=m;i++){        cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        if(check(p[i])) re.push_back(p[i]);    }    sort(re.begin(),re.end());    if(re.empty()){        cout&lt;&lt;-1&lt;&lt;endl;    }    else{        cout&lt;&lt;re.size()&lt;&lt;endl;        for(auto v:re) cout&lt;&lt;v.x&lt;&lt;&#39; &#39;&lt;&lt;v.y&lt;&lt;endl;    }    return 0;}</code></pre><h4 id="Numbers-of-interval-1"><a href="#Numbers-of-interval-1" class="headerlink" title="Numbers of interval"></a>Numbers of interval</h4><p>Problem solving:<br>构造前缀和数组sum<br>枚举l 然后二分最小的r，那么r 及其右边的都满足条件<br>线性枚举即可, 复杂度O(nlog(n))</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;typedef long long ll;long long a[N],sum[N];int main(){        int n,k;        cin&gt;&gt;n&gt;&gt;k;        for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i];        long long ans=0;        for(int l=1;l&lt;=n;l++){            int id=lower_bound(sum+1,sum+n+1,k+sum[l-1])-sum;            ans+=(n-id+1);        }        cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h4 id="剪纸-1"><a href="#剪纸-1" class="headerlink" title="剪纸"></a>剪纸</h4><p>Problem solving:<br>开一个二维数组构造即可</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+10;int n,m,a;char str[1000+10][1000+10];int main(){    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)){        for(int i=n;i&lt;n*2;i++){            scanf(&quot;%s&quot;,str[i]+m);        }        for(int i=0;i&lt;n;i++){            for(int j=0;j&lt;m;j++){                str[i][j]=str[n*2-1-i][j]=str[i][m*2-1-j]=str[n*2-1-i][m*2-1-j];            }        }        for(int i=0;i&lt;n*2;i++){            for(int j=0;j&lt;m*2;j++){                printf(&quot;%c&quot;,str[i][j]);            }            printf(&quot;\n&quot;);        }    }    return 0;}</code></pre><h4 id="Fake-hpuoj-predictor-1"><a href="#Fake-hpuoj-predictor-1" class="headerlink" title="Fake hpuoj predictor"></a>Fake hpuoj predictor</h4><p>Problem solving:<br>暴力算出codancer 实际的得分和期望得分<br>根据他当前的rating 使用不同的K 更新rating<br>每次更新完rating 向上取整</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+10;int n,m,a;struct node{    char name[30];    double rating;}p[maxn];double cal(double rating){    if(rating&lt;1350) return 15.0;    else if(rating&lt;1500) return 20.0;    else if(rating&lt;1600) return 25.0;    else if(rating&lt;1700) return 30.0;    else if(rating&lt;1800) return 35.0;    else return 50.0;}double Rating(double rating){    double k=cal(rating);    double ea=0,sa=0;    for(int i=0;i&lt;n;i++){        if(strcmp(p[i].name,&quot;codancer&quot;)==0) continue;        ea+=1.0/(1.0+pow(10,(p[i].rating-rating)/400.0));    }    for(int i=0;i&lt;n;i++){        if(strcmp(p[i].name,&quot;codancer&quot;)==0){            sa=n-1-i;            break;        }    }    double now_rating=rating+k*(sa-ea);//    return now_rating;    return ceil(now_rating);}int main(){    int m;    scanf(&quot;%d&quot;,&amp;m);    double codancerNB_rating=0.0;    while(m--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=0;i&lt;n;i++){            scanf(&quot;%s&quot;,p[i].name);            if(strcmp(p[i].name,&quot;codancer&quot;)==0){                p[i].rating=codancerNB_rating;                continue;            }            scanf(&quot;%lf&quot;,&amp;p[i].rating);        }        codancerNB_rating=Rating(codancerNB_rating);    }    printf(&quot;%.0lf\n&quot;,ceil(codancerNB_rating));    return 0;}</code></pre><h4 id="花花与三猫Catlive-1"><a href="#花花与三猫Catlive-1" class="headerlink" title="花花与三猫Catlive"></a>花花与三猫Catlive</h4><p>Problem solving:<br>每次每只猫能够向前走一步的概率为2/M<br>答案即为L/（2/m）= LM/2</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;const int MOD = 1e9 + 7;int qpow(int a, int b, int mod){    int res = 1;    while(b){        if(b&amp;1) res = 1LL * res * a % mod;        a = 1LL * a * a % mod;        b &gt;&gt;= 1;    }    return res;}int inv(int p, int mod){    return qpow(p, mod - 2, mod);}int main(){    int T;    scanf(&quot;%d&quot;, &amp;T);    int L, M;    while(T--){        scanf(&quot;%d %d&quot;, &amp;L, &amp;M);        printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD);    }}</code></pre><h4 id="Same-String-1"><a href="#Same-String-1" class="headerlink" title="Same String"></a>Same String</h4><p>Problem solving:<br>解法一: 对于m 组关系建好图，每次判断某个字母可否到达<br>另一个字母<br>解法二: 利用Warshall 可以O(263) 求出传递闭包然后O(1<br>的判断可达性</p><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;typedef long long ll;bool f[26][26];int main(){    // for(int it=1;it&lt;=40;it++){    //     memset(f,0,sizeof(f));    //     Create_InFiles(it);    //     Create_OutFiles(it);        int n,m;        string s1,s2;        cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;        cin&gt;&gt;m;        char u,v;        for(int i=1;i&lt;=m;i++){            cin&gt;&gt;u&gt;&gt;v;            f[u-&#39;a&#39;][v-&#39;a&#39;]=1;        }        for(int j=0;j&lt;26;j++){            for(int i=0;i&lt;26;i++){                for(int k=0;k&lt;26;k++){                    f[i][k]|=(f[i][j]&amp;f[j][k]);                }            }        }        bool check=0;        for(int i=0;i&lt;n;i++){            if(s1[i]!=s2[i]){                if(f[s1[i]-&#39;a&#39;][s2[i]-&#39;a&#39;]==0){                    check=1;break;                }            }        }        if(check){            puts(&quot;NO&quot;);        }        else puts(&quot;YES&quot;);    // }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BFS </tag>
            
            <tag> greedy </tag>
            
            <tag> gcd </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> inverse-modulo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 10(河南理工大学暑期第十天)</title>
      <link href="/2019/07/26/10/"/>
      <url>/2019/07/26/10/</url>
      
        <content type="html"><![CDATA[<h3 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h3><p>Description:<br>Background<br>Mr Somurolov, fabulous chess-gamer indeed, asserts that no one else but him can move knights from one position to another so fast. Can you beat him?<br>The Problem<br>Your task is to write a program to calculate the minimum number of moves needed for a knight to reach one point from another, so that you have the chance to be faster than Somurolov.<br>For people not familiar with chess, the possible knight moves are shown in Figure 1.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094930.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094930.webp" class="img-shadow img-margin"></center></a><p>Input</p><blockquote><p>The input begins with the number n of scenarios on a single line by itself.<br>Next follow n scenarios. Each scenario consists of three lines containing integer numbers. The first line specifies the length l of a side of the chess board (4 &lt;= l &lt;= 300). The entire board has size l <em> l. The second and third line contain pair of integers {0, ..., l-1}\</em>{0, ..., l-1} specifying the starting and ending position of the knight on the board. The integers are separated by a single blank. You can assume that the positions are valid positions on the chess board of that scenario.</p></blockquote><p>Output</p><blockquote><p>For each scenario of the input you have to calculate the minimal amount of knight moves which are necessary to move from the starting point to the ending point. If starting point and ending point are equal,distance is zero. The distance must be written on a single line.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>8<br>0 0<br>7 0<br>100<br>0 0<br>30 50<br>10<br>1 1<br>1 1</p></blockquote><p>Sample Output</p><blockquote><p>5<br>28<br>0</p></blockquote><p>Problem solving:<br>简单的BFS模板题，8个方向查找即可。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;struct node{    int x,y;};const int maxn=305;int vis[maxn][maxn];int step[maxn][maxn];int n,m,sx,sy,ex,ey;int d[8][2]={2,1,1,2,-1,2,-2,1,-2,-1,-1,-2,1,-2,2,-1};void bfs(){    queue&lt;node&gt; q;    node now,mid;    vis[sx][sy]=1;    now.x=sx,now.y=sy;    q.push(now);    while(!q.empty())    {        mid=q.front();        q.pop();        for(int i = 0 ;i&lt;8;i++)        {            now.x=mid.x+d[i][0];            now.y=mid.y+d[i][1];            if(now.x&lt;0||now.x&gt;=m||now.y&lt;0||now.y&gt;=m||vis[now.x][now.y])    continue;            vis[now.x][now.y]=1;            step[now.x][now.y]=step[mid.x][mid.y]+1;            q.push(now);        }    }}int main(){    cin&gt;&gt;n;    while(n--)    {        memset(vis,0,sizeof(vis));        memset(step,0,sizeof(step));        cin&gt;&gt;m&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey;        bfs();        cout&lt;&lt;step[ex][ey]&lt;&lt;endl;    }}</code></pre><h3 id="变形课"><a href="#变形课" class="headerlink" title="变形课"></a>变形课</h3><p>Description:<br>呃......变形课上Harry碰到了一点小麻烦,因为他并不像Hermione那样能够记住所有的咒语而随意的将一个棒球变成刺猬什么的,但是他发现了变形咒语的一个统一规律:如果咒语是以a开头b结尾的一个单词,那么它的作用就恰好是使A物体变成B物体.<br>Harry已经将他所会的所有咒语都列成了一个表,他想让你帮忙计算一下他是否能完成老师的作业,将一个B(ball)变成一个M(Mouse),你知道,如果他自己不能完成的话,他就只好向Hermione请教,并且被迫听一大堆好好学习的道理.<br>Input</p><blockquote><p>测试数据有多组。每组有多行，每行一个单词,仅包括小写字母,是Harry所会的所有咒语.数字0表示一组输入结束.</p></blockquote><p>Output</p><blockquote><p>如果Harry可以完成他的作业,就输出&quot;Yes.&quot;,否则就输出&quot;No.&quot;(不要忽略了句号)</p></blockquote><p>Sample Input</p><blockquote><p>so<br>soon<br>river<br>goes<br>them<br>got<br>moon<br>begin<br>big<br>0</p></blockquote><p>Sample Output</p><blockquote><p>Yes.</p></blockquote><p>Harry 可以念这个咒语:&quot;big-got-them&quot;.</p><p>Problem solving:<br>这道题我的想法是用邻接表存图，把输入的每一个单词的首字母与最后一个字母当成两个节点，并且是有向边，然后bfs以&#39;b&#39;为起点查找如果能找到&#39;m&#39;与它相连，就输出Yes，反之输出&#39;No&#39;.<br>这道题还有一个很难受的地方就是输入、、、多组套多组，里面的多组还有结束条件。不过写完这道题也算是学会了，这样写就行。</p><pre><code>while(cin&gt;&gt;s){    while(s!=&#39;0&#39;)    {        cin&gt;&gt;s;    }}</code></pre><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int ma[100][100],vis[100];bool bfs(int x){    queue&lt;int&gt; q;    q.push(x);    vis[x]=1;    while(!q.empty())    {        x=q.front();        if(x==&#39;m&#39;-&#39;0&#39;)    return 1;        q.pop();        for(int i=&#39;a&#39;-&#39;0&#39;;i&lt;=&#39;z&#39;-&#39;0&#39;;i++)        {            if(ma[x][i]==1&amp;&amp;!vis[i])            {                vis[i]=1;//                cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;//                cout&lt;&lt;ma[x][i]&lt;&lt;&quot;?&quot;&lt;&lt;ma[i][x]&lt;&lt;endl;                q.push(i);            }        }    }    return 0;}int main(){    string s;    while(cin&gt;&gt;s)    {        memset(ma,0,sizeof(ma));        memset(vis,0,sizeof(vis));        while(s!=&quot;0&quot;)        {            char sx=s[0],ex=s[s.size()-1];//                cout&lt;&lt;sx-&#39;0&#39;&lt;&lt;&quot; &quot;&lt;&lt;ex-&#39;0&#39;&lt;&lt;endl;            ma[sx-&#39;0&#39;][ex-&#39;0&#39;]=1;            cin&gt;&gt;s;        }        if(bfs(&#39;b&#39;-&#39;0&#39;))    puts(&quot;Yes.&quot;);        else puts(&quot;No.&quot;);    }}</code></pre><h3 id="Pet"><a href="#Pet" class="headerlink" title="Pet"></a>Pet</h3><p>Description:<br>一天早上小明醒来时发现他的宠物仓鼠不见了。 他在房间寻找但是没找到仓鼠。 他想用奶酪诱饵去找回仓鼠。 他把奶酪诱饵放在房间并且等待了好几天。 但是可怜的小明除了老鼠和蟑螂没见到任何东西。 他找到学校的地图发现地图上没有环路，并且学校里的每个站点都可以从他的房间到达。 奶酪诱饵的手册提到在距离D之内宠物必定会被吸引回来. 你的任务是帮助小明从给定的地图中有多少可能的站点是仓鼠的藏身处. 假定仓鼠一直藏在学校的某个站点并且两个相邻站点间的距离都是1个单位。<br>Input</p><blockquote><p>输入包含多组数据。 第一行一个整数T (0&lt;T&lt;=10), 表示测试数据的组数。 每组数据, 第一行包含两个整数 N (0&lt;N&lt;=100000) 和 D(0&lt;D&lt;N). N 是学校里的站点数， D 是诱饵的影响距离。 下面 N-1行为地图描述, 每行一对 x 和 y(0&lt;=x,y&lt;N), 用一个空格隔开, 表示x和y两个站点是相邻的。小明的房间用0表示。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，输出可能找到仓鼠的站点数。<br>Sample Input<br>1<br>10 2<br>0 1<br>0 2<br>0 3<br>1 4<br>1 5<br>2 6<br>3 7<br>4 8<br>6 9</p></blockquote><p>Sample Output</p><blockquote><p>2</p></blockquote><p>Problem solving:<br>题意还挺好理解的，就是问你一个图距离顶点距离大于某一值得点有多少个。构建一个图，因为现在已经知道了0是顶点，直接从0开始bfs查找，找出每个点距离0的最远距离，与给的定值进行比较即可。<br>注意多组输入每次需要初始化（我因为这个WA了一发。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn=1e5+10;vector&lt;int&gt; v[maxn];int dis[maxn],vis[maxn],ans;using namespace std;int n,d,t,x,y;void bfs(int x){    queue&lt;int&gt; q;    q.push(x);    vis[x]=1;dis[x]=0;    while(!q.empty())    {        x=q.front();        q.pop();        for(int i=0;i&lt;v[x].size();i++)        {            if(v[x][i]&amp;&amp;!vis[v[x][i]])            {                q.push(v[x][i]);                vis[v[x][i]]=1;                dis[v[x][i]]=dis[x]+1;            }        }    }}int main(){    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(vis,0,sizeof(vis));        memset(dis,0,sizeof(dis));        ans=0;        scanf(&quot;%d %d&quot;,&amp;n,&amp;d);        for(int i=0;i&lt;n;i++)            v[i].clear();        for(int i=1;i&lt;n;i++)        {            scanf(&quot;%d %d&quot;,&amp;x,&amp;y);            v[x].push_back(y);            v[y].push_back(x);        }        bfs(0);        for(int i=0;i&lt;n;i++)        {            if(dis[i]&gt;d)    ans++;        }        printf(&quot;%d\n&quot;,ans);    }}</code></pre><h3 id="蜘蛛牌"><a href="#蜘蛛牌" class="headerlink" title="蜘蛛牌"></a>蜘蛛牌</h3><p>Description:<br>蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。<br>Input</p><blockquote><p>第一个输入数据是T，表示数据的组数。<br>每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。</p></blockquote><p>Output</p><blockquote><p>对应每组数据输出最小移动距离。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>1 2 3 4 5 6 7 8 9 10</p></blockquote><p>Sample Output</p><blockquote><p>9</p></blockquote><p>Problem solving:<br>暂无（毫无思路题，据说是dfs）</p><p>Code:</p><pre><code>/** *　　　　　　　　┏┓　　 　┏┓ * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　 　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　... 　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛ */// warm heart, wagging tail,and a smile just for you!////                            _ooOoo_//                           o8888888o//                           88&quot; . &quot;88//                           (| -_- |)//                           O\  =  /O//                        ____/`---&#39;\____//                      .&#39;  \|     |//  `.//                     /  \|||  :  |||//  \//                    /  _||||| -:- |||||-  \//                    |   | \\  -  /// |   |//                    | \_|  &#39;&#39;\---/&#39;&#39;  |   |//                    \  .-\__  `-`  ___/-. ///                  ___`. .&#39;  /--.--\  `. . __//               .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |//              \  \ `-.   \_ __\ /__ _/   .-` /  ///         ======`-.____`-.___\_____/___.-`____.-&#39;======//                            `=---=&#39;//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//</code></pre><h3 id="逃离迷宫"><a href="#逃离迷宫" class="headerlink" title="逃离迷宫"></a>逃离迷宫</h3><p>Description:<br>给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？<br>Input</p><blockquote><p>第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，<br>　　第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符&#39;.&#39;表示该位置为空地，字符&#39;*&#39;表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x 1, y 1, x 2, y 2 (1 ≤ k ≤ 10, 1 ≤ x 1, x 2 ≤ n, 1 ≤ y 1, y 2 ≤ m),其中k表示gloria最多能转的弯数，(x 1, y 1), (x 2, y 2)表示两个位置，其中x 1，x 2对应列，y 1, y 2对应行。</p></blockquote><p>Output</p><blockquote><p>　　每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>5 5<br>...<strong><br>*.</strong>.<br>.....<br>.....<br><em>....<br>1 1 1 1 3<br>5 5<br>...**</em>.<em>*.<br>.....<br>.....</em>....<br>2 1 1 1 3</p></blockquote><p>Sample Output</p><blockquote><p>no<br>yes</p></blockquote><p>Problem solving:<br>这也是一道查找的题，给了你起点和终点和最大拐弯次数，问你能不能从起点走到终点。我选择了bfs，其实是一道挺简单的题，难点就是如何得到当前转弯的次数。我一开始想着用x，y坐标的差值来表示，但是又麻烦又不好理解。然后我在网上看到了一种写法。就是在bfs的过程中，每选择了一个方向就按照这个方向一直走下去直到越界或者到了走不了的点。这一步描述的如果你不是很懂，可以参考一下下面代码我加上的注释。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,sx,sy,ex,ey,k;char s[105][105];int vis[105][105];struct node{    int x,y,flag;//flag就是用来存当前的拐弯次数};int d[4][2]={1,0,0,1,0,-1,-1,0};bool bfs(){    queue&lt;node&gt; q;    node now,mid;    now.x=sx,now.y=sy,now.flag=-1;//初始的转弯次数设为-1是因为第一次走是不算入转弯次数的    vis[sx][sy]=1;    q.push(now);    while(!q.empty())    {//        cout&lt;&lt;&quot;?&quot;;        now=q.front();        q.pop();        if(now.flag&gt;=k)    continue;//如果此时转弯次数已经大于k了，就没有走下去的必要了。这一点在这种写法中很重要        for(int i=0;i&lt;4;i++)        {            mid.x=now.x+d[i][0];            mid.y=now.y+d[i][1];            mid.flag=now.flag+1;//此时你选择了一个方向            while(1)//沿着这个方向一直走下去            {                if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||s[mid.x][mid.y]==&#39;*&#39;)    break;//如果越界了或者不能走了，就说明沿着这个方向一直走走不下去了，break就行                if(mid.x==ex&amp;&amp;mid.y==ey)    return 1;//如果当前走到的点与终点相等，就说明可以走到，返回true                if(vis[mid.x][mid.y]==0)                {                    vis[mid.x][mid.y]=1;                    q.push(mid);                }                mid.x+=d[i][0];//沿着这个方向更新到下一个走到的点的x，y坐标                mid.y+=d[i][1];            }        }    }    return 0;}int main(){    cin&gt;&gt;t;    while(t--)    {        memset(vis,0,sizeof(vis));        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;n;i++)            cin&gt;&gt;s[i];        cin&gt;&gt;k&gt;&gt;sy&gt;&gt;sx&gt;&gt;ey&gt;&gt;ex;//这有个坑，它先输入的是y的值        sx--,sy--,ex--,ey--;        if(bfs()) puts(&quot;yes&quot;);        else    puts(&quot;no&quot;);    }}</code></pre><h3 id="Kaitou-Kid-The-Phantom-Thief-2"><a href="#Kaitou-Kid-The-Phantom-Thief-2" class="headerlink" title="Kaitou Kid - The Phantom Thief (2)"></a>Kaitou Kid - The Phantom Thief (2)</h3><p>Description:<br>破解字迷之后，你得知Kid将会在展览开始后T分钟内盗取至少一颗宝石，并离开展馆。整个展馆呈矩形分布，划分为N*M个区域，有唯一的入口和出口（不能从出口进入，同样不能从入口出去）。由某个区域可直接移动至相邻四个区域中的一个，且最快需要一分钟。假设Kid进入放有宝石的区域即可盗取宝石，无需耗时。问至少要封锁几个区域（可以封锁放有宝石的区域，但不能封锁入口和出口）才能保证Kid无法完成任务。<br>Input</p><blockquote><p>输入的第一行有一个整数C，代表有C组测试数据。每组测试数据的第一行有三个整数N，M，T(2&lt;=N,M&lt;=8,T&gt;0)。接下来N行M列为展馆布置图，其中包括：<br>&#39;S&#39;：入口<br>&#39;E&#39;：出口<br>&#39;J&#39;：放有宝石的区域，至少出现一次<br>&#39;.&#39;：空白区域<br>&#39;#&#39;：墙</p></blockquote><p>Output</p><blockquote><p>对每组测试数据，输出至少要封锁的区域数。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>5 5 5<br>SJJJJ<br>..##J<br>.JJJJ<br>.J...<br>EJ...<br>5 5 6<br>SJJJJ<br>..##J<br>.JJJJ<br>.J...<br>EJ...</p></blockquote><p>Sample Output</p><blockquote><p>0<br>2</p></blockquote><p>Problem solving:<br>暂无（据说是bfs+dfs）</p><p>Code:</p><pre><code>/** *　　　　　　　　┏┓　　 　┏┓ * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　 　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　... 　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛ */// warm heart, wagging tail,and a smile just for you!////                            _ooOoo_//                           o8888888o//                           88&quot; . &quot;88//                           (| -_- |)//                           O\  =  /O//                        ____/`---&#39;\____//                      .&#39;  \|     |//  `.//                     /  \|||  :  |||//  \//                    /  _||||| -:- |||||-  \//                    |   | \\  -  /// |   |//                    | \_|  &#39;&#39;\---/&#39;&#39;  |   |//                    \  .-\__  `-`  ___/-. ///                  ___`. .&#39;  /--.--\  `. . __//               .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |//              \  \ `-.   \_ __\ /__ _/   .-` /  ///         ======`-.____`-.___\_____/___.-`____.-&#39;======//                            `=---=&#39;//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//</code></pre><h3 id="A计划"><a href="#A计划" class="headerlink" title="A计划"></a>A计划</h3><p>Description:<br>可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。<br>现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。<br>Input</p><blockquote><p>输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小N<em>M（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前N</em>M表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。</p></blockquote><p>Output</p><blockquote><p>如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5 5 14<br>S<em>#</em>.<br>.#...<br>.....<br><em>**</em>.<br>...#.<br>..*.P</p><h1 id><a href="#" class="headerlink" title=".*.."></a>.*..</h1><p><em>**..<br>...</em>.<br>*.#..</p></blockquote><p>Sample Output</p><blockquote><p>YES</p></blockquote><p>Problem solving:<br>哇，这道题坑的一批。最后玄学过题<br>就是个三维的bfs，而且给定了只有两层。<br>因为遇到传送门进行传送的时候是不需要耗费时间的，所以传送门那需要特殊处理一下（可以想一下，如果传送门传送过去的位置还是传送门，就成死循环了。如果传送门传送过去是墙，也可以直接看做这个传送门是一堵墙）</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int c,n,m,t;struct node{    int x,y,z,step;};int d[4][2]={1,0,0,1,0,-1,-1,0},vis[2][15][15],flag;char s[2][15][15];node now,mid,meizi;void bfs(){    queue&lt;node&gt; q;    q.push(now);    vis[now.x][now.y][now.z]=1;    while(!q.empty())    {        mid=q.front();        q.pop();        if(s[mid.x][mid.y][mid.z]==&#39;P&#39;&amp;&amp;mid.step&lt;=t)        {            flag=1;            return ;        }        for(int i=0;i&lt;4;i++)        {            meizi=mid;            meizi.y+=d[i][0];            meizi.z+=d[i][1];            meizi.step+=1;            if(meizi.step&gt;t||meizi.y&lt;0||meizi.y&gt;=n||meizi.z&lt;0||meizi.z&gt;=m||vis[meizi.x][meizi.y][meizi.z]||s[meizi.x][meizi.y][meizi.z]==&#39;*&#39;)            continue;            vis[meizi.x][meizi.y][meizi.z]=1;            if(s[meizi.x][meizi.y][meizi.z]==&#39;#&#39;&amp;&amp;s[(meizi.x+1)%2][meizi.y][meizi.z]!=&#39;*&#39;&amp;&amp;!vis[(meizi.x+1)%2][meizi.y][meizi.z])            meizi.x=(meizi.x+1)%2;            q.push(meizi);        }    }}int main(){    cin&gt;&gt;c;    while(c--)    {        memset(vis,0,sizeof(vis));        cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;        for(int i=0;i&lt;2;i++)        {            for(int j=0;j&lt;n;j++)            {                for(int k=0;k&lt;m;k++)                {                    cin&gt;&gt;s[i][j][k];                    if(s[i][j][k]==&#39;S&#39;)                    {                        now.x=i,now.y=j,now.z=k,now.step=0;                    }                }            }        }        for(int j=0;j&lt;n;j++)        {            for(int k=0;k&lt;m;k++)            {                if(s[0][j][k]==&#39;#&#39;&amp;&amp;s[1][j][k]==&#39;*&#39;)                {                    s[0][j][k]=s[1][j][k]=&#39;*&#39;;                }                if(s[0][j][k]==&#39;*&#39;&amp;&amp;s[1][j][k]==&#39;#&#39;)                {                    s[0][j][k]=s[1][j][k]=&#39;*&#39;;                }                if(s[0][j][k]==&#39;#&#39;&amp;&amp;s[1][j][k]==&#39;#&#39;)                {                    s[0][j][k]=s[1][j][k]=&#39;*&#39;;                }            }        }        flag=0;        bfs();        if(flag)    puts(&quot;YES&quot;);        else    puts(&quot;NO&quot;);    }}</code></pre><h3 id="Nightmare"><a href="#Nightmare" class="headerlink" title="Nightmare"></a>Nightmare</h3><p>Description:<br>Ignatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the exploding time to 6 minutes.</p><p>Given the layout of the labyrinth and Ignatius&#39; start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1.</p><p>Here are some rules:</p><ol><li>We can assume the labyrinth is a 2 array.</li><li>Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too.</li><li>If Ignatius get to the exit when the exploding time turns to 0, he can&#39;t get out of the labyrinth.</li><li>If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can&#39;t use the equipment to reset the bomb.</li><li>A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish.</li><li>The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6.<br>Input<blockquote><p>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case starts with two integers N and M(1&lt;=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.<br>There are five integers which indicate the different type of area in the labyrinth:<br>0: The area is a wall, Ignatius should not walk on it.<br>1: The area contains nothing, Ignatius can walk on it.<br>2: Ignatius&#39; start position, Ignatius starts his escape from this position.<br>3: The exit of the labyrinth, Ignatius&#39; target position.<br>4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas.</p></blockquote></li></ol><p>Output</p><blockquote><p>For each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>3 3<br>2 1 1<br>1 1 0<br>1 1 3<br>4 8<br>2 1 1 0 1 1 1 0<br>1 0 4 1 1 0 4 1<br>1 0 0 0 0 0 0 1<br>1 1 1 4 1 1 1 3<br>5 8<br>1 2 1 1 1 1 1 4<br>1 0 0 0 1 0 0 1<br>1 4 1 0 1 1 0 1<br>1 0 0 0 0 3 0 1<br>1 1 4 1 1 1 1 1</p></blockquote><p>Sample Output</p><blockquote><p>4<br>-1<br>13</p></blockquote><p>Problem solving:<br>这道题我是用bfs来做的，跟一种题很像，就是给你规定一个时间看能否走出迷宫之类的问题。<br>但是这道题有一种新的规则，就是如果走到某些特殊的点。时间会更新一次。<br>0是墙，不可以走<br>1是路<br>2是起点<br>3是终点<br>4是可以重置时间的点<br>刚开始看到这里的时候我想着肯定要经过很负责的处理。但是后来发现其实我们只需要知道这两点就可以了。并且题目中规定如果时间为0就不能继续走下去了。</p><ol><li>每个点都是可以重复访问的</li><li>可以刷新时间的点我们只走一次<br>第一点到不需要怎么理解，就是第二点我们该如何理解呢？<br>如果同一个位置的炸弹你第二次走到了它上面就说明此时已经不是最优解了。所以每个刷新时间的点我们每次走完之后就把它存为0——即墙。</li></ol><p>关于第二点的理解还有另一种解释方式:<br>上同一位置是bomb离explode的时间长短来标记。简言之，如果第二次踏上一个位置，那么找出路已用的时间肯定是增加了，那为啥还要走上这条路呢？唯一的追求就是bomb离爆炸的时间增大了。所以可以利用这个条件来标记了。每次在入队前检查下爆炸时间是否比上次在同一位置的大，若是，则入队；反之，入队无意义了。从以上的分析中可以引出另一思路，也就是只要进入位置4，那么bomb就会延时到6分钟，最大的延时时间。换句话说，下次再进入该4位置，也不会获得更大的延时时间了。所以，只要访问过位置4了，就可以直接标记为0位置，表明下次不可在访问。详见代码二。<br>转载于：<a href="https://blog.sina.com.cn/s/blog_7f09a7160101sym7.html" target="_blank" rel="noopener">clouddyx</a></p><p>其实想一下也确实是，假设我们现在走到了一个可以重置时间的点，如果下次在走到这，是不是就一直循环下去了，所以按照这个理解也可以。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[10][10];struct node{    int x,y,step,time;};int d[4][2]={1,0,0,1,0,-1,-1,0};int ans;node now,mid;void bfs(){    queue&lt;node&gt; q;    q.push(now);    while(!q.empty())    {//        cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;        now=q.front();        q.pop();        if(now.time&lt;=0)    continue;        if(a[now.x][now.y]==3)        {            ans=now.step;            return ;        }        for(int i=0;i&lt;4;i++)        {            mid.x=now.x+d[i][0];            mid.y=now.y+d[i][1];            mid.step=now.step+1;            mid.time=now.time-1;            if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||mid.time&lt;=0||a[mid.x][mid.y]==0)    continue;            if(a[mid.x][mid.y]==4)            {                a[mid.x][mid.y]=0;                mid.time=6;            }            q.push(mid);        }    }}int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        ans=-1;        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;m;j++)            {                cin&gt;&gt;a[i][j];                if(a[i][j]==2)                {                    now.x=i,now.y=j,now.step=0,now.time=6;                }            }        }        bfs();        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="胜利大逃亡"><a href="#胜利大逃亡" class="headerlink" title="胜利大逃亡"></a>胜利大逃亡</h3><p>Description:<br>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.</p><p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.<br><a href="https://i..net/2019/07/26/5d3af3fd5f8c290859.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://i..net/2019/07/26/5d3af3fd5f8c290859.webp" class="img-shadow img-margin"></center></a><br>Input</p><blockquote><p>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)<br>特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交.</p></blockquote><p>Output</p><blockquote><p>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>3 3 4 20<br>0 1 1 1<br>0 0 1 1<br>0 1 1 1<br>1 1 1 1<br>1 0 0 1<br>0 1 1 1<br>0 0 0 0<br>0 1 1 0<br>0 1 1 0</p></blockquote><p>Sample Output</p><blockquote><p>11</p></blockquote><p>Problem solving:<br>简单的三维bfs，直接写就行了，六个方向。注意多组输入需要初始化，我又是这WA了一次。。。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a,b,c,k;int s[51][51][51];int vis[51][51][51];struct node{    int x,y,z,step;};node mz,mid,ne;int d[6][3]={1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1,0,0,-1},ans;void bfs(){    mz.x=mz.y=mz.z=mz.step=0;    queue&lt;node&gt; q;    q.push(mz);    vis[0][0][0]=1;    while(!q.empty())    {        mid=q.front();        q.pop();        if(mid.step&gt;k)        {            return  ;        }        if(mid.x==a-1&amp;&amp;mid.y==b-1&amp;&amp;mid.z==c-1&amp;&amp;mid.step&lt;=k)        {            ans=mid.step;            return ;        }        for(int i=0;i&lt;6;i++)        {            ne.x=mid.x+d[i][0];            ne.y=mid.y+d[i][1];            ne.z=mid.z+d[i][2];            if(ne.x&lt;0||ne.x&gt;=a||ne.y&lt;0||ne.y&gt;=b||ne.z&lt;0||ne.z&gt;=c||vis[ne.x][ne.y][ne.z]||s[ne.x][ne.y][ne.z]==1)                continue;            ne.step=mid.step+1;            vis[ne.x][ne.y][ne.z]=1;            q.push(ne);        }    }}int main(){    int t;scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(vis,0,sizeof(vis));        ans=-1;        scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;k);        for(int i=0;i&lt;a;i++)        {            for(int j=0;j&lt;b;j++)            {                for(int k=0;k&lt;c;k++)                {                    scanf(&quot;%1d&quot;,&amp;s[i][j][k]);                }            }        }        bfs();        printf(&quot;%d\n&quot;,ans);    }}</code></pre><h3 id="A-strange-lift"><a href="#A-strange-lift" class="headerlink" title="A strange lift"></a>A strange lift</h3><p>Description:<br>计院有一个bug电梯，可能是hyk造的，很多bug，电梯只有两个按钮，“上”和“下”，电梯每层都可以停，每层都有一个数字Ki（0&lt;=Ki&lt;=n），当你在一层楼，你按“上”键会到1+K1层，你按“下”键会到1-K1层。当然，电梯不能升到N以上，也不能降到1以下。例如，有一个五层楼的建筑，k1=3，k2=3，k3=1，k4=2，k5=5。从第一层开始，你可以按“上”按钮，然后你就上到第四层，如果在第一层按“下”按钮，电梯就不能做到，因为你知道它不能下到负二层。负二楼不存在。<br>那么，你想从A层到B层，你至少要按多少次“上”或“下”按钮呢？</p><p>Input</p><blockquote><p>输入由几个测试用例组成，每个测试用例包含两行。<br>第一行包含三个整数n，a，b（1&lt;=n，a，b&lt;=200），如上文所述，第二行包含n个整数k1，k2，….kn。<br>单个0表示输入的结束。</p></blockquote><p>Output</p><blockquote><p>对于每种情况下的输入输出一个整数，当你在A层，你必须按下按钮的最少次数，你想去B层。如果你不能到达B层，打印“-1”。</p></blockquote><p>Sample Input</p><blockquote><p>5 1 5<br>3 3 1 2 5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>3</p></blockquote><p>Problem solving:<br>也是一道存图的题。每次存的时候注意判断第二个点与0跟n的大小关系。也是有向图。<br>注意初始化！！！又是这样WA了一次。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,a,b,meizi;int s[250][250],ans;int vis[250],step[250];void bfs(int x){    queue&lt;int&gt; q;    q.push(x);    vis[x]=1,step[x]=0;    while(!q.empty())    {        int mid=q.front();        q.pop();//        cout&lt;&lt;mid&lt;&lt;endl;        if(mid==b)        {//            cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;            ans=step[mid];            return ;        }        for(int i=1;i&lt;=n;i++)        {//            cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[x][i]&lt;&lt;endl;            if(s[mid][i]&amp;&amp;vis[i]==0)            {                q.push(i);                vis[i]=1;                step[i]=step[mid]+1;            }        }    }}int main(){    while(cin&gt;&gt;n&amp;&amp;n)    {        memset(vis,0,sizeof(vis));        memset(step,0,sizeof(step));        memset(s,0,sizeof(s));        ans=-1;        cin&gt;&gt;a&gt;&gt;b;        for(int i=1;i&lt;=n;i++)        {            cin&gt;&gt;meizi;            if(i+meizi&gt;=1&amp;&amp;i+meizi&lt;=n)    s[i][meizi+i]=1;            if(i-meizi&gt;=1&amp;&amp;i-meizi&lt;=n)  s[i][i-meizi]=1;        }        bfs(a);        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
            <tag> HDU </tag>
            
            <tag> Queue </tag>
            
            <tag> STL </tag>
            
            <tag> poj </tag>
            
            <tag> 邻接表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 9（河南理工大学暑期第九天）</title>
      <link href="/2019/07/25/9/"/>
      <url>/2019/07/25/9/</url>
      
        <content type="html"><![CDATA[<p>关于今天刷题遇到的主要的知识，请去这里查看。</p><center><font color="red">------------------------------------->[戳这里](https://cndrew.cn/blog/2019/07/25/mapsave)<-------------------------------------< font></-------------------------------------<></font></center><h3 id="Labyrinth"><a href="#Labyrinth" class="headerlink" title="Labyrinth"></a>Labyrinth</h3><p>Description:<br>The northern part of the Pyramid contains a very large and complicated labyrinth. The labyrinth is divided into square blocks, each of them either filled by rock, or free. There is also a little hook on the floor in the center of every free block. The ACM have found that two of the hooks must be connected by a rope that runs through the hooks in every block on the path between the connected ones. When the rope is fastened, a secret door opens. The problem is that we do not know which hooks to connect. That means also that the neccessary length of the rope is unknown. Your task is to determine the maximum length of the rope we could need for a given labyrinth.<br>Input</p><blockquote><p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers C and R (3 &lt;= C,R &lt;= 1000) indicating the number of columns and rows. Then exactly R lines follow, each containing C characters. These characters specify the labyrinth. Each of them is either a hash mark (#) or a period (.). Hash marks represent rocks, periods are free blocks. It is possible to walk between neighbouring blocks only, where neighbouring blocks are blocks sharing a common side. We cannot walk diagonally and we cannot step out of the labyrinth.</p><p>The labyrinth is designed in such a way that there is exactly one path between any two free blocks. Consequently, if we find the proper hooks to connect, it is easy to find the right path connecting them.<br>Output<br>Your program must print exactly one line of output for each test case. The line must contain the sentence &quot;Maximum rope length is X.&quot; where Xis the length of the longest path between any two free blocks, measured in blocks.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3 3</p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><h1 id="-1"><a href="#-1" class="headerlink" title="."></a>.</h1><h2 id="-2"><a href="#-2" class="headerlink" title="#"></a>#</h2><p>7 6</p><h6 id="-3"><a href="#-3" class="headerlink" title="#"></a>#</h6><h1 id="-4"><a href="#-4" class="headerlink" title=".#."></a>.#.</h1><h1 id="-5"><a href="#-5" class="headerlink" title=".#."></a>.#.</h1><h1 id="-6"><a href="#-6" class="headerlink" title=".#.#."></a>.#.#.</h1><h1 id="-7"><a href="#-7" class="headerlink" title="....."></a>.....</h1><h6 id="-8"><a href="#-8" class="headerlink" title="#"></a>#</h6></blockquote><p>Sample Output</p><blockquote><p>Maximum rope length is 0.<br>Maximum rope length is 8.</p></blockquote><p>Hint</p><blockquote><p>Huge input, scanf is recommended.<br>If you use recursion, maybe stack overflow. and now C++/c &#39;s stack size is larger than G++/gcc</p></blockquote><p>Problem solving:<br>这一题是最简单的求树的直径的题，bfs两次即可，注意虽然第一次开始查找的位置可以是任意的，但是第二次开始的位置应该是第一次查找到最后的那个位置，还有就是两个bfs之间不要忘了memset。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int dis[1005][1005];int vis[1005][1005];char s[1005][1005];int d[4][2]={1,0,0,1,-1,0,0,-1};struct node{    int x,y;};int n,c,r,sx,sy;int bfs(int x,int y){    node now,mid;    queue&lt;node&gt; que;    now.x=x;now.y=y;    que.push(now);    vis[x][y]=1;dis[x][y]=0;    while(!que.empty())    {        now=que.front();        que.pop();        for(int i=0;i&lt;4;i++)        {            mid.x=now.x+d[i][0];            mid.y=now.y+d[i][1];            if(mid.x&lt;0||mid.x&gt;=r||mid.y&lt;0||mid.y&gt;=c||s[mid.x][mid.y]==&#39;#&#39;||vis[mid.x][mid.y])    continue;            vis[mid.x][mid.y]=1;            dis[mid.x][mid.y]=dis[now.x][now.y]+1;            que.push(mid);        }    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        memset(vis,0,sizeof(vis));        memset(dis,0,sizeof(dis));        scanf(&quot;%d %d&quot;,&amp;c,&amp;r);        int flag=0;        for(int i=0;i&lt;r;i++)    scanf(&quot;%s&quot;,s[i]);        for(int i=0;i&lt;r;i++)        {            for(int j=0;j&lt;c;j++)            {                if(s[i][j]==&#39;.&#39;)                {                    sx=i,sy=j;                    flag=1;                    break;                }                if(flag)    break;            }        }        bfs(sx,sy);int px=0;        for(int i=0;i&lt;r;i++)        {            for(int j=0;j&lt;c;j++)            {                if(dis[i][j]&gt;px)                {                    sx=i;                    sy=j;                    px=dis[i][j];                }            }        }        memset(vis,0,sizeof(vis));        memset(dis,0,sizeof(dis));        bfs(sx,sy);        int ans=0;        for(int i=0;i&lt;r;i++)        {            for(int j=0;j&lt;c;j++)            {                ans=max(ans,dis[i][j]);            }        }        printf(&quot;Maximum rope length is %d.\n&quot;,ans);    }}</code></pre><h3 id="Cow-Marathon"><a href="#Cow-Marathon" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h3><p>Description:<br>After hearing about the epidemic of obesity in the USA, Farmer John wants his cows to get more exercise, so he has committed to create a bovine marathon for his cows to run. The marathon route will include a pair of farms and a path comprised of a sequence of roads between them. Since FJ wants the cows to get as much exercise as possible he wants to find the two farms on his map that are the farthest apart from each other (distance being measured in terms of total length of road on the path between the two farms). Help him determine the distances between this farthest pair of farms.<br>有n个农田和m条路，以及每条路的方向（方向在这道题中没有用），求最长的一条路，也就是两点间的最大距离，即树的直径.<br>Input</p><blockquote><ul><li>Lines 1.....: Same input format as &quot;Navigation Nightmare&quot;.</li></ul></blockquote><p>Output</p><blockquote><ul><li>Line 1: An integer giving the distance between the farthest pair of farms.</li></ul></blockquote><p>Sample Input</p><blockquote><p>7 6<br>1 6 13 E<br>6 3 9 E<br>3 5 7 S<br>4 1 3 N<br>2 4 20 W<br>4 7 2 S</p></blockquote><p>Sample Output</p><blockquote><p>52</p></blockquote><p>Hint</p><blockquote><p>The longest marathon runs from farm 2 via roads 4, 1, 6 and 3 to farm 5 and is of length 20+3+13+9+7=52.</p></blockquote><p>Problem solving:<br>这道题就是一道带权的无向图求树的最大直径。<br>直接套模板即可。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int a,b,c,ans,n,m;const int maxn = 1e5+10;int vis[maxn],dis[maxn];char s;vector&lt;pair&lt;int,int&gt; &gt; v[maxn];int bfs(int x){    memset(vis,0,sizeof(vis));    memset(dis,0,sizeof(dis));    vis[x]=1;    int point=0;    queue&lt;int&gt; q;    q.push(x);    while(!q.empty())    {        x=q.front();        q.pop();        if(dis[x]&gt;ans)        {            ans=dis[x];            point=x;        }        pair&lt;int,int&gt; mid;        for(int i=0;i&lt;v[x].size();i++)        {            mid=v[x][i];            if(!vis[mid.first])            {                vis[mid.first]=1;                dis[mid.first]=dis[x]+mid.second;                q.push(mid.first);            }        }    }    return point;}int main(){    cin&gt;&gt;n&gt;&gt;m;    while(m--)    {        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;s;        v[a].push_back(make_pair(b,c));        v[b].push_back(make_pair(a,c));    }    ans=0;    int point=bfs(1);    ans=0;    bfs(point);    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h3 id="Roads-in-the-North"><a href="#Roads-in-the-North" class="headerlink" title="Roads in the North"></a>Roads in the North</h3><p>Description:<br>Building and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice.<br>Given is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area.</p><p>The area has up to 10,000 villages connected by road segments. The villages are numbered from 1.<br>Input</p><blockquote><p>Input to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way.</p></blockquote><p>Output</p><blockquote><p>You are to output a single integer: the road distance between the two most remote villages in the area.</p></blockquote><p>Sample Input</p><blockquote><p>5 1 6<br>1 4 5<br>6 3 9<br>2 6 8<br>6 1 7</p></blockquote><p>Sample Output</p><blockquote><p>22</p></blockquote><p>Problem solving:<br>同B，直接套模板即可。这里是输入组数不确定，所以直接while(cin)即可。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int a,b,c,ans;const int maxn = 1e5+10;int vis[maxn],dis[maxn];vector&lt;pair&lt;int,int&gt; &gt; v[maxn];int bfs(int x){    memset(vis,0,sizeof(vis));    memset(dis,0,sizeof(dis));    vis[x]=1;    int point=0;    queue&lt;int&gt; q;    q.push(x);    while(!q.empty())    {        x=q.front();        q.pop();        if(dis[x]&gt;ans)        {            ans=dis[x];            point=x;        }        pair&lt;int,int&gt; mid;        for(int i=0;i&lt;v[x].size();i++)        {            mid=v[x][i];            if(!vis[mid.first])            {                vis[mid.first]=1;                dis[mid.first]=dis[x]+mid.second;                q.push(mid.first);            }        }    }    return point;}int main(){    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)    {        v[a].push_back(make_pair(b,c));        v[b].push_back(make_pair(a,c));    }    ans=0;    int point=bfs(1);    ans=0;    bfs(point);    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h3><p>Description:<br>一所学校不久前买了第一台电脑（所以这台电脑的ID是1）。近年来，学校购买了N-1新电脑。每台新电脑都连接到一台先前安装的电脑上。学校的管理人员担心网络运行缓慢，希望知道第i台计算机需要发送信号的最大距离si（即到最远计算机的电缆长度）。您需要提供此信息。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094845.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094845.webp" class="img-shadow img-margin"></center></a></p><p>提示：示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。<br>输入</p><blockquote><p>输入文件包含多组测试样例。在每组样例中，第一行中都有自然数n（n&lt;=10000），然后是（n-1）行，其中包含对计算机的描述。第i行包含两个自然数-第i计算机所连接的计算机和用于连接的电缆长度。电缆总长度不超过1e9。输入行中的数字用空格分隔。</p></blockquote><p>输出</p><blockquote><p>对于每组样例，输出n行。第i行第i台计算机的到其他计算机的最大长度Si（1&lt;=i&lt;=n）。</p></blockquote><p>样例输入</p><blockquote><p>5<br>1 1<br>2 1<br>3 1<br>1 1</p></blockquote><p>样例输出</p><blockquote><p>3<br>2<br>3<br>4<br>4</p></blockquote><p>提示</p><blockquote><p>示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。</p></blockquote><p>Problem solving:<br>这道题应该是今天最难的题了。一开始毫无思路，但是后来听了学长一句话。离某个点最远的一定是树的直径的端点。我们第一次bfs结束时的点是这个树的两个端点之一，再以这个端点就行bfs结束的时候就到了另外一个端点，而且我们在查找的过程中使用的dis数组就是当前位置距离将要到达的！！端点！！的距离，所以就在bfs一次，与上一次得到的距离去max最大值即可。总结一下就是三次bfs。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const long long maxn=1e5;long long n,a,b,ans;long long vis[maxn],dis[maxn],dis2[maxn];vector&lt;pair&lt;long long,long long&gt; &gt; v[maxn];long long bfs(long long x){    memset(vis,0,sizeof(vis));    memset(dis,0,sizeof(dis));    ans=0;    queue&lt;long long&gt; q;    q.push(x);    vis[x]=1;    long long point;    while(!q.empty())    {        x=q.front();        q.pop();        if(dis[x]&gt;ans)        {            ans=dis[x];            point=x;        }        pair&lt;long long,long long&gt; mid;        for(long long i=0;i&lt;v[x].size();i++)        {            mid=v[x][i];            if(!vis[mid.first])            {                vis[mid.first]=1;                dis[mid.first]=dis[x]+mid.second;                q.push(mid.first);            }        }    }    return point;}int main(){    while(cin&gt;&gt;n)    {        memset(v,0,sizeof(v));        for(long long i=2;i&lt;=n;i++)        {            cin&gt;&gt;a&gt;&gt;b;            v[a].push_back(make_pair(i,b));            v[i].push_back(make_pair(a,b));        }        long long point=bfs(1);        long long next=bfs(point);        for(long long i=1;i&lt;=n;i++)    dis2[i]=dis[i];        bfs(next);        for(long long i=1;i&lt;=n;i++)        {            cout&lt;&lt;max(dis2[i],dis[i])&lt;&lt;endl;;        }    }}</code></pre><h3 id="Farthest-Nodes-in-a-Tree"><a href="#Farthest-Nodes-in-a-Tree" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h3><p>Description:<br>Given a tree (a connected graph with no cycles), you have to find the farthest nodes in the tree. The edges of the tree are weighted and undirected. That means you have to find two nodes in the tree whose distance is maximum amongst all nodes.</p><p>Input</p><blockquote><p>Input starts with an integer T (≤ 10), denoting the number of test cases.<br>Each case starts with an integer n (2 ≤ n ≤ 30000) denoting the total number of nodes in the tree. The nodes are numbered from 0 to n-1. Each of the next n-1 lines will contain three integers u v w (0 ≤ u, v &lt; n, u ≠ v, 1 ≤ w ≤ 10000) denoting that node u and v are connected by an edge whose weight is w. You can assume that the input will form a valid tree.</p></blockquote><p>Output</p><blockquote><p>For each case, print the case number and the maximum distance.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>4<br>0 1 20<br>1 2 30<br>2 3 50<br>5<br>0 2 20<br>2 1 10<br>0 3 29<br>0 4 50</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 100<br>Case 2: 80</p></blockquote><p>Problem solving:<br>同BC，直接套模板就行。然后就是输出格式的控制</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;const int maxn= 1e5+10;using namespace std;int dis[maxn],ans;bool vis[maxn];vector&lt;pair&lt;int,int&gt; &gt; v[maxn];int bfs(int x){    memset(dis,0,sizeof(dis));    memset(vis,0,sizeof(vis));    queue&lt;int&gt; que;    que.push(x);vis[x]=1;    int point=0;    while(!que.empty())    {        int f=que.front();        que.pop();        if(dis[f]&gt;ans)        {            ans=dis[f];            point=f;        }        pair&lt;int,int&gt; t;        for(int i=0;i&lt;v[f].size();i++)        {            t=v[f][i];            if(vis[t.first]==0)            {                vis[t.first]=1;                dis[t.first]=dis[f]+t.second;                que.push(t.first);            }        }    }    return point;}int main(){    int n,m,x,y,z,flag=0;    cin&gt;&gt;n;    while(n--)    {        memset(v,0,sizeof(v));        cin&gt;&gt;m;        for(int i=1;i&lt;m;i++)        {            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;            v[x].push_back(make_pair(y,z));            v[y].push_back(make_pair(x,z));        }        ans=0;        int point=bfs(1);        ans=0;        bfs(point);        printf(&quot;Case %d: %d\n&quot;,++flag,ans);    }}</code></pre><h3 id="51nod-2602-树的直径"><a href="#51nod-2602-树的直径" class="headerlink" title="51nod 2602 树的直径"></a>51nod 2602 树的直径</h3><p>Description:<br>一棵树的直径就是这棵树上存在的最长路径。现在有一棵n个节点的树，现在想知道这棵树的直径包含的边的个数是多少？<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094907.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094907.webp" class="img-shadow img-margin"></center></a></p><p>如图所示的数据，这棵树的直径为(1-2-3-6-9)这条路径，包含的边的个数为4，所以答案是4。</p><p>输入</p><blockquote><p>第1行：一个整数n，表示树上的节点个数。(1&lt;=n&lt;=100000)<br>第2-n行：每行有两个整数u,v,表示u与v之间有一条路径。(1&lt;=u,v&lt;=n)</p></blockquote><p>输出</p><blockquote><p>输出一个整数，表示这棵树直径所包含的边的个数。</p></blockquote><p>输入样例</p><blockquote><p>10<br>1 2<br>2 3<br>3 4<br>3 5<br>3 6<br>3 7<br>3 10<br>6 8<br>6 9</p></blockquote><p>输出样例</p><blockquote><p>4</p></blockquote><p>Problem solving:<br>求树的直径的模板题。不过无权值。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+10;int dis[maxn],ans,vis[maxn],n,a,b;vector&lt;int&gt; v[maxn];int bfs(int x){    memset(vis,0,sizeof(vis));    memset(dis,0,sizeof(dis));    queue&lt;int&gt; q;    q.push(x);    vis[x]=1,dis[x]=0;    int point;    while(!q.empty())    {        x=q.front();        q.pop();        if(dis[x]&gt;ans)        {            ans=dis[x];            point=x;        }        for(int i=0;i&lt;v[x].size();i++)        {            if(!vis[v[x][i]])            {                vis[v[x][i]]=1;                dis[v[x][i]]=dis[x]+1;                q.push(v[x][i]);            }        }    }    return point;}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;n;i++)    {        cin&gt;&gt;a&gt;&gt;b;        v[a].push_back(b);        v[b].push_back(a);    }    ans=0;    int point=bfs(1);    ans=0;    bfs(point);    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>上面有三道题我都直接说得套模板。那么求树的直径的模板是什么呢？这里只写上带权的吧，不带权的可以类比得出。或者去这里看：<center><font color="red">------------------------------>[戳这里](https://cndrew.cn/blog/2019/07/25/mapsave)<------------------------------< font></------------------------------<></font></center></p><p>在这里我结合代码想详细的分析一下这个模板。</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int a,b,c,ans;const int maxn = 1e5+10;int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pairint bfs(int x){    memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组    memset(dis,0,sizeof(dis));    vis[x]=1;//已经访问过的节点标记为1    int point=0;//用来储存当前所能走到的最远的点    queue&lt;int&gt; q;//用来实现bfs的队列    q.push(x);    while(!q.empty())    {        x=q.front();        q.pop();        if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值        {            ans=dis[x];            point=x;        }        pair&lt;int,int&gt; mid;        for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs        {            mid=v[x][i];            if(!vis[mid.first])//没访问过就继续            {                vis[mid.first]=1;//标记成已经访问过的                dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x]                q.push(mid.first);//放进队列以进行bfs            }        }    }    return point;//把当前走到的最远的点返回}int main(){    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)    {        v[a].push_back(make_pair(b,c));//存图        v[b].push_back(make_pair(a,c));    }    ans=0;//初始化    int point=bfs(1);    ans=0;    bfs(point);//第二次以某一端点位起点的bfs    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h3 id="学长标程"><a href="#学长标程" class="headerlink" title="学长标程"></a>学长标程</h3><p>学长写的代码比我的好看多了。。。贴一下</p><h4 id="Labyrinth-1"><a href="#Labyrinth-1" class="headerlink" title="Labyrinth"></a>Labyrinth</h4><pre><code>#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,u,v,ans;int dir[4][2]={1,0,0,1,-1,0,0,-1};char MAP[1200][1200];bool vis[1200][1200];void dfs(int x,int y,int res){    for(int i=0;i&lt;4;i++){        int nx=dir[i][0]+x;        int ny=dir[i][1]+y;        if(nx&gt;=0&amp;&amp;nx&lt;N&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;M&amp;&amp;vis[nx][ny]==0&amp;&amp;MAP[nx][ny]==&#39;.&#39;){            vis[nx][ny]=1;            dfs(nx,ny,res+1);        }    }    if(res&gt;=ans){        u=x;v=y;ans=res;    }}int main(){    int T;    scanf(&quot;%d&quot;,&amp;T);    while(T--){        scanf(&quot;%d%d&quot;,&amp;M,&amp;N);        for(int i=0;i&lt;N;i++){            scanf(&quot;%s&quot;,&amp;MAP[i]);        }        memset(vis,0,sizeof(vis));        ans=0;        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;M;j++){                if(MAP[i][j]==&#39;.&#39;){                    dfs(i,j,0);                }            }        }        memset(vis,0,sizeof(vis));        dfs(u,v,0);        cout&lt;&lt;&quot;Maximum rope length is &quot;&lt;&lt;ans&lt;&lt;&#39;.&#39;&lt;&lt;endl;    }    return 0;}</code></pre><h4 id="Cow-Marathon-1"><a href="#Cow-Marathon-1" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h4><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[40020];bool vis[40020];vector&lt;pair&lt;int,int&gt; &gt;V[40020];int bfs(int n){    memset(dis,0,sizeof(dis));    memset(vis,0,sizeof(vis));    queue&lt;int&gt;Q;    Q.push(n);    vis[n]=1;    ans=0;    int point=0,t;    while(!Q.empty()){        t=Q.front();        Q.pop();        if(dis[t]&gt;ans){            ans=dis[t];            point=t;        }        for(int i=0;i&lt;V[t].size();i++){            if(vis[V[t][i].first]==0){                vis[V[t][i].first]=1;                dis[V[t][i].first]=dis[t]+V[t][i].second;                Q.push(V[t][i].first);            }        }    }    return point;}int main(){    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);    for(int i=0;i&lt;M;i++){        scanf(&quot;%d%d%d %*c&quot;,&amp;X,&amp;Y,&amp;Z);        V[X].push_back(make_pair(Y,Z));        V[Y].push_back(make_pair(X,Z));    }    bfs(bfs(1));    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><h4 id="Roads-in-the-North-1"><a href="#Roads-in-the-North-1" class="headerlink" title="Roads in the North"></a>Roads in the North</h4><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[40020];bool vis[40020];vector&lt;pair&lt;int,int&gt; &gt;V[40020];int bfs(int n){    memset(dis,0,sizeof(dis));    memset(vis,0,sizeof(vis));    queue&lt;int&gt;Q;    Q.push(n);    vis[n]=1;    ans=0;    int point=0,t;    while(!Q.empty()){        t=Q.front();        Q.pop();        if(dis[t]&gt;ans){            ans=dis[t];            point=t;        }        for(int i=0;i&lt;V[t].size();i++){            if(vis[V[t][i].first]==0){                vis[V[t][i].first]=1;                dis[V[t][i].first]=dis[t]+V[t][i].second;                Q.push(V[t][i].first);            }        }    }    return point;}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z)!=EOF){        V[X].push_back(make_pair(Y,Z));        V[Y].push_back(make_pair(X,Z));    }    bfs(bfs(1));    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><h4 id="Computer-1"><a href="#Computer-1" class="headerlink" title="Computer"></a>Computer</h4><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[40020];int diss[40020];bool vis[40020];vector&lt;pair&lt;int,int&gt; &gt;V[40020];int bfs(int n){    memset(dis,0,sizeof(dis));    memset(vis,0,sizeof(vis));    queue&lt;int&gt;Q;    Q.push(n);    vis[n]=1;    ans=0;    int point,t;    while(!Q.empty()){        t=Q.front();        Q.pop();        if(dis[t]&gt;ans){            ans=dis[t];            point=t;        }        for(int i=0;i&lt;V[t].size();i++){            if(vis[V[t][i].first]==0){                vis[V[t][i].first]=1;                dis[V[t][i].first]=dis[t]+V[t][i].second;                Q.push(V[t][i].first);            }        }    }    return point;}int main(){    while(scanf(&quot;%d&quot;,&amp;N)!=EOF){        for(int i=0;i&lt;=N;i++)V[i].clear();        for(int i=1;i&lt;N;i++){            scanf(&quot;%d%d&quot;,&amp;X,&amp;Z);            V[i+1].push_back(make_pair(X,Z));            V[X].push_back(make_pair(i+1,Z));        }        int point=bfs(bfs(1));        for(int i=1;i&lt;=N;i++){            diss[i]=dis[i];        }        bfs(point);        for(int i=1;i&lt;=N;i++){            printf(&quot;%d\n&quot;,max(dis[i],diss[i]));        }    }    return 0;}</code></pre><h4 id="Farthest-Nodes-in-a-Tree-1"><a href="#Farthest-Nodes-in-a-Tree-1" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h4><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[40020];bool vis[40020];vector&lt;pair&lt;int,int&gt; &gt;V[40020];int bfs(int n){    memset(dis,0,sizeof(dis));    memset(vis,0,sizeof(vis));    queue&lt;int&gt;Q;    Q.push(n);    vis[n]=1;    ans=0;    int point,t;    while(!Q.empty()){        t=Q.front();        Q.pop();        if(dis[t]&gt;ans){            ans=dis[t];            point=t;        }        for(int i=0;i&lt;V[t].size();i++){            if(vis[V[t][i].first]==0){                vis[V[t][i].first]=1;                dis[V[t][i].first]=dis[t]+V[t][i].second;                Q.push(V[t][i].first);            }        }    }    return point;}int main(){    int T,Case=1;    scanf(&quot;%d&quot;,&amp;T);    while(T--){        scanf(&quot;%d&quot;,&amp;N);        for(int i=0;i&lt;N;i++)V[i].clear();        for(int i=1;i&lt;N;i++){            scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z);            V[X].push_back(make_pair(Y,Z));            V[Y].push_back(make_pair(X,Z));        }        bfs(bfs(0));        printf(&quot;Case %d: %d\n&quot;,Case++,ans);    }    return 0;}</code></pre><h4 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h4><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[100020];bool vis[100020];vector&lt;pair&lt;int,int&gt; &gt;V[100020];int bfs(int n){    memset(dis,0,sizeof(dis));    memset(vis,0,sizeof(vis));    queue&lt;int&gt;Q;    Q.push(n);    vis[n]=1;    ans=0;    int point,t;    while(!Q.empty()){        t=Q.front();        Q.pop();        if(dis[t]&gt;ans){            ans=dis[t];            point=t;        }        for(int i=0;i&lt;V[t].size();i++){            if(vis[V[t][i].first]==0){                vis[V[t][i].first]=1;                dis[V[t][i].first]=dis[t]+V[t][i].second;                Q.push(V[t][i].first);            }        }    }    return point;}int main(){    scanf(&quot;%d&quot;,&amp;N);    for(int i=1;i&lt;N;i++){        scanf(&quot;%d%d&quot;,&amp;X,&amp;Y);        V[X].push_back(make_pair(Y,1));        V[Y].push_back(make_pair(X,1));    }    bfs(bfs(1));    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BFS </tag>
            
            <tag> HDU </tag>
            
            <tag> poj </tag>
            
            <tag> 51nod </tag>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 8（河南理工大学暑期第八天）</title>
      <link href="/2019/07/24/8/"/>
      <url>/2019/07/24/8/</url>
      
        <content type="html"><![CDATA[<h3 id="Oil-Deposits"><a href="#Oil-Deposits" class="headerlink" title="Oil Deposits"></a>Oil Deposits</h3><p>Description：<br>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.<br>Input<br>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either `*&#39;, representing the absence of oil, or `@&#39;, representing an oil pocket.</p><p>Output</p><blockquote><p>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p></blockquote><p>Sample Input</p><pre><code>1 1*3 5*@*@***@***@*@*1 8@@****@*5 5****@*@@*@*@**@@@@*@@@**@0 0</code></pre><p>Sample Output</p><blockquote><p>0<br>1<br>2<br>2</p></blockquote><p>Problem solving:<br>简单题，输入一个图，@表示油田，*表示没有油田，@只要是相邻的都可以算成是一个，所以就是八个方向上dfs就行，访问过的@就换成*或者其他的字符就行只要不是@.(如果这样写的话其实就不需要标记数组了)</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char s[105][105];int vis[105][105];int m,n,ans;int d[8][2]={1,0,0,1,0,-1,-1,0,1,1,1,-1,-1,-1,-1,1};void dfs(int x,int y){    vis[x][y]=1;    if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n)    return ;    for(int i=0;i&lt;8;i++)    {        int dx=x+d[i][0];        int dy=y+d[i][1];        if(dx&gt;=0&amp;&amp;dx&lt;m&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;n&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]==&#39;@&#39;)        {            s[dx][dy]=&#39;*&#39;;            dfs(dx,dy);        }    }}int main(){    while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m)    {        memset(vis,0,sizeof(vis));        ans=0;        for(int i=0;i&lt;m;i++)    cin&gt;&gt;s[i];        for(int i=0;i&lt;m;i++)        {            for(int j=0;j&lt;n;j++)            {                if(s[i][j]==&#39;@&#39;)                {                    dfs(i,j);                    ans++;                }            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="How-Many-Equations-Can-You-Find"><a href="#How-Many-Equations-Can-You-Find" class="headerlink" title="How Many Equations Can You Find"></a>How Many Equations Can You Find</h3><p>Description：<br>Now give you an string which only contains 0, 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9.You are asked to add the sign ‘+’ or ’-’ between the characters. Just like give you a string “12345”, you can work out a string “123+4-5”. Now give you an integer N, please tell me how many ways can you find to make the result of the string equal to N .You can only choose at most one sign between two adjacent characters.<br>Input</p><blockquote><p>Each case contains a string s and a number N . You may be sure the length of the string will not exceed 12 and the absolute value of N will not exceed 999999999999.</p></blockquote><p>Output</p><blockquote><p>The output contains one line for each data set : the number of ways you can find to make the equation.</p></blockquote><p>Sample Input</p><blockquote><p>123456789 3<br>21 1</p></blockquote><p>Sample Output</p><blockquote><p>18<br>1</p></blockquote><p>Problem solving:<br>每两个数中间都有两种可能，一种是加号一种是减号，并且能放入操作符的位置我们也是知道的，所以只需要查找每个位置放上不同的运算符之后得到的所有结果，看有几个与n相等即可。查找的过程用dfs来实现。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;string s;int n,ans;void dfs(int x,int now)//x代表的是当前要进行操作的位置，now代表当前得到的值{    if(x==s.size())//如果x已经跟字符串的长度相等说明这一次遍历已经结束了    {        if(now==n)    ans++;//如果得到的值跟n相等，答案就加一//        cout&lt;&lt;now&lt;&lt;endl;        return ;    }    for(int i=x;i&lt;s.size();i++)    {        int mid=0;        for(int j=x;j&lt;=i;j++)        {            mid=mid*10+s[j]-&#39;0&#39;;//得到运算符左边字符串所代表数的大小//            cout&lt;&lt;mid&lt;&lt;&quot;?&quot;&lt;&lt;now&lt;&lt;endl;        }        dfs(i+1,now+mid);//去访问下一个位置，并且此时的值加上上面得到的运算符左边字符串所代表的数        if(x)    dfs(i+1,now-mid);//减号不能放在最前面，所以要有一个x不为0的判断    }}int main(){    while(cin&gt;&gt;s&gt;&gt;n)    {        ans=0;        dfs(0,0);//从s[0]开始，当前值为0        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><p>Description：<br>在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>你的任务是，对于给定的N，求出有多少种合法的放置方法。</p><p>Input</p><blockquote><p>共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。</p></blockquote><p>Output</p><blockquote><p>共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>8<br>5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>1<br>92<br>10</p></blockquote><p>Problem solving:<br>从第一行开始放，然后放下一行，如果出现了在同一行的或者同一列的或者同一条斜线上的就return，如果放进去的个数等于n，答案就加一。这道题N虽然小于等于10，但是是多组输入，如果每次输入都计算一次并且输入数据很多的话，肯定会TLE。所以需要打表，就是如果这个计算过了就把它的结果记录下来，如果下次又要求这个的结果直接调用就行。也可以直接从输入前就先计算好存进数组。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,mid;int ans[12],mmp[12];void dfs(int x){    if(x==n+1)    {        mid++;        return ;    }    for(int i=1;i&lt;=n;i++)    {    int flag=1;        mmp[x]=i;        for(int j=1;j&lt;x;j++)        {            if(mmp[j]==i||(abs(j-x)==abs(mmp[j]-mmp[x])))            {                flag=0;                break;            }        }        if(flag)    dfs(x+1);    }}int main(){    for(n=1;n&lt;=10;n++)    {        mid=0;        dfs(1);        ans[n]=mid;    }    int t;    while(cin&gt;&gt;t&amp;&amp;t)    {        cout&lt;&lt;ans[t]&lt;&lt;endl;    }}</code></pre><h3 id="Fox-And-Two-Dots"><a href="#Fox-And-Two-Dots" class="headerlink" title="Fox And Two Dots"></a>Fox And Two Dots</h3><p>Description：<br>Fox Ciel is playing a mobile puzzle game called &quot;Two Dots&quot;. The basic levels are played on a board of size n × m cells, like this:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094801.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094801.webp" class="img-shadow img-margin"></center></a><br>Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.</p><p>The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, ..., dk a cycle if and only if it meets the following condition:</p><ol><li>These k dots are different: if i ≠ j then di is different from dj.</li><li>k is at least 4.</li><li>All dots belong to the same color.</li><li>For all 1 ≤ i ≤ k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge.</li></ol><p>Determine if there exists a cycle on the field.<br>Input</p><blockquote><p>The first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.<br>Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.</p></blockquote><p>Output</p><blockquote><p>Output &quot;Yes&quot; if there exists a cycle, and &quot;No&quot; otherwise.</p></blockquote><p>Examples<br>Input</p><blockquote><p>3 4<br>AAAA<br>ABCA<br>AAAA</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>3 4<br>AAAA<br>ABCA<br>AADA</p></blockquote><p>Output</p><blockquote><p>No</p></blockquote><p>Input</p><blockquote><p>4 4<br>YYYR<br>BYBY<br>BBBY<br>BBBY</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>7 6<br>AAAAAB<br>ABBBAB<br>ABAAAB<br>ABABBB<br>ABAAAB<br>ABBBAB<br>AAAAAB</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>2 13<br>ABCDEFGHIJKLM<br>NOPQRSTUVWXYZ</p></blockquote><p>Output</p><blockquote><p>No</p></blockquote><p>Note<br>In first sample test all &#39;A&#39; form a cycle.</p><p>In second sample there is no such cycle.</p><p>The third sample is displayed on the picture above (&#39;Y&#39; = Yellow, &#39;B&#39; = Blue, &#39;R&#39; = Red).<br>Problem solving:<br>这道题的意思就是输入一个由大写字母组成的图，如果相同的字母可以组成一个环，就输出Yes，否则输出No。<br>这道题跟昨天的那个机器人有点类似，不过那个机器人每次走的方向是定的，而这个是可以随意走的。<br>所以如何进行判断会不会有环的存在呢？<br>我们只需要在每次进行dfs的查找之前把最初的初始位置记录一下，然后开始dfs查找，上下左右四个方向，遇到与当前字母一样的字母就以这个为初始位置继续dfs，并且记录下来当前走的步数。如果在dfs结束之前遇到了一个(dx,dy)与我们记录的最初始的初始位置相等并且步数大于等于4的情况，就说明存在环，输出&#39;Yes&#39;即可，反之输出&#39;No&#39;。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char s[60][60];int vis[60][60],flag,n,m,sx,sy;int d[4][2]={1,0,0,1,-1,0,0,-1};void dfs(int x,int y,int step){    if(flag)    return ;    vis[x][y]=1;    for(int i=0;i&lt;4;i++)    {        int dx=x+d[i][0];        int dy=y+d[i][1];        if(dx==sx&amp;&amp;dy==sy&amp;&amp;step&gt;=4)        {            flag=1;            return ;        }        if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]==s[x][y])        {            dfs(dx,dy,step+1);        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;s[i];    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;m;j++)        {            memset(vis,0,sizeof(vis));            sx=i,sy=j;            dfs(sx,sy,1);        }    }    if(flag)    puts(&quot;Yes&quot;);    else    puts(&quot;No&quot;);}</code></pre><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><p>Description：<br>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。<br>Input</p><blockquote><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p></blockquote><p>Output</p><blockquote><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C\&lt;2^31）。</p></blockquote><p>Sample Input</p><pre><code>2 1#..#4 4...#..#..#..#...-1 -1</code></pre><p>Sample Output</p><blockquote><p>2<br>1</p></blockquote><p>Problem solving:<br>跟n皇后很像的一个问题。判断条件还少了一个。注意回溯就行。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,k,vis[10],ans,now;char s[10][10];void dfs(int x){    if(now==k)    {        ans++;        return ;    }    if(x&gt;=n)    return ;    for(int j=0;j&lt;n;j++)    {        if(!vis[j]&amp;&amp;s[x][j]==&#39;#&#39;)        {            vis[j]=1;            now++;            dfs(x+1);            now--;            vis[j]=0;        }    }    dfs(x+1);}int main(){    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;k)&amp;&amp;n!=-1&amp;&amp;k!=-1)    {        memset(vis,0,sizeof(vis));        for(int i=0;i&lt;n;i++)    cin&gt;&gt;s[i];        ans=0,now=0;        dfs(0);        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h3><p>Description：<br>Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.</p><p><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094825.webp" alt="JUT0QY($RVW[_(1EGZ@@)PK.webp" title="JUT0QY($RVW[_(1EGZ@@)PK.webp"></p><p>Input</p><blockquote><p>The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.</p></blockquote><p>Output</p><blockquote><p>For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>103000509<br>002109400<br>000704000<br>300502006<br>060000050<br>700803004<br>000401000<br>009205800<br>804000107</p></blockquote><p>Sample Output</p><blockquote><p>143628579<br>572139468<br>986754231<br>391542786<br>468917352<br>725863914<br>237481695<br>619275843<br>854396127</p></blockquote><p>Problem solving:<br>这道题的处理方式很巧妙。dfs中的参数只设置一个n(n就是代表着这是第几个数)就够了，就是当前的位置，在dfs中每次加一，如果当前位置不为0，就直接查找下一个位置。否则就从1～9中选一个数放进去，看同一行同一列以及同一小方格的同一行同一列有没有与之相同的，如果没有，就将当前位置的数更新成这个没有重复出现过的数。知道查找到n&gt;=81的时候，即每个位置都查找完了，结束查找输出即可。注意在查找的过程中需要用到回溯，因为如果这一条路行不通而返回上一条路的时候，此时当前位置还应该是0.<br>思路还是很清晰的，难点主要有两个</p><ol><li>如何用n来表示当前的位置</li><li>如何判断同一行同一列以及同一小方格的同一行同一列有没有与之相同的数</li></ol><p>n/9代表的就是当前位置的行，n%9代表的就是当前位置的列。<br>n/9/3*3表示的就是当前位置在小方格里的行，n%9/3*3代表的就是当前位置在小方格里的列。</p><p>位置都能表示出来了，那么判断也就简单了。<br>分别确定二维数组的第一个和第二个坐标进行判断就行了。这一点可能说的不是很好理解，可以看看代码，还是很好理解的。</p><p>这里还用到了一个很巧妙的输入<code>scanf(&quot;%1d&quot;,&amp;a)</code>;这样的话就不用输入字符再转换成整型了。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[10][10],flag;bool check(int n,int now){    for(int i=0;i&lt;9;i++)    {        int j=n%9;        if(a[i][j]==now)            return 0;    }    for(int j=0;j&lt;9;j++)    {        int i=n/9;        if(a[i][j]==now)            return 0;    }    int di=n/9/3*3;    int dj=n%9/3*3;    for(int i =di;i&lt;di+3;i++)    {        for(int j=dj;j&lt;dj+3;j++)        {            if(a[i][j]==now)    return 0;        }    }    return 1;}int dfs(int n){    if(n&gt;=81)    {        flag=1;        return 0;    }    if(a[n/9][n%9]!=0)    dfs(n+1);    else    {        for(int i=1;i&lt;=9;i++)        {            if(check(n,i)==1)            {                a[n/9][n%9]=i;                dfs(n+1);                if(flag==1)                    return 0;                a[n/9][n%9]=0;//回溯            }        }            }//    cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;}int main(){    int t;    cin&gt;&gt;t;    while(t--)    {        flag=0;        for(int i=0;i&lt;9;i++)            for(int j=0;j&lt;9;j++)            scanf(&quot;%1d&quot;,&amp;a[i][j]);        dfs(0);        for(int i=0;i&lt;9;i++)        {            for(int j=0;j&lt;9;j++)                printf(&quot;%d&quot;,a[i][j]);            puts(&quot;&quot;);        }    }    return 0;}</code></pre><h3 id="放苹果"><a href="#放苹果" class="headerlink" title="放苹果"></a>放苹果</h3><p>Description：<br>把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。<br>Input</p><blockquote><p>第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。</p></blockquote><p>Output</p><blockquote><p>对输入的每组数据M和N，用一行输出相应的K。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>7 3</p></blockquote><p>Sample Output</p><blockquote><p>8</p></blockquote><p>Problem solving:<br>思维题。(让我说也说不清，还是借用一下大佬的解释吧)<br>设f(m,n) 为m个苹果，n个盘子的放法数目，则先对n作讨论，<br>        当n&gt;m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n&gt;m) f(m,n) = f(m,m)　　<br>        当n&lt;=m：不同的放法可以分成两类：<br>        1、有至少一个盘子空着，即相当于f(m,n) = f(m,n-1);<br>        2、所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n) = f(m-n,n).<br>        而总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n) </p><p> 递归出口条件说明：<br>        当n=1时，所有苹果都必须放在一个盘子里，所以返回１；<br>        当没有苹果可放时，定义为１种放法；<br>        递归的两条路，第一条n会逐渐减少，终会到达出口n==1;<br>        第二条m会逐渐减少，因为n&gt;m时，我们会return f(m,m)　所以终会到达出口m==0．<br>此解释源于：<a href="https://blog.csdn.net/jason0539/article/details/12183817" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/12183817</a></p><p>Code:</p><pre><code>#include&lt;iostream&gt;using namespace std;int t,n,m,ans;int dfs(int x,int y){    if(x==0||y==1){        return 1;    }    else if(x&lt;y)    return dfs(x,x);    return dfs(x,y-1)+dfs(x-y,y);}int main(){    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;m&gt;&gt;n;        cout&lt;&lt;dfs(m,n)&lt;&lt;endl;    }}</code></pre><h3 id="Tempter-of-the-Bone"><a href="#Tempter-of-the-Bone" class="headerlink" title="Tempter of the Bone"></a>Tempter of the Bone</h3><p>Description：<br>小明做了一个很久很久的梦，醒来后他竟发现自己和朋友在一个摇摇欲坠的大棋盘上，他们必须得想尽一切办法逃离这里。<br>经过长时间的打探，小明发现，自己所在的棋盘格子上有个机关，上面写着“你只有一次机会，出发后t秒大门会为你敞开”，而他自己所在的棋盘是大小为 N*M 的长方形，他可以向上下左右四个方向移动（不可走有障碍点）。棋盘中有一扇门。根据机关的提示，小明顿时明白了，他和朋友必须在第 t 秒到门口。而这一切，没有回头路！因为一旦他移动了，他刚才所在的点就会消失，并且他不能在一个点上停留超过一秒，不然格子会爆炸。大逃亡开始了，请问小明和朋友能安全的逃出这奇怪的棋盘吗？</p><p>Input</p><blockquote><p>输入多组测试数据。每个测试用例的第一行包含三个整数 N、M 和 T ( 1 &lt; N , M &lt; 7 ; 0 &lt; T &lt; 50 )，分别表示棋盘的大小和门打开的时间。接下来的N行给出棋盘布局，每一行包含M个字符。其中<br>&quot;.&quot;: 无障碍点<br>&quot;X&quot;: 障碍点<br>&quot;S&quot;: 起点<br>&quot;D&quot;: 门<br>输入以 3 个 0 结束。这个测试用例不需要处理。<br>输入数据中的空格有些问题，请不要使用getchar()，如果一定要用可以选择scanf(&quot;%s&quot;,) 自动忽略空格</p></blockquote><p>Output</p><blockquote><p>对于每组样例输出一行。<br>如果小明能够安全逃出，输出 &quot;YES&quot; ，否则输出 &quot;NO&quot;。</p></blockquote><p>Sample Input</p><pre><code>4 4 5S.X...X...XD....3 4 5S.X...X....D0 0 0</code></pre><p>Sample Output</p><blockquote><p>NO<br>YES</p></blockquote><p>Problem solving:<br>注意题目中要求的是当你走到D的时候你走的步数与它开门的时间即T相等，所以需要用DFS查找每一条到达D的路，看与T相等的值是否存在。<br>因为要查询到每一条路，这道题可能会超时。所以会用到一种很神奇的剪枝——<a href="https://baike.baidu.com/item/%E5%A5%87%E5%81%B6%E5%89%AA%E6%9E%9D" target="_blank" rel="noopener">奇偶剪枝</a><br>除去这个剪枝的难度的话这道题就很简单了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,sx,sy,ex,ey,ti,flag;char s[10][10];int vis[10][10];int d[4][2]={0,1,0,-1,1,0,-1,0};void dfs(int x,int y){    if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||ti&gt;t)    return ;    if(flag)    return ;    if(s[x][y]==&#39;D&#39;&amp;&amp;ti==t)    {//        cout&lt;&lt;ti&lt;&lt;endl;        flag=1;        return ;    }    int temp1 = abs(ex-x) + abs(ey-y);    int temp2 = abs(t-ti);    int temp = abs(temp1-temp2);    if(temp%2!=0)    return ;    vis[x][y]=1;    for(int i=0;i&lt;4;i++)    {        int dx=x+d[i][0];        int dy=y+d[i][1];        if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]!=&#39;X&#39;)        {//            cout&lt;&lt;ti&lt;&lt;&quot;--&gt;&quot;&lt;&lt;dx&lt;&lt;&quot; --&gt;&quot;&lt;&lt;dy&lt;&lt;&quot;\n&quot;;            ti++;            dfs(dx,dy);            vis[dx][dy]=0;            ti--;        }    }}int main(){        ios::sync_with_stdio(0);    while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t)    {        if(n==0&amp;&amp;m==0&amp;&amp;t==0)    break;        flag=0,ti=0;        memset(vis,0,sizeof(vis));        for(int i=0;i&lt;n;i++)    cin&gt;&gt;s[i];        for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;m;j++)                if(s[i][j]==&#39;S&#39;)                {                        sx=i,sy=j;                }                else if(s[i][j]==&#39;D&#39;)                {                    ex=i,ey=j;                }        dfs(sx,sy);        if(flag)    puts(&quot;YES&quot;);        else    puts(&quot;NO&quot;);    }}</code></pre><h3 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h3><p>Description：<br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can&#39;t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>Input</p><blockquote><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>&#39;.&#39; - a black tile<br>&#39;#&#39; - a red tile<br>&#39;@&#39; - a man on a black tile(appears exactly once in a data set)</p></blockquote><p>Output</p><blockquote><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p></blockquote><p>Sample Input</p><pre><code>6 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0</code></pre><p>Sample Output</p><blockquote><p>45<br>59<br>6<br>13</p></blockquote><p>Problem solving:<br>对没错就是昨天那道题，用bfs可以写，用dfs也可以写。太强了。只要下一个还是可以走得就一直dfs查找下去就行。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char s[25][25];int vis[25][25];int a,b,ans;int d[4][2]={1,0,0,1,0,-1,-1,0};void dfs(int x,int y){    vis[x][y]=1;    if(x&lt;0||x&gt;=b||y&lt;0||y&gt;=a)    return ;    for(int i=0;i&lt;4;i++)    {        int dx=x+d[i][0];        int dy=y+d[i][1];        if(dx&gt;=0&amp;&amp;dx&lt;b&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;a&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]!=&#39;#&#39;)        {            ans++;            dfs(dx,dy);        }    }}int main(){    while(cin&gt;&gt;a&gt;&gt;b)    {        if(a==0&amp;&amp;b==0)    break;        ans=1;        memset(vis,0,sizeof(vis));        for(int i=0;i&lt;b;i++)        {            for(int j=0;j&lt;a;j++)            {                cin&gt;&gt;s[i][j];            }        }        for(int i=0;i&lt;b;i++)            for(int j=0;j&lt;a;j++)            {                if(s[i][j]==&#39;@&#39;)    dfs(i,j);            }                cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> STL </tag>
            
            <tag> poj </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 7（河南理工大学暑期第七天）</title>
      <link href="/2019/07/23/7/"/>
      <url>/2019/07/23/7/</url>
      
        <content type="html"><![CDATA[<h3 id="Rescue"><a href="#Rescue" class="headerlink" title="Rescue"></a>Rescue</h3><p>Description:<br>Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.</p><p>Angel&#39;s friends want to save Angel. Their task is: approach Angel. We assume that &quot;approach Angel&quot; is to get to the position where Angel stays. When there&#39;s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.</p><p>You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)<br>Input</p><blockquote><p>First line contains two integers stand for N and M.<br>Then N lines follows, every line has M characters. &quot;.&quot; stands for road, &quot;a&quot; stands for Angel, and &quot;r&quot; stands for each of Angel&#39;s friend.<br>Process to the end of the file.</p></blockquote><p>Output</p><blockquote><p>For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing &quot;Poor ANGEL has to stay in the prison all his Life.&quot;</p></blockquote><p>Sample Input</p><pre><code>7 8#.#####.#.a#..r.#..#x.....#..#.##...##...#..............</code></pre><p>Sample Output</p><blockquote><p>13</p></blockquote><p>Problem solving:<br>注意是多组输入，这里用到了运算符重载和优先队列，这两个东西最近在刷题的过程中出现的频率很高。<br>因为这道题中r可能有多个所以我们用a去寻找r，用结构体存点的坐标，用优先队列存结构体实现BFS，先定义一个ans变量用来存放答案，初始化为-1，如果可以找到符合条件的点就更新ans的值并结束查找。查找结束之后，如果ans仍是-1，那么输出<code>Poor ANGEL has to stay in the prison all his Life.</code>，否则就输出ans的值，查找过程就是bfs的模板，但是用的是优先队列。我们遇到X的时候只需要+2即可。其他的判断条件都挺好理解，可以直接看代码。</p><p>结构体如果想套到优先队列中就需要运算符重载。运算符重载的方法有好几种，这里我就会这一种。</p><p>Code</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char s[205][205];int d[4][2]={-1,0,0,1,1,0,0,-1};struct node{    int x,y,step;    friend bool operator &lt; (node a,node b)    {        return a.step&gt;b.step;    }};int n,m;int vis[205][205];void bfs(int x,int y,int xx,int yy){    int ans=-1;    memset(vis,0,sizeof(vis));    priority_queue&lt;node&gt; q;    node mid,mmp;    mid.x=x,mid.y=y,mid.step=0;    vis[x][y]=1;    q.push(mid);    while(!q.empty())    {        mid=q.top();        q.pop();        if(mid.x==xx&amp;&amp;mid.y==yy)        {            ans=mid.step;            break;        }        for(int i=0;i&lt;4;i++)        {            mmp.x=mid.x+d[i][0];            mmp.y=mid.y+d[i][1];            if(mmp.x&lt;0||mmp.x&gt;=n||mmp.y&lt;0||mmp.y&gt;=m||vis[mmp.x][mmp.y]==1||s[mmp.x][mmp.y]==&#39;#&#39;)    continue;            if(s[mmp.x][mmp.y]==&#39;x&#39;)    mmp.step=mid.step+2;            else    mmp.step=mid.step+1;            q.push(mmp);            vis[mmp.x][mmp.y]=1;        }    }    if(ans==-1)    puts(&quot;Poor ANGEL has to stay in the prison all his Life.&quot;);    else    cout&lt;&lt;ans&lt;&lt;endl;}int main(){    int sx,sy,ex,ey;    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;m;j++)            {                cin&gt;&gt;s[i][j];                if(s[i][j]==&#39;a&#39;)                {                    sx=i;                    sy=j;                }                if(s[i][j]==&#39;r&#39;)                {                    ex=i;                    ey=j;                }            }        }        bfs(sx,sy,ex,ey);            }}</code></pre><h3 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h3><p>Description:<br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can&#39;t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>Input</p><blockquote><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>&#39;.&#39; - a black tile<br>&#39;#&#39; - a red tile<br>&#39;@&#39; - a man on a black tile(appears exactly once in a data set)</p></blockquote><p>Output</p><blockquote><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p></blockquote><p>Sample Input</p><pre><code>6 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0</code></pre><p>Sample Output</p><blockquote><p>45<br>59<br>6<br>13</p></blockquote><p>Problem solving:<br>简单的BFS模板题，注意答案要加上一开始所处位置的点。</p><p>Code</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char s[25][25];int vis[25][25];int d[4][2]={1,0,0,1,0,-1,-1,0};struct node{    int x,y;};int w,h;queue&lt;node&gt; que;void bfs(int x,int y){    memset(vis,0,sizeof(vis));    node mid,now,mmp;    int ans=0;    mid.x=x;    mid.y=y;    vis[x][y]=1;    que.push(mid);    while(!que.empty())    {        now=que.front();        que.pop();        for(int i=0;i&lt;4;i++)        {            mmp.x=now.x+d[i][0];            mmp.y=now.y+d[i][1];            if(mmp.x&lt;0||mmp.x&gt;=h||mmp.y&lt;0||mmp.y&gt;=w||vis[mmp.x][mmp.y]==1||s[mmp.x][mmp.y]==&#39;#&#39;)    continue;            ans++;            vis[mmp.x][mmp.y]=1;            que.push(mmp);            s[mmp.x][mmp.y]=&#39;?&#39;;        }    }    cout&lt;&lt;ans+1&lt;&lt;endl;}int main(){    int sx,sy;    while(scanf(&quot;%d %d&quot;,&amp;w,&amp;h)&amp;&amp;w&amp;&amp;h)    {        for(int i=0;i&lt;h;i++)        {            for(int j=0;j&lt;w;j++)            {                cin&gt;&gt;s[i][j];                if(s[i][j]==&#39;@&#39;)                {                    sx=i;                    sy=j;                }            }        }//        cout&lt;&lt;sx&lt;&lt;&quot; &quot;&lt;&lt;sy&lt;&lt;endl;        bfs(sx,sy);//        for(int i=0;i&lt;h;i++)//        {//            for(int j=0;j&lt;w;j++)//            {//                cout&lt;&lt;s[i][j];//            }//            puts(&quot;&quot;);//        }    }}</code></pre><h3 id="Battle-City"><a href="#Battle-City" class="headerlink" title="Battle City"></a>Battle City</h3><p>Description:<br>Many of us had played the game &quot;Battle city&quot; in our childhood, and some people (like me) even often play it on computer now.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094608.webp" data-fancybox="images" data-caption="主人没有描述我哦~" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094608.webp" class="img-shadow img-margin"></center></a><br>What we are discussing is a simple edition of this game. Given a map that consists of empty spaces, rivers, steel walls and brick walls only. Your task is to get a bonus as soon as possible suppose that no enemies will disturb you (See the following picture).<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094623.webp" data-fancybox="images" data-caption="主人没有描述我哦~" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094623.webp" class="img-shadow img-margin"></center></a><br>Your tank can&#39;t move through rivers or walls, but it can destroy brick walls by shooting. A brick wall will be turned into empty spaces when you hit it, however, if your shot hit a steel wall, there will be no damage to the wall. In each of your turns, you can choose to move to a neighboring (4 directions, not 8) empty space, or shoot in one of the four directions without a move. The shot will go ahead in that direction, until it go out of the map or hit a wall. If the shot hits a brick wall, the wall will disappear (i.e., in this turn). Well, given the description of a map, the positions of your tank and the target, how many turns will you take at least to arrive there?</p><p>Input</p><blockquote><p>The input consists of several test cases. The first line of each test case contains two integers M and N (2 &lt;= M, N &lt;= 300). Each of the following M lines contains N uppercase letters, each of which is one of &#39;Y&#39; (you), &#39;T&#39; (target), &#39;S&#39; (steel wall), &#39;B&#39; (brick wall), &#39;R&#39; (river) and &#39;E&#39; (empty space). Both &#39;Y&#39; and &#39;T&#39; appear only once. A test case of M = N = 0 indicates the end of input, and should not be processed.</p></blockquote><p>Output</p><blockquote><p>For each test case, please output the turns you take at least in a separate line. If you can&#39;t arrive at the target, output &quot;-1&quot; instead.</p></blockquote><p>Sample Input</p><blockquote><p>3 4<br>YBEB<br>EERE<br>SSTE<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>8</p></blockquote><p>Problem solving:<br>这道题跟A很像。用优先队列进行BFS查找。判断条件也很简单。不懂的话，可以直接看代码</p><p>Code</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int m,n;char s[305][305];int vis[305][305];struct node{    int x,y,step;    friend bool operator &lt; (node a,node b)    {        return a.step&gt;b.step;    }};int d[4][2]={1,0,0,1,-1,0,0,-1};void bfs(int x,int y,int xx,int yy){    int ans=-1;    memset(vis,0,sizeof(vis));    node mid,now;    priority_queue&lt;node&gt; q;    mid.x=x;mid.y=y;mid.step=0;    q.push(mid);    vis[x][y]=1;    while(!q.empty())    {        mid=q.top();        if(mid.x==xx&amp;&amp;mid.y==yy)        {//            cout&lt;&lt;mid.x&lt;&lt;&quot; &quot;&lt;&lt;mid.y&lt;&lt;endl;            ans=mid.step;            break;        }        q.pop();        for(int i=0;i&lt;8;i++)        {            now.x=mid.x+d[i][0];            now.y=mid.y+d[i][1];            if(now.x&lt;0||now.x&gt;=m||now.y&lt;0||now.y&gt;=n||s[now.x][now.y]==&#39;S&#39;||s[now.x][now.y]==&#39;R&#39;||vis[now.x][now.y]==1)    continue;            if(s[now.x][now.y]==&#39;B&#39;)    now.step=mid.step+2;            else    now.step=mid.step+1;            vis[now.x][now.y]=1;            s[now.x][now.y]=now.step+&#39;0&#39;;            q.push(now);        }    }    cout&lt;&lt;ans&lt;&lt;endl;}int main(){    int sx,sy,ex,ey;    while(scanf(&quot;%d %d&quot;,&amp;m,&amp;n)&amp;&amp;m&amp;&amp;n)    {        for(int i=0;i&lt;m;i++)        {            for(int j=0;j&lt;n;j++)            {                cin&gt;&gt;s[i][j];                if(s[i][j]==&#39;Y&#39;)                {                    sx=i;                    sy=j;                }                if(s[i][j]==&#39;T&#39;)                {                    ex=i;                    ey=j;                }            }        }        bfs(sx,sy,ex,ey);//        for(int i=0;i&lt;m;i++)//        {//            for(int j=0;j&lt;n;j++)//            {//                cout&lt;&lt;s[i][j];//            }//            puts(&quot;&quot;);//        }    }}</code></pre><h3 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h3><p>Description:<br>农夫知道一头牛的位置，想要抓住它。农夫和牛都于数轴上 ，农夫起始位于点 N(0&lt;=N&lt;=100000) ，牛位于点 K(0&lt;=K&lt;=100000) 。农夫有两种移动方式： 1、从 X移动到 X-1或X+1 ，每次移动花费一分钟 2、从 X移动到 2\X ，每次移动花费一分钟 假设牛没有意识到农夫的行动，站在原地不。最少要花多少时间才能抓住牛？<br>Input<br>一行: 以空格分隔的两个字母: N 和 K<br>Output<br>一行: 农夫抓住牛需要的最少时间，单位分钟<br>Sample Input</p><blockquote><p>5 17</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint<br>农夫使用最短时间抓住牛的方案如下: 5-10-9-18-17, 需要4分钟.</p><p>Problem solving:<br>经典的BFS例题。每次往下扩展队列的时候只有3种情况。就像是经常在图里面用到的四个方向一样。判断条件中要有一个最大值，不然就有可能会一直查找下去。</p><p>Code</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int vis[1000000];int step[1000000];void bfs(int x,int y){    memset(vis,0,sizeof(vis));    queue&lt;int&gt; q;    q.push(x);    step[x]=0;    vis[x]=1;    while(!q.empty())    {        int mid=q.front(),mmp;        q.pop();        if(mid==y)        {                    cout&lt;&lt;step[y]&lt;&lt;endl;            break;        }        for(int i=0;i&lt;3;i++)        {            if(i==0)    mmp=mid-1;            if(i==1)    mmp=mid+1;            if(i==2)    mmp=mid*2;            if(mmp&gt;=0&amp;&amp;mmp&lt;1000000&amp;&amp;vis[mmp]==0)            {                q.push(mmp);                step[mmp]=step[mid]+1;                vis[mmp]=1;            }                    }    }}int main(){    int n,k;    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;k))    {        if(n&gt;=k)    cout&lt;&lt;n-k&lt;&lt;endl;        else    bfs(n,k);    }}</code></pre><h3 id="Dungeon-Master"><a href="#Dungeon-Master" class="headerlink" title="Dungeon Master"></a>Dungeon Master</h3><p>Description:<br>[NWUACM]<br>你被困在一个三维的空间中,现在要寻找最短路径逃生！<br>空间由立方体单位构成<br>你每次向上下前后左右移动一个单位需要一分钟<br>你不能对角线移动并且四周封闭<br>是否存在逃出生天的可能性？如果存在，则需要多少时间？</p><p>Input<br>输入第一行是一个数表示空间的数量。<br>每个空间的描述的第一行为L，R和C（皆不超过30）。<br>L表示空间的高度。<br>R和C分别表示每层空间的行与列的大小。<br>随后L层地牢，每层R行，每行C个字符。<br>每个字符表示空间的一个单元。&#39;#&#39;表示不可通过单元，&#39;.&#39;表示空白单元。你的起始位置在&#39;S&#39;，出口为&#39;E&#39;。<br>每层空间后都有一个空行。L，R和C均为0时输入结束。</p><p>Output - 输出<br>每个空间对应一行输出。<br>如果可以逃生，则输出如下<br>Escaped in x minute(s).<br>x为最短脱离时间。<br>如果无法逃生，则输出如下<br>Trapped!</p><p>Sample Input</p><pre><code>3 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0</code></pre><p>Sample Output</p><blockquote><p>Escaped in 11 minute(s).<br>Trapped!</p></blockquote><p>Problem solving:<br>三维中的BFS，跟平常用到的差不多。不过是6个方向，上下左右前后，然后开三位数组进行BFS就好了</p><p>Code</p><pre><code>#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;char map[30][30][30];        int sta[30][30][30];        int base[6][3] = { {-1,0,0},{1,0,0},{0,-1,0},{0,1,0},{0,0,-1},{0,0,1} };int L, R, C;struct Piont{    int x, y, z;                int step;                };struct Piont s;               struct Piont e;               struct Piont curp;            bool success(struct Piont cur){    if (cur.x == e.x &amp;&amp; cur.y == e.y &amp;&amp; cur.z == e.z)        return true;    else        return false;}bool check(int x, int y, int z){    if ((x &gt;= 0) &amp;&amp; (x &lt; L) &amp;&amp; (y &gt;= 0) &amp;&amp; (y &lt; R) &amp;&amp; (z &gt;= 0) &amp;&amp; (z &lt; C) &amp;&amp; (!sta[x][y][z]) &amp;&amp; (map[x][y][z] == &#39;.&#39; || map[x][y][z] == &#39;E&#39;))        return true;    else        return false;}void bfs(){    struct Piont next;    queue&lt;Piont&gt;q;    q.push(s);    while (!q.empty())    {        curp = q.front();        q.pop();        if (success(curp))            return;        else        {            sta[curp.x][curp.y][curp.z] = 1;            for (int i = 0; i &lt; 6; i++)            {                next.x = curp.x + base[i][0];                next.y = curp.y + base[i][1];                next.z = curp.z + base[i][2];                if (check(next.x, next.y, next.z))                        {                    next.step = curp.step + 1;                    sta[next.x][next.y][next.z] = 1;                    q.push(next);                }             }        }    }}int main(){    while (scanf(&quot;%d%d%d&quot;, &amp;L, &amp;R, &amp;C))    {        if((L == 0) &amp;&amp; (R == 0) &amp;&amp; (C == 0))            break;        memset(sta, 0, sizeof(sta));        for (int i = 0; i &lt; L; i++) {            getchar();            for (int j = 0; j &lt; R; j++) {                for (int k = 0; k &lt; C; k++)                {                    scanf(&quot;%c&quot;, &amp;map[i][j][k]);                    if (map[i][j][k] == &#39;S&#39;) {                        s.x = i;                        s.y = j;                        s.z = k;                        s.step = 0;                    }                    else if (map[i][j][k] == &#39;E&#39;)                    {                        e.x = i;                        e.y = j;                        e.z = k;                    }                }                getchar();            }        }        bfs();        if (curp.x == e.x &amp;&amp; curp.y == e.y &amp;&amp; curp.z == e.z)            printf(&quot;Escaped in %d minute(s).\n&quot;, curp.step);        else            printf(&quot;Trapped!\n&quot;);    }    return 0;}</code></pre><h3 id="Robot-Motion"><a href="#Robot-Motion" class="headerlink" title="Robot Motion"></a>Robot Motion</h3><p>Description:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094653.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094653.webp" class="img-shadow img-margin"></center></a></p><p>A robot has been programmed to follow the instructions in its path. Instructions for the next direction the robot is to move are laid down in a grid. The possible instructions are</p><p>N north (up the page)<br>S south (down the page)<br>E east (to the right on the page)<br>W west (to the left on the page)</p><p>For example, suppose the robot starts on the north (top) side of Grid 1 and starts south (down). The path the robot follows is shown. The robot goes through 10 instructions in the grid before leaving the grid.</p><p>Compare what happens in Grid 2: the robot goes through 3 instructions only once, and then starts a loop through 8 instructions, and never exits.</p><p>You are to write a program that determines how long it takes a robot to get out of the grid or how the robot loops around.<br>Input</p><blockquote><p>There will be one or more grids for robots to navigate. The data for each is in the following form. On the first line are three integers separated by blanks: the number of rows in the grid, the number of columns in the grid, and the number of the column in which the robot enters from the north. The possible entry columns are numbered starting with one at the left. Then come the rows of the direction instructions. Each grid will have at least one and at most 10 rows and columns of instructions. The lines of instructions contain only the characters N, S, E, or W with no blanks. The end of input is indicated by a row containing 0 0 0.</p></blockquote><p>Output</p><blockquote><p>For each grid in the input there is one line of output. Either the robot follows a certain number of instructions and exits the grid on any one the four sides or else the robot follows the instructions on a certain number of locations once, and then the instructions on some number of locations repeatedly. The sample input below corresponds to the two grids above and illustrates the two forms of output. The word &quot;step&quot; is always immediately followed by &quot;(s)&quot; whether or not the number before it is 1.</p></blockquote><p>Sample Input</p><blockquote><p>3 6 5<br>NEESWE<br>WWWESS<br>SNWWWW<br>4 5 1<br>SESWE<br>EESNW<br>NWEEN<br>EWSEN<br>0 0 0</p></blockquote><p>Sample Output</p><blockquote><p>10 step(s) to exit<br>3 step(s) before a loop of 8 step(s)</p></blockquote><p>Problem solving:<br>这道题我是CSDN上搜的，一开始有思路不知道怎么实现。<br>但是我们可以发现这个里面每个点就会决定自己下一步是往哪里走，所以情况是唯一的。可以直接模拟。<br>这个模拟方式很巧妙地就是标记了走到任意一个位置需要的步数，如果是走出去了，直接调用中间用来存放步数的变量的值进行输出就行。如果在循环的过程中发现下一个要去到的点对应的步数的数组已经有值了就说明此时是在里面刚好转了一圈了。而转圈之前走的步数正好是从开始走走到这个点用到的步数减一，<br>每次转圈的长度就可以用存放步数的变量的值减去到达转圈的第一个点所需要的步数来得到（可以看着代码理解，模拟一下。</p><p>Code</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char s[12][12];int vis[12][12];int main(){    int a,b,c;    while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c))    {        if(a==0&amp;&amp;b==0&amp;&amp;c==0)    break;        for(int i=0;i&lt;a;i++)            for(int j=0;j&lt;b;j++)                cin&gt;&gt;s[i][j];        int x=0,y=c-1,step=0;        memset(vis,0,sizeof(vis));        while(true)        {            step++;            if(s[x][y]==&#39;N&#39;&amp;&amp;!vis[x][y])            {                vis[x][y]=step;                x--;            }            else if(s[x][y]==&#39;S&#39;&amp;&amp;!vis[x][y])            {                vis[x][y]=step;                x++;            }            else if(s[x][y]==&#39;W&#39;&amp;&amp;!vis[x][y])            {                vis[x][y]=step;                y--;            }            else if(s[x][y]==&#39;E&#39;&amp;&amp;!vis[x][y])            {                vis[x][y]=step;                y++;            }            if(x&lt;0||x==a||y&lt;0||y==b)            {                printf(&quot;%d step(s) to exit\n&quot;,step);    break;            }            else if(vis[x][y])            {                printf(&quot;%d step(s) before a loop of %d step(s)\n&quot;,vis[x][y]-1,step+1-vis[x][y]);                break;            }        }    }}</code></pre><h3 id="Number-Transformation"><a href="#Number-Transformation" class="headerlink" title="Number Transformation"></a>Number Transformation</h3><p>Description:<br>In this problem, you are given an integer number s. You can transform any integer number A to another integer number B by adding x to A. This x is an integer number which is a prime factor of A (please note that 1 and A are not being considered as a factor of A). Now, your task is to find the minimum number of transformations required to transform s to another integer number t.</p><p>Input</p><blockquote><p>Input starts with an integer T (≤ 500), denoting the number of test cases.<br>Each case contains two integers: s (1 ≤ s ≤ 100) and t (1 ≤ t ≤ 1000).</p></blockquote><p>Output</p><blockquote><p>For each case, print the case number and the minimum number of transformations needed. If it&#39;s impossible, then print -1.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>6 12<br>6 13</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 2<br>Case 2: -1</p></blockquote><p>Problem solving:<br>暴力解决就行，数据范围很小。<br>先对素数打表，然后再进行BFS查找即可。<br>BFS中扩展队列的方式<br>对输入的s，求出s的每个质因子加上它本身之后放进队列，如果出现了与t相同的情况，退出查找即可。关于特殊情况的判定我们还用A题的方式，定义一个ans变量初始值设为-1，如果出现了相等的就对ans进行更新即可。注意，如果在扩展队列的过程中遇到了之前已经出现过的数或者这个数已经大于了t，就不需要再把这个数放进队列了。</p><p>Code</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 2005;int p[2005];int vis[2005];void init(){    p[1]=p[0]=1;    for(int i=2;i&lt;sqrt(maxn);i++)    {        for(int j=i*2;j&lt;maxn;j+=i)            p[j]=1;    }}struct node{    int x,step;};int flag;void bfs(int x,int y){    memset(vis,0,sizeof(vis));    flag=-1;    queue&lt;node&gt; q;    node now,mid;    now.x=x;now.step=0;    vis[x]=1;    q.push(now);    int ans=-1;    while(!q.empty())    {        now=q.front();        q.pop();        for(int i=2;i&lt;now.x;i++)        {            if(now.x%i==0&amp;&amp;!p[i])            {                mid.x=now.x+i;                if(vis[mid.x]||mid.x&gt;y)    continue;                vis[mid.x]=1;                mid.step=now.step+1;                if(mid.x==y)                {                    flag=mid.step;                    return ;                }                q.push(mid);            }        }    }}int main(){    int n,a,b;    cin&gt;&gt;n;    init();    int cnt=1;    while(n--)    {        int a,b;        cin&gt;&gt;a&gt;&gt;b;        cout&lt;&lt;&quot;Case &quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot;;        if(a==b)        {            puts(&quot;0&quot;);            continue;        }        bfs(a,b);        cout&lt;&lt;flag&lt;&lt;endl;    }}</code></pre><h3 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h3><p>Description:<br>A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.<br>Of course you know that it is vice versa. So you offer him to write a program that solves the &quot;difficult&quot; part.</p><p>Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.<br>Input</p><blockquote><p>The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.</p></blockquote><p>Output</p><blockquote><p>For each test case, print one line saying &quot;To get from xx to yy takes n knight moves.&quot;.</p></blockquote><p>Sample Input</p><blockquote><p>e2 e4<br>a1 b2<br>b2 c3<br>a1 h8<br>a1 h7<br>h8 a1<br>b1 c3<br>f6 f6</p></blockquote><p>Sample Output</p><blockquote><p>To get from e2 to e4 takes 2 knight moves.<br>To get from a1 to b2 takes 4 knight moves.<br>To get from b2 to c3 takes 2 knight moves.<br>To get from a1 to h8 takes 6 knight moves.<br>To get from a1 to h7 takes 5 knight moves.<br>To get from h8 to a1 takes 6 knight moves.<br>To get from b1 to c3 takes 1 knight moves.<br>To get from f6 to f6 takes 0 knight moves.</p></blockquote><p>Problem solving:<br>这道题就是一道简单的BFS模板题，只不过题不太好懂，这里我找到一张图可以参考一下。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094733.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094733.webp" class="img-shadow img-margin"></center></a><br>就是马走日的问题，分8个方向进行查找即可。从图上就可以以看出输入的字符串如何处理成坐标的形式。即</p><pre><code>while(~scanf(&quot;%s %s&quot;,a,b))    {        sx=a[0]-&#39;a&#39;+1;sy=a[1]-&#39;0&#39;;ex=b[0]-&#39;a&#39;+1;ey=b[1]-&#39;0&#39;;</code></pre><p>Code</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int vis[10][10],sx,sy,ex,ey;struct node{    int x,y,step;};int d[8][2]={-2,-1, -1,-2, 1,-2, 2,-1, 2,1, 1,2, -1,2, -2,1};int bfs(int x,int y){    memset(vis,0,sizeof(vis));    queue&lt;node&gt; que;    vis[x][y]=1;    node now,mid;    now.x=x;now.y=y;now.step=0;    que.push(now);    while(!que.empty())    {                now=que.front();que.pop();        if(now.x==ex&amp;&amp;now.y==ey)        {            return now.step;        }        for(int i=0;i&lt;8;i++)        {            mid.x=now.x+d[i][0];            mid.y=now.y+d[i][1];            if(mid.x&lt;=0||mid.x&gt;8||mid.y&lt;=0||mid.y&gt;8||vis[mid.x][mid.y])    continue;            vis[mid.x][mid.y]=1;            mid.step=now.step+1;            que.push(mid);        }    }}int main(){    char a[3],b[3];    while(~scanf(&quot;%s %s&quot;,a,b))    {        int m;        sx=a[0]-&#39;a&#39;+1;sy=a[1]-&#39;0&#39;;ex=b[0]-&#39;a&#39;+1;ey=b[1]-&#39;0&#39;;//        cout&lt;&lt;sx&lt;&lt;sy&lt;&lt;ex&lt;&lt;ey&lt;&lt;endl;        m=bfs(sx,sy);        cout&lt;&lt;&quot;To get from &quot;&lt;&lt;a&lt;&lt;&quot; to &quot;&lt;&lt;b&lt;&lt;&quot; takes &quot;&lt;&lt;m&lt;&lt;&quot; knight moves.&quot;&lt;&lt;endl;    }}//To get from e2 to e4 takes 2 knight moves.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
            <tag> Thinking </tag>
            
            <tag> Simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 6（河南理工大学暑期第六天）</title>
      <link href="/2019/07/22/6/"/>
      <url>/2019/07/22/6/</url>
      
        <content type="html"><![CDATA[<h3 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h3><p>Description:<br>My birthday is coming up and traditionally I&#39;m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though.</p><p>My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size.</p><p>What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.<br>Input<br>One line with a positive integer: the number of test cases. Then for each test case:<br>---One line with two integers N and F with 1 &lt;= N, F &lt;= 10 000: the number of pies and the number of friends.<br>---One line with N integers ri with 1 &lt;= ri &lt;= 10 000: the radii of the pies.<br>Output<br>For each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^(-3).<br>Sample Input</p><blockquote><p>3<br>3 3<br>4 3 3<br>1 24<br>5<br>10 5<br>1 4 2 3 4 5 6 5 4 2</p></blockquote><p>Sample Output</p><blockquote><p>25.1327<br>3.1416<br>50.2655</p></blockquote><p>Problem solving:<br>注意到人数也得算得上自己，然后因为每个人分到的pie必须是一块（所以不可以平均分），这个时候就用到二分答案了。<br>二分中检测是否满足题意的判断方法是，用一个for循环计算出以每人分到mid面积时可以分给多少人，跟需要分到的人数进行比较就行了。<br>Code:</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const double pi = acos(-1.0);double       s[10005];int main(){    int n;    cin &gt;&gt; n;    while (n--)    {        int a, b, x; double sum = 0, pm = 0;        cin &gt;&gt; a &gt;&gt; b;        b += 1;        for (int i = 0; i &lt; a; i++)        {            cin &gt;&gt; x;            s[i] = x * x * pi;            sum += s[i];            pm   = max(pm, s[i]);        }        double l = 0, r = sum / b, mid;        while (r - l &gt; 0.000001)        {            mid = (r + l) / 2;            int now = 0;            for (int i = 0; i &lt; a; i++)            {                now += int(s[i] / mid);            }            if (now &lt; b)                r = mid;            else                l = mid;        }        printf(&quot;%.4lf\n&quot;, mid);    }}</code></pre><h3 id="Best-Cow-Line"><a href="#Best-Cow-Line" class="headerlink" title="Best Cow Line"></a>Best Cow Line</h3><p>Description:<br>FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual&quot;Farmer of the Year&quot; competition. In this contest every farmer arranges his cows in a line and herds them past the judges.</p><p>The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows&#39; names.</p><p>FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.</p><p>FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he&#39;s finished, FJ takes his cows for registration in this new order.</p><p>Given the initial order of his cows, determine the least lexicographic string of initials he can make this way.</p><p>Input</p><ul><li>Line 1: A single integer: N</li><li>Lines 2: N+1: Line i+1 contains a single initial (&#39;A&#39;..&#39;Z&#39;) of the cow in the ith position in the original line</li></ul><p>Output<br>The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (&#39;A&#39;..&#39;Z&#39;) in the new line.</p><p>Sample Input</p><blockquote><p>6<br>A<br>C<br>D<br>B<br>C<br>B</p></blockquote><p>Sample Output</p><blockquote><p>ABCBCD</p></blockquote><p>Problem solving:<br>白书原题，经典贪心问题。先比较当前的第一个和最后一个字符，如果想等就比较第二个和倒数第二个字符，以此找到前后字符的大小关系，然后进行删除和添加的操作就行了。具体看代码。<br>注意，每输出80个字符就得换行！！！</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n;char a[2005];void solve(){    int p=0,x=0,b=n-1;    while(x&lt;=b)    {        int flag=0;        for(int i=0;x+i&lt;=b;i++)        {            if(a[x+i]&lt;a[b-i])            {                flag=1;                break;            }            else if(a[x+i]&gt;a[b-i])            {                flag=0;                break;            }        }        if(flag)    putchar(a[x++]);        else    putchar(a[b--]);        p++;        if(p%80==0)    puts(&quot;&quot;);    }    puts(&quot;&quot;);}int main(){    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];    solve();    return 0;}</code></pre><h3 id="Trailing-Zeroes-III"><a href="#Trailing-Zeroes-III" class="headerlink" title="Trailing Zeroes (III)"></a>Trailing Zeroes (III)</h3><p>Description:<br>You task is to find minimal natural number N, so that N! contains exactly Q zeroes on the trail in decimal notation. As you know N! = 1<em>2</em>...*N. For example, 5! = 120, 120 contains one zero on the trail.</p><p>Input<br>Input starts with an integer T (≤ 10000), denoting the number of test cases.</p><p>Each case contains an integer Q (1 ≤ Q ≤ 1e8) in a line.</p><p>Output<br>For each case, print the case number and N. If no solution is found then print &#39;impossible&#39;.</p><p>Sample Input</p><blockquote><p>3<br>1<br>2<br>5</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 5<br>Case 2: 10<br>Case 3: impossible</p></blockquote><p>Problem solving:<br>求n的阶乘的0的个数，只需要求得n中5得个数即可。因为只有2*5=10，所以每一个0都对应着一个2和一个5，而二的个数多于5，所以我们只要找到5得个数就是0得个数。</p><pre><code>\\找5得个数得方法long long co(long long x){    long long ans = 0;    while (x)    {        ans += x / 5;        x /= 5;    }    return ans;}</code></pre><p>剩下的就是二分答案。注意这道题存在着“impossible”得情况，所以在二分得过程中如果遇到了满足题意得mid，一定要记录下来。方便后面判断。</p><p>Code:</p><pre><code>#include &lt;iostream&gt;using namespace std;long long co(long long x){    long long ans = 0;    while (x)    {        ans += x / 5;        x /= 5;    }    return ans;}int main(){    long long t, q;    cin &gt;&gt; t;    long long cas = 1;    while (t--)    {        cin &gt;&gt; q; long long flag = 0;        long long           l = 1, r = 1000000000000, mid;        while (l &lt;= r)        {            mid = (l + r) / 2;            if (co(mid) == q)            {                flag = mid;                r    = mid - 1;            }            else if (co(mid) &gt; q)                r = mid - 1;            else                l = mid + 1;        }        if (flag)            cout &lt;&lt; &quot;Case &quot; &lt;&lt; cas++ &lt;&lt; &quot;: &quot; &lt;&lt; flag &lt;&lt; endl;        else            cout &lt;&lt; &quot;Case &quot; &lt;&lt; cas++ &lt;&lt; &quot;: &quot; &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    }}</code></pre><h3 id="The-Frog-39-s-Games"><a href="#The-Frog-39-s-Games" class="headerlink" title="The Frog&#39;s Games"></a>The Frog&#39;s Games</h3><p>Description:<br>The annual Games in frogs&#39; kingdom started again. The most famous game is the Ironfrog Triathlon. One test in the Ironfrog Triathlon is jumping. This project requires the frog athletes to jump over the river. The width of the river is L (1&lt;= L &lt;= 1000000000). There are n (0&lt;= n &lt;= 500000) stones lined up in a straight line from one side to the other side of the river. The frogs can only jump through the river, but they can land on the stones. If they fall into the river, they<br>are out. The frogs was asked to jump at most m (1&lt;= m &lt;= n+1) times. Now the frogs want to know if they want to jump across the river, at least what ability should they have. (That is the frog&#39;s longest jump distance).<br>Input<br>The input contains several cases. The first line of each case contains three positive integer L, n, and m.<br>Then n lines follow. Each stands for the distance from the starting banks to the nth stone, two stone appear in one place is impossible.<br>Output<br>For each case, output a integer standing for the frog&#39;s ability at least they should have.<br>Sample Input</p><blockquote><p>6 1 2<br>2<br>25 3 3<br>11<br>2<br>18</p></blockquote><p>Sample Output</p><blockquote><p>4<br>11</p></blockquote><p>Problem solving:<br>题意就是让你找到青蛙得最大的最小弹跳力，即每次可以跳的最远距离。<br>左边界时每个石头间距的最大值，右边界是河的宽度，然后进行二分。每次二分的时候，找到处于当前位置位置的青蛙跳一次mid的距离刚好最小到达的点，然后进行下一次循环（具体看代码吧）<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500005;int a[maxn];int main(){    int i,L,n,m;    while(scanf(&quot;%d%d%d&quot;,&amp;L,&amp;n,&amp;m)!=EOF)    {        memset(a,0,sizeof(a));        for(i=1;i&lt;=n;i++)            scanf(&quot;%d&quot;,&amp;a[i]);        a[n+1]=L;        sort(a+1,a+n+2);        int maxx=0;        for(i=1;i&lt;=n+1;i++)        {            if(a[i]-a[i-1]&gt;maxx)            maxx=a[i]-a[i-1];                }        int l=maxx,r=L;        while(l&lt;=r)        {            int ans=0,pos=0;            int mid=(l+r)/2;            for(i=1;i&lt;=n;i++)            {                if(a[i]-a[pos]&lt;=mid&amp;&amp;a[i+1]-a[pos]&gt;mid)//i即为青蛙跳一次之后到达的最远的石头                {                    pos=i;                    ans++;                }            }            ans++;            if(ans&lt;=m)    r=mid-1;            else    l=mid+1;        }        printf(&quot;%d\n&quot;,l);    }    return 0;}</code></pre><h3 id="湫湫系列故事——消灭兔子"><a href="#湫湫系列故事——消灭兔子" class="headerlink" title="湫湫系列故事——消灭兔子"></a>湫湫系列故事——消灭兔子</h3><p>Description:<br>湫湫减肥<br>　　越减越肥！<br>　　<br>　　最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。<br>　　游戏规则很简单，用箭杀死免子即可。<br>　　箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。<br>　　假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。<br>Input<br>输入数据有多组，每组数据有四行；<br>第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；<br>第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；<br>第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；<br>第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。</p><p>特别说明：<br>1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；<br>2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。<br>Output<br>如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。<br>Sample Input</p><blockquote><p>3 3<br>1 2 3<br>2 3 4<br>1 2 3<br>3 4<br>1 2 3<br>1 2 3 4<br>1 2 3 1</p></blockquote><p>Sample Output</p><blockquote><p>6<br>4</p></blockquote><p>Problem solving:<br>将兔子的血量进行降序排序，然后将剑按照攻击力降序排列，如果攻击力相等就按照qq币的花费降序排列。<br>要用到优先队列，对降序排列的兔子，找到攻击力大于它的剑，放进优先队列，直到攻击力小于兔子的血量，然后答案加上优先队列顶部的qq消费。如果兔子还没杀完队列就为空了，就输出no。贪心的思想。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;struct node{    int d,p;    friend bool operator &lt; (node a,node b)    {        return a.p&gt;b.p;    }}x[maxn];int b[maxn];bool cmp2(int x,int y){    return x&gt;y;}bool cmp(node a,node b){    if(a.d==b.d)    return a.p&gt;b.p;    return a.d&gt;b.d;}int main(){    int n,m;    while(cin&gt;&gt;n&gt;&gt;m)    {        for(int i=0;i&lt;n;i++)    cin&gt;&gt;b[i];        sort(b,b+n,cmp2);        for(int i=0;i&lt;m;i++)    cin&gt;&gt;x[i].d;        for(int i=0;i&lt;m;i++)    cin&gt;&gt;x[i].p;        sort(x,x+m,cmp);        priority_queue&lt;node&gt; sta;        int pos=0;        long long ans=0;        int flag=0;        for(int i=0;i&lt;n;i++)        {            while(x[pos].d&gt;=b[i]&amp;&amp;pos&lt;m)            {                sta.push(x[pos]);//                cout&lt;&lt;x[pos].d&lt;&lt;&quot; &quot;&lt;&lt;x[pos].p&lt;&lt;endl;                pos++;            }            if(sta.empty())            {                flag=1;                break;            }//            cout&lt;&lt;sta.top().p&lt;&lt;&quot;?\n&quot;;            ans+=sta.top().p;            sta.pop();        }        if(flag)    puts(&quot;No&quot;);        else    cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="Strange-fuction"><a href="#Strange-fuction" class="headerlink" title="Strange fuction"></a>Strange fuction</h3><p>Description:<br>Now, here is a fuction:<br>  F(x) = 6 <em> x^7+8</em>x^6+7<em>x^3+5</em>x^2-y*x (0 &lt;= x &lt;=100)<br>Can you find the minimum value when x is between 0 and 100.<br>Input<br>The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)<br>Output<br>Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.<br>Sample Input</p><blockquote><p>2<br>100<br>200</p></blockquote><p>Sample Output</p><blockquote><p>-74.4291<br>-178.8534</p></blockquote><p>Problem solving:<br>简单的数学题，求函数极值，对函数求一阶导，另它为0即可，因为本题中二次导之后函数恒大于0所以一阶导为0求出来的极值就是极小值。确定x的值得时候用二分确定</p><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int    t;    double y;    cin &gt;&gt; t;    while (t--)    {        cin &gt;&gt; y;        double l = 0, r = 100, x;        while (r - l &gt; 0.000001)        {            x = (l + r) / 2;            double mmp;            mmp = 42 * pow(x, 6) + 48 * pow(x, 5) + 21 * pow(x, 2) + 10 * x;            if (mmp &lt; y)                l = x;            else                r = x;        }        double ans = 6 * pow(x, 7) + 8 * pow(x, 6) + 7 * pow(x, 3) + 5 * x * x - y * x;        printf(&quot;%.4lf\n&quot;, ans);    }    return 0;}</code></pre><h3 id="Can-you-find-it"><a href="#Can-you-find-it" class="headerlink" title="Can you find it?"></a>Can you find it?</h3><p>Description:<br>Give you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X.<br>Input<br>There are many cases. Every data case is described as followed: In the first line there are three integers L, N, M, in the second line there are L integers represent the sequence A, in the third line there are N integers represent the sequences B, in the forth line there are M integers represent the sequence C. In the fifth line there is an integer S represents there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500, 1&lt;=S&lt;=1000. all the integers are 32-integers.<br>Output<br>For each case, firstly you have to print the case number as the form &quot;Case d:&quot;, then for the S queries, you calculate if the formula can be satisfied or not. If satisfied, you print &quot;YES&quot;, otherwise print &quot;NO&quot;.<br>Sample Input</p><blockquote><p>3 3 3<br>1 2 3<br>1 2 3<br>1 2 3<br>3<br>1<br>4<br>10</p></blockquote><p>Sample Output</p><blockquote><p>Case 1:<br>NO<br>YES<br>NO</p></blockquote><p>Problem solving:<br>优雅的暴力之后再二分查找。<br>把前两个数组可以组成的所有的和用一个数组存下来（这一步最坏的情况的复杂度也才O（2e5），显然不会超时。然后对接下来输入的需要判断的每个值进行查找，对第三个数组中的每一个数<br>使用二分查找去找两者的差值再上一步得到的新数组中有没有存在。有即YES，否则就是NO。<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 505;int       a[maxn], b[maxn], c[maxn], d[250005];int main(){    int l, n, m, cas = 0;    while (~scanf(&quot;%d %d %d&quot;, &amp;l, &amp;n, &amp;m))    {        for (int i = 0; i &lt; l; i++)            cin &gt;&gt; a[i];        for (int j = 0; j &lt; n; j++)            cin &gt;&gt; b[j];        for (int k = 0; k &lt; m; k++)            cin &gt;&gt; c[k];        int pos = 0;        sort(a, a + l); sort(b, b + n);        for (int i = 0; i &lt; l; i++)        {            for (int j = 0; j &lt; n; j++)            {                d[pos++] = a[i] + b[j];            }        }        sort(d, d + pos); sort(c, c + m);        cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++cas &lt;&lt; &quot;:\n&quot;;        int p, mid;        cin &gt;&gt; p;        while (p--)        {            int flag = 0;            cin &gt;&gt; mid;            for (int i = 0; i &lt; m; i++)            {                if (binary_search(d, d + pos, mid - c[i]))                {                    flag = 1;                    break;                }            }            if (flag)                puts(&quot;YES&quot;);            else                puts(&quot;NO&quot;);        }    }}</code></pre><h3 id="pairs"><a href="#pairs" class="headerlink" title="pairs"></a>pairs</h3><p>Description:<br>John has n points on the X axis, and their coordinates are (x[i],0),(i=0,1,2,…,n−1). He wants to know how many pairs<a,b> that |x[b]−x[a]|≤k.(a<b) input the first line contains a single integer t (about 5), indicating number of cases. each test case begins with two integers n,k(1≤n≤100000,1≤k≤1e9). next n lines contain an xi(−1e9≤x[i]≤1e9), means x coordinates. output for case, how many pairs<a,b> that |x[b]−x[a]|≤k.<br>Sample Input</b)></a,b></p><blockquote><p>2<br>5 5<br>-100<br>0<br>100<br>101<br>102<br>5 300<br>-100<br>0<br>100<br>101<br>102</p></blockquote><p>Sample Output</p><blockquote><p>3<br>10</p></blockquote><p>Problem solving:<br>排序之后直接进行二分查找，用lower_bound()或者手写也行，复杂度是O(N)</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=1e5+7;long long p[maxn];int main(){    long long t,a,b;    cin&gt;&gt;t;    while(t--)    {        cin&gt;&gt;a&gt;&gt;b;        for(long long i=0;i&lt;a;i++    )    cin&gt;&gt;p[i];        sort(p,p+a);        long long ans=0,pos=0;        for(long long i=0;i&lt;a;i++)        {            while(p[pos]-p[i]&lt;=b&amp;&amp;pos&lt;a)    pos++;            ans+=pos-i-1;        }        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h3 id="Radar-Installation"><a href="#Radar-Installation" class="headerlink" title="Radar Installation"></a>Radar Installation</h3><p>Description:<br>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.</p><p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.</p><p>Figure A Sample Input of Radar Installations<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094431.webp" data-fancybox="images" data-caption="主人没有描述我哦~" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094431.webp" class="img-shadow img-margin"></center></a></p><p>Input<br>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.</p><p>The input is terminated by a line containing pair of zeros<br>Output<br>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. &quot;-1&quot; installation means no solution for that case.<br>Sample Input</p><blockquote><p>3 2<br>1 2<br>-3 1<br>2 1<br>1 2<br>0 2<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 2<br>Case 2: 1</p></blockquote><p>Problem solving:<br>这道题跟暑假不AC很像（在前几天的训练中做过），对每个岛的坐标求出来以它为圆心，雷达探测半径为半径的圆与x的两个交点，然后对得到的每组左右端点进行贪心。（我的代码这里写的有点麻烦了，直接输入求交点就行，不用存岛的坐标）。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct node{    int x,y;    double l,r;}p[1005];bool cmp(node x,node y){    if(x.r==y.r)    return x.l&gt;y.l;    return x.r&lt;y.r;}int main(){    int n,d,i=0;    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;d)&amp;&amp;n&amp;&amp;d)    {        int flag=0;        for(int i=0;i&lt;n;i++)    cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        for(int i=0;i&lt;n;i++)        {            if(p[i].y&gt;d)            {                flag=1;            }            double mid;            mid=sqrt(d*d-p[i].y*p[i].y);            p[i].l=p[i].x-mid;            p[i].r=p[i].x+mid;        }        if(flag)    cout&lt;&lt;&quot;Case &quot;&lt;&lt;++i&lt;&lt;&quot;: -1&quot;&lt;&lt;endl;        else        {            sort(p,p+n,cmp);            int ans=1;double ri=p[0].r;            for(int i=1;i&lt;n;i++)            {                if(p[i].l&gt;ri)                {                    ans++;                    ri=p[i].r;                }            }            cout&lt;&lt;&quot;Case &quot;&lt;&lt;++i&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;                    }    }}</code></pre><h3 id="Aggressive-cows"><a href="#Aggressive-cows" class="headerlink" title="Aggressive cows"></a>Aggressive cows</h3><p>Description:<br>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,...,xN (0 &lt;= xi &lt;= 1,000,000,000).</p><p>His C (2 &lt;= C &lt;= N) cows don&#39;t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?<br>Input</p><ul><li><p>Line 1: Two space-separated integers: N and C</p></li><li><p>Lines 2..N+1: Line i+1 contains an integer stall location, xi<br>Output</p></li><li>Line 1: One integer: the largest minimum distance</li></ul><p>Sample Input</p><blockquote><p>5 3<br>1<br>2<br>8<br>4<br>9</p></blockquote><p>Sample Output</p><blockquote><p>3</p></blockquote><p>Hint<br>OUTPUT DETAILS:</p><p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p><p>Huge input data,scanf is recommended.</p><p>Problem solving:<br>白书原题，经典二分题，二分答案，对mid的检测方法是看它能不能满足以mid为最小的距离时能住下的牛的个数大于等于要求的个数。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll n,c;ll a[100005];bool check(ll x){    ll mmp=0;    for(int i=1;i&lt;c;i++)    {        ll mid=mmp+1;        while(mid&lt;n&amp;&amp;a[mid]-a[mmp]&lt;x)        {            mid++;        }        if(mid==n)    return 0;        mmp=mid;    }    return 1;}int main(){    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;c);    for(ll i=0;i&lt;n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i]);    }    sort(a,a+n);    ll l=0,r=1e18,mid;    while(r-l&gt;1)    {        mid=(l+r)/2;        if(check(mid))        {            l=mid;        }        else            r=mid;    }    printf(&quot;%lld\n&quot;,l);}</code></pre><h3 id="River-Hopscotch"><a href="#River-Hopscotch" class="headerlink" title="River Hopscotch"></a>River Hopscotch</h3><p>Description:<br>Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, L units away from the start (1 ≤ L ≤ 1,000,000,000). Along the river between the starting and ending rocks, N (0 ≤ N ≤ 50,000) more rocks appear, each at an integral distance Di from the start (0 &lt; Di &lt; L).</p><p>To play the game, each cow in turn starts at the starting rock and tries to reach the finish at the ending rock, jumping only from rock to rock. Of course, less agile cows never make it to the final rock, ending up instead in the river.</p><p>Farmer John is proud of his cows and watches this event each year. But as time goes by, he tires of watching the timid cows of the other farmers limp across the short distances between rocks placed too closely together. He plans to remove several rocks in order to increase the shortest distance a cow will have to jump to reach the end. He knows he cannot remove the starting and ending rocks, but he calculates that he has enough resources to remove up to M rocks (0 ≤ M ≤ N).</p><p>FJ wants to know exactly how much he can increase the shortest distance <em>before</em> he starts removing the rocks. Help Farmer John determine the greatest possible shortest distance a cow has to jump after removing the optimal set of M rocks.</p><p>Input<br>Line 1: Three space-separated integers: L, N, and M<br>Lines 2.. N+1: Each line contains a single integer indicating how far some rock is away from the starting rock. No two rocks share the same position.<br>Output<br>Line 1: A single integer that is the maximum of the shortest distance a cow has to jump after removing M rocks<br>Sample Input</p><blockquote><p>25 5 2<br>2<br>14<br>11<br>21<br>17</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint<br>Before removing any rocks, the shortest jump was a jump of 2 from 0 (the start) to 2. After removing the rocks at 2 and 14, the shortest required jump is a jump of 4 (from 17 to 21 or from 21 to 25).</p><p>Problem solving:<br>一开始以为这道题用贪心，但是涉及到删除这个操作就很烦。<br>后来发现者就是一道二分答案的题，套板子就行。<br>check函数里面判断的条件就是当最小距离已知时，求出它对应的需要拿走石头的值，与输入的进行比较。（一开始直接循环判断样例都不过，后来才想到不能直接判断，因为有可能一次跳两个石头。所以需要这样写</p><pre><code>int mid=0,pos=0;for(int i=1;i&lt;=n+1;i++){    if(a[i]-a[pos]&lt;x)        mid++;    else        pos=i;}</code></pre><p>mid即为当前假设的最小距离所对应的需要拿走的石头个数，然后二分答案就行了。</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=50005;int a[maxn];int l,n,m;bool check(int x){    int mid=0,pos=0;    for(int i=1;i&lt;=n+1;i++)    {        if(a[i]-a[pos]&lt;x)            mid++;        else            pos=i;    }    if(mid&gt;m)    return 0;    return 1;}int main(){    cin&gt;&gt;l&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i];    }    sort(a+1,a+n+1);    a[n+1]=l,a[0]=0;    int l=0,r=1e9,mid;    while(l&lt;=r)    {        mid=(l+r)/2;        if(check(mid))    l=mid+1;        else r=mid-1;    }    cout&lt;&lt;l-1&lt;&lt;endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> STL </tag>
            
            <tag> Greedy </tag>
            
            <tag> Binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 5（河南理工大学暑期第五天）</title>
      <link href="/2019/07/21/5/"/>
      <url>/2019/07/21/5/</url>
      
        <content type="html"><![CDATA[<p>跟几个玩的不错的朋友去看了银河补习班，一开始朋友邀请我去看的时候我是拒绝的，但一听说是邓超演的我就同意了，还是很喜欢邓超的。这个电影看之前就听说让自备纸巾，还是很有自信心的。一开始演的还不错，影片就是讲述了一个成功的儿子是如何在爸爸的帮助下变得成功的。看到后来有些无聊，不过还是很值的去看的，虽然我自己带的纸巾也没用上，主要是我泪点高？<br>没有刷题的一天，按理说应该挺开心的，但是看到旁边的人都在刷题，唉，这可能就是我菜的原因吧Orz。</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> movie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 4（河南理工大学暑期第四天）</title>
      <link href="/2019/07/20/4/"/>
      <url>/2019/07/20/4/</url>
      
        <content type="html"><![CDATA[<p>又是自闭的一天，第一次积分赛暗淡收场，这种被打爆的感觉没人会喜欢的吧，好好补题，好好学习。<br>刷题日记：<a href="https://blog.cndrew.cn/blog/2019/07/20/jifen/" target="_blank" rel="noopener">https://blog.cndrew.cn/blog/2019/07/20/jifen/</a></p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河南理工大学算法协会暑期集训积分赛（一）</title>
      <link href="/2019/07/20/jf11/"/>
      <url>/2019/07/20/jf11/</url>
      
        <content type="html"><![CDATA[<h3 id="Nth-power-of-n"><a href="#Nth-power-of-n" class="headerlink" title="Nth power of n"></a>Nth power of n</h3><p>Descripition:<br>求 nn 的个位数。</p><p>输入格式<br>多组输入，处理到文件结束。<br>每组数据输入一个 n。(1≤n≤1e9)</p><p>输出格式<br>输出 nn 的个位数。</p><p>样例<br>input<br>1<br>2<br>3<br>output<br>1<br>4<br>7<br>Problem solving:<br>快速幂的板子题，对10取模即可。<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll poww(ll x,ll y){    ll ans=1;    while(y)    {        if(y&amp;1)    ans=ans*x%10;        x=x*x%10;        y/=2;    }    return ans;}int main(){    ll n;    while(~scanf(&quot;%lld&quot;,&amp;n))    {        cout&lt;&lt;poww(n,n)&lt;&lt;endl;    }    return 0;}</code></pre><h3 id="复读机的力量"><a href="#复读机的力量" class="headerlink" title="复读机的力量"></a>复读机的力量</h3><p>Descripition:<br>Codancer: “我好菜啊！”<br>Dicer: “我好菜啊！”<br>Todest: “我好菜啊！”<br>CaprYang: “我好菜啊！”<br>…<br>大佬们又开始装弱了，真正的菜鸡瑟瑟发抖不敢说话。</p><p>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。</p><p>输入格式<br>输入T组,(1≤T≤10)<br>每组第一行输入一个正整数N,表示聊天记录的长度（1≤N≤10000）。<br>接下来N行，每行两个字符串，前一个字符串为姓名，后一个字符为聊天记录。<br>保证所有字符串长度不超过50，保证所有字符串只包含小写字母.</p><p>输出格式<br>如果没有复读机，输出 “Unbelievable!”(不包含引号）<br>否则按照熟练度从大到小输出所有的复读机，如果熟练度相同，按照字典序从小到大输出。</p><p>样例<br>input<br>1<br>4<br>codancer iamsovegetable<br>dicer iamsovegetable<br>todest iamsovegetable<br>capryang iamsovegetable<br>output<br>capryang<br>dicer<br>todest<br>提示<br>数据保证上面大佬们说的话都是瞎话。</p><p>Problem solving:<br>不难，但是是一道送命题。需要注意的是当一个人说的每一句话都是复读的上一个人说的话的时候他才能算得上是复读机。然后就是map，结构体，set之类的使用。具体可以看代码</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;struct node{    string x,y;}p[10005];struct nod{    string na;    int fo;}pp[10005];bool cmp(nod m,nod n){    if(m.fo==n.fo)    return m.na&lt;n.na;    return m.fo&gt;n.fo;}int main(){    int t,n;    cin&gt;&gt;t;    string x,y;    while(t--)    {        cin&gt;&gt;n;        set&lt;string&gt; se;        map&lt;string,int&gt; ma;        map&lt;string,int&gt; mp;        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;            se.insert(p[i].x);            ma[p[i].x]=1;        }        ma[p[0].x]=0;        for(int i=1;i&lt;n;i++)        {            if(p[i].y==p[i-1].y)                mp[p[i].x]++;            if(p[i].y!=p[i-1].y)                ma[p[i].x]=0;        }        int pos=0;        for(set&lt;string&gt;::iterator it=se.begin();it!=se.end();it++)        {            if(ma[*it])            {                pp[pos].na=*it;                pp[pos].fo=mp[*it];                pos++;            }        }        if(pos==0) puts(&quot;Unbelievable!&quot;);        else        {                    sort(pp,pp+pos,cmp);            for(int i=0;i&lt;pos;i++)            {                cout&lt;&lt;pp[i].na&lt;&lt;endl;            }        }    }}</code></pre><h3 id="无穷的小数"><a href="#无穷的小数" class="headerlink" title="无穷的小数"></a>无穷的小数</h3><p>Descripition:<br>在十进制下，我们能够很轻易地判断一个小数的位数是有穷的或无穷的，但是把这个小数用二进制表示出的情况下其有穷性和无穷性就会发生改变，比如</p><p>十进制下的 0.5 ,在二进制下的值为 0.1 ；<br>十进制下的 0.75 ,在二进制下的值为 0.11 ；<br>十进制下的 0.6 ,在二进制下的值为 0.1001100......</p><p>给你一个十进制的小数，判断其在二进制表示下小数位数是否无穷。</p><p>输入格式<br>多组输入，处理到文件结束<br>每组数据输入一个六位的小数 n.(0≤n\&lt;1)</p><p>输出格式<br>如果在二进制下小数位数是有穷的，输出”YES”,否则输出”NO”.</p><p>样例<br>input<br>0.500000<br>0.600000<br>0.750000<br>output<br>YES<br>NO<br>YES</p><p>Problem solving:<br>我拿了一血，主要是一开始大佬们没有注意到这个水题233.<br>模拟就行了，小数转换成二进制就是每次乘以2直到等于1.如果一个小数在二进制表示下小数位数是无穷的，意思就是无论它承几次2，都不会正好等于1。我们只需要乘以2一定的次数，如果出现1，就不是无穷的，反之即无穷的。这个次数我写的时候用的100，后来结束后各种测试发现最小改成6也能过Orz。<br>官方题解里面说会有精度问题，但是我没遇到哈，double过了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    double s;    while(~scanf(&quot;%lf&quot;,&amp;s))    {        int i=0,flag=0;        while(i&lt;=6)        {            s*=2;            if(s==int(s))    flag=1;            i++;        }        if(!flag)    cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        else    puts(&quot;YES&quot;);    }    return 0;}</code></pre><h3 id="Special-String"><a href="#Special-String" class="headerlink" title="Special String"></a>Special String</h3><p>Descripition:<br>我们定义一个字符串S为Special String只要这个字符串满足下面这些条件:<br>1.这个串是回文的，即把这个字符串正着读和反着读相同，如abba和aca，而ba和abca则不是。<br>2.26个小写字母必须全部出现<br>3.这个串的长度为偶数。<br>对于给定的S,判断它是否是Special String.</p><p>输入格式<br>输入一个只由小写字母组成的字符串S。(1≤|S|≤1e5)</p><p>输出格式<br>如果这个字符串是Special String，输出”YE5”,否则输出”N0”</p><p>样例<br>input<br>aaaa<br>output<br>N0<br>input<br>abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba<br>output<br>YE5</p><p>Problem solving:<br>这道题，很厉害，很难！<br>三个条件的判断：<br>回文串的判断可以通过可以翻转之后比较或者比较对称位置上的字符是否相等来实现<br>26个字母都必须出现的判断，因为保证输入是小写字母，用一个set就行，最后看set的大小是否为26.<br>长度为偶数这个就不用说了。</p><p>最难的地方来了，<font color="red">是&#39;YE5&#39;和&#39;N0&#39;，不是&#39;YES&#39;和&#39;NO&#39;。。。学长tql。</font></p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    string s,mid;    cin&gt;&gt;s;    set&lt;char&gt; se;    int flag=0,len=s.size();    if(len%2==0)    flag++;    for(int i=0;i&lt;len;i++)    se.insert(s[i]);    if(se.size()==26)    flag++;    mid=s;    reverse(s.begin(),s.end());    if(mid==s)    flag++;    if(flag==3)    puts(&quot;YE5&quot;);    else puts(&quot;N0&quot;);    return 0;}</code></pre><h3 id="Max-Gcd"><a href="#Max-Gcd" class="headerlink" title="Max Gcd"></a>Max Gcd</h3><p>Descripition:<br>一个数组a，现在你需要删除某一项使得它们的gcd最大，求出这个最大值。</p><p>输入格式<br>第一行输入一个正整数n，表示数组的大小，接下来一行n个数，第i个数为ai。(2≤n≤1e5,1≤ai≤1e9)</p><p>输出格式<br>输出删除掉某个数以后的gcd的最大值。</p><p>样例<br>input<br>4<br>2 4 8 1<br>output<br>2<br>input<br>4<br>1 2 3 4<br>output<br>1<br>提示<br>样例一：删除第四个元素后，2,4,8的最大公因子为2。<br>样例二：无论删除哪一个，最大公因子都为1。</p><p>Problem solving:<br>比赛的时候这题毫无思路，，，<br>完了之后了解到，是使用了一个前缀gcd数组和一个后缀gcd数组来实现求去掉第I位数字之后剩余所有数字的gcd。<br>b为前缀gcd数组，c为后缀gcd数组<br>那么去点第I位的数字之后剩余所有数字的gcd就是<br>gcd（b[i-1],c[i+1]）<br>这种思想是真的巧妙。<br>我师父还想到了一种贪心的解法，但是我没听太懂233，总之很强就对了。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a[200005];int b[200005];int c[200005];int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];    b[0]=a[0];    for(int i=1;i&lt;n;i++)    {        b[i]=__gcd(b[i-1],a[i]);//        cout&lt;&lt;b[i]&lt;&lt;endl;    }    c[0]=a[n-1];    for(int i=n-1;i&gt;=0;i--)    {        c[i]=__gcd(c[i+1],a[i]);    }    int ans=0;    for(int i=0;i&lt;n;i++)    {        if(i==0)    ans=max(ans,c[1]);        else if(i==n-1)    ans=max(ans,b[n-2]);        else ans=max(ans,__gcd(b[i-1],c[i+1]));    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h3 id="Count-Prime-Pairs"><a href="#Count-Prime-Pairs" class="headerlink" title="Count Prime Pairs"></a>Count Prime Pairs</h3><p>Descripition:<br>对于数组a，如果i≠j并且ai+aj是一个质数，那么我们就称(i,j)为质数对，计算数组中质数对的个数。</p><p>输入格式<br>第一行输入一个n，表示数组的长度,接下来n个整数，第i个数代表ai。<br>(1≤n≤100000,0≤ai≤100)</p><p>输出格式<br>输出数组中质数对的个数。</p><p>样例<br>input<br>3<br>1 2 3<br>output<br>4<br>提示<br>样例说明：a1+a2,a2+a1,a2+a3,a3+a2都为质数，总共有四对。<br>Problem solving:<br>其实比赛的时候想到了这样去暴力，但是没实现。<br>题目中最大的素数是199，每个素数对所有出现过的数进行判断看差值是否出现过，就行了。<br>先来个素数打表，还有就是用map统计每个数出现的次数。<br>假设1出现了2次，2出现了2次，那么和为3的次数就是2*2=4次<br>假设1出现了4次，那么和为2出现的次数就是4*（4-1）/2=6次<br>按照这上面两种进行统计输出就行。</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int t[205];int p[205];int main(){    p[0]=p[1]=1;    for(int i=2;i&lt;=205;i++)    {        for(int j=i*2;j&lt;=205;j+=i)            p[j]=1;    }    int n,a;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;a;        t[a]++;    }    int ans=0;    for(int i=0;i&lt;=100;i++)    {        for(int j=i+1;j&lt;=100;j++)        {            if(i==j)    continue;            if(!p[i+j])            {                ans+=t[i]*t[j];            }                     }    }    cout&lt;&lt;ans*2+t[1]*(t[1]-1)&lt;&lt;endl;}</code></pre><h3 id="平行线"><a href="#平行线" class="headerlink" title="平行线"></a>平行线</h3><p>Descripition:<br>“大猩猩为什么不喜欢平行线？”“因为平行线没有相交”<br>哈哈哈哈哈哈哈哈哈</p><p>为了管理动物园不听话的大猩猩们，动物管理员Boctorio 决定去远方的ACM之城找一些平行线，当他逛到一个神奇的店铺时，他发现了一副黑色的图，上面依稀可见一些白色的点。Boctorio 询问店铺老板这幅画是什么，老板说：“天机不可泄露”。等Boctorio仔细端详了一会这幅画后，他惊讶的发现其中所蕴含的奥秘。向店铺老板道谢后，他拿着刚买的这幅画，就连忙赶回动物园。</p><p>输入格式<br>输入一个数 n(1≤n≤1000)，表示点的个数。<br>接下来n行，每行两个整数 xi,yi(1≤xi,yi≤1e9),表示第i个点。<br>数据保证没有重复的点</p><p>输出格式<br>输出用这些点所能表示出来的平行线段的对数。（两条不同的线段重合也算为平行）</p><p>样例<br>input<br>6<br>0 0<br>1 0<br>1 1<br>3 1<br>3 3<br>5 4<br>output<br>10</p><p>Problem solving:<br>两线平行的条件就是斜率相等（也可以用向量做）统计每个斜率出现的次数即可<br>斜率不能直接用double存，会爆精度，可以用一个pair来存，但是注意，分数要进行约分，同时除以它们的gcd就行了</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1005;int x[maxn],y[maxn];int main(){    int n;    cin&gt;&gt;n;    set&lt;pair&lt;int,int&gt; &gt; se;    map&lt;pair&lt;int,int&gt; ,int&gt; ma;    for(int i=0;i&lt;n;i++)    {        cin&gt;&gt;x[i]&gt;&gt;y[i];    }    for(int i=0;i&lt;n;i++)    {        for(int j=i+1;j&lt;n;j++)        {            int dx=x[j]-x[i];            int dy=y[j]-y[i];            int mid=__gcd(dx,dy);            dx/=mid;            dy/=mid;            ma[{dx,dy}]++;            se.insert({dx,dy});        }    }    int ans=0;    for(set&lt;pair&lt;int,int&gt; &gt;::iterator it=se.begin();it!=se.end();it++)    {        ans+=(ma[*it]*(ma[*it]-1))/2;    }    cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h3 id="Area-of-polygons"><a href="#Area-of-polygons" class="headerlink" title="Area of polygons"></a>Area of polygons</h3><p>Descripition:<br>现在有a个边长为1的正方形，b个半径为1的圆，c个边长为1的等边三角形，现在你随机拿出一个图形，求这个图形面积的期望。</p><p>输入格式<br>第一行输入一个T,代表输入的组数。(1≤T≤100)<br>接下来T行，每行三个数字a,b,c(1≤a,b,c≤1000)。</p><p>输出格式<br>输出T行，对于每一组输入，输出面积的期望，小数点后保留三位小数。</p><p>样例<br>input<br>3<br>1 2 3<br>4 5 6<br>7 8 9<br>output<br>1.430<br>1.487<br>1.501<br>提示<br>圆周率为3.1415926535897</p><p>Problem solving:<br>简单数学题<br>期望即平均值</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define PI 3.1415926535897int main(){    double t,a,b,c;    cin&gt;&gt;t;    while(t--)    {        double sum=0;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        sum+=a+PI*b+sqrt(3)*c/4;        printf(&quot;%.3lf\n&quot;,sum/(a+b+c));    }}</code></pre><h3 id="双色球"><a href="#双色球" class="headerlink" title="双色球"></a>双色球</h3><p>Descripition:<br>双色球投注区分为红色球号码区和蓝色球号码区，红色球号码区由1-33共三十三个号码组成，蓝色球号码区由1-16共十六个号码组成。投注时选择6个红色球号码和1个蓝色球号码组成一注进行单式投注。其中奖规则为：</p><p>一等奖（6+1）<br>二等奖（6+0）<br>三等奖（5+1）<br>四等奖（5+0、4+1）<br>五等奖（4+0、3+1）<br>六等奖（2+1、1+1、0+1）<br>其中(a+b)即为有a个红色球，b个蓝色球与开奖某个数字相同（只与数字有关，与位置无关）。<br>现在你有 n 张双色球彩票，以及本场彩票开奖结果，请你求出这 n 张彩票获得的最高奖。</p><p>输入格式<br>第一行输入一个 n ，表示 n 张彩票<br>接下来 n 行，每行 7 个数字，表示每张彩票的选号，其中前六个位红色球，后一个为蓝色球。<br>接下来一行，输入 7 个数字，表示开奖结果，其中前六个为红色球，后一个为蓝色球。</p><p>输出格式<br>输出所有彩票中能获得的最高等级奖，若无，则输出”0”。</p><p>样例<br>input<br>5<br>2 17 21 28 30 32 10<br>2 12 17 29 30 31 15<br>9 10 19 25 26 30 12<br>6 8 18 29 30 31 10<br>13 14 21 22 27 32 8<br>6 7 12 19 27 28 12<br>output<br>6<br>input<br>3<br>2 17 21 28 30 32 10<br>2 12 17 29 30 31 15<br>9 10 19 25 26 30 12<br>6 8 18 29 30 31 10<br>output<br>6<br>提示<br>彩票六个红色球数字均为从小到大排列<br>Problem solving:<br>看懂题意后直接暴力模拟就行</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;struct node{    int ball[10];}p[100];int re[10];int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;7;j++)            cin&gt;&gt;p[i].ball[j];    }    for(int i=0;i&lt;7;i++)    cin&gt;&gt;re[i];    int ans,mmp=7,mmm=7;    for(int i=0;i&lt;n;i++)    {        ans=0;        int flag=0;        for(int j=0;j&lt;6;j++)        {            if(binary_search(re,re+6,p[i].ball[j]))                ans++;        }        if(p[i].ball[6]==re[6])    flag=1;        if(ans==1&amp;flag)    mmm=6;        else if(ans==0&amp;&amp;flag)    mmm=6;        else if(ans==2&amp;&amp;flag)    mmm=6;        else if(ans==3&amp;&amp;flag==1)    mmm=5;        else if(ans==4)        {            if(!flag)    mmm=5;            else    mmm=4;                }        else if(ans==5)        {            if(!flag)    mmm=4;            else    mmm=3;        }        else if(ans==6)        {            if(!flag)    mmm=2;            else    mmm=1;        }        mmp=min(mmm,mmp);    }    cout&lt;&lt;mmp%7&lt;&lt;endl;}</code></pre><h3 id="Remainder-Minimization-2019"><a href="#Remainder-Minimization-2019" class="headerlink" title="Remainder Minimization 2019"></a>Remainder Minimization 2019</h3><p>Descripition:<br>给你一个区间[L,R],在这个区间内找到两个不同的数字i,j，使得(i∗j)%2019的值最小。</p><p>输入格式<br>输入两个数 L,R,(1≤L\&lt;R≤1e9）</p><p>输出格式<br>如题</p><p>样例<br>input<br>4 5<br>output<br>20<br>input<br>2020 2040<br>output<br>2<br>Problem solving:<br>区间内只要出现2019的倍数，那么答案就是0。<br>所以我们只需要判断区间大小与2019的关系，如果大于2019，直接输出0就行，反之直接两个for循环就行，因为这时区间长度小于2019，时间复杂度也不高。注意要用long long。</p><p>Code:</p><pre><code>a,b=input().split()a=eval(a)b=eval(b)ans=1111111111111for i in range(a,b):    for j in range(a+1,b+1):        mid = i*j % 2019        ans = min(ans,mid)        if ans==0:            break    if ans==0:            breakprint(ans)</code></pre><h3 id="学长标程-amp-amp-题解"><a href="#学长标程-amp-amp-题解" class="headerlink" title="学长标程 &amp;&amp; 题解"></a>学长标程 &amp;&amp; 题解</h3><p>我的代码会显得有点笨拙，因为还是不够熟练，所以把学长的代码也放在这里吧。</p><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><ul><li>只要有一次某个人不是复读的就不是复读机</li><li>第一个人一定不是复读机</li><li>使用 map<string,bool> 判断这个人是否是复读机</string,bool></li><li>使用 map<string,int> 记录这个人复读的次数</string,int></li><li>用结构体记录排序</li><li>复杂度 O(n∗log(n))</li></ul><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;struct peo{    string name;    int num;};vector&lt;peo&gt; all;map&lt;string,bool&gt; jud;map&lt;string,int&gt; num;string a[N],b[N];set&lt;string&gt; name;bool cmp(peo a,peo b){    if(a.num==b.num) return a.name&lt;b.name;    return a.num&gt;b.num;}int main(){    int T;    cin&gt;&gt;T;    while(T--){        int n;        jud.clear();num.clear();name.clear();all.clear();        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i],jud[a[i]]=1,num[a[i]]=0,name.insert(a[i]);        jud[a[1]]=0;        for(int i=2;i&lt;=n;i++){            if(b[i]!=b[i-1]){                jud[a[i]]=0;            }            num[a[i]]++;        }        for(auto v:name){            if(jud[v]) all.push_back({v,num[v]});        }        sort(all.begin(),all.end(),cmp);        if(all.size()==0){            cout&lt;&lt;&quot;Unbelievable!&quot;&lt;&lt;endl;        }        else{            for(auto v:all) cout&lt;&lt;v.name&lt;&lt;endl;        }    }    return 0;}</code></pre><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><ul><li>由于只有后六位，先乘上 106 防止爆精度。</li><li>按照最普通的算法，每次乘以 2 再对 106 取余</li><li>当循环次数超过某一个值时，即可判定为无</li></ul><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    double y;    while(scanf(&quot;%lf&quot;,&amp;y)!=EOF){        y*=10000000;        bool flag=0;        long long x=(long long)y;        int num=0;        while(1){            if(x==0) break;            if(num&gt;=200){                flag=1;break;            }            num++;            x=2*x;            if(x&gt;=10000000) x-=10000000;            if(x==0) break;        }        if(flag) puts(&quot;NO&quot;);        else puts(&quot;YES&quot;);    }    return 0;}</code></pre><h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;bool check(string s){    string c=s;    reverse(c.begin(), c.end());    return s==c;}pair&lt;int,int&gt; pii;int main(){    pii.first=1;    pii.second=2;    pii=make_pair(1,2);    //cout&lt;&lt;pii.first&lt;&lt;&#39; &#39;&lt;&lt;pii.second&lt;&lt;endl;    string s;    cin&gt;&gt;s;    bool flag=0;    int l=s.length();    if(l&amp;1) flag=1;    if(!check(s)) flag=1;    int num[27];    memset(num,0,sizeof(num));    for(int i=0;i&lt;l;i++){        num[s[i]-&#39;a&#39;]++;    }    for(int i=0;i&lt;26;i++){        if(num[i]==0){            flag=1;break;        }    }    if(flag) cout&lt;&lt;&quot;N0&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;YE5&quot;&lt;&lt;endl;    return 0;}</code></pre><h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><ul><li>维护前缀 gcd 数组 pre 和后缀 gcd 数组 od</li><li>删除第 i 个数之后剩余数的 gcd 即为 gcd(pre[i−1],od[i+1])</li><li>线性枚举即可, 复杂度 O(n)</li></ul><p>Code:</p><pre><code>//前缀后缀解法#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+100;long long a[N];long long pre[N],sa[N];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    pre[1]=a[1];sa[n]=a[n];    for(int i=2;i&lt;=n;i++) pre[i]=__gcd(pre[i-1],a[i]);    for(int i=n-1;i&gt;=1;i--) sa[i]=__gcd(sa[i+1],a[i]);    long long ans=max(sa[2],pre[n-1]);    for(int i=2;i&lt;=n-1;i++) ans=max(ans,__gcd(pre[i-1],sa[i+1]));    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}//贪心解法//#include&lt;bits/stdc++.h&gt;//using namespace std;//const int maxn = 1e5 + 10;//int a[maxn];//bool cmp(int x,int y)//{//    return x &gt; y;//}//int gcd(int a,int b)//{//    return b ? gcd(b,a % b) : a;//}//int main()//{//    int n;//    scanf(&quot;%d&quot;,&amp;n);//    for (int i = 0;i &lt; n;i ++)//        scanf(&quot;%d&quot;,&amp;a[i]);//    sort(a,a + n,cmp);//    int ans = a[0],now = a[0];//    for (int i = 1;i &lt; n;i ++)//    {//        ans = max(gcd(ans,a[i]),now);//        now = gcd(now,a[i]);//    }//    printf(&quot;%d\n&quot;,ans);//    return 0;//}</code></pre><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><ul><li>注意到 ai 的范围很小，我们可以先打出 [1,200] 以内的质数 表</li><li>O(n) 或 O(nlog(n)) 的统计每个数出现的次数</li><li>对于第 i 个质数 pi，和数组中第 j 个元素 aj，答案应该累加 上 pi−aj 出现的次数</li><li>注意 pi = 2∗aj 的情况，应该加上 aj 出现的次数减去 1</li></ul><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;bool check(int x){    if(x==1) return 0;    if(x==2) return 1;    for(int i=2;i*i&lt;=x;i++){        if(x%i==0) return 0;    }    return 1;}vector&lt;int&gt; pr;void init(){    for(int i=1;i&lt;=250;i++){        if(check(i)) pr.push_back(i);    }}int a[N];int vis[300];int main(){    init();    memset(vis,0,sizeof(vis));    long long ans=0;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],vis[a[i]]++;    for(int i=0;i&lt;(int)pr.size();i++){        int now=pr[i];        for(int j=1;j&lt;=n;j++){            if(now&gt;=a[j]){                if(now==(a[j]*2)) ans+=vis[a[j]]-1;                else{                     if(vis[a[j]]&amp;&amp;vis[now-a[j]]) ans+=vis[now-a[j]];                }            }        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><ul><li>对 yi−yj/xi−xj 用 gcd 约分后用 pair 存储</li><li>利用 map 统计每个斜率的线段条数, 假设为 num, 那么斜率 k 的贡献即为 num∗(num−1)/2</li><li>累加不同的斜率的贡献即可 复杂度 O(n2log(n2))</li></ul><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2000;typedef long long ll;int x[N],y[N];int main(){    int n;    cin&gt;&gt;n;    map&lt;pair&lt;int,int&gt; ,int&gt; k;    set&lt;pair&lt;long long,long long&gt;&gt; all;    long long ans=0;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i];    for(int i=1;i&lt;=n;i++){        for(int j=i+1;j&lt;=n;j++){            int dx=x[j]-x[i];            int dy=y[j]-y[i];            if(dx&lt;0&amp;&amp;dy&lt;0){                dx=-dx;                dy=-dy;            }            long long gc=__gcd(dx,dy);            dx/=gc;dy/=gc;            k[{dx,dy}]++;            all.insert({dx,dy});        }    }    for(auto v:all){        ans+=(k[v]*(k[v]-1)/2);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h4 id="H"><a href="#H" class="headerlink" title="H"></a>H</h4><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int T;    cin&gt;&gt;T;    while(T--){        double a,b,c;        scanf(&quot;%lf %lf %lf&quot;,&amp;a,&amp;b,&amp;c);        double all=(a+b+c);        printf(&quot;%.3lf\n&quot;,(a+M_PI*b+sqrt(3)*c/4)/(a+b+c));    }    return 0;}</code></pre><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;pair&lt;int,int&gt; solve(vector&lt;int&gt; a,vector&lt;int&gt; b){    int num[34];    memset(num,0,sizeof(num));    int r=0;    int bl=0;    for(int i=0;i&lt;6;i++){        num[a[i]]++;    }    for(int i=0;i&lt;6;i++){        if(num[b[i]]) r++;    }    if(a[6]==b[6]) bl=1;    return {r,bl};}int cal(pair&lt;int,int&gt; pii){    if(pii.first==6&amp;&amp;pii.second==1) return 1;    if(pii.first==6&amp;&amp;pii.second==0) return 2;    if(pii.first==5&amp;&amp;pii.second==1) return 3;    if((pii.first==5&amp;&amp;pii.second==0)||(pii.first==4&amp;&amp;pii.second==1)) return 4;    if((pii.first==4&amp;&amp;pii.second==0)||(pii.first==3&amp;&amp;pii.second==1)) return 5;    if((pii.first==2&amp;&amp;pii.second==1)||(pii.first==1&amp;&amp;pii.second==1)||(pii.first==0&amp;&amp;pii.second==1)) return 6;    return 99999;}const int N = 1e3+100;vector&lt;int&gt; a[N];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        int x;        for(int j=0;j&lt;7;j++){            cin&gt;&gt;x;            a[i].push_back(x);        }    }    int ans=7;    vector&lt;int&gt; b(7);    for(int i=0;i&lt;7;i++) cin&gt;&gt;b[i];    for(int i=1;i&lt;=n;i++) {        ans=min(ans,cal(solve(a[i],b)));    }    if(ans==7) ans=0;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h4 id="J"><a href="#J" class="headerlink" title="J"></a>J</h4><ul><li>当 L 和 R 的差值大于 2019 的时候，其中必定含有 2019 的 倍数，此时答案为 0</li><li>否则暴力枚举</li></ul><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    long long L,R;    cin&gt;&gt;L&gt;&gt;R;    if(R-L&gt;2019) cout&lt;&lt;0&lt;&lt;endl;    else{        int ans=9999;        for(int i=L;i&lt;=R;i++){            for(int j=i+1;j&lt;=R;j++){                ans=min(ans,((i%2019)*(j%2019))%2019);            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><p>今天的题确实不算太难吧，就过了6题，还罚时巨高，主要还是自己的原因。STL和结构体的使用能力还有点欠缺，另外用map统计出现次数这个真的是很有用的东西，set去重，这些都知道的东西用不到平常写题的过程中太亏了。继续加油，Fighting！！！</p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> STL </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 3（河南理工暑期集训第三天）</title>
      <link href="/2019/07/19/3/"/>
      <url>/2019/07/19/3/</url>
      
        <content type="html"><![CDATA[<p><center><p color="red">Today's problem I spent too much wrong on the format,I should be more careful.</p></center></p><h3 id="Windows-Message-Queue"><a href="#Windows-Message-Queue" class="headerlink" title="Windows Message Queue"></a>Windows Message Queue</h3><p>Description:<br>Message queue is the basic fundamental of windows system. For each process, the system maintains a message queue. If something happens to this process, such as mouse click, text change, the system will add a message to the queue. Meanwhile, the process will do a loop for getting message from the queue according to the priority value if it is not empty. Note that the less priority value means the higher priority. In this problem, you are asked to simulate the message queue for putting messages to and getting message from the message queue.<br>Input</p><blockquote><p>There&#39;s only one test case in the input. Each line is a command, &quot;GET&quot; or &quot;PUT&quot;, which means getting message or putting message. If the command is &quot;PUT&quot;, there&#39;re one string means the message name and two integer means the parameter and priority followed by. There will be at most 60000 command. Note that one message can appear twice or more and if two messages have the same priority, the one comes first will be processed first.(i.e., FIFO for the same priority.) Process to the end-of-file.</p></blockquote><p>Output</p><blockquote><p>For each &quot;GET&quot; command, output the command getting from the message queue with the name and parameter in one line. If there&#39;s no message in the queue, output &quot;EMPTY QUEUE!&quot;. There&#39;s no output for &quot;PUT&quot; command.</p></blockquote><p>Sample Input</p><blockquote><p>GET<br>PUT msg1 10 5<br>PUT msg2 10 4<br>GET<br>GET<br>GET</p></blockquote><p>Sample Output</p><blockquote><p>EMPTY QUEUE!<br>msg2 10<br>msg1 10<br>EMPTY QUEUE!</p></blockquote><p>Problem solving:<br>Through a special queue with a struct and Operator overloading.The main question is understand this,oh my poor English.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;struct node{    string s;    int    p, q, id;} n[6005];bool operator &lt;(const node &amp;x, const node &amp;y)//Operator overloading.{    if (x.q == y.q)        return x.id &gt; y.id;    return x.q &gt; y.q;}priority_queue&lt;node&gt; que;int main(){    string s;    int    k = 0;    while (cin &gt;&gt; s)    {        if (s[0] == &#39;G&#39;)        {            if (que.empty())                puts(&quot;EMPTY QUEUE!&quot;);            else            {                cout &lt;&lt; que.top().s &lt;&lt; &quot; &quot; &lt;&lt; que.top().p &lt;&lt; endl;                que.pop();            }        }        if (s[0] == &#39;P&#39;)        {            cin &gt;&gt; n[0].s &gt;&gt; n[0].p &gt;&gt; n[0].q;            n[0].id = k;            k++;            que.push(n[0]);        }    }}</code></pre><h3 id="Train-Problem-I"><a href="#Train-Problem-I" class="headerlink" title="Train Problem I"></a>Train Problem I</h3><p>Description:<br>As the new term comes, the Ignatius Train Station is very busy nowadays. A lot of student want to get back to school by train(because the trains in the Ignatius Train Station is the fastest all over the world ^v^). But here comes a problem, there is only one railway where all the trains stop. So all the trains come in from one side and get out from the other side. For this problem, if train A gets into the railway first, and then train B gets into the railway before train A leaves, train A can&#39;t leave until train B leaves. The pictures below figure out the problem. Now the problem for you is, there are at most 9 trains in the station, all the trains has an ID(numbered from 1 to n), the trains get into the railway in an order O1, your task is to determine whether the trains can get out in an order O2.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094118.webp" data-fancybox="images" data-caption="主人没有描述我哦~" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094118.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094200.webp" data-fancybox="images" data-caption="主人没有描述我哦~" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094200.webp" class="img-shadow img-margin"></center></a></p><p>Input</p><blockquote><p>The input contains several test cases. Each test case consists of an integer, the number of trains, and two strings, the order of the trains come in:O1, and the order of the trains leave:O2. The input is terminated by the end of file. More details in the Sample Input.</p></blockquote><p>Output</p><blockquote><p>The output contains a string &quot;No.&quot; if you can&#39;t exchange O2 to O1, or you should output a line contains &quot;Yes.&quot;, and then output your way in exchanging the order(you should output &quot;in&quot; for a train getting into the railway, and &quot;out&quot; for a train getting out of the railway). Print a line contains &quot;FINISH&quot; after each test case. More details in the Sample Output.</p></blockquote><p>Sample Input</p><blockquote><p>3 123 321<br>3 123 312</p></blockquote><p>Sample Output</p><blockquote><p>Yes.<br>in<br>in<br>in<br>out<br>out<br>out<br>FINISH<br>No.<br>FINISH</p></blockquote><p>For the first Sample Input, we let train 1 get in, then train 2 and train 3.<br>So now train 3 is at the top of the railway, so train 3 can leave first, then train 2 and train 1.<br>In the second Sample input, we should let train 3 leave first, so we have to let train 1 get in, then train 2 and train 3.<br>Now we can let train 3 leave.<br>But after that we can&#39;t let train 1 leave before train 2, because train 2 is at the top of the railway at the moment.<br>So we output &quot;No.&quot;.<br>Problem solving:<br>An easy problem.Use a stack to simulate this process and a queue to record &#39;in&#39; or &#39;out&#39;.Judge if we can pop or push.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int n;    while (~scanf(&quot;%d&quot;, &amp;n))    {        int           flag = 0;        string        a, b;        cin &gt;&gt; a &gt;&gt; b;        stack&lt;char&gt;   s;        queue&lt;string&gt; q;        for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt;= n;)        {            if (s.empty() || s.top() != b[i])            {                if (j == n)                {                    cout &lt;&lt; &quot;No.\nFINISH\n&quot;;                    flag = 1;                    break;                }                s.push(a[j]);                j++;                q.push(&quot;in&quot;);            }            else            {                s.pop();                q.push(&quot;out&quot;);                i++;            }        }        if (flag)            continue;        else        {            cout &lt;&lt; &quot;Yes.\n&quot;;            while (!q.empty())            {                cout &lt;&lt; q.front() &lt;&lt; endl;                q.pop();            }        }        cout &lt;&lt; &quot;FINISH\n&quot;;    }}</code></pre><h3 id="Rails"><a href="#Rails" class="headerlink" title="Rails"></a>Rails</h3><p>Description:<br>There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094307.webp" data-fancybox="images" data-caption="主人没有描述我哦~" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094307.webp" class="img-shadow img-margin"></center></a><br>The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has N &lt;= 1000 coaches numbered in increasing order 1, 2, ..., N. The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be a1, a2, ..., aN. Help him and write a program that decides whether it is possible to get the required order of coaches. You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.</p><p>Input</p><blockquote><p>The input consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of 1, 2, ..., N. The last line of the block contains just 0.<br>The last block consists of just one line containing 0.</p></blockquote><p>Output</p><blockquote><p>The output contains the lines corresponding to the lines with permutations in the input. A line of the output contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input. Otherwise it contains No. In addition, there is one empty line after the lines corresponding to one block of the input. There is no line in the output corresponding to the last null&#39; block of the input.</p></blockquote><p>Sample Input</p><blockquote><p>5<br>1 2 3 4 5<br>5 4 1 2 3<br>0<br>6<br>6 5 4 3 2 1<br>0<br>0</p></blockquote><p>Sample Output</p><pre><code>YesNoYes</code></pre><p>Problem solving:<br>An easy stack question.<br>Code:</p><pre><code>#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;int a[1005];int main(){    int n;    while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        while (1)        {            int flag = 0;            for (int i = 0; i &lt; n; i++)            {                cin &gt;&gt; a[i];                if (a[i] == 0)                {                    flag = 1; break;                }            }            if (flag)                break;            stack&lt;int&gt; sta;            int        pos = 0;            for (int i = 1; i &lt;= n; i++)            {                sta.push(i);                while (!sta.empty() &amp;&amp; sta.top() == a[pos])                {                    sta.pop();                    pos++;                }            }            if (sta.empty())                puts(&quot;Yes&quot;);            else                puts(&quot;No&quot;);        }        puts(&quot;&quot;);    }}</code></pre><h3 id="D-A-B"><a href="#D-A-B" class="headerlink" title="D - {A} + {B}"></a>D - {A} + {B}</h3><p>Description:<br>给你两个集合，要求{A} + {B}.<br>注:同一个集合中不会有两个相同的元素.<br>Input</p><blockquote><p>每组输入数据分为三行,第一行有两个数字n,m(0&lt;n,m&lt;=10000),分别表示集合A和集合B的元素个数.后两行分别表示集合A和集合B.每个元素为不超出int范围的整数,每个元素之间有一个空格隔开.</p></blockquote><p>Output</p><blockquote><p>针对每组数据输出一行数据,表示合并后的集合,要求从小到大输出,每个元素之间有一个空格隔开.</p></blockquote><p>Sample Input</p><blockquote><p>1 2<br>1<br>2 3<br>1 2<br>1<br>1 2</p></blockquote><p>Sample Output</p><blockquote><p>1 2 3<br>1 2</p></blockquote><p>Problem solving:<br>An easy set question.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int n, m, a;    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        set&lt;int&gt; s;        for (int i = 0; i &lt; n + m; i++)        {            cin &gt;&gt; a;            s.insert(a);        }        for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)        {            if (it == s.begin())                cout &lt;&lt; *it;            else                cout &lt;&lt; &quot; &quot; &lt;&lt; *it;        }        cout &lt;&lt; endl;    }}</code></pre><h3 id="水果"><a href="#水果" class="headerlink" title="水果"></a>水果</h3><p>Description:<br>夏天来了<del>好开心啊,呵呵,好多好多水果</del><br>Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.<br>Input</p><blockquote><p>第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据.<br>每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.</p></blockquote><p>Output</p><blockquote><p>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.<br>两组测试数据之间有一个空行.最后一组测试数据之后没有空行.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5<br>apple shandong 3<br>pineapple guangdong 1<br>sugarcane guangdong 1<br>pineapple guangdong 3<br>pineapple guangdong 1</p></blockquote><p>Sample Output</p><blockquote><p>guangdong<br>　　|----pineapple(5)<br>　　|----sugarcane(1)<br>shandong<br>　　|----apple(3)</p></blockquote><p>Problem solving:<br>An unusual problem.We can ues a map in map.And then the iterator is a little different now.Just see the Code.Luckily,map can automatic sorting makes this problem is not so hard.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int    n, m, p;    string x, y;    cin &gt;&gt; n;    int xxxx=0;    while (n--)    {        if(xxxx!=0) puts(&quot;&quot;);        xxxx=1;        int                            i = 0;        map&lt;string, map&lt;string, int&gt; &gt; ma;        cin &gt;&gt; m;        while (m--)        {            cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;            ma[y][x] += p;        }        map&lt;string, int&gt;::iterator iit;        for (map&lt;string, map&lt;string, int&gt; &gt;::iterator it = ma.begin(); it != ma.end(); it++)        {            cout &lt;&lt; it-&gt;first &lt;&lt; endl;            for (iit = it-&gt;second.begin(); iit != it-&gt;second.end(); iit++)            {                cout &lt;&lt; &quot;   |----&quot; &lt;&lt; iit-&gt;first &lt;&lt; &quot;(&quot; &lt;&lt; iit-&gt;second &lt;&lt; &quot;)&quot; &lt;&lt; endl;            }        }    }}</code></pre><h3 id="Let-the-Balloon-Rise"><a href="#Let-the-Balloon-Rise" class="headerlink" title="Let the Balloon Rise"></a>Let the Balloon Rise</h3><p>Description:<br>Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges&#39; favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.<br>This year, they decide to leave this lovely job to you.<br>Input</p><blockquote><p>Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) -- the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.<br>A test case with N = 0 terminates the input and this test case is not to be processed.</p></blockquote><p>Output</p><blockquote><p>For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case.</p></blockquote><p>Sample Input</p><blockquote><p>5<br>green<br>red<br>blue<br>red<br>red<br>3<br>pink<br>orange<br>pink<br>0</p></blockquote><p>Sample Output</p><blockquote><p>red<br>pink</p></blockquote><p>Problem solving:<br>An easy map problem.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int    n;    string s;    while (cin &gt;&gt; n)    {        map&lt;string, int&gt; ma;        if (n == 0)            break;        while (n--)        {            cin &gt;&gt; s;            ma[s]++;        }        int    mid = 0;        string ans;        for (map&lt;string, int&gt;::iterator it = ma.begin(); it != ma.end(); it++)        {            if (it-&gt;second &gt; mid)            {                ans = it-&gt;first;                mid = it-&gt;second;            }        }        cout &lt;&lt; ans &lt;&lt; endl;    }}</code></pre><h3 id="不重复数字"><a href="#不重复数字" class="headerlink" title="不重复数字"></a>不重复数字</h3><p>Description:<br>给出N个数，要求把其中重复的去掉，只保留第一次出现的数。<br>例如，给出的数为1 2 18 3 3 19 2 3 6 5 4，其中2和3有重复，去除后的结果为1 2 18 3 19 6 5 4。</p><p>Input</p><blockquote><p>输入第一行为正整数T，表示有T组数据。<br>接下来每组数据包括两行，第一行为正整数N，表示有N个数。第二行为要去重的N个正整数。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，输出一行，为去重后剩下的数字，数字之间用一个空格隔开。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>11<br>1 2 18 3 3 19 2 3 6 5 4<br>6<br>1 2 3 4 5 6</p></blockquote><p>Sample Output</p><blockquote><p>1 2 18 3 19 6 5 4<br>1 2 3 4 5 6</p></blockquote><p>Hint</p><blockquote><p>对于30%的数据，1 &lt;= N &lt;= 100，给出的数不大于100，均为非负整数；<br>对于50%的数据，1 &lt;= N &lt;= 10000，给出的数不大于10000，均为非负整数；<br>对于100%的数据，1 &lt;= N &lt;= 50000，给出的数在32位有符号整数范围内。<br>提示:<br>由于数据量很大，使用C++的同学请使用scanf和printf来进行输入输出操作，以免浪费不必要的时间。</p></blockquote><p>Problem solving:<br>We can&#39;t use set here because set will automatic sort.I wanted to ues a flag array to know the number has appread or not.But always RE.So I choose a set to know if the number has already appeared.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    {        int        n, a;        scanf(&quot;%d&quot;, &amp;n);        set&lt;int&gt;   s;        int        mid = s.size();        queue&lt;int&gt; q;        while (n--)        {            scanf(&quot;%d&quot;, &amp;a);            s.insert(a);            if (s.size() != mid)            {                q.push(a);                mid = s.size();            }        }        while (!q.empty())        {            cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;            q.pop();        }        puts(&quot;&quot;);    }}</code></pre><h3 id="Andy-39-s-First-Dictionary"><a href="#Andy-39-s-First-Dictionary" class="headerlink" title="Andy&#39;s First Dictionary"></a>Andy&#39;s First Dictionary</h3><p>Description:<br>Andy, 8, has a dream - he wants to produce his very own dictionary. This is not an easy task for him, as the number of words that he knows is, well, not quite enough. Instead of thinking up all the words himself, he has a briliant idea. From his bookshelf he would pick one of his favourite story books, from which he would copy out all the distinct words. By arranging the words in<br>alphabetical order, he is done! Of course, it is a really time-consuming job, and this is where a computer program is helpful.You are asked to write a program that lists all the different words in the input text. In this problem, a word is defined as a consecutive sequence of alphabets, in upper and/or lower case. Words with only one letter are also to be considered. Furthermore, your program must be CaSe InSeNsItIvE. For example, words like “Apple”, “apple” or “APPLE” must be considered the same.<br>Input</p><blockquote><p>The input file is a text with no more than 5000 lines. An input line has at most 200 characters. Input<br>is terminated by EOF.</p></blockquote><p>Output</p><blockquote><p>Your output should give a list of different words that appears in the input text, one in a line. The<br>words should all be in lower case, sorted in alphabetical order. You can be sure that he number of<br>distinct words in the text does not exceed 5000.</p></blockquote><p>Sample Input</p><blockquote><p>Adventures in Disneyland<br>Two blondes were going to Disneyland when they came to a fork in the<br>road. The sign read: &quot;Disneyland Left.&quot;<br>So they went home.</p></blockquote><p>Sample Output</p><blockquote><p>a<br>adventures<br>blondes<br>came<br>disneyland<br>fork<br>going<br>home<br>in<br>left<br>read<br>road<br>sign<br>so<br>the<br>they<br>to<br>two<br>went<br>were<br>when</p></blockquote><p>Problem solving:<br>I know a new useful function through this problem--Stringstream.I will write a new artical about this these days.It&#39;s amazing,suitable for us who is lazy.About this problem,you just know what you should do:</p><ol><li>Turn uppercase letter to lower case letters.</li><li>Delete the char which is not a letter.</li></ol><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    string      s;    set&lt;string&gt; se;    while (cin &gt;&gt; s)    {        for (int i = 0; i &lt; s.size(); i++)        {            if (s[i] &gt;= &#39;A&#39; &amp;&amp; s[i] &lt;= &#39;Z&#39;)                s[i] += 32;            else if (s[i] &gt;= &#39;a&#39; &amp;&amp; s[i] &lt;= &#39;z&#39;)                s[i] = s[i];            else                s[i] = &#39; &#39;;        }        string       mi;        stringstream mid(s);        while (mid &gt;&gt; mi)        {            se.insert(mi);        }    }    for (set&lt;string&gt;::iterator it = se.begin(); it != se.end(); it++)    {        cout &lt;&lt; *it &lt;&lt; endl;    }}</code></pre><h3 id="A-and-B-and-Compilation-Errors"><a href="#A-and-B-and-Compilation-Errors" class="headerlink" title="A and B and Compilation Errors"></a>A and B and Compilation Errors</h3><p>Description:<br>A and B are preparing themselves for programming contests.</p><p>B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.</p><p>Initially, the compiler displayed n compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.</p><p>However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.</p><p>Can you help B find out exactly what two errors he corrected?</p><p>Input</p><blockquote><p>The first line of the input contains integer n (3 ≤ n ≤ 105) — the initial number of compilation errors.<br>The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the errors the compiler displayed for the first time.<br>The third line contains n - 1 space-separated integers b1, b2, ..., bn - 1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one.<br>The fourth line contains n - 2 space-separated integers с1, с2, ..., сn - 2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.</p></blockquote><p>Output</p><blockquote><p>Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.</p></blockquote><p>Examples<br>Input</p><blockquote><p>5<br>1 5 8 123 7<br>123 7 5 1<br>5 1 7</p></blockquote><p>Output</p><blockquote><p>8<br>123</p></blockquote><p>Input</p><blockquote><p>6<br>1 4 3 3 5 7<br>3 7 5 4 3<br>4 3 7 5</p></blockquote><p>Output</p><blockquote><p>1<br>3</p></blockquote><p>Note</p><blockquote><p>In the first test sample B first corrects the error number 8, then the error number 123.<br>In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.</p></blockquote><p>Problem solving:<br>Through reding,you will kown the first line we output is the different number between the second line and the third line we input,and the second line we output is the different number between the third line and the fourth line we input.I choose a force way but easy to understand.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int           n, a;    cin &gt;&gt; n;    map&lt;int, int&gt; ma;    map&lt;int, int&gt; ma1;    map&lt;int, int&gt; ma2;    for (int i = 0; i &lt; n; i++)    {        cin &gt;&gt; a;        ma[a]++;    }    for (int i = 0; i &lt; n - 1; i++)    {        cin &gt;&gt; a;        ma1[a]++;    }    for (int i = 0; i &lt; n - 2; i++)    {        cin &gt;&gt; a;        ma2[a]++;    }    int x = 0, y = 0;    for (map&lt;int, int&gt;::iterator it = ma.begin(); it != ma.end(); it++)    {        int mid = it-&gt;first;        if (ma[mid] != ma1[mid])            cout &lt;&lt; mid &lt;&lt; endl;    }    for (map&lt;int, int&gt;::iterator it = ma1.begin(); it != ma1.end(); it++)    {        int mid = it-&gt;first;        if (ma2[mid] != ma1[mid])            cout &lt;&lt; mid &lt;&lt; endl;    }    return 0;}</code></pre><h3 id="排列2"><a href="#排列2" class="headerlink" title="排列2"></a>排列2</h3><p>Description:<br>Ray又对数字的列产生了兴趣：<br>现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。<br>Input</p><blockquote><p>每组数据占一行，代表四张卡片上的数字（0&lt;=数字&lt;=9），如果四张卡片都是0，则输入结束。</p></blockquote><p>Output</p><blockquote><p>对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。<br>每组输出数据间空一行，最后一组数据后面没有空行。</p></blockquote><p>Sample Input</p><blockquote><p>1 2 3 4<br>1 1 2 3<br>0 1 2 3<br>0 0 0 0</p></blockquote><p>Sample Output</p><pre><code>1234 1243 1324 1342 1423 14322134 2143 2314 2341 2413 24313124 3142 3214 3241 3412 34214123 4132 4213 4231 4312 43211123 1132 1213 1231 1312 13212113 2131 23113112 3121 32111023 1032 1203 1230 1302 13202013 2031 2103 2130 2301 23103012 3021 3102 3120 3201 3210</code></pre><p>Problem solving:<br>An easy problem through &#39;next_permutation()&#39;.The most disgusting place is the format.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int a[5];int main(){    int mid, x = 0;    while (scanf(&quot;%d %d %d %d&quot;, &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3]) != EOF)    {        sort(a, a + 4);        if (a[0] == 0 &amp;&amp; a[1] == 0 &amp;&amp; a[2] == 0 &amp;&amp; a[3] == 0)            break;        if (x)            cout &lt;&lt; endl;        x = 1;        int flag = 1;        do        {            if (a[0] == 0)                continue;            if (flag)            {                cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];                flag = 0;            }            else if (mid == a[0])                cout &lt;&lt; &quot; &quot; &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];            else            {                cout &lt;&lt; endl;                cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];            }            mid = a[0];        } while (next_permutation(a, a + 4));        puts(&quot;&quot;);    }}</code></pre><p>I have too much PE before I passed this problem.</p><h3 id="Ignatius-and-the-Princess-II"><a href="#Ignatius-and-the-Princess-II" class="headerlink" title="Ignatius and the Princess II"></a>Ignatius and the Princess II</h3><p>Description:<br>Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, &quot;I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.&quot; Ignatius says confidently, &quot;OK, at last, I will save the Princess.&quot;</p><p>&quot;Now I will show you the first problem.&quot; feng5166 says, &quot;Given a sequence of number 1 to N, we define that 1,2,3...N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it&#39;s easy to see the second smallest sequence is 1,2,3...N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It&#39;s easy, isn&#39;t is? Hahahahaha......&quot;<br>Can you help Ignatius to solve this problem?<br>Input</p><blockquote><p>The input contains several test cases. Each test case consists of two numbers, N and M(1&lt;=N&lt;=1000, 1&lt;=M&lt;=10000). You may assume that there is always a sequence satisfied the BEelzebub&#39;s demand. The input is terminated by the end of file.</p></blockquote><p>Output</p><blockquote><p>For each test case, you only have to output the sequence satisfied the BEelzebub&#39;s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number.</p></blockquote><p>Sample Input</p><blockquote><p>6 4<br>11 8</p></blockquote><p>Sample Output</p><blockquote><p>1 2 3 5 6 4<br>1 2 3 4 5 6 7 9 8 11 10</p></blockquote><p>Problem solving:<br>An easy problem through &#39;next_permutation()&#39;.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int a[1005];int main(){    int n, m;    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        for (int i = 1; i &lt;= n; i++)        {            a[i] = i;        }        int flag = 0;        do        {            flag++;            if (flag == m)                break;        } while (next_permutation(a + 1, a + n + 1));        for (int i = 1; i &lt; n; i++)            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;        cout &lt;&lt; a[n] &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> Queue </tag>
            
            <tag> STL </tag>
            
            <tag> poj </tag>
            
            <tag> UVA </tag>
            
            <tag> math </tag>
            
            <tag> Thinking </tag>
            
            <tag> CodeForces </tag>
            
            <tag> Stack </tag>
            
            <tag> Stringstream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 2（河南理工暑期集训第二天）</title>
      <link href="/2019/07/18/2/"/>
      <url>/2019/07/18/2/</url>
      
        <content type="html"><![CDATA[<h3 id="前m大的数"><a href="#前m大的数" class="headerlink" title="前m大的数"></a>前m大的数</h3><p>Description:<br>还记得Gardon给小希布置的那个作业么？（上次比赛的1005）其实小希已经找回了原来的那张数表，现在她想确认一下她的答案是否正确，但是整个的答案是很庞大的表，小希只想让你把答案中最大的M个数告诉她就可以了。<br>给定一个包含N(N&lt;=3000)个正整数的序列，每个数不超过5000，对它们两两相加得到的N*(N-1)/2个和，求出其中前M大的数(M&lt;=1000)并按从大到小的顺序排列。<br>Input</p><blockquote><p>输入可能包含多组数据，其中每组数据包括两行：<br>第一行两个数N和M，<br>第二行N个数，表示该序列。</p></blockquote><p>Output</p><blockquote><p>对于输入的每组数据，输出M个数，表示结果。输出应当按照从大到小的顺序排列。</p></blockquote><p>Sample Input</p><blockquote><p>4 4<br>1 2 3 4<br>4 5<br>5 3 6 4</p></blockquote><p>Sample Output</p><blockquote><p>7 6 5 5<br>11 10 9 9 8</p></blockquote><p>Problem solving:<br>I have nothing to say about this *** problem,just do it without thinking.</p><p>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e7;int a[maxn],b[4000];int main(){    int n,m;    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        int k=0;        for(int i=0;i&lt;n;i++)            scanf(&quot;%d&quot;,&amp;b[i]);        for(int i=0;i&lt;n-1;i++)        {            for(int j=i+1;j&lt;n;j++)            {                a[k]=b[i]+b[j];                k++;            }        }        sort(a,a+k);        for(int i=k-1;i&gt;0;i--)        {            if(m==0)    break;            if(i==k-1)    cout&lt;&lt;a[i];            else    cout&lt;&lt;&quot; &quot;&lt;&lt;a[i];            m--;        }        puts(&quot;&quot;);    }}</code></pre><h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><p>Description:<br>大家都知道，快速排序是不稳定的排序方法。<br>如果对于数组中出现的任意a[i],a<a href="i&lt;j">j</a>,其中a[i]==a[j]，在进行排序以后a[i]一定出现在a[j]之前，则认为该排序是稳定的。</p><p>某高校招生办得到一份成绩列表，上面记录了考生名字和考生成绩。并且对其使用了某排序算法按成绩进行递减排序。现在请你判断一下该排序算法是否正确，如果正确的话，则判断该排序算法是否为稳定的。<br>Input</p><blockquote><p>本题目包含多组输入，请处理到文件结束。<br>对于每组数据，第一行有一个正整数N(0&lt;N&lt;300)，代表成绩列表中的考生数目。<br>接下来有N行，每一行有一个字符串代表考生名字(长度不超过50，仅包含&#39;a&#39;~&#39;z&#39;),和一个整数代表考生分数(小于500)。其中名字和成绩用一个空格隔开。<br>再接下来又有N行，是上述列表经过某排序算法以后生成的一个序列。格式同上。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，如果算法是正确并且稳定的，就在一行里面输出&quot;Right&quot;。如果算法是正确的但不是稳定的，就在一行里面输出&quot;Not Stable&quot;，并且在下面输出正确稳定排序的列表，格式同输入。如果该算法是错误的，就在一行里面输出&quot;Error&quot;,并且在下面输出正确稳定排序的列表，格式同输入。<br>注意，本题目不考虑该排序算法是错误的，但结果是正确的这样的意外情况。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>aa 10<br>bb 10<br>cc 20<br>cc 20<br>bb 10<br>aa 10<br>3<br>aa 10<br>bb 10<br>cc 20<br>cc 20<br>aa 10<br>bb 10<br>3<br>aa 10<br>bb 10<br>cc 20<br>aa 10<br>bb 10<br>cc 20</p></blockquote><p>Sample Output</p><blockquote><p>Not Stable<br>cc 20<br>aa 10<br>bb 10<br>Right<br>Error<br>cc 20<br>aa 10<br>bb 10</p></blockquote><p>Problem solving:<br>Attention: we&#39;d better make the order in which it arrears.And then just sort for structures.Compare the second input with the right and stable result.If the score&#39;s order is wrong,output &#39;Error&#39;,if the name&#39;s order is wrong,output &#39;Not Stable&#39;,if all order are right,output &#39;Right&#39;.</p><p>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node{    string na;    int s,i;}p[305],pp[305];bool cmp(node x,node y){    if(x.s==y.s)    return x.i&lt;y.i;    return x.s&gt;y.s;}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n))    {        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;p[i].na&gt;&gt;p[i].s;            p[i].i=i;        }        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;pp[i].na&gt;&gt;pp[i].s;        }        sort(p,p+n,cmp);        int flag=0;        for(int i=0;i&lt;n-1;i++)        {            if(pp[i].s&lt;pp[i+1].s)            {                flag=1;                break;            }        }        if(flag)        {            puts(&quot;Error&quot;);            for(int i=0;i&lt;n;i++)            {                cout&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;            }        }        else        {            for(int i=0;i&lt;n;i++)            {                if(p[i].na!=pp[i].na)                {                    flag=1;                    break;                }            }            if(flag)            {                puts(&quot;Not Stable&quot;);                for(int i=0;i&lt;n;i++)                {                    cout&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;                }            }            else            {                puts(&quot;Right&quot;);            }        }    }    return 0;}</code></pre><h3 id="开门人和关门人"><a href="#开门人和关门人" class="headerlink" title="开门人和关门人"></a>开门人和关门人</h3><p>Description:<br>每天第一个到机房的人要把门打开，最后一个离开的人要把门关好。现有一堆杂乱的机房签<br>到、签离记录，请根据记录找出当天开门和关门的人。<br>Input</p><blockquote><p>测试输入的第一行给出记录的总天数N ( &gt; 0 )。下面列出了N天的记录。<br>每天的记录在第一行给出记录的条目数M ( &gt; 0 )，下面是M行，每行的格式为<br>证件号码 签到时间 签离时间<br>其中时间按“小时:分钟:秒钟”（各占2位）给出，证件号码是长度不超过15的字符串。</p></blockquote><p>Output</p><blockquote><p>对每一天的记录输出1行，即当天开门和关门人的证件号码，中间用1空格分隔。<br>注意：在裁判的标准测试输入中，所有记录保证完整，每个人的签到时间在签离时间之前，<br>且没有多人同时签到或者签离的情况。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1<br>ME3021112225321 00:00:00 23:59:59<br>2<br>EE301218 08:05:35 20:56:35<br>MA301134 12:35:45 21:40:42<br>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p></blockquote><p>Sample Output</p><blockquote><p>ME3021112225321 ME3021112225321<br>EE301218 MA301134<br>SC3021234 CS301133</p></blockquote><p>Problem solving:<br>The earliest person and the lastest person is what we should output.The way we get these two person&#39;s name is sort,sort for structures.The best thing is we can find this efficient through sort string.You can look my code carefully to understand this.<br>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node{    string n,b,e;}p[1000];bool cmp(node x,node y){    return x.b&lt;y.b;}bool ccmp(node x,node y){    return x.e&gt;y.e;}int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        int m;        scanf(&quot;%d&quot;,&amp;m);        for(int i=0;i&lt;m;i++)        {            cin&gt;&gt;p[i].n&gt;&gt;p[i].b&gt;&gt;p[i].e;        }        sort(p,p+m,cmp);        cout&lt;&lt;p[0].n&lt;&lt;&quot; &quot;;        sort(p,p+m,ccmp);        cout&lt;&lt;p[0].n;        puts(&quot;&quot;);    }}</code></pre><h3 id="EXCEL排序"><a href="#EXCEL排序" class="headerlink" title="EXCEL排序"></a>EXCEL排序</h3><p>Description:<br>Excel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。<br>Input</p><blockquote><p>测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (&lt;=100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有 N<br>行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N=0 时，全部输入结束，相应的结果不要输出。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3<br>时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。</p></blockquote><p>Sample Input</p><blockquote><p>3 1<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>4 2<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>000002 James 98<br>4 3<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>000002 James 90<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>Case 1:<br>000001 Zoe 60<br>000007 James 85<br>000010 Amy 90<br>Case 2:<br>000010 Amy 90<br>000002 James 98<br>000007 James 85<br>000001 Zoe 60<br>Case 3:<br>000001 Zoe 60<br>000007 James 85<br>000002 James 90<br>000010 Amy 90</p></blockquote><p>Problem solving:<br>Look the problem description carefully,and sort for structures.Easy.<br>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node{    string id,na;    int s;}p[100008];bool cmp1(node x,node y){    return x.id&lt;y.id;}bool cmp2(node x,node y){        if(x.na==y.na)        return x.id&lt;y.id;    return x.na&lt;y.na;}bool cmp3(node x,node y){    if(x.s==y.s)        return x.id&lt;y.id;    return x.s&lt;y.s;}int main(){    int n,c,j=0;    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;c)&amp;&amp;n)    {        j++;        for(int i=0;i&lt;n;i++)        cin&gt;&gt;p[i].id&gt;&gt;p[i].na&gt;&gt;p[i].s;        if(c==1)        {            sort(p,p+n,cmp1);        }        if(c==2)        {            sort(p,p+n,cmp2);        }        if(c==3)        {            sort(p,p+n,cmp3);        }        printf(&quot;Case %d:\n&quot;,j);        for(int i=0;i&lt;n;i++)        cout&lt;&lt;p[i].id&lt;&lt;&quot; &quot;&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;endl;    }}</code></pre><h3 id="统计同成绩学生人数"><a href="#统计同成绩学生人数" class="headerlink" title="统计同成绩学生人数"></a>统计同成绩学生人数</h3><p>Description:<br>读入N名学生的成绩，将获得某一给定分数的学生人数输出。<br>Input</p><blockquote><p>测试输入包含若干测试用例，每个测试用例的格式为<br>第1行：N<br>第2行：N名学生的成绩，相邻两数字用一个空格间隔。<br>第3行：给定分数<br>当读到N=0时输入结束。其中N不超过1000，成绩分数为（包含）0到100之间的一个整数。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，将获得给定分数的学生人数输出。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>80 60 90<br>60<br>2<br>85 66<br>0<br>5<br>60 75 90 55 75<br>75<br>0</p></blockquote><p>Sample Output</p><blockquote><p>1<br>0<br>2</p></blockquote><p>Problem solving:<br>We can solve this by loop for,but I think map is exciting.<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,a,m;    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)    {                map&lt;int,int&gt; ma;        for(int i=0;i&lt;n;i++)        {            scanf(&quot;%d&quot;,&amp;a);            ma[a]++;        }        scanf(&quot;%d&quot;,&amp;m);        printf(&quot;%d\n&quot;,ma[m]);    }    return 0;}</code></pre><h3 id="What-Is-Your-Grade"><a href="#What-Is-Your-Grade" class="headerlink" title="What Is Your Grade?"></a>What Is Your Grade?</h3><p>Description:<br>“Point, point, Life of student!”<br>This is a ballad（歌谣）well known in colleges, and you must care about your score in this exam too. How many points can you get? Now, I told you the rules which are used in this course.<br>There are 5 problems in this final exam. And I will give you 100 points if you can solve all 5 problems; of course, it is fairly difficulty for many of you. If you can solve 4 problems, you can also get a high score 95 or 90 (you can get the former(前者) only when your rank is in the first half of all students who solve 4 problems). Analogically（以此类推）, you can get 85、80、75、70、65、60. But you will not pass this exam if you solve nothing problem, and I will mark your score with 50.<br>Note, only 1 student will get the score 95 when 3 students have solved 4 problems.<br>I wish you all can pass the exam!<br>Come on!<br>Input</p><blockquote><p>Input contains multiple test cases. Each test case contains an integer N (1&lt;=N&lt;=100, the number of students) in a line first, and then N lines follow. Each line contains P (0&lt;=P&lt;=5 number of problems that have been solved) and T（consumed time）. You can assume that all data are different when 0\&lt;p.<br>A test case starting with a negative integer terminates the input and this test case should not to be processed.</p></blockquote><p>Output</p><blockquote><p>Output the scores of N students in N lines for each case, and there is a blank line after each case.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>5 06:30:17<br>4 07:31:27<br>4 08:12:12<br>4 05:23:13<br>1<br>5 06:30:17<br>-1</p></blockquote><p>Sample Output</p><blockquote><p>100<br>90<br>90<br>95<br>100</p></blockquote><p>Problem solving:<br>&#39;only when your rank is in the first half of all students who solve 4 problems&#39;-&gt;This is important.What we should pay more attention to is the meaning of this problem.<br>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node{    int na;    string t;    int s;    int i;}p[105];bool cmp(node x,node y){    if(x.s==y.s)    return x.t&lt;y.t;    return x.s&gt;y.s;}bool cmp1(node x,node y){    return x.i&lt;y.i;}int main(){    int n;    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n&gt;0)    {        int mid=0,aa=0,bb=0,cc=0,dd=0;        for(int i=0;i&lt;n;i++)        {            p[i].i=i;            cin&gt;&gt;p[i].na&gt;&gt;p[i].t;            if(p[i].na==5)    p[i].s=100;            if(p[i].na==0)    p[i].s=50;            if(p[i].na==4)    {p[i].s=90;aa++;}            if(p[i].na==3)    {p[i].s=80;bb++;}            if(p[i].na==2)    {p[i].s=70;cc++;}            if(p[i].na==1)    {p[i].s=60;dd++;}        }        aa/=2;        bb/=2;        cc/=2;        dd/=2;        sort(p,p+n,cmp);        for(int i=0;i&lt;n;i++)        {            if(p[i].s==90&amp;&amp;aa)            {                p[i].s=95;                aa--;            }            if(p[i].s==80&amp;&amp;bb)            {                p[i].s=85;                bb--;            }            if(p[i].s==70&amp;&amp;cc)            {                p[i].s=75;                cc--;            }            if(p[i].s==60&amp;&amp;dd)            {                p[i].s=65;                dd--;            }        }        sort(p,p+n,cmp1);        for(int i=0;i&lt;n;i++){            cout&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;        }        puts(&quot;&quot;);    }}</code></pre><h3 id="Magical-Bamboos"><a href="#Magical-Bamboos" class="headerlink" title="Magical Bamboos"></a>Magical Bamboos</h3><p>Description:<br>In a magical forest, there exists N bamboos that don&#39;t quite get cut down the way you would expect.</p><p>Originally, the height of the ith bamboo is equal to hi. In one move, you can push down a bamboo and decrease its height by one, but this move magically causes all the other bamboos to increase in height by one.</p><p>If you can do as many moves as you like, is it possible to make all the bamboos have the same height?</p><p>Input</p><blockquote><p>The first line of input is T – the number of test cases.<br>The first line of each test case contains an integer N (1 ≤ N ≤ 105) - the number of bamboos.<br>The second line contains N space-separated integers hi (1 ≤ hi ≤ 105) - the original heights of the bamboos.</p></blockquote><p>Output</p><blockquote><p>For each test case, output on a single line &quot;yes” (without quotes), if you can make all the bamboos have the same height, and &quot;no&quot; otherwise.</p></blockquote><p>Example</p><blockquote><p>Input<br>2<br>3<br>2 4 2<br>2<br>1 2</p><p>Output<br>yes<br>no</p></blockquote><p>Problem solving:<br>Sorted this array fist.If the difference of two adjacent numbers have odd,output &#39;no&#39;,otherwise,output &#39;yes&#39;.<br>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+7;int a[maxn];int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        int m,flag=0;        scanf(&quot;%d&quot;,&amp;m);        for(int i=0;i&lt;m;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);        }        for(int i=0;i&lt;m-1;i++)        {            if((a[i+1]-a[i])%2!=0)            {                flag=1;                break;            }        }        if(flag)    puts(&quot;no&quot;);        else    puts(&quot;yes&quot;);    }    return 0;}</code></pre><h3 id="Bear-and-Three-Balls"><a href="#Bear-and-Three-Balls" class="headerlink" title="Bear and Three Balls"></a>Bear and Three Balls</h3><p>Description:<br>Limak is a little polar bear. He has n balls, the i-th ball has size ti.</p><p>Limak wants to give one ball to each of his three friends. Giving gifts isn&#39;t easy — there are two rules Limak must obey to make friends happy:</p><p>No two friends can get balls of the same size.<br>No two friends can get balls of sizes that differ by more than 2.<br>For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can&#39;t choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can&#39;t choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).</p><p>Your task is to check whether Limak can choose three balls that satisfy conditions above.</p><p>Input</p><blockquote><p>The first line of the input contains one integer n (3 ≤ n ≤ 50) — the number of balls Limak has.<br>The second line contains n integers t1, t2, ..., tn (1 ≤ ti ≤ 1000) where ti denotes the size of the i-th ball.</p></blockquote><p>Output</p><blockquote><p>Print &quot;YES&quot; (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print &quot;NO&quot; (without quotes).</p></blockquote><p>Examples</p><blockquote><p>Input<br>4<br>18 55 16 17</p><p>Output<br>YES</p></blockquote><p>Input</p><blockquote><p>6<br>40 41 43 44 44 44</p></blockquote><p>Output</p><blockquote><p>NO</p></blockquote><p>Input</p><blockquote><p>8<br>5 972 3 4 1 4 970 971</p></blockquote><p>Output</p><blockquote><p>YES</p></blockquote><p>Note</p><blockquote><p>In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.<br>In the second sample, there is no way to give gifts to three friends without breaking the rules.<br>In the third sample, there is even more than one way to choose balls:</p><ol><li>Choose balls with sizes 3, 4 and 5.</li><li>Choose balls with sizes 972, 970, 971.</li></ol></blockquote><p>Problem solving:<br>If there have three numbers which are adjacent,output &#39;yes&#39;,otherwise ouput&#39;no&#39;.<br>Code:</p><pre><code>#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[100];int main(){    int n,flag=0;    scanf(&quot;%d&quot;,&amp;n);    for(int i=0;i&lt;n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);    }    sort(a,a+n);    for(int i=0;i&lt;n;i++)    {        if(binary_search(a,a+n,a[i]+1)&amp;&amp;binary_search(a,a+n,a[i]+2))        {            flag=1;            break;        }    }    if(flag)    puts(&quot;YES&quot;);    else    puts(&quot;NO&quot;);}</code></pre><h3 id="今年暑假不AC"><a href="#今年暑假不AC" class="headerlink" title="今年暑假不AC"></a>今年暑假不AC</h3><p>Description:<br>“今年暑假不AC？”<br>“是的。”<br>“那你干什么呢？”<br>“看世界杯呀，笨蛋！”<br>“@#$%^&amp;*%...”</p><p>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）<br>Input</p><blockquote><p>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>12<br>1 3<br>3 4<br>0 7<br>3 8<br>15 19<br>15 20<br>10 15<br>8 18<br>6 12<br>5 10<br>4 14<br>2 9<br>0</p></blockquote><p>Sample Output</p><blockquote><p>5</p></blockquote><p>Problem solving:<br>Greedy,sort by the end time,and then start counting.<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;struct node{    int b,s;}x[maxn];bool cmp(node q,node w){    return q.s&lt;w.s;}int main(){    int n;    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)    {        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;x[i].b&gt;&gt;x[i].s;        }        sort(x,x+n,cmp);        int o=x[0].s,ans=1;        for(int i=0;i&lt;n;i++)        {            if(x[i].b&gt;=o)            {                ans++;                o=x[i].s;            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h3 id="The-sum-problem"><a href="#The-sum-problem" class="headerlink" title="The sum problem"></a>The sum problem</h3><p>Description:<br>Given a sequence 1,2,3,......N, your job is to calculate all the possible sub-sequences that the sum of the sub-sequence is M.<br>Input</p><blockquote><p>Input contains multiple test cases. each case contains two integers N, M( 1 &lt;= N, M &lt;= 1000000000).input ends with N = M = 0.</p></blockquote><p>Output</p><blockquote><p>For each test case, print all the possible sub-sequence that its sum is M.The format is show in the sample below.print a blank line after each test case.</p></blockquote><p>Sample Input</p><blockquote><p>20 10<br>50 30<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>[1,4]<br>[10,10]<br>[4,8]<br>[6,9]<br>[9,11]<br>[30,30]</p></blockquote><p>Problem solving:<br>Sum Formula of Equal Difference Sequences.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094035.webp" data-fancybox="images" data-caption="等差数列求和公式" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804094035.webp" class="img-shadow img-margin"></center></a><br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,m;    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        if(m==0&amp;&amp;m==0)    break;        for(int i=sqrt(2*m);i&gt;=1;i--)        {            int a=(m-i*(i-1)/2)/i;            if((a*i)+i*(i-1)/2==m)            printf(&quot;[%d,%d]\n&quot;,a,a+i-1);        }        puts(&quot;&quot;);    }return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> STL </tag>
            
            <tag> math </tag>
            
            <tag> Thinking </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPU Summer Training Day 1（河南理工大学暑期第一天）</title>
      <link href="/2019/07/17/1/"/>
      <url>/2019/07/17/1/</url>
      
        <content type="html"><![CDATA[<p>盼望着，盼望着，暑假集训来了，希望集训完自己能变的厉害点吧。不然这丢失的40天左右的假期还真是浪费了啊。</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804093910.webp" data-fancybox="images" data-caption="假期开始到假期结束" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804093910.webp" class="img-shadow img-margin"></center></a>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筱玛爱地理</title>
      <link href="/2019/06/26/nowcoder-946/"/>
      <url>/2019/06/26/nowcoder-946/</url>
      
        <content type="html"><![CDATA[<center> nowcoder-946-A 筱玛爱地理</center><p>Link: <a href="https://ac.nowcoder.com/acm/contest/946/A" target="_blank" rel="noopener">nowcoder-946-A</a><br>Description:<br>筱玛是一个热爱地理的好筱玛。最近，在《地理II》作业本上，筱玛学到了“贝塔指数”的概念：</p><blockquote><p>在经济地理学中，交通的联结度表示交通网络的发达程度，通常用贝塔指数来计算与比较。若用<br>V表示一个交通网络中结点的数量，用<br>E表示边的数量，则贝塔指数的计算方式为：β=E/V。</p></blockquote><p>“实践是检验真理的唯一标准”。作为一个热爱地理的好筱玛，她马上就把新学的知识应用到实践当中去。筱玛一口气出了n张交通网络规划图，其中第i张交通网络Gi有Vi个结点和Ei条边。筱玛一眼就看出了哪张图好、哪张图坏。但是作为一个负责任的好筱玛，她必须带领同学们一起进步。因此，她需要你将所有的n张图按照贝塔指数排序，并求出它们各自的贝塔指数在模1e9+7意义下的值。</p><p>输入描述:<br>第一行一个整数n，表示交通网络规划图的数量。</p><p>接下来n行，每行两个整数Vi和Ei，分别表示图Gi中的结点数量和边的数量。</p><p>输出描述:<br>输出共n行，每行一个数，表示贝塔指数第i大的交通网络的贝塔指数在模1e9+7意义下的值。<br>如果不能整除，输出分数取模后的结果。<br>示例1<br>输入</p><blockquote><p>1<br>1 3</p></blockquote><p>输出</p><blockquote><p>3</p></blockquote><p>说明</p><blockquote><p>显然此时<br>β=E/V=3。</p></blockquote><p>备注:</p><blockquote><p>对于100%的数据，保证<br>1≤n≤2×1e5，<br>1≤Vi,Ei≤1e9。</p></blockquote><p>Problem solving:<br>Obviously,we can solve this problem through sort.But there has a unusual situation is fractional modulo.So we use Inverse-modulo(逆元) here.</p><p><details>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>显然是一个sort就可以解决的问题，但是更难得在于要对分数取模，这个时候就会用到逆元。</details><br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e9 + 7;struct node{    ll     x, y;    double z;} a[200005];bool cmp(node x, node y){    return x.z &lt; y.z;}const int mod = 1e9 + 7;long long quickpow(long long a, long long b){    if (b &lt; 0)        return 0;    long long ret = 1;    a %= mod;    while (b)    {        if (b &amp; 1)            ret = (ret * a) % mod;        b &gt;&gt;= 1;        a   = (a * a) % mod;    }    return ret;}long long inv(long long a){    return quickpow(a, mod - 2);}int main(){    ll n;    cin &gt;&gt; n;    for (ll i = 0; i &lt; n; i++)    {        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;        a[i].z = a[i].y * 1.0 / a[i].x;    }    sort(a, a + n, cmp);    for (ll i = n - 1; i &gt;= 0; i--)        cout &lt;&lt;a[i].y * inv(a[i].x) % maxn &lt;&lt; endl;}</code></pre><p><center>About  Inverse-modulo(逆元)</center><br>There are many ways to find it.But I love this way,it&#39;s easy to understand and remember.That is <a href="https://zh.wikipedia.org/zh-hans/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">Fermat&#39;s little theorem</a>,we can ues this when the mode is a prime number.<br>The Inverse-modulo(逆元) of a in mode p is<code>a ^ (p-2)</code>.<br>Code:   </p><pre><code>const int mod = 1e9 + 7;long long quickpow(long long a, long long b){    if (b &lt; 0)        return 0;    long long ret = 1;    a %= mod;    while (b)    {        if (b &amp; 1)            ret = (ret * a) % mod;        b &gt;&gt;= 1;        a   = (a * a) % mod;    }    return ret;}long long inv(long long a){    return quickpow(a, mod - 2);}</code></pre><p><font color="red">So (a/b)%p=a*inv(b)%p.</font></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
            <tag> inverse-modulo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 572 (Div. 2)</title>
      <link href="/2019/06/25/Codeforces-572/"/>
      <url>/2019/06/25/Codeforces-572/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1189" target="_blank" rel="noopener">Codeforces Round 572</a></p><p><center>A Keanu Reeves</center><br>Description:<br>After playing Neo in the legendary &quot;Matrix&quot; trilogy, Keanu Reeves started doubting himself: maybe we really live in virtual reality? To find if this is true, he needs to solve the following problem.</p><p>Let&#39;s call a string consisting of only zeroes and ones good if it contains different numbers of zeroes and ones. For example, 1, 101, 0000 are good, while 01, 1001, and 111000 are not good.</p><p>We are given a string s of length n consisting of only zeroes and ones. We need to cut s into minimal possible number of substrings s1,s2,…,sk such that all of them are good. More formally, we have to find minimal by number of strings sequence of good strings s1,s2,…,sk such that their concatenation (joining) equals s, i.e. s1+s2+⋯+sk=s.</p><p>For example, cuttings 110010 into 110 and 010 or into 11 and 0010 are valid, as 110, 010, 11, 0010 are all good, and we can&#39;t cut 110010 to the smaller number of substrings as 110010 isn&#39;t good itself. At the same time, cutting of 110010 into 1100 and 10 isn&#39;t valid as both strings aren&#39;t good. Also, cutting of 110010 into 1, 1, 0010 isn&#39;t valid, as it isn&#39;t minimal, even though all 3 strings are good.</p><p>Can you help Keanu? We can show that the solution always exists. If there are multiple optimal answers, print any.</p><p>Input<br>The first line of the input contains a single integer n (1≤n≤100) — the length of the string s.</p><p>The second line contains the string s of length n consisting only from zeros and ones.</p><p>Output<br>In the first line, output a single integer k (1≤k) — a minimal number of strings you have cut s into.</p><p>In the second line, output k strings s1,s2,…,sk separated with spaces. The length of each string has to be positive. Their concatenation has to be equal to s and all of them have to be good.</p><p>If there are multiple answers, print any.</p><p>Examples<br>input</p><blockquote><p>1<br>1</p></blockquote><p>output</p><blockquote><p>1<br>1</p></blockquote><p>input</p><blockquote><p>2<br>10</p></blockquote><p>output</p><blockquote><p>2<br>1 0</p></blockquote><p>input</p><blockquote><p>6<br>100011</p></blockquote><p>output</p><blockquote><p>2<br>100 011</p></blockquote><p>Note</p><blockquote><p>In the first example, the string 1 wasn&#39;t cut at all. As it is good, the condition is satisfied.<br>In the second example, 1 and 0 both are good. As 10 isn&#39;t good, the answer is indeed minimal.<br>In the third example, 100 and 011 both are good. As 100011 isn&#39;t good, the answer is indeed minimal.</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int o[105], z[105];int main(){    int    n, a, b;    a = b = 0;    string s;    cin &gt;&gt; n &gt;&gt; s;    for (int i = 0; i &lt; s.size(); i++)    {        if (s[i] == &#39;1&#39;)            a++;        if (s[i] == &#39;0&#39;)            b++;        o[i] = a;        z[i] = b;    }    int ans = 0;    if (a != b)    {        cout &lt;&lt; &quot;1\n&quot; &lt;&lt; s &lt;&lt; endl;    }    else    {        cout &lt;&lt; &quot;2\n&quot;;        for (int i = 0; i &lt; s.size()-1; i++)            cout &lt;&lt; s[i];        cout &lt;&lt; &quot; &quot; &lt;&lt; s[s.size() - 1] &lt;&lt; endl;    }}</code></pre><p><center>B Number Circle</center><br>Description:<br>You are given n numbers a1,a2,…,an. Is it possible to arrange them in a circle in such a way that every number is strictly less than the sum of its neighbors?</p><p>For example, for the array [1,4,5,6,7,8], the arrangement on the left is valid, while arrangement on the right is not, as 5≥4+1 and 8&gt;1+6.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095249.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095249.webp" class="img-shadow img-margin"></center></a><br>Input<br>The first line contains a single integer n (3≤n≤105) — the number of numbers.</p><p>The second line contains n integers a1,a2,…,an (1≤ai≤109) — the numbers. The given numbers are not necessarily distinct (i.e. duplicates are allowed).</p><p>Output<br>If there is no solution, output &quot;NO&quot; in the first line.</p><p>If there is a solution, output &quot;YES&quot; in the first line. In the second line output n numbers — elements of the array in the order they will stay in the circle. The first and the last element you output are considered neighbors in the circle. If there are multiple solutions, output any of them. You can print the circle starting with any element.</p><p>Examples<br>input</p><blockquote><p>3<br>2 4 3</p></blockquote><p>output</p><blockquote><p>YES<br>4 2 3</p></blockquote><p>input</p><blockquote><p>5<br>1 2 3 4 4</p></blockquote><p>output</p><blockquote><p>YES<br>4 4 2 1 3</p></blockquote><p>input</p><blockquote><p>3<br>13 8 5</p></blockquote><p>output</p><blockquote><p>NO</p></blockquote><p>input</p><blockquote><p>4<br>1 10 100 1000</p></blockquote><p>output</p><blockquote><p>NO</p></blockquote><p>Note</p><blockquote><p>One of the possible arrangements is shown in the first example:<br>4&lt;2+3;<br>2&lt;4+3;<br>3&lt;4+2.<br>One of the possible arrangements is shown in the second example.<br>No matter how we arrange 13,8,5 in a circle in the third example, 13 will have 8 and 5 as neighbors, but 13≥8+5.<br>There is no solution in the fourth example.</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;typedef long long ll;ll        a[maxn];int main(){    queue&lt;ll&gt; f;    stack&lt;ll&gt; e;    ll        n;    cin &gt;&gt; n;    for (ll i = 0; i &lt; n; i++)    {        cin &gt;&gt; a[i];    }    sort(a, a + n);    if (a[n - 1] &gt;= (a[n - 3] + a[n - 2]))    {        puts(&quot;NO&quot;);        return 0;    }    puts(&quot;YES&quot;);    int flag = 1;    for (int i = n - 1; i &gt;= 0; i--)    {        if (flag)        {            f.push(a[i]);            if (a[i - 1] != a[i])                flag = 0;        }        else        {            e.push(a[i]);            if (a[i - 1] != a[i])                flag = 1;        }    }    while (!f.empty())    {        cout &lt;&lt; f.front() &lt;&lt; &quot; &quot;;        f.pop();    }    while (!e.empty())    {        cout &lt;&lt; e.top() &lt;&lt; &quot; &quot;;        e.pop();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Thinking </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Past About</title>
      <link href="/2019/06/25/about-past/"/>
      <url>/2019/06/25/about-past/</url>
      
        <content type="html"><![CDATA[<h1 id="My-blog"><a href="#My-blog" class="headerlink" title=" My blog"></a><font> My blog</font></h1><font>   Purpose：<br>1.It is to record what i have learned, and it is convenient to go back to review.<br>2.Get to know more friends through this exploration.<br>3.Enhance your hands-on ability, language organization skills, etc.</font><h1 id="Contact-me"><a href="#Contact-me" class="headerlink" title="Contact me"></a><font>Contact me</font></h1><font>qq: 1120437716<br>G-mial: miaodrew@gmail.com</font><!-- # <font color=green><center>Uncle_drew——Kyrie Irving</font><video poster="https://i.loli.net/2019/04/24/5cbfe870ab5df.webp" src="https://cndrew.oss-cn-beijing.aliyuncs.com/DLDS%20BD_Trim.mp4?Expires=1556797279&OSSAccessKeyId=TMP.AgGrsBlrr7wyRY2eNLMPVJBpZWXPEh0ijJyum9uPzwXMY5zZpJwKbs9oDg_3ADAtAhQfBbYsXegEID7fRFYP75aPc4vAsQIVALvgj5FULPk_DxHxdlG7tUe7yHLF&Signature=FXoaWI8EWBw5n5rdQuy5FHOH8Js%3D" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta">Your browser does not support the video tag.</video> --><h1 id="Some-sharing-of-Baiduyun"><a href="#Some-sharing-of-Baiduyun" class="headerlink" title="Some sharing of Baiduyun"></a><font><center>Some sharing of Baiduyun</center></font></h1><font>* [c++API帮助文档](https://pan.baidu.com/s/1fazrwAR31I3va5okG3R_Mw)提取码：hyco<br>* [python学习参考资料](https://pan.baidu.com/s/1vVrI4Qmhw_YXwsIPjf7fRA)提取码：2k84 <br><center>Continuous update...</center></font><h1 id="My-favorite-music"><a href="#My-favorite-music" class="headerlink" title="My favorite music"></a><font><center>My favorite music</center></font></h1><div class="aplayer" data-id="2005855998&userid=1305878902" data-server="netease" data-type="playlist" data-mode="random"></div><h1 id="Relax-for-a-moment丷"><a href="#Relax-for-a-moment丷" class="headerlink" title="Relax for a moment丷"></a><font>Relax for a moment丷</font></h1><h2 id="泰戈尔"><a href="#泰戈尔" class="headerlink" title="泰戈尔"></a><font>泰戈尔</font></h2><a href="https://5b0988e595225.cdn.sohucs.comhttps://cdn.jsdelivr.net/gh/drew233/cdn/20180124/c87253f017d447419c45728c72899c6b.jpeg" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://5b0988e595225.cdn.sohucs.comhttps://cdn.jsdelivr.net/gh/drew233/cdn/20180124/c87253f017d447419c45728c72899c6b.jpeg" class="img-shadow img-margin"></center></a><h3 id="生如夏花"><a href="#生如夏花" class="headerlink" title="生如夏花"></a><font color="#292421" size="10"><center>生如夏花</center></font></h3><font><center>我听见回声，来自山谷和心间以寂寞的镰刀收割空旷的灵魂不断地重复决绝，又重复幸福终有绿洲摇曳在沙漠我相信自己生来如同璀璨的夏日之花不凋不败，妖治如火承受心跳的负荷和呼吸的累赘乐此不疲我听见音乐，来自月光和胴体辅极端的诱饵捕获飘渺的唯美一生充盈着激烈，又充盈着纯然总有回忆贯穿于世间我相信自己死时如同静美的秋日落叶不盛不乱，姿态如烟即便枯萎也保留丰肌清骨的傲然玄之又玄我听见爱情，我相信爱情爱情是一潭挣扎的蓝藻如同一阵凄微的风穿过我失血的静脉驻守岁月的信念我相信一切能够听见甚至预见离散，遇见另一个自己而有些瞬间无法把握任凭东走西顾，逝去的必然不返请看我头置簪花，一路走来一路盛开频频遗漏一些，又深陷风霜雨雪的感动般若波罗蜜，一声一声生如夏花，死如秋叶还在乎拥有什么<br></center></font><h3 id="当时光已逝"><a href="#当时光已逝" class="headerlink" title="当时光已逝"></a><font color="#292421" size="10"><center>当时光已逝</center></font></h3><font><center>假如时光已逝，鸟儿不再歌唱，风儿也吹倦了，那就用黑暗的厚幕把我盖上，如同黄昏时节你用睡眠的衾被裹住大地，又轻轻合上睡莲的花瓣。路途未完，行囊已空,衣裳破裂污损，人已精疲力竭。你驱散了旅客的羞愧和困窘，使他在你仁慈的夜幕下，如花朵般焕发生机。在你慈爱的夜幕下苏醒。<br></center></font><h3 id="不要不辞而别，我爱"><a href="#不要不辞而别，我爱" class="headerlink" title="不要不辞而别，我爱"></a><font color="#292421" size="10"><center>不要不辞而别，我爱</center></font></h3><font><center>不要不辞而别，我爱。我看望了一夜，现在我脸上睡意重重。只恐我在睡中把你丢失了。不要不辞而别，我爱。我惊起伸出双手去摸触你，我问自己说：“这是一个梦么？”但愿我能用我的心系住你的双足，紧抱在胸前！不要不辞而别，我爱。<br></center></font><h3 id="永恒的爱情"><a href="#永恒的爱情" class="headerlink" title="永恒的爱情"></a><font color="#292421" size="10"><center><center>永恒的爱情</center></center></font></h3><font><center><center>我以数不清的方式爱你我的痴心永远为你编织歌之花环亲爱的，接受我的奉献世世代代以各种方式挂在你的胸前我听过的许多古老爱情的故事充满聚首的欢乐和离别的悲郁纵观无始的往昔我看见你像永世难忘的北斗穿透岁月的黑暗姗姗来到我的面前从洪荒时代的心源出发你我泛舟顺流而下你我在亿万爱侣中间嬉戏分离时辛酸的眼泪和团圆时甜蜜的羞涩里古老的爱情孕育了新意陈腐的爱情而今化为你脚下的灰尘一切心灵的爱欲、悲喜一切爱情传说，历史诗人写的恋歌歌词全部融合在你我新型的爱情里<br></center></center></font><h2 id="林徽因"><a href="#林徽因" class="headerlink" title="林徽因"></a><font>林徽因</font></h2><a href="https://photocdn.sohu.com/20130315/Img368991812.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://photocdn.sohu.com/20130315/Img368991812.webp" class="img-shadow img-margin"></center></a><h3 id="深夜里听到乐声"><a href="#深夜里听到乐声" class="headerlink" title="深夜里听到乐声"></a><font color="#292421" size="10"><center>深夜里听到乐声</center></font></h3><font><center>这一定又是你的手指，轻弹着，在这深夜，稠密的悲思；我不禁颊边泛上了红，静听着，这深夜里弦子的生动。一声听从我心底穿过，忒凄凉我懂得，但我怎能应和？生命早描定她的式样，太薄弱是人们的美丽的想象。除非在梦里有这么一天，你和我同来攀动那根希望的弦。选自《新月诗选》（1931年9月）<br></center></font><h3 id="山中一个夏夜"><a href="#山中一个夏夜" class="headerlink" title="山中一个夏夜"></a><font color="#292421" size="10"><center>山中一个夏夜</center></font></h3><font><center>山中一个夏夜，深得象没有底一样；黑影，松林密密的；周围没有点光亮。对山闪着只一盏灯———两盏象夜的眼，夜的眼在看！满山的风全蹑着脚象是走路一样；躲过了各处的枝叶各处的草，不响。单是流水，不断的在山谷上石头的心，石头的口在唱。均匀的一片静，罩下象张软垂的幔帐。疑问不见了，四角里模糊，是梦在窥探？夜象在祈祷，无声的在期望幽郁的虔诚在无声里布漫。<p align="right">选自《新月》四卷七期（1933年6月）</p><br></center></font><h3 id="那一晚"><a href="#那一晚" class="headerlink" title="那一晚"></a><font color="#292421" size="10"><center>那一晚</center></font></h3><font><center>那一晚我的船推出了河心，澄蓝的天上托着密密的星。那一晚你的手牵着我的手，迷惘的星夜封锁起重愁。那一晚你和我分定了方向，两人各认取个生活的模样。到如今我的船仍然在海面飘，细弱的桅杆常在风涛里摇。到如今太阳只在我背后徘徊，层层的阴影留守在我周围。到如今我还记着那一晚的天，星光、眼泪、白茫茫的江边！到如今我还想念你岸上的耕种：红花儿黄花儿朵朵的生动。那一天我希望要走到了顶层，蜜一般酿出那记忆的滋润。那一天我要跨上带羽翼的箭，望着你花园里射一个满弦。那一天你要听到鸟般的歌唱，那便是我静候着你的赞赏。那一天你要看到零乱的花影，那便是我私闯入当年的边境！</center></font><h2 id="六毛"><a href="#六毛" class="headerlink" title="六毛"></a><font>六毛</font></h2><h3 id="纠纷"><a href="#纠纷" class="headerlink" title="纠纷"></a><font color="#292421" size="10"><center>纠纷</center></font></h3><font><center>数不清的繁星点亮勾勒出，你的脸庞你是我的繁星在无尽的黑夜发光数不清的鲜花绽放显现出，我的念想你是我的鲜花在我的心中为王。但我知道，我只是一片最普通，最平凡的土壤配不上任何一朵花的芳香我知道，我只是一片虚无与黑暗相随不值得任何繁星点亮。你不必反复强调我们的关系，我只会与你保持应有的距离。</center></font><h3 id="鹰的独白Ⅰ——古寺·远方"><a href="#鹰的独白Ⅰ——古寺·远方" class="headerlink" title="鹰的独白Ⅰ——古寺·远方"></a><font color="#292421" size="10"><center>鹰的独白Ⅰ——古寺·远方</center></font></h3><font><center>我曾经 是只雄鹰如今 失去了翅膀慵懒的如古寺中的老僧唯一的消遣是抬头看看太阳我梳理着身上的羽毛回忆着它疯狂拼搏的曾经厌倦着它如今的闪闪发光我是一只雄鹰却渴望在远方有种宝藏 叫翅膀我曾经知道努力懂得疯狂待尘埃落尽 换回的却是百孔千疮蹒跚着 我走向那远方没有意料中的翅膀只有一种力量助我飞翔叫 坚强！</center></font><h3 id="鹰的独白Ⅱ——沉思"><a href="#鹰的独白Ⅱ——沉思" class="headerlink" title="鹰的独白Ⅱ——沉思"></a><font color="#292421" size="10"><center>鹰的独白Ⅱ——沉思</center></font></h3><font><center>我再次获得了飞翔的力量我拼命煽动着这双不会感到疲惫的翅膀无翼的牢笼不在束缚着我取而代之的是 古寺让我牵挂无奈我是一只多情的鹰纵然飞了起来也只是换了一个地方 晒晒太阳我最终选择了离去来到异地他乡这里的新奇模样让我忘却了忧伤可这并不长久我思念起了古寺想起故乡沉默我看着自己的翅膀怀念那时纵然不会飞时的 四处游荡我渴望回到过去即使不再可以飞翔</center></font><h3 id="鹰的独白Ⅲ——终篇·轮回"><a href="#鹰的独白Ⅲ——终篇·轮回" class="headerlink" title="鹰的独白Ⅲ——终篇·轮回"></a><font color="#292421" size="10"><center>鹰的独白Ⅲ——终篇·轮回</center></font></h3><font><center>我回到了这里我朝思暮想的地方美人鱼失去声音换来幸福我失去了翅膀与记忆换来轮回无穷无尽我在这世间游荡古寺远方我都曾有印象我不敢继续回想只是害怕发现无法发承受的真相我是一只雄鹰我失去过翅膀我是一只雄鹰曾经也可以自由自在的翱翔因为轮回我忘却了一切脑海中唯一留下的是我是一只雄鹰古寺远方永远都是我的信仰<p align="right">2017</p></center></font><h3 id="无题"><a href="#无题" class="headerlink" title="无题"></a><font color="#292421" size="10"><center>无题</center></font></h3><font><center>独自在街头散步昏黄的灯光照亮前方的路是否有人在梅花盛开之际陪我一起守候看灯火通明无奈无人伴我左右盛开的梅花凋零以久孤守黑暗的阁楼凄凉的月光照进我的心头彷徨在无人的山头观望梅花依旧起身醉吟梦回沙场战争彼此挥刀舞剑只为去留大雨留下漫天印记阴沉的乌云遮蔽万丈晴空自以为是斑出一副小丑阿谀奉承未讨倾心却痛了心头悲痛不知结局已定心中的纠结像尘埃一样充满在空中仿佛一切的源头都来自似血般浓稠的朋友却问如何继续伪装翅膀早已鲜血淋淋再无法飞上天际消解心中的痛俯身抚摸自己的影子到底该如何决定是去是留缠绵在悲伤的季节仰望天空浑然只剩悲愁牵手好像无法跨越的壕沟只有望洋兴叹看落英近在崖口枯树逢春便萌发生命强劲不知春早不如旧转身看人海茫茫寻一人天长地久再次贸然决定还是停留<p align="right">2015.1.29</p></center></font><h2 id="好友投稿专区"><a href="#好友投稿专区" class="headerlink" title="好友投稿专区"></a><font>好友投稿专区</font></h2><h3 id="QQQiang"><a href="#QQQiang" class="headerlink" title="QQQiang."></a><font>QQQiang.</font></h3><font>那些毫不留情告诉你不可能的女孩子，上辈子一定是天使，才会如此善良。虽然当时她像是用一颗铁钉将你穿破，其实后来想起，还有美好的回忆，还能记起曾喜欢过的感觉，甚至还要谢谢她，那么绝情，那么美。那些在你准备离去的时候假装热情的女孩子，用一种名为“希望”的泡沫，在你的心上划下了一刀又一刀，放空了你心里所有的温柔，落得满是伤痕，千疮百孔。回忆起来，竟然只剩下憎恨，憎恨她，憎恨喜欢她的自己。年少的时候，喜欢来了，你就欢喜，你就庆幸，然后你才苦恼，你才纠结。年长了以后，喜欢来了，你先否定，你先假设，然后你才承认，你才相信。这世界上不是每个人都值得我们温柔以待。这个世界上却还有一些人让我愿意满腔温柔。愿你遇见那个，会对你的温柔回报以歌的女孩。想必她在你眼里，耀眼得像颗恒星。编辑于 2018-06-22<p align="right">文章来源于知乎@柒岁安</p></font><h3 id="程阳"><a href="#程阳" class="headerlink" title="程阳"></a><font>程阳</font></h3><font><center>你不是赵雷的南方姑娘不是马頓的傲雪不是宋冬野的董小姐不是李志的港岛妹妹不是海龟的玛卡瑞纳不是二百的玫瑰不是尧十三的北方女王不是花粥的良人不是低苦艾的小花花不是陈粒的祝星你是青岛春天的海你是南京路边的梧桐你是苏州水摊上的姑娘你是武汉长江上的船你是郑州夜晚的孩子你是太原路上的琴声你是我失去的爱人</center><p align="right">摘自：酷狗音乐《北方女王》热评</p></font><font><center>四景浩荡录我题诗中乾坤 白日犹见月，闲游青川走马 使我不收砚三山五岳 纵巍峨绝险 不过在人间四景天河浩荡 尽在我画卷我行江湖沧浪 独揽寒山月兴来足点竹稍 我便似神仙鸟鸣花间 纵千里不绝 不过此山间天下清风雨露 皆为我拭剑以江作镜自照 拂拭天地变笑我收剑平事 出剑慨世间挥毫江山 落笔回春野 悬砚为风月四景天河浩荡 尽在我画卷同行江湖沧浪 诗酒书一篇逐松风且放歌 再吹绿山野以笔作剑 开星与点月 踏遍扬州雪四景天河浩荡 皆共我揽结题诗中乾坤 行江湖沧浪16岁的仙生日快乐！@流仙</center></font>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Poetry </tag>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A 3D-Album</title>
      <link href="/2019/06/21/3dAlbum/"/>
      <url>/2019/06/21/3dAlbum/</url>
      
        <content type="html"><![CDATA[<p>Demo: <a href="https://cndrew.cn/blog/photos" target="_blank" rel="noopener">3D-Album</a><br>Reprinted on: <a href="https://blog.csdn.net/u014346301/article/details/53447712" target="_blank" rel="noopener">https://blog.csdn.net/u014346301/article/details/53447712</a><br>Code:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;3D相册&lt;/title&gt;    &lt;style&gt;        .container{            width:800px;            height: 400px;            margin:0 auto;            perspective: 1000px;        }        .box{            position: relative;            width: 100%;            height: 100%;            -webkit-transform-style: preserve-3d;            -moz-transform-style: preserve-3d;            -ms-transform-style: preserve-3d;            transform-style: preserve-3d;            -webkit-animation:animate 12s linear infinite;            -o-animation:animate 12s linear infinite;            animation:animate 12s linear infinite;        }        .img{            position: absolute;            width:300px;            height: 200px;            background: #8959a8;            top: 100px;            left:250px;            box-shadow: inset 0 0 5px #bbbbbb;        }        .img1{            background: url(&quot;../img/1.webp&quot;) no-repeat;            -webkit-background-size:cover;            background-size:cover;            transform: rotateY(0deg) translateZ(300px);        }        .img2{            background: url(&quot;../img/2.webp&quot;) no-repeat;            -webkit-background-size:cover;            background-size:cover;            transform: rotateY(60deg) translateZ(300px);        }        .img3{            background: url(&quot;../img/3.webp&quot;) no-repeat;            -webkit-background-size:cover;            background-size:cover;            transform: rotateY(120deg) translateZ(300px);        }        .img4{            background: url(&quot;../img/4.webp&quot;) no-repeat;            -webkit-background-size:cover;            background-size:cover;            transform: rotateY(180deg) translateZ(300px);        }        .img5{            background: url(&quot;../img/5.webp&quot;) no-repeat;            -webkit-background-size:cover;            background-size:cover;            transform: rotateY(240deg) translateZ(300px);        }        .img6{            background: url(&quot;../img/6.webp&quot;) no-repeat;            -webkit-background-size:cover;            background-size:cover;            transform: rotateY(300deg) translateZ(300px);        }        @keyframes animate {            0%{                transform: rotateY(0deg);            }            100%{                transform: rotateY(360deg);            }        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;        &lt;div class=&quot;img img1&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;img img2&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;img img3&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;img img4&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;img img5&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;img img6&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> Tutorial </tag>
            
            <tag> Useful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to use rss.</title>
      <link href="/2019/06/20/RSS/"/>
      <url>/2019/06/20/RSS/</url>
      
        <content type="html"><![CDATA[<h3 id="如何使用RSS"><a href="#如何使用RSS" class="headerlink" title="如何使用RSS"></a>如何使用RSS</h3><p>作者： 阮一峰<br>日期： 2006年1月 8日</p><p>一、</p><p>自从我发现很多人不知道什么是RSS以后，我就一直想向大家介绍它，因为它太有用了，将来会和电子邮件一样重要。不懂得RSS，上网的效率和乐趣都要大打折扣。<br>我在网上找不到简明易懂的介绍文章，只好下决心自己来写。虽然我不是这方面的专业人士，但是我相信你只要耐心读完这篇文章，你就会基本搞懂RSS以及它的使用方法。</p><p>二、</p><p>在解释RSS是什么之前，让我先来打一个比方。</p><p>读大学的时候，我有个习惯，就是每天要去看食堂后面的海报栏。在那里，会贴出各种各样最新的消息，比如哪个系要开讲座了、星期二晚上的电影放什么、二手货转让等等。只要看一下海报栏，就会对学校的各种活动心中有数。</p><p>如果没有海报栏的话，要想知道这些消息就会很麻烦。讲座消息会贴在各个系自己的公告栏里，电影排片表是贴在电影院里的，二手货消息则会贴在各幢宿舍的楼道里。我所在的大学有20几个系，一万多人，要想知道所有这些消息的话，即使是可能的话，也会相当的麻烦。</p><p>从这个例子出发，让我们来考虑一下互联网。</p><p>互联网是什么？最直观的说，就是一个杂乱无章的巨大信息源，其丰富和杂乱的程度，不仅是巨大的，而且几乎是无限的。</p><p>一个使用者，要想及时掌握的互联网上出现的最新信息，有办法吗？</p><p>答案是没有办法，他只有一个网站一个网站的打开，去看有什么最新内容，就好比每天都必须去每一个系里走一遍，看有什么最新讲座。如果是几个网站，哪倒也不难，都去看一遍也花不了多少时间。但是随着你关注的网站数量上升，这项工作会迅速的变为&quot;Mission Impossible&quot;。想象一下，如果你每天关注几十个、甚至几百个网站，会是怎样的情景。光是打开它们的首页，就要花费多少时间啊，更别说浏览花去的时间了。</p><p>也许有人会说，普通人的话，谁会关心那么多网站啊？</p><p>我要说，哪怕你只是一个网络的初级或最单纯的使用者，与你发生关系的网站数量也在急剧增加，因为Blog出现了。越来越多的人开始写作网络日志（Blog），把自己的想法和生活在网上展示，其中也必然包括你的朋友，或者其他你感兴趣的人。你想知道他/她的最新动向，就势必要留心他/她的Blog。所以，你的网站浏览清单总有一天会和你的电话本、MSN Message好友列表一样多，甚至更多。</p><p>那时，你会发现浏览网站会变成一种困难和低效率的行为。</p><p>有没有办法找到互联网上的&quot;海报栏&quot;，只去一个地方就知道你所想知道的所有最新内容？</p><p>有，那就是RSS。</p><p>三</p><p>准确的说，RSS就像一个网站的海报，里面包括这个网站的最新内容，会自动更新。所以，我们只要订阅了RSS，就不会错过自己喜欢的网站的更新了。</p><p>但是光有海报还不行，还必须有海报栏，也就是说必须有RSS阅读器才行。因为RSS只是数据源，它本身是写给程序看的，必须经过阅读器转换，才能成为可以浏览的格式。</p><p>RSS阅读器多种多样，大致分为两种，一种是桌面型的，需要安装；另一种是在线型，直接使用浏览器进行阅读。</p><p>四</p><p>在浏览器中订阅RSS，就必须先知道RSS的地址。一般来说，各个网站的首页都会用显著位置标明。名称可能会有些不同，比如RSS、XML、FEED，大家知道它们指的都是同样的东西就可以了。有时RSS后面还会带有版本号，比如2.0、1.0，甚至0.92，这个不必理会，它们只是内部格式不同，内容都是一样。</p><p>将RSS地址复制下来以后，你就可以在在线阅读器中添加。</p><p>以后，只用打开这一个网页，就可以看到所有你喜欢的网站的最新内容了。</p><p>（完）</p><p>Reprinted on: <a href="https://www.ruanyifeng.com/blog/2006/01/rss.html?20190629083248#comment-text" target="_blank" rel="noopener">阮一峰的网络日志</a></p><h3 id="A-rss-reader-Newsflow"><a href="#A-rss-reader-Newsflow" class="headerlink" title="A rss reader--Newsflow."></a>A rss reader--Newsflow.</h3><p>You can download it and use it to achieve rss subscription locally.I will not make a specific introduction.If you are interested, you can explore it yourself.</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Tutorial </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to download images on instagram</title>
      <link href="/2019/06/19/ins/"/>
      <url>/2019/06/19/ins/</url>
      
        <content type="html"><![CDATA[<p>As we all know,there are many high quality images on the instagram.But saving the image directly is forbidden.As the saying goes,there must be a road before the car goes to the mountain.There have been many ways to download images on instagram.Such as a plugin or a WeChat public number.I tried all these methods, but the results did not satisfy me.And then I found a easy and useful way.</p><p>Such as,we are willing to download this image.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095723.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095723.webp" class="img-shadow img-margin"></center></a><br>First,right click to find this option - view the page source code.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095806.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095806.webp" class="img-shadow img-margin"></center></a><br>After you click in,you may be scared by a lot of things you don&#39;t understand.Calm down,use the shortcut key <code>Ctrl+u</code> to bring up the search box.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095823.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095823.webp" class="img-shadow img-margin"></center></a><br>And then input <code>webp</code>,the first result of the search results is the url of the image we are looking for(Look at where I draw).<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095939.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095939.webp" class="img-shadow img-margin"></center></a><br>So now we know the url of this image is:</p><pre><code>https://scontent-nrt1-1.cdninstagram.com/vp/ff449eed1ee7a9806334532d0e3dcbb9/5DA3D2C0/t51.2885-15/e35/58721835_156199248745005_4328502816718543045_n.webp?_nc_ht=scontent-nrt1-1.cdninstagram.com</code></pre><p>Copy this url to the address box of the browser,then you can Right click -&gt; Save as image.</p><p>Finally,I want to share a very interesting thing with you.When I was in high school, I learned a star online and found a beautiful photo of her, but when I wanted to see it again these two days, I found out that I couldn’t find it. I suddenly thought of ins and turned over about 500 photos,then I found this and I am very happy.Here is the photo<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100001.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804100001.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> instagram </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Make your own template by mkdocs.</title>
      <link href="/2019/06/18/mkdocs_template/"/>
      <url>/2019/06/18/mkdocs_template/</url>
      
        <content type="html"><![CDATA[<p>一次偶然的机回，接触到了mkdocs，被它的分明的层次直接就震住了，又想起来本蒻蒻最好自己总结一个ACM的模板（毕竟自己的能更好的看懂。再加上很强的探(zhuang)索(b)精神，就去谷歌百度各种关于mkdocs的介绍及使用，也是成功的搭好了自己的模板（内容尚未完成。<br>Demo: <a href="https://cndrew.cn/My-Template/" target="_blank" rel="noopener">Uncle drew&#39;s template</a></p><h3 id="安装mkdocs"><a href="#安装mkdocs" class="headerlink" title="安装mkdocs"></a>安装mkdocs</h3><p>安装有很多方式。例如apt-get，dnf，homebrew， yum，chocolatey等。但是我一个都没见过，不过mkdocs也可以使用python（中的pip）安装。<br>安装mkdocs的命令</p><pre><code>pip install mkdocs</code></pre><p>运行这一行命令之后等一会，会有安装成功的提示。这里因为我之前已经安装过了，所以安装成功的提示我也截不到图，相信你应该是可以看懂successful的。</p><h3 id="建立一个基本的页面"><a href="#建立一个基本的页面" class="headerlink" title="建立一个基本的页面"></a>建立一个基本的页面</h3><p>安装好mkdocs之后，我们首先要创立一个自己的项目</p><pre><code>mkdocs new my-project(项目名可以自定义)</code></pre><p>执行完之后，会显示</p><pre><code>INFO    -  Creating project directory: my-projectINFO    -  Writing config file: my-project\mkdocs.ymlINFO    -  Writing initial docs: my-project\docs\index.md</code></pre><p>然后我们再去你创建新项目的文件夹中就可以看到<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101358.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101358.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101426.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101426.webp" class="img-shadow img-margin"></center></a></p><p>这时候最基础的一个网页你就生成好了，你可以选择</p><pre><code>mkdocs serve</code></pre><p>这行命令实现本地预览（注意，要去到<code>my-projrct</code>的根目录，即有<code>mkdocs.yml</code>的地方运行这一行命令）。运行成功的话可以看到</p><pre><code>INFO    -  Building documentation...INFO    -  Cleaning site directory[I 190629 07:29:38 server:296] Serving on https://127.0.0.1:8000[I 190629 07:29:38 handlers:62] Start watching changes[I 190629 07:29:38 handlers:64] Start detecting changes</code></pre><p>然后你就可以去浏览器输入<code>https://127.0.0.1:8000</code>进行本地预览。效果如下<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101601.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101601.webp" class="img-shadow img-margin"></center></a></p><h3 id="添加新的页面"><a href="#添加新的页面" class="headerlink" title="添加新的页面"></a>添加新的页面</h3><p>这里以添加about页面为例。在<code>docs</code>里面新建一个文件&#39;about.md&#39;即可。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101620.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101620.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101709.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101709.webp" class="img-shadow img-margin"></center></a><br>以此为例，可以添加你想添加的页面，以markdown的格式编辑即可。</p><h3 id="建立网站"><a href="#建立网站" class="headerlink" title="建立网站"></a>建立网站</h3><p>如果你想把你的mkdocs搭建的东西托管在github（诸如此类）的地方，接着看下去。<br>执行这个命令</p><pre><code>mkdocs build</code></pre><p>成功的话会有提示信息</p><pre><code>INFO    -  Cleaning site directoryINFO    -  Building documentation to directory: E:\mkdocs\my-project\site</code></pre><p>然后在你的mkdocs根目录中会出现一个新的文件夹&#39;site&#39;,里面的文件大致上是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101815.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101815.webp" class="img-shadow img-margin"></center></a></p><h3 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h3><p>这个跟hexo还不一样，但是你需要github上面存在一个仓库用于存放mkdocs的相关文件。只要把site文件夹里面的文件全部上传到github上的仓库里面，github pages就可以直接使用了。<br>或者你可以直接使用命令</p><pre><code>mkdocs gh-deploy</code></pre><p>这个命令我现在还有点懵，推荐大家可以去看看这篇博客： <a href="https://blog.keybrl.com/professional/2018-05-19-mkdocs-blog.html" target="_blank" rel="noopener">https://blog.keybrl.com/professional/2018-05-19-mkdocs-blog.html</a><br>不过我只是用mkdocs做出来一个模板，也不是写个人博客。上传频率不高，手动copy完全可以满足我的需要（要是能弄好自动部署，谁还愿意手动啊，卑微。</p><h3 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h3><p>第一次看到mkdocs的demo，十分中意它两边的目录，可是自己弄了之后发现不是这样的，后来搜索了一番才知道那是另一个主题——<a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">mkdocs-material</a>。<br>安装之后就可以出现很炫酷（个人认为 的双目录了。</p><h3 id="我的mkdocs-yml文档"><a href="#我的mkdocs-yml文档" class="headerlink" title="我的mkdocs.yml文档"></a>我的mkdocs.yml文档</h3><p>关于一些mkdocs的配置，以及这个主题的配置，可以看看我的yml</p><pre><code>site_name: Templatesite_author: Uncle_drewrepo_url: https://github.com/Drew233site_url: https://github.com/Drew233site_description: My own template.theme:  language: &#39;zh&#39;  feature:    tabs: true  name: &#39;material&#39;  palette:    primary: &#39;indigo&#39;    accent: &#39;indigo&#39;    font:    text: &#39;Ubuntu&#39;    code: &#39;Ubuntu Mono&#39;    include_search_page: false    search_index_only: trueextra:  search:    language: &#39;zh&#39;  social:    - type: &#39;github&#39;      link: &#39;https://github.com/Drew233&#39;markdown_extensions:  - admonition  - codehilite:      guess_lang: false  - toc:      permalink: trueextra_css:  - &#39;_static/extra.css&#39;nav:    - 介绍: index.md    - 关于: about.md    - 数学:        - 素数: math/prime.md        - 快速幂: math/poww.md        - 大数: math/bign.md        - 斐波那契(大数): math/Fibo.md    - 字符串:        - 最长回文字串: string/Manacher.md    - 图论:        - 最小生成树: Graph/kruskal.md        - 最短路: Graph/Dijkstra.md    - 搜索:        - BFS: search/bfs.md        - DFS: search/dfs.md    - 动态规划:        - 编辑距离: dp/distance.md        - 最长公共子序列: dp/LS.md        - 最长递增子序列: dp/LIS.md        - 最大子段和: dp/Maxsum.md        - 换零钱(背包): dp/pack.md    - 几何:        - 求多边形面积: geometric/s.mdextra_javascript:  - &#39;https://cdn.jsdelivr.net/gh/ethantw/Han@3.3.0/dist/han.min.js&#39;  - &#39;_static/js/extra.js?v=10&#39;  - &#39;https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&#39;extra_css:  - &#39;https://cdn.jsdelivr.net/npm/ah@1.5.0/han.min.css&#39;  - &#39;_static/css/extra.css?v=11&#39;# Extensionsmarkdown_extensions:  - admonition  - codehilite:      guess_lang: false      linenums: true  - def_list  - footnotes  - meta  - toc:      permalink: true  - pymdownx.arithmatex  - pymdownx.caret  - pymdownx.critic  - pymdownx.details  - pymdownx.emoji:      emoji_generator: !!python/name:pymdownx.emoji.to_svg  - pymdownx.inlinehilite  - pymdownx.keys  - pymdownx.magiclink  - pymdownx.mark  - pymdownx.progressbar  - pymdownx.smartsymbols  - pymdownx.superfences:      custom_fences:        - name: math          class: arithmatex          format: !!python/name:pymdownx.arithmatex.fence_mathjax_format  - pymdownx.tasklist:      custom_checkbox: true  - pymdownx.tilde</code></pre><h3 id="不支持中文搜索"><a href="#不支持中文搜索" class="headerlink" title="不支持中文搜索"></a>不支持中文搜索</h3><p>另外，mkdocs自带的搜索功能似乎只是支持英文搜索，网上有解决的办法，有兴趣的可以去看下。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> MkDocs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Getting started-MkDocs</title>
      <link href="/2019/06/16/getting-started-mkdocs/"/>
      <url>/2019/06/16/getting-started-mkdocs/</url>
      
        <content type="html"><![CDATA[<p><font color="red">Reprinted from&lt;/color&gt;: <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">https://squidfunk.github.io/mkdocs-material/</a></font></p><h1 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h1><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h3 id="Installing-MkDocs"><a href="#Installing-MkDocs" class="headerlink" title="Installing MkDocs"></a>Installing MkDocs</h3><p>Before installing <a href="https://www.mkdocs.org" target="_blank" rel="noopener">MkDocs</a>, you need to make sure you have Python and <code>pip</code><br>– the Python package manager – up and running. You can verify if you&#39;re already<br>good to go with the following commands:</p><pre><code class="lang-sh">python --version# Python 2.7.13pip --version# pip 9.0.1</code></pre><p>Installing and verifying MkDocs is as simple as:</p><pre><code class="lang-sh">pip install mkdocs &amp;&amp; mkdocs --version# mkdocs, version 0.17.1</code></pre><p>Material requires MkDocs &gt;= 0.17.1.</p><h3 id="Installing-Material"><a href="#Installing-Material" class="headerlink" title="Installing Material"></a>Installing Material</h3><h4 id="using-pip"><a href="#using-pip" class="headerlink" title="using pip"></a>using pip</h4><p>Material can be installed with <code>pip</code>:</p><pre><code class="lang-sh">pip install mkdocs-material</code></pre><h4 id="using-choco"><a href="#using-choco" class="headerlink" title="using choco"></a>using choco</h4><p>If you&#39;re on Windows you can use <a href="https://chocolatey.org" target="_blank" rel="noopener">Chocolatey</a> to install <a href="https://chocolatey.org/packages/mkdocs-material" target="_blank" rel="noopener">Material</a>:</p><pre><code class="lang-dos">choco install mkdocs-material</code></pre><p>This will install all required dependencies like <a href="https://chocolatey.org/packages/python" target="_blank" rel="noopener">Python</a> and <a href="https://chocolatey.org/packages/mkdocs" target="_blank" rel="noopener">MkDocs</a>.</p><h4 id="cloning-from-GitHub"><a href="#cloning-from-GitHub" class="headerlink" title="cloning from GitHub"></a>cloning from GitHub</h4><p>Material can also be used without a system-wide installation by cloning the<br>repository into a subfolder of your project&#39;s root directory:</p><pre><code class="lang-sh">git clone https://github.com/squidfunk/mkdocs-material.git</code></pre><p>This is especially useful if you want to <a href="customization.md#extending-the-theme">extend the theme</a> and<br><a href="customization.md#overriding-partials">override some parts</a> of the theme. The theme will reside in the folder<br><code>mkdocs-material/material</code>.</p><h3 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h3><p>!!! warning &quot;Installation on macOS&quot;</p><pre><code>When you&#39;re running the pre-installed version of Python on macOS, `pip`tries to install packages in a folder for which your user might not havethe adequate permissions. There are two possible solutions for this:1. **Installing in user space** (recommended): Provide the `--user` flag  to the install command and `pip` will install the package in a user-site  location. This is the recommended way.2. **Switching to a homebrewed Python**: Upgrade your Python installation  to a self-contained solution by installing Python with Homebrew. This  should eliminate a lot of problems you may be having with `pip`.</code></pre><p>!!! failure &quot;Error: unrecognized theme &#39;material&#39;&quot;</p><pre><code>If you run into this error, the most common reason is that you installedMkDocs through some package manager (e.g. Homebrew or `apt-get`) and theMaterial theme through `pip`, so both packages end up in differentlocations. MkDocs only checks its install location for themes.</code></pre><h3 id="Alternative-Using-Docker"><a href="#Alternative-Using-Docker" class="headerlink" title="Alternative: Using Docker"></a>Alternative: Using Docker</h3><p>If you&#39;re familiar with Docker, the official <a href="https://hub.docker.com/r/squidfunk/mkdocs-material/" target="_blank" rel="noopener">Docker image</a> for Material<br>comes with all dependencies pre-installed and ready-to-use with the latest<br>version published on PyPI, packaged in a very small image. Pull it with:</p><pre><code>docker pull squidfunk/mkdocs-material</code></pre><p>The <code>mkdocs</code> executable is provided as an entrypoint, <code>serve</code> is the default<br>command. Start the development server in your project root with:</p><pre><code>docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material</code></pre><p>If you&#39;re using Windows command prompt (<code>cmd.exe</code>), substitute <code>${PWD}</code> with<br><code>&quot;%cd%&quot;</code>.</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>In order to enable the theme just add one of the following lines to your<br>project&#39;s <code>mkdocs.yml</code>. If you installed Material using a package manager:</p><pre><code class="lang-yaml">theme:  name: &#39;material&#39;</code></pre><p>If you cloned Material from GitHub:</p><pre><code class="lang-yaml">theme:  name: null  custom_dir: &#39;mkdocs-material/material&#39;</code></pre><p>MkDocs includes a development server, so you can review your changes as you go.<br>The development server can be started with the following command:</p><pre><code class="lang-sh">mkdocs serve</code></pre><p>Now you can point your browser to <a href="https://localhost:8000" target="_blank" rel="noopener">https://localhost:8000</a> and the Material<br>theme should be visible. From here on, you can start writing your documentation,<br>or read on and customize the theme.</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Color-palette"><a href="#Color-palette" class="headerlink" title="Color palette"></a>Color palette</h3><p>A default hue is defined for every primary and accent color on Google&#39;s<br>Material Design <a href="https://www.materialui.co/colors" target="_blank" rel="noopener">color palette</a>, which makes it very easy to change the<br>overall look of the theme. Just set the primary and accent colors using the<br>following variables:</p><pre><code class="lang-yaml">theme:  palette:    primary: &#39;indigo&#39;    accent: &#39;indigo&#39;</code></pre><p>Color names are case-insensitive, but must match the names of the Material<br>Design color palette. Valid values are: <code>red</code>, <code>pink</code>, <code>purple</code>, <code>deep purple</code>,<br><code>indigo</code>, <code>blue</code>, <code>light blue</code>, <code>cyan</code>, <code>teal</code>, <code>green</code>, <code>light green</code>, <code>lime</code>,<br><code>yellow</code>, <code>amber</code>, <code>orange</code>, <code>deep orange</code>, <code>brown</code>, <code>grey</code>, <code>blue grey</code> and<br><code>white</code>. The last four colors can only be used as a primary color.</p><p>If the color is set via this configuration, an additional CSS file that<br>defines the color palette is automatically included. If you want to keep things<br>lean, clone the repository and recompile the theme with your custom colors set.<br>See the guide on <a href="customization.md">customization</a> for more information.</p><h4 id="Primary-colors"><a href="#Primary-colors" class="headerlink" title="Primary colors"></a>Primary colors</h4><blockquote><p>Default: <code>indigo</code></p></blockquote><p>Click on a tile to change the primary color of the theme:</p><button data-md-color-primary="red">Red</button><button data-md-color-primary="pink">Pink</button><button data-md-color-primary="purple">Purple</button><button data-md-color-primary="deep-purple">Deep Purple</button><button data-md-color-primary="indigo">Indigo</button><button data-md-color-primary="blue">Blue</button><button data-md-color-primary="light-blue">Light Blue</button><button data-md-color-primary="cyan">Cyan</button><button data-md-color-primary="teal">Teal</button><button data-md-color-primary="green">Green</button><button data-md-color-primary="light-green">Light Green</button><button data-md-color-primary="lime">Lime</button><button data-md-color-primary="yellow">Yellow</button><button data-md-color-primary="amber">Amber</button><button data-md-color-primary="orange">Orange</button><button data-md-color-primary="deep-orange">Deep Orange</button><button data-md-color-primary="brown">Brown</button><button data-md-color-primary="grey">Grey</button><button data-md-color-primary="blue-grey">Blue Grey</button><button data-md-color-primary="white">White</button><script>  var buttons = document.querySelectorAll("button[data-md-color-primary]");  Array.prototype.forEach.call(buttons, function(button) {    button.addEventListener("click", function() {      document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary;    })  })</script><h4 id="Accent-colors"><a href="#Accent-colors" class="headerlink" title="Accent colors"></a>Accent colors</h4><blockquote><p>Default: <code>indigo</code></p></blockquote><p>Click on a tile to change the accent color of the theme:</p><button data-md-color-accent="red">Red</button><button data-md-color-accent="pink">Pink</button><button data-md-color-accent="purple">Purple</button><button data-md-color-accent="deep-purple">Deep Purple</button><button data-md-color-accent="indigo">Indigo</button><button data-md-color-accent="blue">Blue</button><button data-md-color-accent="light-blue">Light Blue</button><button data-md-color-accent="cyan">Cyan</button><button data-md-color-accent="teal">Teal</button><button data-md-color-accent="green">Green</button><button data-md-color-accent="light-green">Light Green</button><button data-md-color-accent="lime">Lime</button><button data-md-color-accent="yellow">Yellow</button><button data-md-color-accent="amber">Amber</button><button data-md-color-accent="orange">Orange</button><button data-md-color-accent="deep-orange">Deep Orange</button><script>  var buttons = document.querySelectorAll("button[data-md-color-accent]");  Array.prototype.forEach.call(buttons, function(button) {    button.addEventListener("click", function() {      document.body.dataset.mdColorAccent = this.dataset.mdColorAccent;    })  })</script><h3 id="Font-family"><a href="#Font-family" class="headerlink" title="Font family"></a>Font family</h3><blockquote><p>Default: <code>Roboto</code> and <code>Roboto Mono</code></p></blockquote><p>By default the <a href="https://fonts.google.com/specimen/Roboto" target="_blank" rel="noopener">Roboto font family</a> is included with the theme, specifically<br>the regular sans-serif type for text and the <code>monospaced</code> type for code. Both<br>fonts are loaded from <a href="https://fonts.google.com" target="_blank" rel="noopener">Google Fonts</a> and can be changed to other fonts,<br>like for example the <a href="https://fonts.google.com/specimen/Ubuntu" target="_blank" rel="noopener">Ubuntu font family</a>:</p><pre><code class="lang-yaml">theme:  font:    text: &#39;Ubuntu&#39;    code: &#39;Ubuntu Mono&#39;</code></pre><p>The text font will be loaded in weights 400 and <strong>700</strong>, the <code>monospaced</code> font<br>in regular weight. If you want to load fonts from other destinations or don&#39;t<br>want to use the Google Fonts loading magic, just set <code>font</code> to <code>false</code>:</p><pre><code class="lang-yaml">theme:  font: false</code></pre><h3 id="Logo"><a href="#Logo" class="headerlink" title="Logo"></a>Logo</h3><blockquote><p>Default icon: <code>school</code></p></blockquote><p>Your logo should have rectangular shape with a minimum resolution of 128x128,<br>leave some room towards the edges and be composed of high contrast areas on a<br>transparent ground, as it will be placed on the colored header bar and drawer.<br>Simply create the folder <code>docshttps://cdn.jsdelivr.net/gh/drew233/cdn</code>, add your logo and embed it with:</p><pre><code class="lang-yaml">theme:  logo: &#39;images/logo.svg&#39;</code></pre><p>Additionally, the default icon can be changed by setting an arbitrary ligature<br>(or Unicode code point) from the <a href="https://material.io/icons/" target="_blank" rel="noopener">Material Design icon font</a>, e.g.</p><pre><code class="lang-yaml">theme:  logo:    icon: &#39;cloud&#39;</code></pre><h3 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h3><p>!!! info &quot;Call for Contributions: Add languages/translations to Material&quot;</p><pre><code>Help translate Material into more languages - it&#39;s just **one click** andtakes approximately **2 minutes**: [click here](https://bit.ly/2EbzFc8)</code></pre><h4 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h4><blockquote><p>Default: <code>en</code></p></blockquote><p>Material for MkDocs supports internationalization (i18n) and provides<br>translations for all template variables and labels in the following languages:</p><table style="white-space: nowrap;">  <thead>    <tr>      <th colspan="4">Available languages    </th></tr>  </thead>  <tbody>    <tr>      <td><code>ar</code> / Arabic</td>      <td><code>ca</code> / Catalan</td>      <td><code>cs</code> / Czech</td>      <td><code>da</code> / Danish</td>    </tr>    <tr>      <td><code>nl</code> / Dutch</td>      <td><code>en</code> / English</td>      <td><code>fi</code> / Finnish</td>      <td><code>fr</code> / French</td>    </tr>    <tr>      <td><code>gl</code> / Galician</td>      <td><code>de</code> / German</td>      <td><code>gr</code> / Greek</td>      <td><code>he</code> / Hebrew</td>    </tr>    <tr>      <td><code>hi</code> / Hindi</td>      <td><code>hr</code> / Croatian</td>      <td><code>hu</code> / Hungarian</td>      <td><code>id</code> / Indonesian</td>    </tr>    <tr>      <td><code>it</code> / Italian</td>      <td><code>ja</code> / Japanese</td>      <td><code>kr</code> / Korean</td>      <td><code>no</code> / Norwegian</td>    </tr>    <tr>      <td colspan="2"><code>nn</code> / Norwegian (Nynorsk)</td>      <td><code>fa</code> / Persian</td>      <td><code>pl</code> / Polish</td>    </tr>    <tr>      <td><code>pt</code> / Portugese</td>      <td><code>ru</code> / Russian</td>      <td><code>sr</code> / Serbian</td>      <td><code>sh</code> / Serbo-Croatian</td>    </tr>    <tr>      <td><code>sk</code> / Slovak</td>      <td><code>si</code> / Slovenian</td>      <td><code>es</code> / Spanish</td>      <td><code>sv</code> / Swedish</td>    </tr>    <tr>      <td><code>tr</code> / Turkish</td>      <td><code>uk</code> / Ukrainian</td>      <td><code>vi</code> / Vietnamese</td>      <td><code>zh</code> / Chinese (Simplified)</td>    </tr>    <tr>      <td colspan="2">        <code>zh-Hant</code> / Chinese (Traditional)      </td>      <td colspan="2"><code>zh-TW</code> / Chinese (Taiwanese)</td>    </tr>    <tr>      <td colspan="4" align="right">        <a href="https://bit.ly/2EbzFc8" target="_blank" rel="noopener">Submit a new language</a>      </td>    </tr>  </tbody></table><p>Specify the language with:</p><pre><code class="lang-yaml">theme:  language: &#39;en&#39;</code></pre><p>If the language is not specified, Material falls back to English. To create a<br>translation for another language, copy the localization file of an existing<br>language, name the new file using the <a href="https://www.w3schools.com/tags/ref_language_codes.asp" target="_blank" rel="noopener">2-letter language code</a> and adjust<br>all translations:</p><pre><code class="lang-sh">cp partials/language/en.html partials/language/jp.html</code></pre><h4 id="Text-direction"><a href="#Text-direction" class="headerlink" title="Text direction"></a>Text direction</h4><blockquote><p>Default: best match for given theme language, automatically set</p></blockquote><p>Material supports both, left-to-right (<code>ltr</code>) and right-to-left (<code>rtl</code>) text<br>direction. This enables more languages like Arabic, Hebrew, Syriac and others<br>to be used with the theme:</p><pre><code class="lang-yaml">theme:  direction: &#39;rtl&#39;</code></pre><h4 id="Site-search"><a href="#Site-search" class="headerlink" title="Site search"></a>Site search</h4><blockquote><p>Default: best match for given theme language, automatically set</p></blockquote><p>Site search is implemented using <a href="https://lunrjs.com" target="_blank" rel="noopener">lunr.js</a>, which includes stemmers for the<br>English language by default, while stemmers for other languages are included<br>with <a href="https://github.com/MihaiValentin/lunr-languages" target="_blank" rel="noopener">lunr-languages</a>, both of which are integrated with this theme.<br>Material selects the matching (or best-matching) stemmer for the given theme<br>language. Multilingual search can be activated in your project&#39;s <code>mkdocs.yml</code><br>by explicitly defining the search language(s):</p><pre><code class="lang-yaml">extra:  search:    language: &#39;en, de, ru&#39;</code></pre><p>At the time of writing, the following languages are supported:</p><table style="white-space: nowrap;">  <thead>    <tr>      <th colspan="4">Available language stemmers    </th></tr>  </thead>  <tbody>    <tr>      <td><code>da</code> / Danish</td>      <td><code>du</code> / Dutch</td>      <td><code>en</code> / English</td>      <td><code>fi</code> / Finnish</td>    </tr>    <tr>      <td><code>fr</code> / French</td>      <td><code>de</code> / German</td>      <td><code>hu</code> / Hungarian</td>      <td><code>it</code> / Italian</td>    </tr>    <tr>      <td><code>ja</code> / Japanese</td>      <td><code>no</code> / Norwegian</td>      <td><code>pt</code> / Portugese</td>      <td><code>ro</code> / Romanian</td>    </tr>    <tr>      <td><code>ru</code> / Russian</td>      <td><code>es</code> / Spanish</td>      <td><code>sv</code> / Swedish</td>      <td><code>tr</code> / Turkish</td>    </tr>  </tbody></table><p>!!! warning &quot;MkDocs 1.0 compatibility&quot;</p><pre><code>While MkDocs 1.0 supports prebuilding the search index, Material currentlydoesn&#39;t support this setting as the default search behavior of the originaltheme was heavily modified for the sake of a better UX. Integration ispossible, but a small subset of the features Material provides will not beportable to the prebuilt index mainly due to missing localization.</code></pre><p>!!! warning &quot;Only specify the languages you really need&quot;</p><pre><code>Be aware that including support for other languages increases the generalJavaScript payload by around 20kb (without gzip) and by another 15-30kb perlanguage.</code></pre><p>The separator for tokenization can be customized which makes it possible<br>to index parts of words that are separated by <code>-</code> or <code>.</code>:</p><pre><code class="lang-yaml">extra:  search:    tokenizer: &#39;[\s\-\.]+&#39;</code></pre><h3 id="Favicon"><a href="#Favicon" class="headerlink" title="Favicon"></a>Favicon</h3><blockquote><p>Default: <code>assetshttps://cdn.jsdelivr.net/gh/drew233/cdn/favicon.webp</code></p></blockquote><p>The default favicon can be changed by setting the <code>favicon</code> variable to an<br><code>.ico</code> or image file:</p><pre><code class="lang-yaml">theme:  favicon: &#39;assetshttps://cdn.jsdelivr.net/gh/drew233/cdn/favicon.ico&#39;</code></pre><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><h4 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h4><blockquote><p>Default: <code>false</code></p></blockquote><p>By default, the entire navigation is rendered on the left side using collapsible<br>sections (different from the default MkDocs theme which renders the top-level<br>sections in the header), because horizontal navigation is often problematic on<br>smaller screens. However, for large documentation projects it&#39;s sometimes<br>desirable to add another navigation layer to separate top-level sections.<br>Material achieves this with the tabs feature, which can be enabled by setting<br>the respective feature flag to <code>true</code>:</p><pre><code class="lang-yaml">theme:  feature:    tabs: true</code></pre><p>When tabs are enabled, <em>top-level sections</em> will be rendered in an additional<br>layer directly below the header. The navigation on the left side will only<br>include the pages contained within the selected section. Furthermore, <em>top-level<br>pages</em> defined inside your project&#39;s <code>mkdocs.yml</code> will be grouped under the<br>first tab which will receive the title of the first page.</p><h2 id="Customization"><a href="#Customization" class="headerlink" title="Customization"></a>Customization</h2><h3 id="Adding-a-source-repository"><a href="#Adding-a-source-repository" class="headerlink" title="Adding a source repository"></a>Adding a source repository</h3><p>To include a link to the repository of your project within your documentation,<br>set the following variables via your project&#39;s <code>mkdocs.yml</code>:</p><pre><code class="lang-yaml">repo_name: &#39;squidfunk/mkdocs-material&#39;repo_url: &#39;https://github.com/squidfunk/mkdocs-material&#39;</code></pre><p>The name of the repository will be rendered next to the search bar on big<br>screens and as part of the main navigation drawer on smaller screen sizes.<br>Furthermore, if <code>repo_url</code> points to a GitHub, BitBucket or GitLab repository,<br>the respective service logo will be shown next to the name of the repository.<br>Additionally, for GitHub, the number of stars and forks is shown.</p><p>If the repository is hosted in a private environment, the service logo can be<br>set explicitly by setting <code>extra.repo_icon</code> to <code>github</code>, <code>gitlab</code> or<br><code>bitbucket</code>.</p><p>!!! question &quot;Why is there an edit button at the top of every article?&quot;</p><pre><code>If the `repo_url` is set to a GitHub or BitBucket repository, and the`repo_name` is set to *GitHub* or *BitBucket* (implied by default), anedit button will appear at the top of every article. This is the automaticbehavior that MkDocs implements. See the [MkDocs documentation][19] on moreguidance regarding the `edit_uri` attribute, which defines whether the editbutton is shown or not.</code></pre><h3 id="Adding-social-links"><a href="#Adding-social-links" class="headerlink" title="Adding social links"></a>Adding social links</h3><p>Social accounts can be linked in the footer of the documentation using the<br>automatically included <a href="https://fontawesome.io/icons/" target="_blank" rel="noopener">FontAwesome</a> webfont. The <code>type</code> must denote the<br>name of the social service, e.g. <code>github</code>, <code>twitter</code> or <code>linkedin</code> and the<br><code>link</code> must contain the URL you want to link to:</p><pre><code class="lang-yaml">extra:  social:    - type: &#39;github&#39;      link: &#39;https://github.com/squidfunk&#39;    - type: &#39;twitter&#39;      link: &#39;https://twitter.com/squidfunk&#39;    - type: &#39;linkedin&#39;      link: &#39;https://linkedin.com/in/squidfunk&#39;</code></pre><p>The links are generated in order and the <code>type</code> of the links must match the<br>name of the FontAwesome glyph. The <code>fa</code> is automatically added, so <code>github</code><br>will result in <code>fa fa-github</code>.</p><h3 id="Adding-a-Web-App-Manifest"><a href="#Adding-a-Web-App-Manifest" class="headerlink" title="Adding a Web App Manifest"></a>Adding a Web App Manifest</h3><p>A <a href="https://developers.google.com/web/fundamentals/web-app-manifest/" target="_blank" rel="noopener">Web App Manifest</a> is a simple JSON file that tells the browser about your<br>web application and how it should behave when installed on the user&#39;s mobile<br>device or desktop. You can specify a manifest in your <code>mkdocs.yml</code>:</p><pre><code class="lang-yaml">extra:  manifest: &#39;manifest.webmanifest&#39;</code></pre><h3 id="More-advanced-customization"><a href="#More-advanced-customization" class="headerlink" title="More advanced customization"></a>More advanced customization</h3><p>  If you want to change the general appearance of the Material theme, see<br>  <a href="customization.md">this article</a> for more information on advanced customization.</p><h2 id="Integrations"><a href="#Integrations" class="headerlink" title="Integrations"></a>Integrations</h2><h3 id="Google-Analytics"><a href="#Google-Analytics" class="headerlink" title="Google Analytics"></a>Google Analytics</h3><p>MkDocs makes it easy to integrate site tracking with Google Analytics.<br>Besides basic tracking, clicks on all outgoing links can be tracked as well as<br>how site search is used. Tracking can be activated in your project&#39;s<br><code>mkdocs.yml</code>:</p><pre><code class="lang-yaml">google_analytics:  - &#39;UA-XXXXXXXX-X&#39;  - &#39;auto&#39;</code></pre><h3 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h3><p>Material for MkDocs is integrated with <a href="https://disqus.com" target="_blank" rel="noopener">Disqus</a>, so if you want to add a<br>comments section to your documentation set the shortname of your Disqus project<br>in your <code>mkdocs.yml</code>:</p><pre><code class="lang-yaml">extra:  disqus: &#39;your-shortname&#39;</code></pre><p>The comments section is inserted on <em>every page, except the index page</em>.<br>Additionally, a new entry at the bottom of the table of contents is generated<br>that is linking to the comments section. The necessary JavaScript is<br>automatically included.</p><p>!!! warning &quot;Requirements&quot;</p><pre><code>`site_url` value must be set in `mkdocs.yml` for the Disqus integration toload properly.</code></pre><p>Disqus can also be enabled or disabled for specific pages using <a href="extensions/metadata.md#disqus">Metadata</a>.</p><h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><p>MkDocs supports several <a href="https://www.mkdocs.org/user-guide/writing-your-docs/#markdown-extensions" target="_blank" rel="noopener">Markdown extensions</a>. The following extensions<br>are not enabled by default (see the link for which are enabled by default)<br>but highly recommended, so they should be switched on at all times:</p><pre><code class="lang-yaml">markdown_extensions:  - admonition  - codehilite:      guess_lang: false  - toc:      permalink: true</code></pre><p>For more information, see the following list of extensions supported by the<br>Material theme including more information regarding installation and usage:</p><ul><li><a href="extensions/admonition.md">Admonition</a></li><li><a href="extensions/codehilite.md">Codehilite</a></li><li><a href="extensions/footnotes.md">Footnotes</a></li><li><a href="extensions/metadata.md">Metadata</a></li><li><a href="extensions/permalinks.md">Permalinks</a></li><li><a href="extensions/pymdown.md">PyMdown Extensions</a></li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>MkDocs&#39;s plugin architecture makes it possible to add pre- or post-processing<br>steps that sit between the theme and your documentation. A great example of a<br>third-party plugin is the <a href="https://github.com/byrnereese/mkdocs-minify-plugin" target="_blank" rel="noopener">mkdocs-minify-plugin</a> which strips all whitespace<br>from the generated documentation.</p><p>Install it with <code>pip</code>:</p><pre><code class="lang-sh">pip install mkdocs-minify-plugin</code></pre><p>Enable it with the following lines in your <code>mkdocs.yml</code>:</p><pre><code class="lang-yaml">plugins:  - search  - minify:      minify_html: true</code></pre><p>The MkDocs wiki contains a <a href="https://github.com/mkdocs/mkdocs/wiki/MkDocs-Plugins" target="_blank" rel="noopener">list of all available plugins</a>.</p><p>!!! warning &quot;Remember to re-add the <code>search</code> plugin&quot;</p><pre><code>If you have no `plugins` entry in your config file yet, you&#39;ll likely alsowant to add the `search` plugin. MkDocs enables it by default if there isno `plugins` entry set.</code></pre><h2 id="Full-example"><a href="#Full-example" class="headerlink" title="Full example"></a>Full example</h2><p>Below is a full example configuration for a <code>mkdocs.yml</code>:</p><pre><code class="lang-yaml"># Project informationsite_name: &#39;Material for MkDocs&#39;site_description: &#39;A Material Design theme for MkDocs&#39;site_author: &#39;Martin Donath&#39;site_url: &#39;https://squidfunk.github.io/mkdocs-material/&#39;# Repositoryrepo_name: &#39;squidfunk/mkdocs-material&#39;repo_url: &#39;https://github.com/squidfunk/mkdocs-material&#39;# Copyrightcopyright: &#39;Copyright &amp;copy; 2016 - 2017 Martin Donath&#39;# Configurationtheme:  name: &#39;material&#39;  language: &#39;en&#39;  palette:    primary: &#39;indigo&#39;    accent: &#39;indigo&#39;  font:    text: &#39;Roboto&#39;    code: &#39;Roboto Mono&#39;# Customizationextra:  manifest: &#39;manifest.webmanifest&#39;  social:    - type: &#39;github&#39;      link: &#39;https://github.com/squidfunk&#39;    - type: &#39;twitter&#39;      link: &#39;https://twitter.com/squidfunk&#39;    - type: &#39;linkedin&#39;      link: &#39;https://linkedin.com/in/squidfunk&#39;# Google Analyticsgoogle_analytics:  - &#39;UA-XXXXXXXX-X&#39;  - &#39;auto&#39;# Extensionsmarkdown_extensions:  - admonition  - codehilite:      guess_lang: false  - toc:      permalink: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> MkDocs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1874：写给未来恋人的情书</title>
      <link href="/2019/06/16/past/"/>
      <url>/2019/06/16/past/</url>
      
        <content type="html"><![CDATA[<p><center>1874：写给未来恋人的情书</center></p><p></p><p align="right">郭敖</p><br>写一封寄往1874的情书，我把它放在七月雨季里的大海之中。一封封情书穿越漫长的梦境，只为了百年前约定的相逢。<br><br>　　<br>　　CHAFTER: INCEPTION<br><br>　　<br>　　泥泞的小巷杂草丛生，又窄又深，不规则的青石板上生出青苔，倾斜的雨线勾勒出来的空巷里跑过一条瘸狗。后腿上的血块已经凝结成一块硬朗的疤痕，伤口周围沾满了泥痕，每走一步都会隐约地渗透出来血迹。<br><br>　　它在一棵繁茂的榆树下停留下来，沉郁而倔强的炮声像闷雷一样划过天空，在雨水中纷飞，四溢的弹片镶嵌入青石板上，留下一道一道短小的划痕。她叫娜兰，穿一身白色的粗布轻纱，头上戴着一株粉红色的花环，雨水浇熄了她最后一丝希望，她在婚礼上落跑的第二天，战火焚烧尽了原有的一切，血染红了雨中泥泞的土地，她的母亲倒在血泊之中，死死地攥住妹妹的手指，妹妹的手被粗织的麻绳捆绑在竖立的竹竿上，和姐姐同样的白色，白色的棉布衣裙包裹了一层泥浆，士兵拿着刺刀挑起她的脸，在她白皙的下颚划了一道细小的伤口。鲜血顺着嫩白的皮肤从伤口里沁出来，滑落成一粒黄豆般大小的血滴，从锋利的刀剑上流淌下来，在冷峻的刀刃上画了一个红色的线段，刀锋上显现出来她那张无助而绝美的脸。<br><br>　　拿着刺刀的士兵脱下手上的白色手套，把枪放在木屋靠近窗子的竹排旁边，三个士兵从军官的背后抢上去，撕破了妹妹的衣服，她躲在树丛中。参天繁茂的树枝把灰暗的天空掩盖地看不到一缕光线。<br><br>　　她看到了妹妹破碎的衣衫在雨幕中四溢横飞，很快被埋没在雨水之中，她不禁喊出了妹妹的名字，诺兰。妹妹今年十七岁，比她小两岁，她看着妹妹哭喊着在人群中挣扎，在她白皙的皮肤上，显赫地多出一道又一道的伤痕，几个日本士兵赤裸子身子。在她身体上尖叫着，狰狞的欢呼淹没了远方的雷声，她虽未成年，乳房却生得好看，白皙，在泥泞中沾满了污渍。<br><br>　　士兵们抓着她扭曲的酮体和四肢，按倒在泥水中，任凭她挣扎。<br><br>　　雨水从她的脸上滑落，她知道她在哭。她眼睛里布满了血丝。不是仇恨，是对于这个世界的无助，和这个世界一切人性的质疑。<br><br>　　她瞳孔里的血丝织成一张球状的网格，就像我天花板上的吊顶。<br><br>　　有一个人素未谋面，你却会常常想起她，她在过去，未来，或者现在正在发生的时间里等待着，我一直都以为每～次转角。每一次相遇，都是在为了和某个人靠近，只是为了和她相遇。<br>　　故事开始的时候。我在梦中，在梦中我第一次遇见那个叫诺兰的女子，很长一段时间里我都在重复着某一个梦境，每天都有着全新的故事，它们发展着，我渐渐地无法辨别出来哪里是梦境，哪里是现实。<br><br>　　我叫郭敖，专栏作家，多数时间里都宅在电脑前，亦没有朋友，也许这一切都归寂于我的生活太乏味。梦境反而来得更真实。<br><br>　　最近我总是梦到枪林弹雨，战火纷飞，看着千疮百孔的梦境在湿润的枕头中醒来，习惯地把枕头拿到阳光下晒干，用架子夹着一只角，放在靠近阳台外边的位置。我的枕头是粉红色，Mini款式小女生才用，在中间有一个凹槽，可以把脑袋放进去，睡上去特别的舒服。每次我把枕头拿到阳台上的时候，都会觉得不好意思，邻居用窃窃私语的眼神打量着我，因为那个枕头很像一只比基尼。<br><br>　　一个礼拜前WOLI把这支枕头拿给我，她并不是我的女友，每个礼拜都会来看望我，买来大包小包的干粮，足够我吃一个礼拜的分量。<br><br>　　她一直在劝我戒烟，每个礼拜都会带几包烟来，她知道我喜欢抽什么牌子的烟。我知道她最讨厌烟的味道，每当我抽烟的时候她都会选择一个最靠近我的位置坐下来，静静地看着我，因为只有我抽烟的时候才会闲下来跟她聊天，谈一些天气，世事。我们无所不谈，比如说今天她穿什么内裤，什么颜色。我又多久没有理发等等。<br><br>　　我多数在白天睡觉，她就坐在我的身边，帮我整理房间。以及换洗的衣物等等，很长一段时间她让我误认为自己还是孩子，那时候生活在老家里，母亲忙碌地打理着一切。<br><br>　　其实我很忌讳有个女人在我睡觉的时候走来走去，而且你不知道她什么时候来，也不知道她什么时候去的，我改了几回电子门的密码，她总是能很快地破解出来，并且毫无忌惮地走进来，和我说话，聊天，仿佛一切都没有发生过。<br><br>　　有一天我终于忍不住问她：你怎么知道的密码，我已经换过很多次了。<br><br><br>　　她无奈地说：那你能告诉我有什么方法可以让我不知道呢?<br><br>　　我说：我从来都没有告诉过你。<br><br>　　她说：以你的智商，除了设置110、112、911、123456、654321……你能不能想点有创意的密码?<br><br>　　第二天早上我换了一个她绝对想不到的密码，是一组怪异的数字，绝对想不到的是我换了太多次。我换过密码一刻钟以后，我再也记不起了那组怪异的数字。那天早上我在门口守候了四个小时五十二分，她准时地出现在门口，然后用不足四秒钟的时间打开了电子锁。那组密码是：1874。<br><br>　　一个让我都感觉到困惑的数字，闪现在脑海之中，稍瞬即逝。<br><br>　　我开始怀疑她是一个贼，一个职业而没有道德的贼。唯一的判断标准是：一个有道德的贼不会趁着别人睡着的时候穿着粉红色的三角裤满屋子跑着给人打扫卫生。并且房间里还多了一只很像比基尼的枕头，到现在为止我不知道她怎么在我不知不觉的情况下把那玩意儿放进我脑袋下的。以至于我睡醒以后，差点被自己给吓死。<br><br>　　我用崇敬而质疑的眼光看着她，我说这密码是我设置的，我自己都忘记了，你怎么会知道?<br><br>　　她说：秘密。<br><br>　　我一直怀疑她是中情局的红色特务。或者是FBI，而她仅仅只是一个设计师，绘图，阅读，看杜拉斯会哭，爱好穿着三角裤跑到我家里帮我洗衣服。<br><br>　　她说：我最近看一个叫郭敖的书，书名叫《北纬已北》，他说秘密是用来交换的，你告诉我一个你的秘密，我就告诉你怎么打开的那把锁。<br><br>　　我想了一会说：我今天是刻意去修改密码，就是不想你进来。<br><br>　　她说：这个不算，你每次都是刻意去修改的，你从来都没想过让我进来，再换一个。<br><br>　　我说：有，没干净衣服穿的时候。<br><br>　　她一脚把我从沙发上踹了出去，说：你从来都不肯说出来自己的想法，<br><br>　　我说即使你打开了天下所有的锁，能破解任何一组密码，有一种密码你一定打不开，就是每个人锁在内心深处的那个秘密。<br><br>　　她说别玩了，出过几本书，你还真当自己是作家。这样吧，讲个公平点的秘密，你告诉我你几天没换内裤了?<br><br>　　我说：咱们还是来谈谈我内心深处的那个秘密吧。我都不记得那个密码了，你先告诉我你怎么破解的密码?<br><br>　　她想了一会说：你设定密码的时候总是喜欢降序，或者升序来排列，还有你每次都吃着鸡腿去设置密码，恶心死了，猪都知道你那只油腻的手指摁过哪个按键。现在轮到你的秘密了。<br><br>　　她挑了一个最舒坦的姿态坐在沙发上，准备聆听我的秘密。<br><br>　　我说：我做了一个很奇怪的梦，每次都梦到大雨，梦到了战争，一队日本士兵攻占了一个港湾，还有一对漂亮的姐妹，被屠城以后的村子里，她亲眼看见了妹妹被一队日本士兵轮奸，我知道他们在求助。我不知道她们是什么人，但是我清 晰地看着他们每一张脸，每一个表情。都刻骨铭心，如果我生活在那个年代，一定陪着她慢慢地老去……<br><br>　　她打断我说：那个漂亮女孩是不是和我很像?<br><br>　　我说：很像，不过不是像那两个女孩，而是那队日本士兵。<br><br>　　说完以后我想改口，因为我不知道WOLI她们家里是做什么的，这已经是第六次我的脑袋被她随身携带的IPHONE砸中。我一直怀疑她是一个狂热电子产品的女飞贼。<br><br>　　每个礼拜六她都会拉我出去新街口逛街，晒太阳，她的理由是担心我一个人躲在屋子里发霉，或者某一天死在了屋子里，从来都没有人知晓，那就成为了悲剧。<br><br>　　她每天都一副很开心的样子，为了一只手套，一件T恤，甚至听到一首老歌。都会让她很快乐，看着她幸福的样子，我觉得自己恍若隔世的老人，抑或一个襁褓中的孩子，对这一切开心的，不开心的事情，懵懂地围观着。<br><br>　　逛街的时候，我在人群中永远是她的跟屁虫，当她转身的时候在人群中，却一眼就能把我找到，而我从来都找不到她跑到了哪里。<br><br>　　我说：这里有这么多人，为什么你一眼就能找到我在哪里?<br><br>　　她说：就你这样子，眼睛只是关注着自己的脚尖，垂头丧气。一眼看上去就像瘪三，这里人虽然多，却没有比你更挫的。<br><br>　　她终于还是勾引起了我比较感兴趣的话题，我说：我真的很挫哦?<br><br>　　她没有说话，却很坚决地点了点头，眼睛里还透露着一丝歉意。看着我质疑的眼睛，她终于拿起手里的IPHONE拍了一张照片，然后拿给我看。说：你看，是不是很挫?<br><br>　　照片里的我一脸唏嘘的胡渣子，眼睛里充满了血丝，黑眼圈好像画上去的烟熏妆，我点了点头只好承认，为了挽回最后一丝希望，我说：其实艺术家也就是这范儿。<br><br>　　她转身收起来手机，质疑地问：你是艺术家吗?<br><br>　　我说：不是。<br><br>　　<br>　　CHAPTER：兰屿<br><br>　　2010年9月16号无梦<br><br>　　我醒着的时间越来越长，我不敢去面对那个梦境，闭上眼睛就是泥泞的水波、挣扎、鲜血、呼喊和战争。<br><br>　　睡去的时候趴在书房里，一个月我都没有再梦到那对姐妹，睡梦中唯一的印象就是MSN不停上下线的提示声。和窗口的抖动。窗外下着雨，噼里啪啦地拍打在我的玻璃上，也许是天气太潮湿的缘故，窗子上的玻璃太薄，无梦的日子仿佛倾斜的水闸，淹没了我的梦境。<br><br>　　倾斜的雨线从空中迅速地拍打下来，飒飒地折断了几根桔死的竹子，绿色的竹林以一个倾斜的角度耸立在山腰上，山脚下的村庄里几处烧毁的房屋依然氤氲着一层白烟。她从树丛中走来，妹妹躺在泥泞之中，几处落红染色了她白色的衣衫，她的整个身体都在冰冷的泥水中抖动，痉挛的双手抓着几根枯死的稻草。<br><br>　　她走过去抱着妹妹，她为自己的懦弱和胆怯感到内疚，她感觉到妹妹在自己的怀里发抖，挣脱。看着灰飞烟灭的家园，她没有哭，拉着妹妹消失在竹林深处。<br><br>　　国境之南，兰屿。<br><br>　　这里荒草丛生，人烟稀少，集市亦很简朴，梯田的弧线规则的摆放在丘陵上，朝九晚五，暮鼓晨钟。她们在这里停留下来的时候，海平面上日军的战舰已经攻入他们的家园。<br><br>　　妹妹的身体一天一天的消瘦下去，她经常一个人坐在港湾的海边仰望着远方，威成的海风从海角以南的方向出来，面对着大海，呆滞的眼神，喃喃自语。<br><br>　　姐姐白天耕织，在傍晚的时候在港湾浅水里捕鱼，姐姐执着木浆在冲着岸边大喊着妹妹的名字：诺兰。<br><br>　　碧蓝色的大海像一块弧形的水晶球，粼粼的波光中映射出她那张忧郁的脸，海鸟在她的头顶盘旋飞过，消失在天际交接之处。<br><br>　　每天集市上的阿晨都会送一些新鲜的素菜来，他是本地的菜农，很小的时候便跟着父亲在兰屿种菜，诺兰在一个礼拜后病倒在竹塌上。每次在梦中惊醒，她的手指已经撕破被单，接下来的日子里，在她的下体总是流出血来，体温高烧不断。<br><br>　　她在挣扎中醒来，扑进姐姐的怀里，她说：娜，我忘不了，忘不了。<br><br>　　姐姐轻抚着她的头发说：又做恶梦?<br><br>　　诺兰：我梦到了一双眼睛在注视着我，我赤裸裸地躺在雨中，在雨线中我似乎看到了他那张脸。我看到他寂寞的一生。没有亲人，朋友，生活在一个浮夸的世界里，虽然没有战争，人与人之间早已经没有了信任，没有了爰，他仿供不属于我们这个世界，他说他会陪我老去，老到都不能动了，还要相互依偎着，拥抱着。<br><br>　　阿晨在门外叩响竹门，在门外大喊着娜兰的名字。娜兰抚摸着妹妹的身体，依然很烫，她让阿晨煮了药水，诺兰始终都不肯再睡去。<br><br>　　娜兰没有说话，诺兰转身看着她说：你不信?<br><br>　　娜兰说：你该休息了。<br><br>　　诺兰说：你有没有梦到过陌生人?他就站在那里，我能感觉到他的呼吸，他的身体，他的眼睛。他的……这么近，却又那么远。<br><br>　　阿晨端着药水从门口进来，他说：你该吃药了。<br><br>　　诺兰打翻了药水，摇着头说：你们都不信?我没病。<br><br>　　她起身踉跄地冲出竹屋，海面的冷风迎面袭来，湿润而成威的风卷动着她的身体，脚下踏着的青石板似乎在晃动。轻浮如棉。<br><br>　　她被海风舞动的身躯，突然失去重心，她感觉到天旋地转，在她重重摔倒在青石板上的一刹那，她看到了海边隐现地浮动着一条彩虹，然后归寂于一片黑暗之中，雨滴倾斜地从她的脸上扫过，她感觉不到疼痛。<br><br>　　我感觉到水滴慢慢地浸透我的衣衫，棉质的衣角从内至外黏贴在我身上，似乎我在从高空坠落。雨越下越大，仿佛用木盆倾流而下。<br><br>　　我睁开眼睛看见WOLI提着一只巨大的木盆。浇在我头上，我倒在书房里，正在重重地从椅子上摔下来。WOLI眨着眼睛看着我，我苏醒了意识，她手里另一桶冰水已经灌在我的头上。我说：我已经苏醒了。<br><br>　　她说：你已经睡了三天。<br><br>　　我说：你有没有梦到过一个很具体的陌生人?名字、身份、环境都是完全的独立的，并且那里我从来都没有去过。我甚至能感觉到她的痛苦，无助和孤寂。<br><br>　　她说有啊，每个人都会有这样的经历，有些人，有些地方，你总是觉得很熟悉，或者在哪里见过，在大脑会重组一些前生今世的信息，其实是你念念不忘的地方和故事，只是你在岁月中忘记了，所以那些你曾经去过的地方，就会出现在你的脑海之中。<br><br>　　我点了点头说：是啊，我也这么觉得。<br><br>　　她操起手里的水桶砸在我脑袋上，气愤地说神经病啊你。这你也信?我建议你去看心理医生，立即，马上，至少在精神病院来抓你以前。<br><br>　　我被她抓去看心理医生，心理医生是一个有着暴力倾向的老男人，他抬头看着我说：梦是一个很奇怪的东西，你可以在阡陌沟壑的城市里穿行，钢铁铸造的屋子和丛林里打猎，甚至梦到你殴打自己的小学老师，和你的高中的女老师做爱，他和我们现实的世界并无两样，只是在梦中你才感觉到前所未有的自由。<br><br>　　我说：从技术成面来讲，有没有可能长时间的梦见某一个陌生人呢?<br><br>　　他说：绝对可以，梦的潜能量是无穷无尽的。你先告诉我你高中的女老师长得漂亮吗?胸大不大?是不是前凸后翘?最主要的你要学会控制你的梦境，记住千万别让人给控制了，最近上映一部电影叫《盗梦空间》，我告诉你，那部电影完全在胡扯，真正的梦境你知道是什么吗?是超越时空 的梦境，用意识去控制另外一个人的梦境，通常这种人被称为特异功能人士，现在这种人大部分被关在监狱里，或者精神病院。<br><br>　　我说：这不是我想要的答案，我在问有没有可能长时间的梦到某一个陌生人。<br><br>　　我们跑题了?他质疑地看了我一眼说：好，现在开始说正题，你知道为什么他们会被关进精神病院吗?因为他们太伟大了，可以颠覆一个政府，甚至一个国家，比如说我就是这种人，自从拥有特异功能这种人被关进精神病院以后，你看这个世界乱成了什么样子?其实不把他们关进去，这个世界更乱，你不要小看我，我只要随手操起一个家伙……<br><br>　　我实在听不下去了，也不想再浪费时间，随手操起一盏台灯向他脑袋上砸去，大骂道：操，操，操，操你妹啊。<br><br>　　WOLI抱歉地看着我说：我真不知道他是神经病。<br><br>　　我说：我也真不知道你是神经病。<br><br>　　她拉着我说：我让你知道一下什么是真实。<br><br><br>　　CHAPTER：给未来恋人的情书<br><br>　　南京。1912酒吧街。<br><br>　　霓虹灯下的一张张面孔就像一张揉皱的纸张，沉醉在嘈杂的音乐和干城一面的旋律之中，我们喝了几只WHISKY，一个玩朋克的女子，葡萄红的爆炸发型，在右边唇上打了一个环钉，举起我手里的杯子说：请我喝一杯?<br><br>　　WOLI从旁边站起来，拿杯子泼了她一脸，说：Getaway，son of bitch!<br><br>　　我笑了笑说：这个世界就是这样，总有一个角度是喜剧。<br><br>　　她拿起另外一个杯子也泼了我一脸说：现在你感觉到真实了吗?那你知不知道人都有一个国度叫幸福?<br><br>　　我摇头，表示不懂。我说：有你在我身边，到哪我都觉得不真实。<br><br>　　她抬手在我脸上扇过，我有半边脸马上麻痹，她问我：疼吗?<br><br>　　我说：我知道了，现在很真实。<br><br>　　她拖着脸说：我就这样一天一天地陪着你，等你老了，会不会就是你的永远呢?<br><br>　　她说这句话的时候，我一直都假装没有听见，我从来都不会给任何人诺言，甚至每天我都在假装从来都没有遇见过她，或者她根本在我的生命之中没有出现过。但是她却活生生地每天在我身边活蹦乱跳。并且随时可能做出危险的事情来。<br><br>　　她看着我良久，表情严肃地问：诺兰是谁?<br><br>　　我不相信自己的耳朵。我相信没有人知道诺兰，我问：你说什么?<br><br>　　她说：你每天晚上在梦中都喊着她的名字。<br><br>　　我说这里太吵，我听不见。她尴尬地背过脸，整个晚上都没有再说话，在回去的路上。她一直都乖乖地跟在我的身后，她知道，有些话，有些事情，她永远都不会知晓，我们之间仿佛突然隔了一层薄薄的轻纱，却无法看清对方的样子。那天晚上她回去开着新买的Land rover揽胜5.0 V8 SC，只因为我说最喜欢的车是路虎。<br><br>　　开出长江大桥以后，她握着方向盘，踩尽了脚下的油门，然后闭上眼睛说：我和你在一起了六年，如果六十秒后我们都还活着，这辈子我都不会再来骚扰你。<br><br>　　五十九分四十八秒的时候，我们冲出了高速公路的栏杆，整个车子和我们飞跃在空中，我感觉到了身体失去了重力。唯一系靠在安全带上，她的脸没有表情，在黑暗中惨白得没有血色，我看到了她眼角里含着的泪水，在这一瞬间肆无忌惮地流下来。<br><br>　　我们没有死，整辆车钻进了高速路旁一家农房里，在床上睡熟的一对夫妻用不解而尴尬的眼神看着这辆路虎和车里正在喘气的两个人。<br><br>　　WOLI没有说话，推开车门径直地走出去，床上的夫妻刚要开始争论，她指着那辆路虎说：这辆车归你们了，明天可以去办过户。<br><br>　　我跟着她走了出去，她加快了步伐，我走过去抱住她，她说：你知道吗?你从来都不肯给任何人承诺，只是为了那个该死的梦?我一直都梦想着我们之间能有一个结局，这个世界上只有死亡是唯一不会落空的结局。你自由了。我们都已经死过了。<br><br>　　我不知道该怎么去面对她。我说：你有没有听说过一个叫兰屿的地方?<br><br>　　她停留了一下，转身破涕而笑，说：台湾兰屿?<br><br>　　我惊愕地问：台湾?那里有过和日本之间的战争?<br><br>　　她说：1874年台湾曾经被日本攻陷，占领。<br><br>　　<br>　　七月，雨季。<br><br>　　我一个人去了台湾兰屿，在一个叫红头村的地方住下。这里的一切我都感觉到似曾相识，我记不清了这里的样子，以前的村子，现在已经变成了度假村。每天都会有很多人在海边划船。最近我频繁地梦到诺兰，我梦到她怀了日本士兵的孩子，却依然坚持把孩子生了下来，我能嗅到她的气味，这个她曾经生活过的地方。<br><br>　　我每天都会写一封信，一封寄往1874年的情书，我把它装在玻璃瓶内。放在七月潮湿的雨季里，看着它消失在天际的尽头。<br><br>　　我不知道诺兰有没有收到这些信，关于我和诺兰的最后一个梦境，我梦到了诺兰在一年后生下来一个女孩，看着那个女孩一天一天地长大，她知道是那些某个日本士兵的孩子，她爱着她，却把所有的仇恨都加载在她的身上。看着孩子一天一天地长大，我梦到诺兰在一天一天仓促地老去。村子里的人都认为她有精神病，姐姐娜兰和阿晨完婚的第二年，诺兰带着女儿搬到了山上住，她的女儿叫JASMINE，她看着镜子里自己苍老的容颜，而我醒着的时间也越来越长，只要不睡去，是不是就不会老去?在睡梦中我听到她说：我在你的梦中老去，你又在谁的梦中醒来?<br><br>　　之后我在兰屿的一年里，都没有再梦到过诺兰，我想这场梦也许真的到了该醒的时候，不会再梦到她了。<br><br>　　我离开兰屿的前一天晚上，在海边遇到了WOLI，她带了七封信给我，那些信纸上的字迹已经泛黄，这一封封情书穿越了漫长的时空和梦境。我抚摸着这一份迟到了百年的温柔。看着纸张上熟悉的文字，已经跨越了一个世纪回到我的手中，在信纸上却留着诺兰的泪痕。WOLI的母亲叫JASMINE，她父亲是著名的台商，他们家族有一个传说，祖母曾经是一个精神病人，她的一生都在等待着一个从未出现过的人，每日的思念让她急促地老去，直到最后她在一场地震中突然死去，那时母亲还小，在整理祖母遗物的时候，找到了她留下来的这七封信。已经封存了百年，WOLI一直都在找寻着这个人，直到在我的一本书里看到了情书中相同的句子。她便走进了我的生活之中。<br><br>　　那天晚上我最后一次梦到诺兰，我走进了那间竹屋。JASMINE已经在另外一个屋子里睡熟。<br>　　诺兰凝视着镜子里自己苍老的容颜，她在镜子里看到了我，我已是一个满头自发的老人，我抚摸着她的白发，拿起檀木的梳子帮她梳理着头发，她的嘴角终于泛起一丝微笑。她的笑容定格在铜镜之中。<br><br>　　突然之间，整个山谷都在晃动，整个屋顶塌陷下来，砸在我的腿上，我听见自己骨骼断裂的声音，血液顺着裤腿流淌下来。我不知道原来梦境可以这么逼真，我的整条腿都在颤抖，她转身用力支撑着从山坡上滚落下来的石块，我躺在石块之下无法动弹，七个小时以后，她依然用颤抖的手指支撑着，手指的皮肤一寸一寸地裂开，鲜血滴落到我的脸上，我从来都没有哭过，那一刻我泪流满面地乞求着她放手，在巨大的泥石流和崩塌到来之前，我乞求着，骂着她。在一切归寂于黑暗之前，我耳边传来崩裂的倒塌声。<br><br>　　我听见她说：来世，你来，我便来。<br><p></p><p></p><p align="right">《流年》2011年1月</p><br>转载于： <a href="https://www.xzbu.com/5/view-2117900.htm" target="_blank" rel="noopener">https://www.xzbu.com/5/view-2117900.htm</a><p></p>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> love </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Times 17</title>
      <link href="/2019/06/14/Times_17/"/>
      <url>/2019/06/14/Times_17/</url>
      
        <content type="html"><![CDATA[<center>Times 17</center><p>Link: <a href="https://ac.nowcoder.com/acm/contest/945/J" target="_blank" rel="noopener">nowcoder-945-J</a><br>Description:<br>After realizing that there is much money to be made in software development, Farmer John has launched a small side business writing short programs for clients in the local farming industry.<br>Farmer John&#39;s first programming task seems quite simple to him -- almost too simple: his client wants him to write a program that takes a number N as input, and prints 17 times N as output. Farmer John has just finished writing this simple program when the client calls him up in a panic and informs him that the input and output both must be expressed as binary numbers, and that these might be quite large.<br>Please help Farmer John complete his programming task. Given an input number N, written in binary with at most 1000 digits, please write out the binary representation of 17 times N.<br>输入描述:</p><ul><li>Line 1: The binary representation of N (at most 1000 digits).</li></ul><p>输出描述:</p><ul><li>Line 1: The binary representation of N times 17.</li></ul><p>示例1<br>输入</p><blockquote><p>10110111</p></blockquote><p>输出</p><blockquote><p>110000100111</p></blockquote><p>说明</p><blockquote><p>OUTPUT DETAILS:<br>The binary number 10110111 is equal to 183 in decimal form.<br>183 x 17 = 3111 is 110000100111 in binary format.</p></blockquote><p>Intentional analysis:<br>When I first saw this problem,I think it&#39;s so easy if I use bitset.But then I find the string input is at most 1000 digits,obviously,even long long can&#39;t save.So we must choose another way.I search the Binary multiplication on the internet.</p><p>How can we perform Binary multiplication?</p><p>I think this following picture is a good way to explain.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102717.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102717.webp" class="img-shadow img-margin"></center></a></p><p>And in this problem,we need to multiply by 17.And the binary of 17 is 10001.So what we should do is add s+&#39;0000&#39; to s(s is the string we input).After this,a less easy problem has also appeared.How do we do binary addition?Just simulation.Just like the simulation we did before adding large numbers.You can see the sode to understand.</p><p><details>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>一开始想用bitset很简单，然后发现数据范围是2^1000,long long都存不下。然后去搜索了一下二进制相乘，上面那个图片就很好理解，这道题我们只需要跟17相乘。而17的二进制形式是10001.所以我们只需要将s后面接四个0与s（例如我们输入的是111，那我们只需要将‘1110000’与‘111’加起来）加起来就好（s是我们输入的字符串）。这个二进制相加只需要模拟就行了，就像我们之前模拟大数相加的时候一样模拟。</details><br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;char ans[1005];int main(){    string s, mid;    int    i = 0;    cin &gt;&gt; s;    mid = s + &quot;0000&quot;;    int temp = 0;    reverse(s.begin(), s.end());//binary addition    reverse(mid.begin(), mid.end());    for (i = 0; i &lt; max(s.size(), mid.size()); i++)    {        if (i &lt; s.size() &amp;&amp; i &lt; mid.size())            temp += s[i] + mid[i] - &#39;0&#39; - &#39;0&#39;;        if (i &gt;= s.size() &amp;&amp; i &lt; mid.size())            temp += mid[i] - &#39;0&#39;;        if (i &lt; s.size() &amp;&amp; i &gt;= mid.size())            temp += s[i] - &#39;0&#39;;        ans[i] = temp % 2 + &#39;0&#39;;        temp  /= 2;    }    if (temp == 1)    {        ans[i] = &#39;1&#39;; i++;    }    for (int j = i - 1; j &gt;= 0; j--)        cout &lt;&lt; ans[j];    return 0;}</code></pre><p>I have to say,python is easy and amazing this time.</p><pre><code>print(bin(int(input(),2)*17)[2:])</code></pre><p>Because you don&#39;t need to care how big the number is.Just calculate.</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nowcoder </tag>
            
            <tag> Thinking </tag>
            
            <tag> Binary </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 570 (Div. 3)</title>
      <link href="/2019/06/13/Codeforces-570/"/>
      <url>/2019/06/13/Codeforces-570/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://codeforces.com/contest/1183" target="_blank" rel="noopener">Codeforces Round #570 (Div. 3)</a></p><h3 id="B-Equalize-Prices"><a href="#B-Equalize-Prices" class="headerlink" title="B. Equalize Prices"></a><center>B. Equalize Prices</center></h3><p>Description:<br>There are n products in the shop. The price of the i-th product is ai. The owner of the shop wants to equalize the prices of all products. However, he wants to change prices smoothly.</p><p>In fact, the owner of the shop can change the price of some product i in such a way that the difference between the old price of this product ai and the new price bi is at most k. In other words, the condition |ai−bi|≤k should be satisfied (|x| is the absolute value of x).</p><p>He can change the price for each product not more than once. Note that he can leave the old prices for some products. The new price bi of each product i should be positive (i.e. bi&gt;0 should be satisfied for all i from 1 to n).</p><p>Your task is to find out the maximum possible equal price B of all productts with the restriction that for all products the condiion |ai−B|≤k should be satisfied (where ai is the old price of the product and B is the same new price of all products) or report that it is impossible to find such price B.</p><p>Note that the chosen price B should be integer.</p><p>You should answer q independent queries.</p><p>Input<br>The first line of the input contains one integer q (1≤q≤100) — the number of queries. Each query is presented by two lines.</p><p>The first line of the query contains two integers n and k (1≤n≤100,1≤k≤108) — the number of products and the value k. The second line of the query contains n integers a1,a2,…,an (1≤ai≤108), where ai is the price of the i-th product.</p><p>Output<br>Print q integers, where the i-th integer is the answer B on the i-th query.</p><p>If it is impossible to equalize prices of all given products with restriction that for all products the condition |ai−B|≤k should be satisfied (where ai is the old price of the product and B is the new equal price of all products), print -1. Otherwise print the maximum possible equal price of all products.</p><p>Example<br>input</p><blockquote><p>4<br>5 1<br>1 1 2 3 1<br>4 2<br>6 4 8 5<br>2 2<br>1 6<br>3 5<br>5 2 5</p></blockquote><p>output</p><blockquote><p>2<br>6<br>-1<br>7</p></blockquote><p>Note</p><blockquote><p>In the first example query you can choose the price B=2. It is easy to see that the difference between each old price and each new price B=2 is no more than 1.<br>In the second example query you can choose the price B=6 and then all the differences between old and new price B=6 will be no more than 2.<br>In the third example query you cannot choose any suitable price B. For any value B at least one condition out of two will be violated: |1−B|≤2, |6−B|≤2.<br>In the fourth example query all values B between 1 and 7 are valid. But the maximum is 7, so it&#39;s the answer.</p></blockquote><p>Intentional analysis:<br>An easy problem.First we should judge the difference between the maximum and minimum values in the series and the size relationship of 2*k.If the difference is greater than 2*k,we should output &quot;-1&quot;,else output the sum of the minimum in the series and k.</p><details><summary><font color="red">Click to see Chinese Intentional analysis</font></summary>我们只需要判断数列中最大最小值的差跟2\*k的大小关系，如果差大于2\*k，就输出“-1”，否则就输出数列中的最小值与k的和。</details><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 10;int       a[maxn];int main(){    int q, n, k;    cin &gt;&gt; q;    while (q--)    {        cin &gt;&gt; n &gt;&gt; k;        for (int i = 0; i &lt; n; i++)            cin &gt;&gt; a[i];        sort(a, a + n);        if ((a[n - 1] - a[0]) &gt; 2 * k)        {            puts(&quot;-1&quot;);            continue;        }        else        {            cout &lt;&lt; a[0] + k &lt;&lt; endl;        }    }    return 0;}</code></pre><h3 id="C-Computer-Game"><a href="#C-Computer-Game" class="headerlink" title="C. Computer Game"></a><center>C. Computer Game</center></h3><p>Description:<br>Vova is playing a computer game. There are in total n turns in the game and Vova really wants to play all of them. The initial charge of his laptop battery (i.e. the charge before the start of the game) is k.</p><p>During each turn Vova can choose what to do:</p><p>If the current charge of his laptop battery is strictly greater than a, Vova can just play, and then the charge of his laptop battery will decrease by a;<br>if the current charge of his laptop battery is strictly greater than b (b&lt;a), Vova can play and charge his laptop, and then the charge of his laptop battery will decrease by b;<br>if the current charge of his laptop battery is less than or equal to a and b at the same time then Vova cannot do anything and loses the game.<br>Vova wants to complete the game (Vova can complete the game if after each of n turns the charge of the laptop battery is strictly greater than 0). Among all possible ways to complete the game, Vova wants to choose the one where the number of turns when he just plays is the maximum possible. It is possible that Vova cannot complete the game at all.</p><p>Your task is to find out the maximum possible number of turns Vova can just play or report that Vova cannot complete the game.</p><p>You have to answer q independent queries.</p><p>Input<br>The first line of the input contains one integer q (1≤q≤105) — the number of queries. Each query is presented by a single line.</p><p>The only line of the query contains four integers k,n,a and b (1≤k,n≤1e9,1≤b&lt;a≤1e9) — the initial charge of Vova&#39;s laptop battery, the number of turns in the game and values a and b, correspondingly.</p><p>Output<br>For each query print one integer: -1 if Vova cannot complete the game or the maximum number of turns Vova can just play otherwise.</p><p>Example<br>input</p><blockquote><p>6<br>15 5 3 2<br>15 5 4 3<br>15 5 2 1<br>15 5 5 1<br>16 7 5 2<br>20 5 7 3</p></blockquote><p>output</p><blockquote><p>4<br>-1<br>5<br>2<br>0<br>1</p></blockquote><p>Note</p><blockquote><p>In the first example query Vova can just play 4 turns and spend 12 units of charge and then one turn play and charge and spend 2 more units. So the remaining charge of the battery will be 1.<br>In the second example query Vova cannot complete the game because even if he will play and charge the battery during each turn then the charge of the notebook battery will be 0 after the last turn.</p></blockquote><p>Intentional analysis:<br>When the laptop battery is greater than a(b)(equal is not allowed to reduce),it is going to reduce a(b).The number of reductions is greater than n to win.<br>We should find the maximum number of times &quot;a&quot; if Vova can finish the game.This requires a two-point answer.</p><details><summary><font color="red">Click to see Chinese Intentional analysis</font></summary>如果能获胜，就输出a能得到的最大值。说人话就是设减a的次数为x，求出可以满足`ax+b(n-x)>k`的a的值。然后二分就行了。</details><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define ll    long longll k, n, a, b;bool cal(ll m){    return (a * m + b * (n - m)) &lt; k;}int main(){    ll q;    cin &gt;&gt; q;    while (q--)    {        cin &gt;&gt; k &gt;&gt; n &gt;&gt; a &gt;&gt; b;        ll l = 0, r = n;        while (l &lt;= r)        {            ll m = (l + r) / 2;            if (cal(m))                l = m + 1;            else                r = m - 1;        }        if (l &gt; 0)            cout &lt;&lt; min(l - 1, n) &lt;&lt; endl;        else            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;    }    return 0;}</code></pre><p>Thanks for my master @<a href="https://boctorio.com/" target="_blank" rel="noopener">boctorio</a></p><h3 id="D-Candy-Box-easy-version"><a href="#D-Candy-Box-easy-version" class="headerlink" title="D. Candy Box (easy version)"></a><center>D. Candy Box (easy version)</center></h3><p>Description:<br>This problem is actually a subproblem of problem G from the same contest.</p><p>There are n candies in a candy box. The type of the i-th candy is ai (1≤ai≤n).</p><p>You have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type 1 and two candies of type 2 is bad).</p><p>It is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift.</p><p>Your task is to find out the maximum possible size of the single gift you can prepare using the candies you have.</p><p>You have to answer q independent queries.</p><p>If you are Python programmer, consider using PyPy instead of Python when you submit your code.</p><p>Input<br>The first line of the input contains one integer q (1≤q≤2⋅105) — the number of queries. Each query is represented by two lines.</p><p>The first line of each query contains one integer n (1≤n≤2⋅105) — the number of candies.</p><p>The second line of each query contains n integers a1,a2,…,an (1≤ai≤n), where ai is the type of the i-th candy in the box.</p><p>It is guaranteed that the sum of n over all queries does not exceed 2⋅105.</p><p>Output<br>For each query print one integer — the maximum possible size of the single gift you can compose using candies you got in this query with the restriction described in the problem statement.</p><p>Example<br>input</p><blockquote><p>3<br>8<br>1 4 8 4 5 6 3 8<br>16<br>2 1 3 3 4 3 4 4 1 3 2 2 2 4 1 1<br>9<br>2 2 4 4 4 7 7 7 7</p></blockquote><p>output</p><blockquote><p>3<br>10<br>9</p></blockquote><p>Note</p><blockquote><p>In the first query, you can prepare a gift with two candies of type 8 and one candy of type 5, totalling to 3 candies.<br>Note that this is not the only possible solution — taking two candies of type 4 and one candy of type 6 is also valid.</p></blockquote><p>Intentional analysis:<br>Count the number of occurrences of each number and sort it out. Add from the biggest beginning, pay attention to if you can&#39;t continue to add the same, you should add one smaller than him.</p><details><summary><font color="red">Click to see Chinese Intentional analysis</font></summary>统计出每个数字出现的次数，排一下序。从最大的开始往下加，注意如果出现相同的不能继续加，应该加上一个比它小一的（比如说4，4加出来应该是4+3，如果是4，2，加起来应该是4+2）。难点就是如何实现。</details><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 10;int       num[maxn];int       n, u, ans;int main(){    int q;    cin &gt;&gt; q;    while (q--)    {        cin &gt;&gt; n;        for (int i = 1; i &lt;= n; i++)            num[i] = 0;        ans = 0;        for (int i = 1; i &lt;= n; i++)        {            cin &gt;&gt; u;            num[u]++;        }        sort(num + 1, num + 1 + n);        int nw = n;        for (int i = n; i &gt;= 1; i--)        {            if (nw &gt; num[i])            {                nw = num[i];            }            ans += nw;            nw--;            if (nw &lt;= 0)                break;        }        cout &lt;&lt; ans &lt;&lt; endl;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Thinking </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A solution</title>
      <link href="/2019/06/13/Solve/"/>
      <url>/2019/06/13/Solve/</url>
      
        <content type="html"><![CDATA[<p>What&#39;s the problem?<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102645.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102645.webp" class="img-shadow img-margin"></center></a><br>Since I used hexo,this problem has been seen many times.<br>When I first met this,I chose to wait.Fortunately,it&#39;s really good in a few days.<br>Then next time,I waited about ten days or more,there&#39;s no changing.So I chose to delete all local files.Add re-&#39;hexo-g&#39;.Although the problem was solved this time, all the upload information before this was gone, and the upload date of the previous article became the same day.<br>The last time,I searched a solution for this on the Internet.</p><ul><li>Delete &#39;.deploy_git&#39; in your Hexo root directory.</li><li>Git clone your repositories of your blog in Github.And renama it to &#39;.deploy_git&#39;.<br>There is a little and useful skill.As we all konw,the download speed is too slow in China.So we can use this code to improve your effectiveness.<pre><code>git clone your-repositorie&#39;s url --depth=1</code></pre></li><li>Re-&#39;hexo-g&#39;,and &#39;hexo-d&#39;,then you can &#39;hexo-d&#39; successfully.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Useful </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Floyd</title>
      <link href="/2019/06/12/Floyd/"/>
      <url>/2019/06/12/Floyd/</url>
      
        <content type="html"><![CDATA[<center> 最短路-Floyd</center><p>Link: <a href="https://acm.hdu.edu.cn/showproblem.php?pid=2544" target="_blank" rel="noopener">HDU-2544</a></p><p>Description:<br>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095517.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095517.webp" class="img-shadow img-margin"></center></a></p><p>Input<br>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。<br>输入保证至少存在1条商店到赛场的路线。</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095545.gif" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095545.gif" class="img-shadow img-margin"></center></a><p>Output<br>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p><p>Sample Input</p><blockquote><p>2 1<br>1 2 3<br>3 3<br>1 2 5<br>2 3 5<br>3 1 2<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>3<br>2</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF  = 0x3f3f3f3f;int       a[maxn][maxn];int main(){    int n, m, u, v, p;    while (cin &gt;&gt; n &gt;&gt; m)    {        if (n == 0 &amp;&amp; m == 0)            break;        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                a[i][j] = INF;        for (int i = 0; i &lt; m; i++)        {            cin &gt;&gt; u &gt;&gt; v &gt;&gt; p;            a[u][v] = p;            a[v][u] = p;        }        for (int k = 1; k &lt;= n; k++)            for (int i = 1; i &lt;= n; i++)                for (int j = 1; j &lt;= n; j++)                    if (a[i][j] &gt; a[i][k] + a[k][j])                        a[i][j] = a[i][k] + a[k][j];        cout &lt;&lt; a[1][n] &lt;&lt; endl;    }    return 0;}</code></pre><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095608.gif" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095608.gif" class="img-shadow img-margin"></center></a>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Put my curriculum on my blog</title>
      <link href="/2019/06/11/curriculum/"/>
      <url>/2019/06/11/curriculum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cndrew.cn/class/" target="_blank" rel="noopener">demo</a></p><h3 id="Create-the-curriculum-locally"><a href="#Create-the-curriculum-locally" class="headerlink" title="Create the curriculum locally"></a>Create the curriculum locally</h3><p>This is easy to finish.</p><h3 id="Convert-the-table-to-a-html-form"><a href="#Convert-the-table-to-a-html-form" class="headerlink" title="Convert the table to a html form"></a>Convert the table to a html form</h3><p>There are many ways to finish.<br>Such as: <a href="https://www.docpe.com/excel/excel-to-html.aspx" target="_blank" rel="noopener">DocPe</a></p><h3 id="Add-some-useful-features"><a href="#Add-some-useful-features" class="headerlink" title="Add some useful features"></a>Add some useful features</h3><h4 id="Now-time"><a href="#Now-time" class="headerlink" title="Now time"></a>Now time</h4><p>Code:</p><pre><code>&lt;body onload=&quot;getTime()&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;function getTime() {    var dateObj = new Date();    var year = dateObj.getFullYear();//年    var month = dateObj.getMonth()+1;//月  (注意：月份+1)    var date = dateObj.getDate();//日    var day = dateObj.getDay();    var weeks = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;];    var week = weeks[day];//根据day值，获取星期数组中的星期数。    var hours = dateObj.getHours();//小时    var minutes = dateObj.getMinutes();//分钟    var seconds = dateObj.getSeconds();//秒    if(month&lt;10){        month = &quot;0&quot;+month;    }    if(date&lt;10){        date = &quot;0&quot;+date;    }    if(hours&lt;10){        hours = &quot;0&quot;+hours;    }    if(minutes&lt;10){        minutes = &quot;0&quot;+minutes;    }    if(seconds&lt;10){        seconds = &quot;0&quot;+seconds;    }    var newDate = year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;+hours+&quot;:&quot;+minutes+&quot;:&quot;+seconds+&quot;&amp;nbsp &amp;nbsp&quot;+week;    document.getElementById(&quot;date1&quot;).innerHTML =  newDate + &quot;　　　　一言：&quot;;//在div中写入时间    setTimeout(&#39;getTime()&#39;, 500);//每隔500ms执行一次getTime()}&lt;/script&gt;&lt;div id=&quot;date1&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h4><pre><code>&lt;div id=&quot;hitokoto&quot; &gt;&lt;script&gt;hitokoto()&lt;/script&gt;&lt;/div&gt;&lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt;</code></pre><h4 id="Weather"><a href="#Weather" class="headerlink" title="Weather"></a>Weather</h4><pre><code>&lt;iframe scrolling=&quot;no&quot; src=&quot;https://tianqiapi.com/api.php?style=tt&amp;skin=pitaya&quot; frameborder=&quot;0&quot; width=&quot;590&quot; height=&quot;98&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> html </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra</title>
      <link href="/2019/06/10/Dijkstra/"/>
      <url>/2019/06/10/Dijkstra/</url>
      
        <content type="html"><![CDATA[<center> 最短路-Dijkstra</center><p>Link: <a href="https://acm.hdu.edu.cn/showproblem.php?pid=2544" target="_blank" rel="noopener">HDU-2544</a></p><p>Description:<br>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><p>Input<br>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。<br>输入保证至少存在1条商店到赛场的路线。</p><p>Output<br>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p><p>Sample Input</p><blockquote><p>2 1<br>1 2 3<br>3 3<br>1 2 5<br>2 3 5<br>3 1 2<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>3<br>2</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF  = 0x3f3f3f3f;int       a[maxn][maxn];int       dis[maxn];bool      vis[maxn];int       n, m, u, v, w;struct node{    int d, id;};bool operator &lt;(const node &amp;a, const node &amp;b){    return a.d &gt; b.d;}priority_queue&lt;node&gt; que;void Dijkstra(){    for (int i = 1; i &lt;= n; i++)        dis[i] = INF;    dis[1] = 0;    que.push(node{ dis[1], 1 });    while (!que.empty())    {        node p = que.top();        que.pop();        int  mid = p.id;        if (vis[mid] == 1)            continue;        vis[mid] = 1;        for (int i = 1; i &lt;= n; i++)        {            if (dis[i] &gt; dis[mid] + a[mid][i])            {                dis[i] = dis[mid] + a[mid][i];                que.push(node{ dis[i], i });            }        }    }    cout &lt;&lt; dis[n] &lt;&lt; endl;}int main(){    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n &amp;&amp; m))    {        memset(vis, 0, sizeof(vis));        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                a[i][j] = INF;        for (int i = 1; i &lt;= m; i++)        {            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;            a[u][v] = w;            a[v][u] = w;        }        Dijkstra();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Somewhere magical</title>
      <link href="/2019/06/08/My_hobby/"/>
      <url>/2019/06/08/My_hobby/</url>
      
        <content type="html"><![CDATA[<h3 id="Generate-virtual-resume-online"><a href="#Generate-virtual-resume-online" class="headerlink" title="Generate virtual resume online"></a>Generate virtual resume online</h3><p>Link: <a href="https://thisresumedoesnotexist.com/" target="_blank" rel="noopener">This resume does not exist</a></p><p>Description:<br>Entering the website will automatically generate a resume. If you are not satisfied, it will be allowed to generate again after 10 seconds!<br>And everything inside is virtual.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101930.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101930.webp" class="img-shadow img-margin"></center></a><h3 id="Avengers-3D-Face-Change-Effect"><a href="#Avengers-3D-Face-Change-Effect" class="headerlink" title="Avengers 3D Face Change Effect"></a>Avengers 3D Face Change Effect</h3><p>Link: <a href="https://avengethem.com/" target="_blank" rel="noopener">Avengethem</a></p><p>Description:<br>You can replace the Avengers face with your own face and generate a GIF</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101947.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101947.webp" class="img-shadow img-margin"></center></a><h3 id="毒鸡汤合集"><a href="#毒鸡汤合集" class="headerlink" title="毒鸡汤合集"></a>毒鸡汤合集</h3><p>Link: <a href="https://www.nows.fun/" target="_blank" rel="noopener">毒鸡汤</a></p><p>Description:<br>You can go here and enjoy yorself.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102004.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102004.webp" class="img-shadow img-margin"></center></a><h3 id="Tetris-Plus"><a href="#Tetris-Plus" class="headerlink" title="Tetris-Plus"></a>Tetris-Plus</h3><p>Link: <a href="https://farter.cn/tetr.js/" target="_blank" rel="noopener">Tetris</a></p><p>Description:<br>You can play kinds of mode Tetris here.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102020.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102020.webp" class="img-shadow img-margin"></center></a><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102102.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102102.webp" class="img-shadow img-margin"></center></a><h3 id="A-magical-drawing-board"><a href="#A-magical-drawing-board" class="headerlink" title="A magical drawing board"></a>A magical drawing board</h3><p>Link: <a href="https://seoi.net/penint/" target="_blank" rel="noopener">noard</a></p><p>Description:<br>Draw a picture you want to paint, and then it will become shy.<br>Suggestion: Girls should think twice before entering.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102120.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102120.webp" class="img-shadow img-margin"></center></a><h3 id="Perfect-AI-portrait-generator"><a href="#Perfect-AI-portrait-generator" class="headerlink" title="Perfect AI portrait generator"></a>Perfect AI portrait generator</h3><p>Link: <a href="https://thispersondoesnotexist.com/" target="_blank" rel="noopener">This Person Does Not Exist</a></p><p>Description:<br>Very professional intelligent AI website, the website will randomly display portrait photos generated by AI intelligence, and generate realistic and non-existent people through the study of huge real portrait data.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102232.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102232.webp" class="img-shadow img-margin"></center></a><h3 id="CSS代码渐变颜色生成工具"><a href="#CSS代码渐变颜色生成工具" class="headerlink" title="CSS代码渐变颜色生成工具"></a>CSS代码渐变颜色生成工具</h3><p>Link: <a href="https://www.grabient.com/" target="_blank" rel="noopener">Grabient</a></p><p>Description:<br>Online visualization to set gradients and generate CSS code</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102246.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102246.webp" class="img-shadow img-margin"></center></a><h3 id="在线扫雷"><a href="#在线扫雷" class="headerlink" title="在线扫雷"></a>在线扫雷</h3><p>Link: <a href="https://www.saolei.org.cn/" target="_blank" rel="noopener">扫雷</a></p><p>Description:<br>Minesweeper,and there are many small games</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102302.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102302.webp" class="img-shadow img-margin"></center></a><h3 id="Canon-Creative-Park"><a href="#Canon-Creative-Park" class="headerlink" title="Canon Creative Park"></a>Canon Creative Park</h3><p>Link: <a href="https://creativepark.canon/en/index.html" target="_blank" rel="noopener">CREATIVE PARK</a></p><p>Description:<br>The website provides a large number of free production drawings of paper molds, cards and furniture accessories.The main thing is that the paper molds are always updated.</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102443.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102443.webp" class="img-shadow img-margin"></center></a>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Plus from Picture</title>
      <link href="/2019/06/07/Picture/"/>
      <url>/2019/06/07/Picture/</url>
      
        <content type="html"><![CDATA[<centerplus from picture< center><p>Link: <a href="https://codeforces.com/contest/1182/problem/B" target="_blank" rel="noopener">CodeForces-566-B</a><br>Description:<br>You have a given picture with size w×h. Determine if the given picture has a single &quot;+&quot; shape or not. A &quot;+&quot; shape is described below:</p><p>A &quot;+&quot; shape has one center nonempty cell.<br>There should be some (at least one) consecutive non-empty cells in each direction (left, right, up, down) from the center. In other words, there should be a ray in each direction.<br>All other cells are empty.<br>Find out if the given picture has single &quot;+&quot; shape.</p><p>Input<br>The first line contains two integers h and w (1≤h, w≤500) — the height and width of the picture.</p><p>The i-th of the next h lines contains string si of length w consisting &quot;.&quot; and &quot;*&quot; where &quot;.&quot; denotes the empty space and &quot;*&quot; denotes the non-empty space.</p><p>Output<br>If the given picture satisfies all conditions, print &quot;YES&quot;. Otherwise, print &quot;NO&quot;.</p><p>You can output each letter in any case (upper or lower).</p><p>Examples<br>input</p><pre><code>5 6........*....****...*.....*...</code></pre><p>output<br>YES</p><p>input</p><pre><code>3 5..*..****..*...</code></pre><p>output<br>NO</p><p>input</p><pre><code>7 7..........*.....****....*......*...........*.....</code></pre><p>output<br>NO</p><p>input</p><pre><code>5 6..**....**..******..**....**..</code></pre><p>output<br>NO</p><p>input</p><pre><code>3 7.*...*.***.***.*...*.</code></pre><p>output<br>NO</p><p>input</p><pre><code>5 10............*........*.******...*.................</code></pre><p>output<br>NO</p><p>Note</p><blockquote><p>In the first example, the given picture contains one &quot;+&quot;.<br>In the second example, two vertical branches are located in a different column.<br>In the third example, there is a dot outside of the shape.<br>In the fourth example, the width of the two vertical branches is 2.<br>In the fifth example, there are two shapes.<br>In the sixth example, there is an empty space inside of the shape.</p></blockquote><p>Intentional analysis:<br>My way is find the center <code>*</code> of the &quot;+&quot;.And turn all of the &#39;*&#39; in &quot;+&quot; to &#39;.&#39;.And if there is still has &#39;*&#39; in the map.Should print &quot;NO&quot;,if not,print &quot;YES&quot;.But there is a special situation,there has no &#39;*&#39; in the map,we&#39;d better make a flag number to satisfy this.</p><details><summary><font color="red">Click to see Chinese Intentional analysis</font></summary>我的方法就是找到“+”最中间的‘\*’。然后把“+”中的'\*'全部变成‘.’。然后再看图里面有没有‘\*’，如果有就输出“NO”，没有就输出“YES”。但是还有一种情况就是图里面没有'\*'，这个特殊处理一下就行。</details><p>Code:</p><pre><code>#include &lt;bits/stdc++.husing namespace std;const int maxn = 550;char      m[maxn][maxn];int       x[maxn];void find(int x, int y, int z){    if (z == 0)    {        while (m[x][y] == &#39;*&#39;)        {            m[x][y] = &#39;.&#39;;            y++;        }    }    if (z == 1)    {        while (m[x][y] == &#39;*&#39;)        {            m[x][y] = &#39;.&#39;;            x++;        }    }    if (z == 2)    {        while (m[x][y] == &#39;*&#39;)        {            m[x][y] = &#39;.&#39;;            y--;        }    }    if (z == 3)    {        while (m[x][y] == &#39;*&#39;)        {            m[x][y] = &#39;.&#39;;            x--;        }    }}int main(){    int  w, h;    bool flag = 0;    cin  w  h;    for (int i = 0; i &lt; w; i++)        for (int j = 0; j &lt; h; j++)            cin  m[i][j];    for (int i = 0; i &lt; w; i++)    {        for (int j = 0; j &lt; h; j++)        {            if (m[i][j] == &#39;*&#39;)            {                int mid = 0;                if (m[i - 1][j] == &#39;*&#39;)                    mid++;                if (m[i][j - 1] == &#39;*&#39;)                    mid++;                if (m[i + 1][j] == &#39;*&#39;)                    mid++;                if (m[i][j + 1] == &#39;*&#39;)                    mid++;                if (mid == 4)                {                    for (int k = 0; k &lt; 4; k++)                    {                        m[i][j] = &#39;*&#39;;                        find(i, j, k);                        flag = 1;                    }                }            }            if (flag)                break;        }        if (flag)            break;    }    bool f = 0;    for (int i = 0; i &lt; w; i++)        for (int j = 0; j &lt; h; j++)        {            if (m[i][j] == &#39;*&#39;)                f = 1;        }    if (!f &amp;&amp; flag)        puts(&quot;YES&quot;);    else        puts(&quot;NO&quot;);    return 0;}</code></pre></centerplus>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> CodeForces </tag>
            
            <tag> Simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filling Shapes</title>
      <link href="/2019/06/06/Filling/"/>
      <url>/2019/06/06/Filling/</url>
      
        <content type="html"><![CDATA[<center>Filling Shapes</center><p>Link: <a href="https://codeforces.com/contest/1182/problem/A" target="_blank" rel="noopener">CodeForces-566-A</a><br>Description:<br>You have a given integer n. Find the number of ways to fill all 3×n tiles with the shape described in the picture below. Upon filling, no empty spaces are allowed. Shapes cannot overlap.</p><a href="https://codeforces.com/predownloaded/4b/1d/4b1df25cd2c4fede25eeac31680020dc14dca1b9.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://codeforces.com/predownloaded/4b/1d/4b1df25cd2c4fede25eeac31680020dc14dca1b9.webp" class="img-shadow img-margin"></center></a><p><center>This picture describes when n=4. The left one is the shape and the right one is 3×n tiles.</center><br>Input<br>The only line contains one integer n (1≤n≤60) — the length.</p><p>Output<br>Print the number of ways to fill.</p><p>Examples<br>input</p><blockquote><p>4</p></blockquote><p>output</p><blockquote><p>4</p></blockquote><p>input</p><blockquote><p>1</p></blockquote><p>output</p><blockquote><p>0</p></blockquote><p>Note</p><blockquote><p>In the first example, there are 4 possible cases of filling.<br>In the second example, you cannot fill the shapes in 3×1 tiles.</p></blockquote><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    long long n;    cin &gt;&gt; n;    if (n % 2 != 0)        cout &lt;&lt; 0 &lt;&lt; endl;    else    {        n /= 2;        n  = pow(2, n);        printf(&quot;%lld\n&quot;, n);    }    return 0;}</code></pre><p>Nothing to say,just find the regular,and <code>cout</code> is something wrong happen and I don&#39;t know the reason now.Record it here!</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lose it!</title>
      <link href="/2019/06/04/Lose_it!/"/>
      <url>/2019/06/04/Lose_it!/</url>
      
        <content type="html"><![CDATA[<center>Lose it!</center><p>Link: <a href="https://codeforces.com/contest/1176/problem/C" target="_blank" rel="noopener">CodeForces-565-C</a><br>Description:<br>You are given an array a consisting of n integers. Each ai is one of the six following numbers: 4,8,15,16,23,42.</p><p>Your task is to remove the minimum number of elements to make this array good.</p><p>An array of length k is called good if k is divisible by 6 and it is possible to split it into k6 subsequences 4,8,15,16,23,42.</p><p>Examples of good arrays:</p><p>[4,8,15,16,23,42] (the whole array is a required sequence);<br>[4,8,4,15,16,8,23,15,16,42,23,42] (the first sequence is formed from first, second, fourth, fifth, seventh and tenth elements and the second one is formed from remaining elements);<br>[] (the empty array is good).<br>Examples of bad arrays:</p><p>[4,8,15,16,42,23] (the order of elements should be exactly 4,8,15,16,23,42);<br>[4,8,15,16,23,42,4] (the length of the array is not divisible by 6);<br>[4,8,15,16,23,42,4,8,15,16,23,23] (the first sequence can be formed from first six elements but the remaining array cannot form the required sequence).<br>Input<br>The first line of the input contains one integer n (1≤n≤5⋅105) — the number of elements in a.</p><p>The second line of the input contains n integers a1,a2,…,an (each ai is one of the following numbers: 4,8,15,16,23,42), where ai is the i-th element of a.</p><p>Output<br>Print one integer — the minimum number of elements you have to remove to obtain a good array.</p><p>Examples<br>input</p><blockquote><p>5<br>4 8 15 16 23</p></blockquote><p>output</p><blockquote><p>5</p></blockquote><p>input</p><blockquote><p>12<br>4 8 4 15 16 8 23 15 16 42 23 42</p></blockquote><p>output</p><blockquote><p>0</p></blockquote><p>input</p><blockquote><p>15<br>4 8 4 8 15 16 8 16 23 15 16 4 42 23 42</p></blockquote><p>output</p><blockquote><p>3</p></blockquote><p>Intentional analysis:<br>The most difficult path of this problem is the order of the numbers is fixed.So you can not just find the minimum number of <code>4,8,15,16,23,42</code>,and I had to say that is my first try,without doubt,wrong answer.But how to make sure that the order in which you find the number is fixed?My method is to use some numbers to mark the appearance of <code>4,8,15,16,23,42</code>.Only 4 has appeared, the number of 8 can be increased by one, and the number of 4 should reduced by one.And so on.The final number of 42 is the answer.See the code.</p><details><summary><font color="red">Click to see Chinese Intentional analysis</font></summary>要保证找出来的最长序列的顺序一定是`4，8，15，16，23，42`，这个一定要看清。我的办法就是用几个数标记他们的出现次数。只有当4出现的次数不为0的时候8出现，那么8出现的次数才能加一，而且此时4出现的次数就得减一。以此类推，最后得到的42出现的次数代表的就是能找到的最长序列的长度的1/6。</details><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n, a, mid = 0;    cin &gt;&gt; n;    ll f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0, f6 = 0;    for (ll i = 0; i &lt; n; i++)    {        cin &gt;&gt; a;        if (a == 4)            f1++;        if (a == 8 &amp;&amp; f1)        {            f2++;            f1--;        }        if (a == 15 &amp;&amp; f2)        {            f3++;            f2--;        }        if (a == 16 &amp;&amp; f3)        {            f4++;            f3--;        }        if (a == 23 &amp;&amp; f4)        {            f5++;            f4--;        }        if (a == 42 &amp;&amp; f5)        {            f6++;            f5--;        }    }    cout &lt;&lt; n - f6 * 6 &lt;&lt; endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to change the avatar under valine</title>
      <link href="/2019/06/03/valine/"/>
      <url>/2019/06/03/valine/</url>
      
        <content type="html"><![CDATA[<p>Comment system I chose valine,but many times I am not satisfied with the default avatar of valine.So I found something related on the Internet and successfully implemented this.<br>This is easy to achieve.<br>First: you shoule go to <a href="https://en.gravatar.com/" target="_blank" rel="noopener">Gravatar</a> to register an account.<br>Attention:The email you use when registering is important and will be used next.After the registration is completed, change the personal information and change the avatar you want to use.<br>Second: Fill in the email address when you comment, it will automatically match your avatar<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102743.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102743.webp" class="img-shadow img-margin"></center></a><br>Then you can find your avatar replaced with your own custom.</p><p>A common problem:<br>You may not received verification email when you are registering.<br>Reason: Some mailboxes have added gravatar to the blacklist.<br>Solution: Add the following address to your email address whitelist in your mailbox settings</p><pre><code>donotreply@gravatar.comdonotreply@wordpress.comsupport@gravatar.com</code></pre><p>Such as QQ-mail<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102758.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102758.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102848.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102848.webp" class="img-shadow img-margin"></center></a><br>Then you should be able to find the verification email in the trash in the email.</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arithmetic Sequence</title>
      <link href="/2019/06/02/chedan/"/>
      <url>/2019/06/02/chedan/</url>
      
        <content type="html"><![CDATA[<center>Arithmetic Sequence</center><p>Links: <a href="https://ac.nowcoder.com/acm/contest/912/H" target="_blank" rel="noopener">nowcoder-921-H</a><br>Description:<br>...<br>然而，强如小r，是不屑于计算一些琐碎的计算的。现在小r给了你一个数X，要求你搞出一个等差数列a使得<br>Sn=a1+a2+a3+⋯+an=∑i=0n−1(a1+id)=n(a1+an)2=X<br>输入描述:<br>输入一个数X，含义见题目描述。</p><p>输入保证X在int范围[−2e31∼2e31−1]内。<br>输出描述:<br>输出两行，第一行输出一个正整数n，代表你将要给出的数列长度。注意n不能太大，否则会导致输出超限、超时或运行时错误。</p><p>第二行输出符合题目要求的数列，每个数之间用空格隔开，含义见题目描述</p><p>要求输出的所有数范围在int内，否则视为答案错误。<br>示例1<br>输入<br>6<br>输出<br>3<br>1 2 3<br>示例2<br>输入<br>49<br>输出<br>7<br>1 3 5 7 9 11 13</p><p>code</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int x;    cin&gt;&gt;x;    cout&lt;&lt;&quot;1&quot;&lt;&lt;endl&lt;&lt;x;}</code></pre><p>一个数也算是数列！！！<br>Paste this problem just to remind myself, be brave when i should be brave.</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Greedy-dating Ⅱ</title>
      <link href="/2019/06/01/dating/"/>
      <url>/2019/06/01/dating/</url>
      
        <content type="html"><![CDATA[<p><center>活动安排问题之二</center><br>有若干个活动，第i个开始时间和结束时间是[Si,fi)，活动之间不能交叠，要把活动都安排完，至少需要几个教室？</p><p>策略： 按照开始时间排序优先安排活动，如果冲突，则加一个教室。<br>简单地理解一下，策略是这样，我们把活动按照开始时间有小到大的顺序排序。假设目前已经分配了k个教室（显然k初始等于0），对于当前这个活动，<br>（1） 如果它能安排在k个教室里的某一个，则把它安排在其中的任何一个教室里，k不变。<br>（2） 否则它和每个教室里的活动都冲突，则增加一个教室，安排这个活动。</p><p>这个策略是最优么？</p><p>我们想像一下k增加1的过程： 因为我们是按照开始时间排序的，意味着当前考虑的这个活动开始的时候，k个教室里都有活动没结束（因为如果有一个教室的活动结束了，我们就可以安排这个活动进入那个教室而不冲突，从而不用增加k)。这就意味着在这个活动开始的时间点，算上目前考虑的这个活动，有(k + 1)个活动正在进行，同一时刻有(k + 1)个活动在进行，无论我们如何安排教室，都至少需要(k + 1)个教室。因为每个教室里不能同时进行两个活动。而我们的策略恰好需要(k + 1)个教室，所以是最优的。</p><p>这个策略也告诉我们，如果从时间轴上“宏观”考虑这个问题。考虑每个时间点同时进行的活动个数，作为这个时间点的厚度（把活动开始和结束时间想像成线段，那么每个时间点有多少条线段覆盖它，可以简单理解为“厚度”），我们至少需要最大厚度那么多个教室——因为那时恰好有最大厚度那么多个活动同时进行，而我们这个贪心策略恰好给了我们一个用最大厚度那么多个教室安排全部活动的一个方案。</p><p>如果只需要教室的个数，我们可以把所有开始时间和结束时间排序，遇到开始时间就把厚度加1，遇到结束时间就把厚度减1，显然最初始和最后结束时的厚度是0，在一系列厚度变化的过程中，峰值（最大值）就是最多同时进行的活动数，也是我们至少需要的教室数。</p><p>The above content comes from 51nod.</p><p>Description:<br>输入</p><p>第一行一个正整数n (n &lt;= 10000)代表活动的个数。<br>第二行到第(n + 1)行包含n个开始时间和结束时间。<br>开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000</p><p>输出</p><p>一行包含一个整数表示最少教室的个数。</p><p>输入示例</p><p>3<br>1 2<br>3 4<br>2 9</p><p>输出示例</p><p>2</p><p>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt; &gt; v;int main(){    int n, a, b;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    {        cin &gt;&gt; a &gt;&gt; b;        v.push_back(make_pair(a, 1));        v.push_back(make_pair(b, 0));    }    sort(v.begin(), v.end());    int sum = 0, ans = 0;    for (int i = 0; i &lt; 2 * n; i++)    {        if (v[i].second == 1)            sum++;        else            sum--;        ans = max(ans, sum);    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><p>Attention：A special case is that the start time and the end time are the same time, so it is very troublesome to use the array array directly.And the vector and pair is suitable here.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 51nod </tag>
            
            <tag> Greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uncle Drew&#39;s ACM Template</title>
      <link href="/2019/05/31/templa/"/>
      <url>/2019/05/31/templa/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><h5 id="Manacher-马拉车算法"><a href="#Manacher-马拉车算法" class="headerlink" title="Manacher(马拉车算法)"></a>Manacher(马拉车算法)</h5><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5;char str[MAXN];char tmp[2*MAXN];int len[2*MAXN];int Manacher(char str[]){    tmp[0] = &#39;$&#39;;    tmp[1] = &#39;#&#39;;    int str_len = strlen(str);    for(int i = 1;i &lt;= str_len;i++){        tmp[2*i] = str[i-1];        tmp[2*i+1] = &#39;#&#39;;    }    tmp[2*str_len+2] = &#39;\0&#39;;    int mx = 0;    int maxlen = -1;    int mid;    for(int i = 1; tmp[i]; i++){        if(i &lt; mx) len[i] = min(len[2*mid-i],mx-i);        else len[i] = 1;        while(tmp[i-len[i]] == tmp[i+len[i]]) len[i]++;        if(len[i]+i &gt; mx){            mx = len[i]+i;            mid = i;        }        maxlen = max(maxlen,len[i]-1);    }    return maxlen;//返回最长回文字串的长度}int main(){    int n;    cin&gt;&gt;n;    scanf(&quot;%s&quot;,str);    cout&lt;&lt;Manacher(str)；    return 0;}</code></pre><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h4><h5 id="Eratosthenes-埃拉托色尼筛法"><a href="#Eratosthenes-埃拉托色尼筛法" class="headerlink" title="Eratosthenes(埃拉托色尼筛法)"></a>Eratosthenes(埃拉托色尼筛法)</h5><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000000];int main(){    int sum=0,n;    int i,j;    while(~scanf(&quot;%d&quot;,&amp;n))    {        sum=0;        for(i=2;i&lt;=n;i++)         a[i]=1;         for(i=2;i&lt;=sqrt(n);i++){          for(j=2*i;j&lt;=n;j+=i){               a[j]=0;              }         }         for(i=2;i&lt;=n;i++){          if(a[i])        cout&lt;&lt;i&lt;&lt;endl;;         }    } return 0;}</code></pre><h5 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h5><pre><code>#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#define N 100int main(void){    bool number[N+1];    int prime[N+1];    int i,j,count=0;    memset(number,true,sizeof(number));    for(i=2;i&lt;=N;i++)    {        if(number[i])            prime[count++]=i;        for(j=0;j&lt;count&amp;&amp;prime[j]*i&lt;=N;j++)        {            number[prime[j]*i]=false;            if(i%prime[j]==0)//精华就在于此：它保证每个合数只会被它的最小质因数筛去，因此每个数只会被标记一次，所以时间复杂度是O(n)                break;        }    }    for(i=2;i&lt;N+1;i++)        if(number[i]==true)            printf(&quot;%d &quot;,i);    return 0;}</code></pre><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><pre><code>ll poww(ll x, ll y, ll z){    ll ans = 1, base = x; while (y != 0)    {        if (y &amp; 1 != 0)            ans = ans * base % z;        base = (base % z) * (base % z) % z; y &gt;&gt;= 1;    }    return ans;}</code></pre><h4 id="斐波那契-大数，根据第n项的值推出n"><a href="#斐波那契-大数，根据第n项的值推出n" class="headerlink" title="斐波那契(大数，根据第n项的值推出n)"></a>斐波那契(大数，根据第n项的值推出n)</h4><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int maxx = 1e9 + 7;typedef long long ll;ll        f[200050]; char s[100000];int main(){    ios::sync_with_stdio(false);    map&lt;ll, ll&gt; ma;    f[0] = 0; f[1] = 1;    for (ll i = 2; i &lt; 200001; i++)    {        f[i]     = (f[i - 1] + f[i - 2]) % maxx;        ma[f[i]] = i;    }    ll n;    cin &gt;&gt; n; while (n--)    {        cin &gt;&gt; s; ll ans, num, l;        l   = strlen(s);//先把长度求出来，用的时候直接用        num = 0; for (ll i = 0; i &lt; l; i++)        {            num = num * 10 + s[i] - &#39;0&#39;; num %= maxx;        }        cout &lt;&lt; ma[num] &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="大数-c"><a href="#大数-c" class="headerlink" title="大数(c++)"></a>大数(c++)</h4><h5 id="大数相加-正整数"><a href="#大数相加-正整数" class="headerlink" title="大数相加(正整数)"></a>大数相加(正整数)</h5><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n;    cin &gt;&gt; n;    int m = 0;    int l = 0;    for (int i = 1; i &lt;= n; i++)    {        string s1, s2, s(10000, &#39;0&#39;);        cin &gt;&gt; s1 &gt;&gt; s2;        m++;        cout &lt;&lt; (l++ ? &quot;\n&quot; : &quot;&quot;);        reverse(s1.begin(), s1.end());        reverse(s2.begin(), s2.end());        for (int j = 0; j &lt; s1.length(); j++)            s[j] = s1[j];        int temp = 0;        for (int k = 0; k &lt; s2.length(); k++)        {            temp += s[k] - 48 + s2[k] - 48;            s[k]  = temp % 10 + &#39;0&#39;;            temp /= 10;        }        s[s2.length()] = s[s2.length()] - 48 + temp + 48;        reverse(s.begin(), s.end());        reverse(s1.begin(), s1.end());        reverse(s2.begin(), s2.end());        cout &lt;&lt; &quot;Case&quot; &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; endl;        cout &lt;&lt; s1 &lt;&lt; &quot;+&quot; &lt;&lt; s2 &lt;&lt; &quot;=&quot; &lt;&lt; s.substr(s.find_first_not_of(&#39;0&#39;)) &lt;&lt; endl;    }    return 0;}</code></pre><h5 id="大数相减-正整数"><a href="#大数相减-正整数" class="headerlink" title="大数相减(正整数)"></a>大数相减(正整数)</h5><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int strComp(string &amp;s1, string &amp;s2){    int len1 = s1.length();    int len2 = s2.length();    if (len1 &gt; len2)        return 0;    else if (len1 &lt; len2)        return 1;    else    {        if (s1 &gt;= s2)            return 0;        else            return 1;    }}int main(){    string s1, s2;    while (cin &gt;&gt; s1 &gt;&gt; s2)    {        string s(10000, &#39;0&#39;);        bool   fgEx = true;        if (strComp(s1, s2) == 1)        {            string temp;            temp = s1;            s1   = s2;            s2   = temp;            fgEx = false;        }        if (s1 == s2)        {            cout &lt;&lt; s1 &lt;&lt; &quot; - &quot; &lt;&lt; s2 &lt;&lt; &quot; = &quot; &lt;&lt; &quot;0&quot; &lt;&lt; endl;            continue;        }        reverse(s1.begin(), s1.end());        reverse(s2.begin(), s2.end());        for (int i = 0; i &lt; s1.length(); i++)            s[i] = s1[i];        for (int i = 0; i &lt; s2.length(); i++)        {            if (s[i] &gt;= s2[i])                s[i] = s[i] - &#39;0&#39; - (s2[i] - &#39;0&#39;) + &#39;0&#39;;            else            {                s[i + 1] = s[i + 1] - &#39;0&#39; - 1 + &#39;0&#39;;                s[i]     = s[i] - &#39;0&#39; + 10 - (s2[i] - &#39;0&#39;) + &#39;0&#39;;            }        }        if (fgEx == false)        {            reverse(s2.begin(), s2.end());            cout &lt;&lt; s2 &lt;&lt; &quot; - &quot;;            reverse(s1.begin(), s1.end());            cout &lt;&lt; s1 &lt;&lt; &quot; = &quot;;            reverse(s.begin(), s.end());            cout &lt;&lt; &quot;-&quot; &lt;&lt; s.substr(s.find_first_not_of(&#39;0&#39;)) &lt;&lt; endl;        }        else        {            reverse(s1.begin(), s1.end());            cout &lt;&lt; s1 &lt;&lt; &quot; - &quot;;            reverse(s2.begin(), s2.end());            cout &lt;&lt; s2 &lt;&lt; &quot; = &quot;;            reverse(s.begin(), s.end());            cout &lt;&lt; s.substr(s.find_first_not_of(&#39;0&#39;)) &lt;&lt; endl;        }    }    return 0;}</code></pre><h5 id="大数相乘-正整数"><a href="#大数相乘-正整数" class="headerlink" title="大数相乘(正整数)"></a>大数相乘(正整数)</h5><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){    string s1, s2;    while (cin &gt;&gt; s1 &gt;&gt; s2)    {        string s(1000, &#39;0&#39;);        reverse(s1.begin(), s1.end());        reverse(s2.begin(), s2.end());        for (int i = 0; i &lt; s1.length(); i++)            for (int j = 0; j &lt; s2.length(); j++)            {                int temp = (s1[i] - &#39;0&#39;) * (s2[j] - &#39;0&#39;);                s[i + j + 1] = s[i + j + 1] - &#39;0&#39; + (s[i + j] - &#39;0&#39; + temp) / 10 + &#39;0&#39;;                s[i + j]     = (s[i + j] - &#39;0&#39; + temp) % 10 + &#39;0&#39;;            }        reverse(s.begin(), s.end());        if (s.find_first_not_of(&#39;0&#39;) == string::npos)            cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;        else            cout &lt;&lt; s.substr(s.find_first_not_of(&#39;0&#39;)) &lt;&lt; endl;    }    return 0;}</code></pre><h5 id="大数相除-正整数"><a href="#大数相除-正整数" class="headerlink" title="大数相除(正整数)"></a>大数相除(正整数)</h5><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int strComp(string &amp;s1, string &amp;s2){    int len1 = s1.length();    int len2 = s2.length();    if (len1 &gt; len2)        return 0;    else if (len1 &lt; len2)        return 1;    else    {        if (s1 &gt;= s2)            return 0;        else            return 1;    }}string Sub(string s1, string s2){    if (strComp(s1, s2) == 1)        return &quot;-1&quot;;    reverse(s1.begin(), s1.end());    reverse(s2.begin(), s2.end());    string s(1000, &#39;0&#39;);    for (int i = 0; i &lt; s1.length(); i++)        s[i] = s1[i];    for (int i = 0; i &lt; s2.length(); i++)    {        if (s[i] &gt;= s2[i])            s[i] = s[i] - &#39;0&#39; - (s2[i] - &#39;0&#39;) + &#39;0&#39;;        else        {            s[i + 1] = s[i + 1] - &#39;0&#39; - 1 + &#39;0&#39;;            s[i]     = s[i] - &#39;0&#39; + 10 - (s2[i] - &#39;0&#39;) + &#39;0&#39;;        }    }    reverse(s.begin(), s.end());    if (s.find_first_not_of(&#39;0&#39;) == string::npos)        return &quot;0&quot;;    else        return s.substr(s.find_first_not_of(&#39;0&#39;));}int main(){    string s1, s2;    while (cin &gt;&gt; s1 &gt;&gt; s2)    {        string s(1000, &#39;0&#39;);        if (strComp(s1, s2) == 1)        {            cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;            continue;        }        int len1 = s1.length();        int len2 = s2.length();        int dis  = len1 - len2;        for (int i = 0; i &lt; dis; i++)            s2 += &#39;0&#39;;        string ans(1000, &#39;0&#39;);        while (dis &gt;= 0)        {            int    sum = 0;            string temp;            while ((temp = Sub(s1, s2)) != &quot;-1&quot;)            {                sum++;                s1 = temp;            }            ans[ans.length() - dis - 1] = sum + &#39;0&#39;;            dis--;            s2 = s2.substr(0, len2 + dis);        }        if (ans.find_first_not_of(&#39;0&#39;) == string::npos)            cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;        else        {            string res = ans.substr(ans.find_first_not_of(&#39;0&#39;));            cout &lt;&lt; res &lt;&lt; endl;        }    }    return 0;}</code></pre><h5 id="大数取模"><a href="#大数取模" class="headerlink" title="大数取模"></a>大数取模</h5><pre><code>typedef long long ll;cin &gt;&gt; s;ll ans, num;ll l = strlen(s);num = 0;for (ll i = 0; i &lt; l; i++){    num = num * 10 + s[i] - &#39;0&#39;;    num %= maxx;}</code></pre><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><h5 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h5><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;struct city{    int a;    int b;    int p;}   c[105];int p[105];int find(int x){    return p[x] != x ? p[x] = find(p[x]) : x;}void join(int x, int y){    x = find(x);    y = find(y);    if (x != y)        p[y] = x;}bool cmp(city x, city y){    return x.p &lt; y.p;}int main(){    int n, m;    while (cin &gt;&gt; n &gt;&gt; m)    {        int sum = 0;        if (n == 0)            break;        for (int i = 1; i &lt;= m; i++)            p[i] = i;        for (int i = 0; i &lt; n; i++)            cin &gt;&gt; c[i].a &gt;&gt; c[i].b &gt;&gt; c[i].p;        sort(c, c + n, cmp);        for (int i = 0; i &lt; n; i++)        {            if (find(c[i].a) != find(c[i].b))            {                join(c[i].a, c[i].b);                sum += c[i].p;            }        }        int flag = 0;        for (int i = 1; i &lt;= m; i++)        {            if (p[i] == i)                flag++;        }        if (flag == 1)            cout &lt;&lt; sum &lt;&lt; endl;        else            puts(&quot;?&quot;);    }    return 0;}</code></pre><h4 id="最短路——Dijkstra"><a href="#最短路——Dijkstra" class="headerlink" title="最短路——Dijkstra"></a>最短路——Dijkstra</h4><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF  = 0x3f3f3f3f;int       a[maxn][maxn];int       dis[maxn];bool      vis[maxn];int       n, m, u, v, w;struct node{    int d, id;};bool operator &lt;(const node &amp;a, const node &amp;b){    return a.d &gt; b.d;}priority_queue&lt;node&gt; que;void Dijkstra(){    for (int i = 1; i &lt;= n; i++)        dis[i] = INF;    dis[1] = 0;    que.push(node{ dis[1], 1 });    while (!que.empty())    {        node p = que.top();        que.pop();        int  mid = p.id;        if (vis[mid] == 1)            continue;        vis[mid] = 1;        for (int i = 1; i &lt;= n; i++)        {            if (dis[i] &gt; dis[mid] + a[mid][i])            {                dis[i] = dis[mid] + a[mid][i];                que.push(node{ dis[i], i });            }        }    }    cout &lt;&lt; dis[n] &lt;&lt; endl;}int main(){    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n &amp;&amp; m))    {        memset(vis, 0, sizeof(vis));        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                a[i][j] = INF;        for (int i = 1; i &lt;= m; i++)        {            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;            a[u][v] = w;            a[v][u] = w;        }        Dijkstra();    }}</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int book[10], a[10], n;void dfs(int step){    int i;    if (step == n + 1)//当你在第n+1步的时候，说明前n部已经排好了。    {        for (i = 1; i &lt;= n; i++)            printf(&quot;%d &quot;, a[i]);        printf(&quot;\n&quot;);        return; //返回之前的一步；    }    for (i = 1; i &lt;= n; i++) //按照1，2，3.。。的方式一一尝试。    {        if (book[i] == 0)    //判断扑克牌i是不是还在手里        {            a[step] = i;     //将i牌放在第step个盒子里。            book[i] = 1;     //表示扑克牌不再第step个盒子里            dfs(step + 1);   //继续下一步。            book[i] = 0;     //将刚才尝试的扑克收回，才能进行下一步的尝试。        }    }    return; //结束搜索。}int main(){    while (~scanf(&quot;%d&quot;, &amp;n))        dfs(1);    return 0;}</code></pre><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define pill pair&lt;int,int&gt;int sx,sy,ex,ey,n;char ma[1050][1050];int vis[1050][1050];int step[1050][1050];int d[4][2]={-1,0,0,1,1,0,0,-1};queue&lt;pair&lt;int,int&gt; &gt;que;void bfs(int x,int y){    vis[x][y]=1;    que.push(pill(x,y));    while(!que.empty())    {        x=que.front().first;        y=que.front().second;        que.pop();        for(int i=0;i&lt;4;i++)        {            int xx=x+d[i][0];            int yy=y+d[i][1];            if(ma[xx][yy]==&#39;#&#39;||xx&lt;0||xx&gt;=n||yy&lt;0||yy&gt;=n||vis[xx][yy]==1) continue;            que.push(pill(xx,yy));            vis[xx][yy]=1;            step[xx][yy]=step[x][y]+1;        }    }}int main(){    while(cin&gt;&gt;n)    {        memset(vis,0,sizeof(vis));        for(int i=0;i&lt;n;i++)        {            scanf(&quot;%s&quot;,ma[i]);        }    }}</code></pre><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1050;int       f[maxn][maxn];string    a, b;bool same(char x, char y){    if (x == y)        return 0;    return 1;}int main(){    while (cin &gt;&gt; a &gt;&gt; b)    {        memset(f, 0, sizeof(f)); for (int i = 0; i &lt;= a.size(); i++)        {            for (int j = 0; j &lt;= b.size(); j++)            {                if (i == 0)                    f[i][j] = j;                else if (j == 0)                    f[i][j] = i;                else                    f[i][j] = min(f[i - 1][j - 1] + same(a[i - 1], b[j - 1]), min(f[i - 1][j] + 1, f[i][j - 1] + 1));            }        }        cout &lt;&lt; f[a.size()][b.size()] &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><pre><code>#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1050;int       dp[maxn][maxn];char      a[maxn], b[maxn];int main(){    scanf(&quot;%s %s&quot;, a + 1, b + 1); int n = strlen(a + 1), m = strlen(b + 1); for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= m; j++)        {            if (a[i] == b[j])                dp[i][j] = dp[i - 1][j - 1] + 1;            else                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        }    stack&lt;char&gt; ans; while (n &gt;= 1 &amp;&amp; m &gt;= 1)    {        if (dp[n][m] == 0)            break;        if (dp[n][m] - dp[n - 1][m - 1] == 1 &amp;&amp; dp[n - 1][m - 1] == dp[n - 1][m] &amp;&amp; dp[n - 1][m - 1] == dp[n][m - 1])        {            ans.push(a[n]); n--; m--;        }        else if (dp[n][m] == dp[n - 1][m] &amp;&amp; n &gt; 1)            n--;        else if (dp[n][m] == dp[n][m - 1] &amp;&amp; m &gt; 1)            m--;    }    while (!ans.empty())    {        printf(&quot;%c&quot;, ans.top()); ans.pop();    }    puts(&quot;&quot;); return 0;}</code></pre><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 50050;const int INF = 0x3f3f3f3f;int       dp[maxn], a[maxn];int main(){    int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)    {        cin &gt;&gt; a[i];    }    fill(dp, dp + n, INF); for (int i = 0; i &lt; n; i++)    {        *lower_bound(dp, dp + n, a[i]) = a[i];    }    cout &lt;&lt; lower_bound(dp, dp + n, INF) - dp &lt;&lt; endl;}</code></pre><h4 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h4><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    int       n, now;    long long maxsum, sum;    while (cin &gt;&gt; n)    {        maxsum = sum = 0;        for (int i = 1; i &lt;= n; i++)        {            cin &gt;&gt; now;            sum    = max(sum, 0LL) + now;            maxsum = max(sum, maxsum);        }        cout &lt;&lt; maxsum &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="换零钱"><a href="#换零钱" class="headerlink" title="换零钱"></a>换零钱</h4><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll solve(ll x){    int coins[13]  = { 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 };    ll  dp[100005] = { 0 };    dp[0] = 1;    for (int i = 0; i &lt; 13; i++)    {        for (int j = coins[i]; j &lt;= x; j++)        {            dp[j] = (dp[j] + dp[j - coins[i]]) % 1000000007;        }    }    return dp[x];}int main(){    ll t, a;    cin &gt;&gt; t;    while (t--)    {        cin &gt;&gt; a;        cout &lt;&lt; solve(a) &lt;&lt; endl;    }}</code></pre><h3 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h3><h4 id="求多边形面积"><a href="#求多边形面积" class="headerlink" title="求多边形面积"></a>求多边形面积</h4><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int main(){    int ncase;    cin &gt;&gt; ncase;    int x, y, x0, y0, sum = 0;    cin &gt;&gt; x &gt;&gt; y;    x0 = x;    y0 = y;    while (--ncase)    {        int xtmp, ytmp;        cin &gt;&gt; xtmp &gt;&gt; ytmp;        sum += (x * ytmp - y * xtmp);        x    = xtmp;        y    = ytmp;    }    sum += (x * y0 - y * x0);    printf(&quot;%d\n&quot;, int(abs(sum) / 2));    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal</title>
      <link href="/2019/05/29/Kruskal/"/>
      <url>/2019/05/29/Kruskal/</url>
      
        <content type="html"><![CDATA[<p>Link: <a href="https://acm.hdu.edu.cn/showproblem.php?pid=1863" target="_blank" rel="noopener">HDU-1863</a></p><p><center>畅通工程</center><br>Description:<br>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。</p><p>Input<br>测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N<br>行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。</p><p>Output<br>对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。</p><p>Sample Input<br>3 3<br>1 2 1<br>1 3 2<br>2 3 4<br>1 3<br>2 3 2<br>0 100</p><p>Sample Output<br>3<br>?</p><p>The main thought of this problem is union-find.<br>Code:</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;struct city{    int a;    int b;    int p;}   c[105];int p[105];int find(int x){    return p[x] != x ? p[x] = find(p[x]) : x;}void join(int x, int y){    x = find(x);    y = find(y);    if (x != y)        p[y] = x;}bool cmp(city x, city y){    return x.p &lt; y.p;}int main(){    // freopen(&quot;../in.txt&quot;, &quot;r&quot;, stdin);    // freopen(&quot;../out.txt&quot;, &quot;w&quot;, stdout);    int n, m;    while (cin &gt;&gt; n &gt;&gt; m)    {        int sum = 0;        if (n == 0)            break;        for (int i = 1; i &lt;= m; i++)            p[i] = i;        for (int i = 0; i &lt; n; i++)            cin &gt;&gt; c[i].a &gt;&gt; c[i].b &gt;&gt; c[i].p;        sort(c, c + n, cmp);        for (int i = 0; i &lt; n; i++)        {            if (find(c[i].a) != find(c[i].b))            {                join(c[i].a, c[i].b);                sum += c[i].p;            }        }        int flag = 0;        for (int i = 1; i &lt;= m; i++)        {            if (p[i] == i)                flag++;        }        if (flag == 1)            cout &lt;&lt; sum &lt;&lt; endl;        else            puts(&quot;?&quot;);    }    return 0;}</code></pre><p>Recommend: <a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">算法导论--最小生成树（Kruskal和Prim算法）</a></p><p>Interjection: &quot;spirited away&quot; was released on June 21st. Do you want to go see it together?</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> Greedy </tag>
            
            <tag> union-find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ with Atom</title>
      <link href="/2019/05/28/atom/"/>
      <url>/2019/05/28/atom/</url>
      
        <content type="html"><![CDATA[<p>I think I can&#39;t teach you how to install atom clearly,so there has more links to what blog I saw when I install atom.</p><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p><a href="https://atom.io/" target="_blank" rel="noopener">Click here to install</a></p><ul><li>Choose your suitable version.When the install begin,what you should do just is wait,atom will do everything itself for you.</li><li><font color="red">Attention</font>: If you can&#39;t installed on the official website.<br>Click here：<a href="https://pan.baidu.com/s/1xpP2G0qsaB_ciXvd9d9juQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1xpP2G0qsaB_ciXvd9d9juQ</a><br>Extraction code：78aa</li><li>If the above two conditions can not solve your installation problem.Just connect me through email or comment.I&#39;d like to help you.<h3 id="An-important-step-Configuration-compilation-environment"><a href="#An-important-step-Configuration-compilation-environment" class="headerlink" title="An important step-Configuration compilation environment"></a>An important step-Configuration compilation environment</h3></li><li>Install MinGW<br><a href="https://mingw.org/" target="_blank" rel="noopener">Click here to install</a><br>To solve this there are many tutorial on the web.So I will not spend more time on this.<br>recommend:  <a href="https://blog.csdn.net/u013171283/article/details/80898442" target="_blank" rel="noopener">MinGW</a>.<br>When you finish this step,You are not far from success.<h3 id="Install-some-useful-packages-c"><a href="#Install-some-useful-packages-c" class="headerlink" title="Install some useful packages(c++)."></a>Install some useful packages(c++).</h3></li></ul><ol><li>linter-gcc2</li><li>linter<br>recommend: <a href="https://blog.csdn.net/qq_36731677/article/details/80259085" target="_blank" rel="noopener">c++</a><h3 id="Install-some-useful-packages-markdown"><a href="#Install-some-useful-packages-markdown" class="headerlink" title="Install some useful packages(markdown)"></a>Install some useful packages(markdown)</h3></li><li>markdown-preview-plus</li><li>markdown-scroll-sync</li><li>language-markdown</li><li>markdown-image-paste</li><li>markdown-table-editor</li><li>markdown-themeable-pdf、pdf-view<br>recommend: <a href="https://www.cnblogs.com/fanzhidongyzby/p/6637084.html" target="_blank" rel="noopener">markdown</a></li></ol><p>There are many useful and beautiful packages in atom,and you can manage them easier than sublime.</p><p>If you still have some problems,just comment here or send a email to me.</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Tutorial </tag>
            
            <tag> Atom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大的湖</title>
      <link href="/2019/05/27/nowcoder%20910%20D/"/>
      <url>/2019/05/27/nowcoder%20910%20D/</url>
      
        <content type="html"><![CDATA[<center>最大的湖</center><p>Link&quot; <a href="https://ac.nowcoder.com/acm/contest/910/D" target="_blank" rel="noopener">nowcoder-910-D</a><br>Description:<br>农场主约翰的农场在最近的一场风暴中被洪水淹没，这一事实只因他的奶牛极度害怕水的消息而恶化。</p><p>然而，他的保险公司只会根据他农场最大的“湖”的大小来偿还他一笔钱。</p><p>农场表示为一个矩形网格，有N（1≤N≤100）行和M（1≤M≤100）列。网格中的每个格子要么是干的，</p><p>要么是被淹没的，而恰好有K（1≤K≤N×M）个格子是被淹没的。正如人们所期望的，一个“湖”有一个</p><p>中心格子，其他格子通过共享一条边（只有四个方向，对角线不算的意思）与之相连。任何与中央格子共享一条边或与中央格</p><p>子相连的格子共享一条边的格子都将成为湖的一部分。</p><p>输入描述:<br>第一行有三个整数N,M,K，分别表示这个矩形网格有N行，M列，K个被淹没的格子。</p><p>接下来K行，每一行有两个整数R,C。表示被淹没的格子在第R行，第C列。<br>输出描述:<br>输出最大的“湖”所包含的格子数目<br>示例1<br>输入<br>3 4 5<br>3 2<br>2 2<br>3 1<br>2 3<br>1 1<br>输出<br>4</p><p>Intentional analysis:<br>My solution to this problem is According to the input structure diagram and then proceed BFS.</p><details><summary>Click to see Chinese Intentional analysis</summary>通过输入构造图然后进行BFS。为了防止各种绕弯，我对下标进行了操作。</details><p>Code：</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char s[105][105];int d[4][2]={0,-1, -1,0, 0,1, 1,0};bool flag[105][105];int n,m,k,a,b,anss=0;queue&lt;pair&lt;int,int&gt; &gt; que;#define pil pair&lt;int,int&gt;int bfs(int x,int y){    memset(flag,0,sizeof(flag));    flag[x][y]=1;    int ans=1;    que.push(pil(x,y));    while(!que.empty())    {        x=que.front().first;        y=que.front().second;        que.pop();        for(int i=0;i&lt;4;i++)        {            int xx=x+d[i][0];            int yy=y+d[i][1];            if(xx&lt;0||yy&lt;0||xx&gt;=n||yy&gt;=m||s[xx][yy]==&#39;#&#39;||flag[xx][yy]==1)    continue;            else            {                flag[xx][yy]=1;                ans++;                que.push(pil(xx,yy));            }        }    }    return ans;}int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++)        for(int j=0;j&lt;m;j++)        {            s[i][j]=&#39;#&#39;;        }    while(k--)    {        cin&gt;&gt;a&gt;&gt;b;        s[a-1][b-1]=&#39;@&#39;;    }    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;=m;j++)        {            if(s[i][j]==&#39;@&#39;)            anss=max(bfs(i,j),anss);        }    }    cout&lt;&lt;anss&lt;&lt;endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nowcoder </tag>
            
            <tag> BFS </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>风雨无阻</title>
      <link href="/2019/05/26/nowcoder-900-A/"/>
      <url>/2019/05/26/nowcoder-900-A/</url>
      
        <content type="html"><![CDATA[<center>风雨无阻</center><p>Links: <a href="https://ac.nowcoder.com/acm/contest/900/A" target="_blank" rel="noopener">风雨无阻</a><br>Description:<br>许cosin的宝贝手表被他的仇人gen海偷走了。他决定秘密前往gen海家，去找回他的手表。<br>许cosin历经千辛万苦，耗时3天，终于找到了gen海家。他通过观察发现gen海不在家，于是他决定偷偷潜入gen海家，然后找回手表。但他在gen海家的门前发现了一个密码锁，他必须解开这个锁才能进入gen海家。可是许cosin实在是太silly了，于是他就向你请教。请快速解决这个问题，gen海还有1秒就会回家了。<br>锁上有两行，第一行一个数字N。第二行是一串字符串S（|S|≤6*105），字符串由许多子串构成，每个子串的格式均是XA<br>其中X是一个运算符，A是一个数字。X可能是*，+，-，%，^（^表示次方）。<br>现在需要把数字N代入字符串S，从左到右进行运算。密码就是运算结果的绝对值。</p><p>题目保证运算过程中N在int(-2147483648~2147483647)范围内，^后面的数字只能为2。运算过程从左至右，不满足运算的优先级（详见样例）<br>输入描述:<br>两行，第一行一个正整数N<br>第二行是一个字符串S<br>输出描述:<br>一个数，表示运算结果的绝对值<br>示例1<br>输入<br>5<br>-7*3<br>输出<br>6<br>说明<br>5-7=-2</p><p>-2*3=-6</p><p>|-6|=6</p><p>Intentional analysis:<br>When I first saw this problem,I think i can AC it easily through the &quot;eval&quot; in python.But,there is no need to consider the precedence of operators here.So I give it up and choose c/c++.I think the main thought is simulation.Process the string.But a other problem came is that a nubmer maybe many chars.So we must process the string with a special way instead of one by one which is wrong.</p><details><summary><font color="red">Click to see Chinese Intentional analysis</font></summary>第一眼看到这个题，我直接想到了python中的eval函数，但是发现题目要求的是不考虑运算符的优先级，所以这个就不能用了。我有回归本行使用c/c++来写，就是一个简单的模拟，但是每次出现的数字它不一定只有一位，这就是这道题麻烦的地方，我选择了用字符串数组存起来每个数，因为题目保证每个运算符后面一定会有数字，所以只要按着顺序来就行，还有个麻烦的地方就是字符串跟整型之间的运算，即将字符串类型转换为整形。一开始我直接模拟了一下转换过程，也是过了这道题，后来我想到一个很方便的函数——stoi。基本作用就是直接将string类型转换为整型。关于这个函数我在这篇博文下面有详细的介绍，有兴趣的可以看一下。</details><p>My fisrt code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string mid[100005];ll zh(string x){    ll ans=0,m,j=1;    for(int i=x.size()-1;i&gt;=0;i--)    {        m=(x[i]-&#39;0&#39;)*j;        j*=10;        ans+=m;    }    return ans;}int main(){    ll a,j=0;    string s;    cin&gt;&gt;a&gt;&gt;s;    for(int i=0;i&lt;s.size();i++)    {        if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)        {            mid[j]+=s[i];        }        else j++;    }    j=1;    for(int i=0;i&lt;s.size();i++)    {        if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)        {            continue;        }        if(s[i]==&#39;+&#39;)   a+=zh(mid[j]);        if(s[i]==&#39;-&#39;)   a-=zh(mid[j]);        if(s[i]==&#39;%&#39;)   a%=zh(mid[j]);        if(s[i]==&#39;^&#39;)   a*=a;        if(s[i]==&#39;*&#39;)   a*=zh(mid[j]);        j++;    }    cout&lt;&lt;abs(a)&lt;&lt;endl;}</code></pre><p>A easy code and a easy thought.<br>After sumbit this code,I thought of a function----&quot;stoi&quot;.It can convert string type directly to int type.So this is more easily!<br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string mid[100005];int main(){    ll a,j=0;    string s;    cin&gt;&gt;a&gt;&gt;s;    for(int i=0;i&lt;s.size();i++)    {        if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)        {            mid[j]+=s[i];        }        else j++;    }    j=1;    for(int i=0;i&lt;s.size();i++)    {        if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)        {            continue;        }        if(s[i]==&#39;+&#39;)   a+=stoi(mid[j]);        if(s[i]==&#39;-&#39;)   a-=stoi(mid[j]);        if(s[i]==&#39;%&#39;)   a%=stoi(mid[j]);        if(s[i]==&#39;^&#39;)   a*=a;        if(s[i]==&#39;*&#39;)   a*=stoi(mid[j]);        j++;    }    cout&lt;&lt;abs(a)&lt;&lt;endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nowcoder </tag>
            
            <tag> Thinking </tag>
            
            <tag> functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Little knowledge point(Reprint)</title>
      <link href="/2019/05/24/Little-knowledge-point(Reprint)/"/>
      <url>/2019/05/24/Little-knowledge-point(Reprint)/</url>
      
        <content type="html"><![CDATA[<p>Original link: <a href="https://blog.csdn.net/c_circle/article/details/78492772" target="_blank" rel="noopener">Lesroad</a></p><p><center>能被2、3、4、5、6、7、8、9等数整除的数的特征</center><br>性质1：如果数a、b都能被c整除，那么它们的和（a+b）或差(a－b)也能被c整除。</p><p>性质2：几个数相乘，如果其中有一个因数能被某一个数整除，那么它们的积也能被这个数整除。</p><p>能被2整除的数，个位上的数能被2整除（偶数都能被2整除），那么这个数能被2整除</p><p>能被3整除的数，各个数位上的数字和能被3整除，那么这个数能被3整除</p><p>能被4整除的数，个位和十位所组成的两位数能被4整除，那么这个数能被4整除</p><p>能被5整除的数，个位上为0或5的数都能被5整除，那么这个数能被5整除</p><p>能被6整除的数，各数位上的数字和能被3整除的偶数，如果一个数既能被2整除又能被3整除，那么这个数能被6整除</p><p>能被7整除的数，若一个整数的个位数字截去，再从余下的数中，减去个位数的2倍，如果差是7的倍数，则原数能被7整除。如果差太大或心算不易看出是否7的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止。例如，判断133是否7的倍数的过程如下：13－3×2＝7，所以133是7的倍数；又例如判断6139是否7的倍数的过程如下：613－9×2＝595 ， 59－5×2＝49，所以6139是7的倍数，余类推。</p><p>能被8整除的数，一个整数的末3位若能被8整除，则该数一定能被8整除。</p><p>能被9整除的数，各个数位上的数字和能被9整除，那么这个数能被9整除</p><p>能被10整除的数，如果一个数既能被2整除又能被5整除，那么这个数能被10整除（即个位数为零）</p><p>能被11整除的数，奇数位（从左往右数）上的数字和与偶数位上的数字和之差（大数减小数）能被11整除，则该数就能被11整除。 11的倍数检验法也可用上述检查7的「割尾法」处理！过程唯一不同的是：倍数不是2而是1！<br>能被12整除的数，若一个整数能被3和4整除，则这个数能被12整除</p><p>能被13整除的数，若一个整数的个位数字截去，再从余下的数中，加上个位数的4倍，如果差是13的倍数，则原数能被13整除。如果差太大或心算不易看出是否13的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止。</p><p>能被17整除的数，若一个整数的个位数字截去，再从余下的数中，减去个位数的5倍，如果差是17的倍数，则原数能被17整除。如果差太大或心算不易看出是否17的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止。</p><p>   另一种方法：若一个整数的末三位与3倍的前面的隔出数的差能被17整除，则这个数能被17整除</p><p>能被19整除的数，若一个整数的个位数字截去，再从余下的数中，加上个位数的2倍，如果差是19的倍数，则原数能被19整除。如果差太大或心算不易看出是否19的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止。</p><p>另一种方法：若一个整数的末三位与7倍的前面的隔出数的差能被19整除，则这个数能被19整除</p><p>能被23整除的数，若一个整数的末四位与前面5倍的隔出数的差能被23(或29)整除，则这个数能被23整除</p><p>能被25整除的数，十位和个位所组成的两位数能被25整除。</p><p>能被125整除的数，百位、十位和个位所组成的三位数能被125整除。</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Useful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰魔法师</title>
      <link href="/2019/05/24/nowcoder-215-A/"/>
      <url>/2019/05/24/nowcoder-215-A/</url>
      
        <content type="html"><![CDATA[<center>灰魔法师</center><p>Links: <a href="https://ac.nowcoder.com/acm/contest/215/A" target="_blank" rel="noopener">nowcoder-215-B</a><br><a href="https://hpuoj.com/contest/3/problem/B/" target="_blank" rel="noopener">HPUOJ-contest-3-B</a><br>Description:<br>“White shores, and beyond. A far green country under a swift sunrise.”--灰魔法师</p><p>给出长度为n的序列a, 求有多少对数对 (i, j) (1 &lt;= i &lt; j &lt;= n) 满足 ai + aj 为完全平方数。<br>输入描述:<br>第一行一个整数 n (1 &lt;= n &lt;= 105)<br>第二行 n 个整数 ai (1 &lt;= ai &lt;= 105)<br>输出描述:<br>输出一个整数，表示满足上述条件的数对个数。<br>示例1<br>输入<br>3<br>1 3 6<br>输出<br>2<br>说明<br>满足条件的有 (1, 2), (2, 3) 两对。</p><p>Intentional analysis:<br>We should use a tag array because the data range is too large and the violence will time out.For this way,this problem is easy too.</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200050;int a[maxn];int main(){    int n,x,ans=0;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;x;        for(int i=1;i*i&lt;=maxn;i++)            if(i*i&gt;x)                ans+=a[i*i-x];        a[x]++;    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><p>The reason why I said this problem is meaningful is a thought,a &quot;flag&quot; thought,which can reduce the time the program runs to avoid TLE.</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nowcoder </tag>
            
            <tag> Thinking </tag>
            
            <tag> HPUOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>棋盘问题</title>
      <link href="/2019/05/23/poj-1321/"/>
      <url>/2019/05/23/poj-1321/</url>
      
        <content type="html"><![CDATA[<center>poj-1321-棋盘问题</center><p>Links: <a href="https://poj.org/problem?id=1321" target="_blank" rel="noopener">poj-1321</a><br>Description:<br>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。<br>Input</p><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。<br>Output</p><p>对于每一组数据，给出一行输出，输出摆放的方案数目C数据保证C\&lt;2^31）。<br>Sample Input</p><p>2 1</p><h1 id><a href="#" class="headerlink" title="."></a>.</h1><p>.#<br>4 4<br>...#<br>..#.<br>.#..</p><h1 id="-1"><a href="#-1" class="headerlink" title="..."></a>...</h1><p>-1 -1<br>Sample Output</p><p>2<br>1</p><p>To solve this problem,you should clear about the judge conditions——Each line and each column cannot have a piece at the same time.</p><details><summary><font color="red">Click to see Chinese Intentional analysis</font></summary>这道题跟八皇后很像，就是判断条件不太一样，每一行和每一列不能同时有棋子，具体看代码注释。</details><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char s[10][10];//The mapint flag[10];//Record whether a column has been put on the chess pieceint n,k,ans,anss;//anss represents how many pieces have been placed now.ans is the final answer.void dfs(int now){    if(k==anss)//All the pieces are finished.    {        ans++;        return ;    }    if(now&gt;=n)//Boundary conditions        return ;    for(int j=0;j&lt;n;j++)    {        if(flag[j]==0&amp;&amp;s[now][j]==&#39;#&#39;)//Judge whether you can put down the pieces here.        {            flag[j]=1;            anss++;            dfs(now+1);            flag[j]=0;//For the back            anss--;        }    }    dfs(now+1);}int main(){    while(cin&gt;&gt;n&gt;&gt;k)    {        memset(s,0,sizeof(s));        ans=0;        if(n==-1&amp;&amp;k==-1)            break;        for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;n;j++)                cin&gt;&gt;s[i][j];        dfs(0);        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><details><summary><font color="red">Click to see Chinese code</font></summary>```#include<iostream>#include<cstring>using namespace std;char s[10][10];//存起来的图int flag[10];//标记这一列已经放过棋子int n,k,ans,anss;//anss是现在已经放上去的棋子，ans是最后的答案void dfs(int now){    if(k==anss)    {        ans++;        return ;    }    if(now>=n)        return ;    for(int j=0;j<n;j++) { if(flag[j]="=0&&s[now][j]=='#')//判断这个位置是否可以放棋子" flag[j]="1;" anss++; dfs(now+1); anss--; } int main() while(cin>>n>>k)    {        memset(s,0,sizeof(s));        ans=0;        if(n==-1&&k==-1)            break;        for(int i=0;i<n;i++) for(int j="0;j<n;j++)" cin>>s[i][j];        dfs(0);        cout<<ans<<endl; } return 0; ``` < details></ans<<endl;></n;i++)></n;j++)></cstring></iostream></details>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> DFS </tag>
            
            <tag> poj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC-Invitational in Xi&#39;an</title>
      <link href="/2019/05/22/ICPC-Invitational-in-Xi&#39;an/"/>
      <url>/2019/05/22/ICPC-Invitational-in-Xi&#39;an/</url>
      
        <content type="html"><![CDATA[<p>　　机缘巧合下，被选去参加了5.18-19的西安邀请赛。<br>　　等了好久，终于等到5.17的晚上。早早的到了火车站，我们需要从焦作先到郑州然后再转车去西安。去郑州还是很快的，但是我们也是第一次倒车，摸索着摸索着就会了呗。去西安的车是硬卧，还是第一次坐硬卧，空间也太狭小了。而且路上总会很颠簸，睡眠得质量还是不是很好的。到了西安，下来火车，映入眼帘得就是一个城墙，果然壮观。据老师跟我们说的，我们需要先坐公交去找他会和。找到他之后，我们去坐下一个公交。路上去吃了西安得“正宗”的胡辣汤，跟我们这里“正宗”得胡辣汤一点都不一样，那时我才反应过来，哦，原来这种“正宗”都是自己给自己加的！下一班公交要坐两个小时，这时已经略微有点倦意。路上还看到了秦岭，真的是连绵不绝。<br>　　到了学校下了车，进了学校，经过了一个耗资两亿的图书馆，看了看沿途学校的风景，挺美的。跟着老师一起去签到，领了参赛牌和衣服，衣服是橙色的，不是很喜欢，不过毕竟是白嫖的。等这些事都忙完已经十一点多了，下午两点多还得到这参加开幕式，我和两个队友就决定不去宾馆在这个学校转转。老师去宾馆处理事情，我们仨就在学校转悠起来。转完之后，坐在签到处等着开幕式，然后又一次机缘巧合下，没去开幕式。<br>　　三点多的时候，已经让进机房了(应该是因为是邀请赛，所以没有在体育馆进行，还是有点可惜的。里面的安排是两个位置坐三个人，而且地方特别小，幸亏我跟我的队友都比较瘦。电脑上也没有dev，有个clione还有codeblock什么的，还支持python。热身赛一共三道题，印象中开始没多久，旁边的那一队就AK了，那时候我们应该是才做出来一道题，而且下面的题毫无思路。一阵阵的伤心，不过最后随着队友的爆发和板子终于是过了两题了。最后一道题队友用python两行写了出来，可是发现题目中要求的是int32，而python中没有这个，导致样例都没过，然后两个队友就开始商量着模拟爆int32得处理，可是最后也莫得实现。距离五点半(比赛结束，只剩不到十分钟了，我说直接交一发吧，队友说肯定不会过毕竟样例都没过，我想的就是就算不过我们也要WA一发，证明我们来过啊。在我的怂恿下队友交了，还有一个队友说：这要是能过，我吃X，然后过了，过了。不知道是评测数据水了还是样例唬人，AK得感觉还是很好的。<br>　　做完题我们拿着饭票去食堂吃饭，但是我们一致决定不在学校吃了，就走着回宾馆，顺便在路上吃个饭，我们找到一家泡馍，就点了三碗，刚开始吃还是挺好吃的，但是吃了一会发现越来越油。可能没有找对地方吧。吃完饭回到宾馆就没事了，洗了个澡，玩会手机就睡了。<br>　　第二天早上起来，在宾馆吃了早餐，坐着大巴去学校，老师就回去了，我们三个到学校的时候还有点早，就站了一会，等到八点四十左右就进去机房了。总共13道题，第一道巨水，过了之后发现后面的题都不简单。然后一个队友开了L，发现可以找规律做，别的也没有思路，我们就开始一起找规律，找啊找啊，找了好久也没找到，这时候发现L和M过了好多，我们又看了M，一个队友说是什么图啊什么的，我就直接去看L了，最后还是队友强，找到规律过了L。周围的队都太强了，三四个气球，我们才两个。到了中午开始发吃的了，每个人发了一个那种“汉堡”还有一个面包一盒奶，本来以为这就结束了，最后又给每个人发了一袋零食，薯片啊，面包啊什么的。不过那个我和队友一点都没吃提了回来。过了一会我们有发现D好像可以写，然后队友写出来了D，一测样例发现第一个样例可以过，第二个样例过不去。我们一起手算了第二个样例，发现跟我们程序跑的一样跟样例也不一样，不敢交，可是我们也找不到更好的答案了，最后我们也知道了一定会打铁的事实，就直接破罐子破摔交了，然后又过了，过了。我枯了。<br>　　比赛结束之后我们坐着大巴到了一个地铁站，然后坐地铁到了钟楼，出来地铁去了回民街，刚进去就看到了一堆人，一堆，而且里面好多外国人，感觉自己就像村里人进城一样。说好给小伙伴带好吃的好玩的回去，结果转了好大一圈也没有发现什么好带的。最后我们每个人买了个肉夹馍，一个肉夹馍花了15块钱。还真是有点坑。这个时候我们已经准备回车站了，到了车站外面，发现不知道怎么去候车厅，问了下路，总算是进了候车厅。回去的车还是卧铺，到了郑州再转去焦作。<br>　　这就回来了，两天三夜的行程，真的很累，睡的也不安稳，还背着沉重的书包跑过来跑过去，不但身上累，心里面更累。还是打了个铁，有点失望的吧，不过我也不会气馁，下一年等我卷土重来！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIS</title>
      <link href="/2019/05/21/LIS/"/>
      <url>/2019/05/21/LIS/</url>
      
        <content type="html"><![CDATA[<center>LIS</center><p><a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank" rel="noopener">wikipedia</a><br>Description:<br>输入</p><p>第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9)</p><p>输出</p><p>输出最长递增子序列的长度。</p><p>输入示例</p><pre><code>8516824510</code></pre><p>输出示例</p><pre><code>5</code></pre><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=50050;const int INF=0x3f3f3f3f;int dp[maxn],a[maxn];int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    {        cin&gt;&gt;a[i];    }    fill(dp,dp+n,INF);    for(int i=0;i&lt;n;i++)    {        *lower_bound(dp,dp+n,a[i])=a[i];    }    cout&lt;&lt;lower_bound(dp,dp+n,INF)-dp&lt;&lt;endl;}</code></pre><p>The main problem solving idea is<br><a href="https://img.51nod.com/upload/000FBEB0/08D25E4125A35C5D0000000000000003.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://img.51nod.com/upload/000FBEB0/08D25E4125A35C5D0000000000000003.webp" class="img-shadow img-margin"></center></a><br>So we can use a convenient function,such as<code>lower_bound</code>.<br><a href="https://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">Click to know more about lower_bound</a><br>Honestly, I don&#39;t know what this has to do with DP, but it doesn&#39;t matter, I will always know it later.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> DP </tag>
            
            <tag> 51nod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大鱼海棠</title>
      <link href="/2019/05/10/movie-dyht/"/>
      <url>/2019/05/10/movie-dyht/</url>
      
        <content type="html"><![CDATA[<p>“你以为你接受的是谁的爱？你接受的是一个天神的爱！他将背叛所有的神灵去爱你！为你忍受一切痛苦！以此带给你快乐。”</p><p align="right">——大鱼海棠 湫</p><a id="more"></a><p>　　这部电影也可以称得上是老电影了，之前看过一遍，可能是时间久了没啥印象，前几天看了一遍感慨万分。<br>　　最喜欢的就是湫。</p><p>　　我告诉你什么事最可悲:你遇见一个人，犯了一个错，你想弥补想还清，到最后才发现你根本无力回天，犯下的罪过永远无法弥补。我们永远无法还清犯下的…</p><p>　　人总会遇见一个人，犯一个错，然后欠下些什么，你还不清的……<br>　　我很后悔那个晚上没有紧紧抱住你，椿，答应我，不要放开我，相信我，你会幸福的。</p><p>　　我喜欢看你吃东西的样子，你任性的样子，生气的样子，伤心的时候，最尴尬的时候，都很好看。</p><p>　　湫：&quot;有些事情我想忘，但是忘不掉&quot;<br>　　鹿神：&quot;那就别忘了，真正的忘记是不需要努力的&quot;</p><p>　　这短短的一生，我们最终都会失去。你不妨大胆一些，爱一个人，攀一座山，追一个梦。</p><p>　　人生最美好的际遇，是在对的时间，遇上对的人，认识你从开始，离开由再见结束，从遇见开始，就不想结束。</p><p>　　明明是神的湫，爱起来还那么卑微。可是我也不懂爱，便也不好过多的评价。可是这部电影不全是爱情，还有椿和她妈妈间的感情，虽然画面很少，可还是让我心里有点难受，特别是最后妈妈说椿：孩子，你走吧。这是最让我心酸的地方，自己最疼爱的孩子犯下弥天大错，在两难的境地下，妈妈不得已只能选择帮助更多的族人。这样也掩盖不住她深深的母爱，我们每个人不也都是这样，从小到大犯过不少错，这就是成长。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Edit distance</title>
      <link href="/2019/05/06/Edit%20distance/"/>
      <url>/2019/05/06/Edit%20distance/</url>
      
        <content type="html"><![CDATA[<center>Edit distance</center><p>wikipedia:<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="noopener">Edit distance</a><br>Description:<br>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。<br>例如将kitten一字转成sitting：<br>sitten （k-&gt;s）<br>sittin （e-&gt;i）<br>sitting （-&gt;g）<br>所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。<br>给出两个字符串a,b，求a和b的编辑距离。</p><p>The problem is easy if you know the state transition equation.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095423.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095423.webp" class="img-shadow img-margin"></center></a></p><pre><code>//From 51nodwe define the function same(i,j) to be 0 if S[i] == T[j], otherwise 1.Let us show the recursion:f(i,j) = min(f(i – 1, j – 1) + same(i,j), f(i – 1,j ) + 1, f(i, j – 1) + 1)initial value:f(0, j) = jf(i, 0) = i</code></pre><p>The tutorial above 51nod is really good.Nou just LCS or Edit distance,but every tutorial there.<br>All the follwing are from 51nod.<br>The difficulty of this problem is that it is difficult to have such operations as &quot;add&quot; and &quot;delete&quot;, which is very troublesome. Let&#39;s try to understand the problem from a different angle and see it as a string alignment problem. In fact, we can understand the problem from the perspective of bioinformatics comparison genes.</p><p>Given the strings S and T, we can use a special character to facilitate the alignment of the two strings. The special character we added is &quot;-&quot;. We allow you to add this special character to S and T so that it is the same length, then &quot;align&quot; the two strings, and finally the two strings appear in the same position with different characters. With 1 point deduction, we want to make these two string alignment points as few as possible.</p><p>For the example we actually took this alignment:</p><p>12345<br>ABCF-<br>DB-FG</p><p>Note: If you want to align, the two &quot;-&quot; are relatively meaningless, so we ask that this does not happen.<br>Then take a look:<br>(1) S, T corresponding positions are ordinary characters, the same, then no points. For example, the position 2, 4<br>(2) S, T is the normal character, and the difference is 1 point. For example, position 1<br>(3) S is a special character at this position, and T is a normal character at this position, then 1 point is deducted, for example, position 5<br>(4) S is a normal character at this position, and T is a special character at that position, then Deduct 1 point, for example, position 3,</p><p>let&#39;s see what the deduction points correspond to?</p><p>(1) No deduction, direct correspondence<br>(2) Corresponding to the character modification of the corresponding position<br>in T (3) Corresponding to deleting the character<br>in T (4) Corresponding to adding the character in T</p><p>, the target is clear, and it feels like Like LCS? Let us try:<br>Let f(i,j) denote the minimum deduction after the alignment of the first i bit of S and the first j bit of T.</p><p>Then let&#39;s take a look at the last one, the alignment</p><p>(1) S[i] == T[j] must be used. At this time, the first i – 1 and j – 1 bits are already aligned. This part must be deducted at least. The minimum deduction in this case is f(i-1,j-1)<br>(2) is similar to (1), S[i]≠T[j], in which case the least deduction is f(i) -1, j – 1) + 1<br>(3) The front i position of S and the front (j – 1) bit of T are already aligned, and this part has the least points. In this case, the least deduction is f(i,j-1) + 1<br>(4) The first (i-1) bit of S has been aligned with the first j position of T, which is the least. In this case, the minimum deduction is f(i,j-1) + 1</p><p>What is the value of f(i,j), obviously it depends on which case has the least deduction.</p><p>An example on nowcoder:<br>Link:<a href="https://www.nowcoder.com/questionTerminal/9649617be3bf42288f50758df4310655" target="_blank" rel="noopener">Edit distance</a><br>Description:<br>UNIX系统下有一个行编辑器ed，它每次只对一行文本做删除一个字符、插入一个字符或替换一个字符三种操作。例如某一行的内容是“ABC”，经过把第二个字符替换成“D”、删除第一个字符、末尾插入一个字符“B”，这三步操作后，内容就变成了“DCB”。即“ABC”变成“DCB”需要经过3步操作，我们称它们的编辑距离为3。<br>现在给你两个任意字符串（不包含空格），请帮忙计算它们的最短编辑距离。</p><p>输入描述:<br>输入包含多组数据。</p><p>每组数据包含两个字符串m和n，它们仅包含字母，并且长度不超过1024。</p><p>输出描述:<br>对应每组输入，输出最短编辑距离。<br>示例1<br>输入<br>ABC CBCD<br>ABC DCB<br>输出<br>2<br>3</p><p>Intentional analysis:<br>A basic Edit distance problem,just use the recursion above.</p><p>Code:</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1050;int f[maxn][maxn];string a,b;bool same(char x,char  y){    if(x==y)    return 0;    return 1;}int main(){    while(cin&gt;&gt;a&gt;&gt;b)    {        memset(f,0,sizeof(f));        for(int i=0;i&lt;=a.size();i++)        {            for(int j=0;j&lt;=b.size();j++)            {                if(i==0)    f[i][j]=j;                else if(j==0)    f[i][j]=i;                else f[i][j]=min(f[i-1][j-1]+same(a[i-1],b[j-1]),min(f[i-1][j]+1,f[i][j-1]+1));            }        }        cout&lt;&lt;f[a.size()][b.size()]&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> DP </tag>
            
            <tag> 51nod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find the Tth Char</title>
      <link href="/2019/05/05/Find-the-Tth-Char/"/>
      <url>/2019/05/05/Find-the-Tth-Char/</url>
      
        <content type="html"><![CDATA[<p>There are all kinds of people in this world. It happens that we have become friends. This is not fate. It is just that we should be friends.</p><p></p><p align="right">——Green Book</p><br><a id="more"></a><br>When I first met a problem which name is Find the Nth Character in nowcoder,I find this problem is interesting for mind.After solving this,I find a similar problem like this in HDU which name is find the Nth digit.<br>Link:<br><a href="https://ac.nowcoder.com/acm/contest/877/A" target="_blank" rel="noopener">Find the Nth Character in nowcoder</a><br><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1597" target="_blank" rel="noopener">find the Nth digit in HDU</a><p></p><p><center>Find the Nth Character</center><br>Description:<br>Mr Cheng今天在给HLJU的同学们上程序算法课的时候出了一道找规律的题目，题目表述如下<br>假设：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095458.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095458.webp" class="img-shadow img-margin"></center></a><br>现在要求上课的同学们把所有的串依次连接起来，于是得到:<br>S=aababcabcdabcde...<br>那么你能告诉Mr Cheng在S串中的第N个字母是多少吗？</p><p>输入描述:<br>输入首先是一个数字K，代表有K次询问(1&lt;=K&lt;=1000)</p><p>接下来的K行每行有一个整数N(1&lt;=N&lt;=10000)</p><p>输出描述:<br>对于每次询问，输出串中第个位置对应的字母。</p><p>示例1<br>输入<br>6<br>1<br>2<br>3<br>4<br>5<br>10<br>输出<br>a<br>a<br>b<br>a<br>b<br>d</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int t;    int n;    cin&gt;&gt;t;    while (t--)    {          cin&gt;&gt;n;          int a = 1;          char ans=&#39;a&#39;;          while ( n &gt; a )          {                n -= a;                  a++;          }          n%=26;          if(n==0) n=26;          ans+=n-1;         cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><p><center>find the nth digit</center><br>Description:<br>假设：<br>S1 = 1<br>S2 = 12<br>S3 = 123<br>S4 = 1234<br>.........<br>S9 = 123456789<br>S10 = 1234567891<br>S11 = 12345678912<br>............<br>S18 = 123456789123456789<br>..................<br>现在我们把所有的串连接起来<br>S = 1121231234.......123456789123456789112345678912.........<br>那么你能告诉我在S串中的第N个数字是多少吗？</p><p>Input<br>输入首先是一个数字K，代表有K次询问。<br>接下来的K行每行有一个整数N(1 &lt;= N &lt; 2^31)。</p><p>Output<br>对于每个N，输出S中第N个对应的数字.</p><p>Sample Input<br>6<br>1<br>2<br>3<br>4<br>5<br>10</p><p>Sample Output<br>1<br>1<br>2<br>1<br>2<br>4</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int t;    int n;    cin&gt;&gt;t;    while (t--)    {          cin&gt;&gt;n;          int a = 1;          char ans=&#39;1&#39;;          while ( n &gt; a )          {                n -= a;                  a++;          }          n%=9;          if(n==0) n=9;          ans+=n-1;         cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><p>Intentional analysis:<br>We can easily find there is a few different between these two codes above.In fact,to solve this problem,the main thinking is find the Nth in the correct position.And the regular is</p><pre><code>1 2 3 4 5 6 7 8 9 10...1 12 123 1234 12345 123456 1234567 12345678 123456789 1234567891...</code></pre><p>Through this,you may understand this more.<br>I know that what I said is not so clearly,so just think through these codes if you can&#39;t understand enough.</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nowcoder </tag>
            
            <tag> HDU </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Discrete mathematics-Chapter Six</title>
      <link href="/2019/05/03/Discrete%20mathematics-Chapter%20Six/"/>
      <url>/2019/05/03/Discrete%20mathematics-Chapter%20Six/</url>
      
        <content type="html"><![CDATA[<h3 id="Judge-an-element-in-a-set-or-not"><a href="#Judge-an-element-in-a-set-or-not" class="headerlink" title="Judge an element in a set or not"></a>Judge an element in a set or not</h3><pre><code class="lang-python">#Judge an element in a set or notprint(&quot;Enter the element to be judged:&quot;)a = input()print(&quot;Enter the set to be judged:&quot;)s = set(input().split())if a in s:    print(&quot;The element %s is in the set %s&quot; % (a,s))else:    print(&quot;The element %s is not in the set %s&quot; % (a,s))</code></pre><h3 id="Judge-if-a-set-is-a-subset-of-another-set"><a href="#Judge-if-a-set-is-a-subset-of-another-set" class="headerlink" title="Judge if a set is a subset of another set"></a>Judge if a set is a subset of another set</h3><pre><code class="lang-python">#Judge if a set is a subset of another setprint(&quot;Input a set:&quot;)a=set(input().split())print(&quot;Input another set&quot;)b=set(input().split())if a.issubset(b):    print(&quot;The set %s is the subset of the set %s&quot; % (a,b))elif b.issubset(a):    print(&quot;The set %s is the subset of the set %s&quot; % (b,a))else:    print(&quot;There is no subset relationship between the set %s and the set %s&quot; % (a,b))</code></pre><h3 id="Judge-if-a-set-is-a-proper-subset-of-another-set"><a href="#Judge-if-a-set-is-a-proper-subset-of-another-set" class="headerlink" title="Judge if a set is a proper subset of another set"></a>Judge if a set is a proper subset of another set</h3><pre><code class="lang-python">#Judge if a set is a proper subset of another setprint(&quot;Input a set:&quot;)a=set(input().split())print(&quot;Input another set&quot;)b=set(input().split())if len(a)!=len(b) and a.issubset(b):    print(&quot;The set %s is the proper subset of the set %s&quot; % (a,b))elif len(a)!=len(b) and b.issubset(a):    print(&quot;The set %s is the proper subset of the set %s&quot; % (b,a))else:    print(&quot;There is no proper subset relationship between the set %s and the set %s&quot; % (a,b))</code></pre><h3 id="Judge-if-two-sets-are-equal"><a href="#Judge-if-two-sets-are-equal" class="headerlink" title="Judge if two sets are equal"></a>Judge if two sets are equal</h3><pre><code class="lang-python">#Judge if two sets are equalprint(&quot;Input a set:&quot;)a=set(input().split())print(&quot;Input another set&quot;)b=set(input().split())if a==b:    print(&quot;The set %s is equal to the set %s&quot; % (a,b))else:    print(&quot;The set %s is not equal to the set %s&quot; % (a,b))</code></pre><h3 id="Judge-a-collection-as-an-empty-set"><a href="#Judge-a-collection-as-an-empty-set" class="headerlink" title="Judge a collection as an empty set"></a>Judge a collection as an empty set</h3><pre><code class="lang-python">#Judge a collection as an empty setprint(&quot;Input a set to be judged:&quot;)a=set(input().split())if a:    print(&quot;The set %s is not an empty set&quot; % (a))else:    print(&quot;The set is an empty set&quot;)</code></pre><p>Reference artical:<br><a href="https://blog.csdn.net/u013247765/article/details/79052257" target="_blank" rel="noopener">https://blog.csdn.net/u013247765/article/details/79052257</a></p><h3 id="Calculate-the-number-of-elements-in-a-set"><a href="#Calculate-the-number-of-elements-in-a-set" class="headerlink" title="Calculate the number of elements in a set"></a>Calculate the number of elements in a set</h3><pre><code class="lang-python">#Calculate the number of elements in a setprint(&quot;Input the set to be calculated:&quot;)a=set(input().split())print(&quot;The number of elements in the set %s is %d&quot; % (a,len(a)))</code></pre><h3 id="List-a-set-of-power-set-elements-and-return-the-number-of-elements"><a href="#List-a-set-of-power-set-elements-and-return-the-number-of-elements" class="headerlink" title="List a set of power set elements and return the number of elements"></a>List a set of power set elements and return the number of elements</h3><pre><code class="lang-python">#List a set of power set elements and return the number of elementsdef powerset(items):      N = len(items)      sall=[]    for i in range(2**N):        powers = []          for j in range(N):              if(i &gt;&gt; j ) % 2 == 1:  #For the i-th bit of the binary of x, if it is 1, this subset contains the ith element of s, otherwise it is not included.                powers.append(items[j])        sall.append(powers)    return sallprint(&quot;Input a set:&quot;)a=set(input().split())ans=powerset(list(a))print(&quot;The power set of the set %s are:&quot; % (a))print(ans)print(&quot;The number of elements is %d&quot; % (len(ans)))</code></pre><p>Reference artical:<br><a href="https://blog.csdn.net/beyondwdq/article/details/5540386" target="_blank" rel="noopener">https://blog.csdn.net/beyondwdq/article/details/5540386</a><br><a href="https://blog.csdn.net/luoganttcc/article/details/80785149" target="_blank" rel="noopener">https://blog.csdn.net/luoganttcc/article/details/80785149</a></p><h3 id="Find-the-union-of-two-sets"><a href="#Find-the-union-of-two-sets" class="headerlink" title="Find the union of two sets"></a>Find the union of two sets</h3><pre><code class="lang-python">#Find the union of two setsprint(&quot;Input a set:&quot;)a=set(input().split())print(&quot;Input another set:&quot;)b=set(input().split())print(&quot;the union of set %s and set %s is %s&quot; % (a,b,a|b))</code></pre><h3 id="Judge-if-the-intersection-of-two-sets-is-an-empty-set"><a href="#Judge-if-the-intersection-of-two-sets-is-an-empty-set" class="headerlink" title="Judge if the intersection of two sets is an empty set"></a>Judge if the intersection of two sets is an empty set</h3><pre><code class="lang-python">#Judge if the intersection of two sets is an empty setprint(&quot;Input a set:&quot;)a=set(input().split())print(&quot;Input another set:&quot;)b=set(input().split())ans=a&amp;bif ans:    print(&quot;The intersection of set %s and set %s is not an empty set&quot; % (a,b))else:    print(&quot;The intersection of set %s and set %s is an empty set&quot; % (a,b))</code></pre><h3 id="Find-the-intersection-of-two-sets"><a href="#Find-the-intersection-of-two-sets" class="headerlink" title="Find the intersection of two sets"></a>Find the intersection of two sets</h3><pre><code class="lang-python">#Find the intersection of two setsprint(&quot;Input a set:&quot;)a=set(input().split())print(&quot;Input another set:&quot;)b=set(input().split())print(&quot;The intersection of set %s and set %s is %s&quot; % (a,b,a&amp;b))</code></pre><h3 id="Find-the-relative-complement-of-two-sets"><a href="#Find-the-relative-complement-of-two-sets" class="headerlink" title="Find the relative complement of two sets"></a>Find the relative complement of two sets</h3><pre><code class="lang-python">#Find the relative complement of two setsprint(&quot;Input a set:&quot;)a=set(input().split())print(&quot;Input another set:&quot;)b=set(input().split())print(&quot;The relative complement of set %s and %s is %s&quot; % (a,b,a-b))print(&quot;The relative complement of set %s and %s is %s&quot; % (b,a,b-a))</code></pre><p>Something about relative complement:<br><a href="https://baike.baidu.com/item/%E7%9B%B8%E5%AF%B9%E8%A1%A5%E9%9B%86" target="_blank" rel="noopener">baike.baidu</a><br><a href="https://en.wikipedia.org/wiki/Complement_(set_theory" target="_blank" rel="noopener">Wikipedia</a></p><h3 id="Find-the-symmetric-difference-set-of-two-sets"><a href="#Find-the-symmetric-difference-set-of-two-sets" class="headerlink" title="Find the symmetric difference set of two sets"></a>Find the symmetric difference set of two sets</h3><pre><code class="lang-python">#Find the symmetric difference set of two setsprint(&quot;Input a set:&quot;)a=set(input().split())print(&quot;Input another set:&quot;)b=set(input().split())print(&quot;The symmetric difference set of set %s and set %s is %s&quot; % (a,b,(a|b)-(a&amp;b)))</code></pre><p>Something about symmetric difference set:<br><a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%B7%AE%E9%9B%86" target="_blank" rel="noopener">baike.baidu</a><br><a href="https://en.wikipedia.org/wiki/Symmetric_difference" target="_blank" rel="noopener">Wikipedia</a></p>]]></content>
      
      
      <categories>
          
          <category> Discrete mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Discrete mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCS</title>
      <link href="/2019/05/02/LCS/"/>
      <url>/2019/05/02/LCS/</url>
      
        <content type="html"><![CDATA[<p>I can&#39;t explain the code correctly so I just paste it here.</p><center>LCS</center><p>给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。<br>比如两个串为：</p><p>abcicba<br>abdkscab</p><p>ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。</p><p>Code:</p><pre><code>//From the internet#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;string a,b;int dp[1050][1050],mark[1050][1050],la,lb;void lcs(){    int i,j;    memset(dp,0,sizeof(dp));    for(int i=1;i&lt;=la;i++)        mark[i][0]=1;    for(int i=1;i&lt;=lb;i++)        mark[0][i]=-1;    for(int i=1;i&lt;=la;i++)    {        for(int j=0;j&lt;=lb;j++)        {            if(a[i-1]==b[j-1])            {                dp[i][j]=dp[i-1][j-1]+1;                mark[i][j]=0;            }            else if(dp[i-1][j]&gt;=dp[i][j-1])            {                dp[i][j]=dp[i-1][j];                mark[i][j]=1;            }            else            {                dp[i][j]=dp[i][j-1];                mark[i][j]=-1;            }        }    }}void output(int x,int y){    if(!x&amp;&amp;!y)        return ;    if(mark[x][y]==0)    {        output(x-1,y-1);        cout&lt;&lt;a[x-1];    }    else if(mark[x][y]==1)    {        output(x-1,y);    }    else    {        output(x,y-1);    }}int main(){    while(cin&gt;&gt;a&gt;&gt;b)    {        la=a.size();lb=b.size();        lcs();        output(la,lb);        cout&lt;&lt;endl;    }    return 0;}</code></pre><p>Code:</p><pre><code>//From boctorio#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;const int maxn = 1050 ;int dp[maxn][maxn];char a[maxn],b[maxn];int main(){    scanf(&quot;%s %s&quot;,a+1,b+1);    int n=strlen(a+1),m=strlen(b+1);    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)        {            if(a[i]==b[j])    dp[i][j]=dp[i-1][j-1]+1;            else    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);        }    stack&lt;char&gt; ans;    while(n&gt;=1&amp;&amp;m&gt;=1)    {        if(dp[n][m]==0)    break;        if(dp[n][m]-dp[n-1][m-1]==1 &amp;&amp; dp[n-1][m-1]==dp[n-1][m] &amp;&amp; dp[n-1][m-1]==dp[n][m-1])        {            ans.push(a[n]);            n--;            m--;        }        else if(dp[n][m]==dp[n-1][m] &amp;&amp; n&gt;1)    n--;        else if(dp[n][m]==dp[n][m-1] &amp;&amp; m&gt;1)    m--;    }    while(!ans.empty())    {        printf(&quot;%c&quot;,ans.top());        ans.pop();    }    puts(&quot;&quot;);    return 0;}</code></pre><p>You can take part in the tutorial of dp in the 51nod.It&#39;s so good!</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> DP </tag>
            
            <tag> 51nod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Basic Greedy</title>
      <link href="/2019/05/01/A-Basic-Greedy/"/>
      <url>/2019/05/01/A-Basic-Greedy/</url>
      
        <content type="html"><![CDATA[<center>删数问题</center><p>link: <a href="https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2072.html" target="_blank" rel="noopener">SDUT-2072</a></p><p>Description:<br>键盘输入一个高精度的正整数n（≤100位），去掉其中任意s个数字后剩下的数字按照原来的左右次序组成一个新的正整数。编程对给定的n与s，寻找一种方案，使得剩下的数字组成的新数最小。<br>Input<br>输入有多组 每组包括原始数n，要去掉的数字数s；<br>Output<br>输出去掉s个数后最小的数<br>Sample Input<br>178543  4<br>Sample Output<br>13<br>Intentional analysis:<br>We&#39;d better use the string type to input.What we should do if find a number in the input which is bigger than it&#39;s next.Like <code>a[i]&gt;a[i+1]</code>.And then delete the <code>a[i]</code>.There is the greedy.There are many special situations we shoule consider.</p><ol><li>Can&#39;t find a a[i] which is satisfy <code>a[i]&gt;a[i+1]</code>,just output the first n characters</li><li>The answer string s has &#39;0&#39; at the first,the ordering output should be a number,nao a string.So the front &#39;0&#39; is not allowed.</li></ol><details><summary><font color="red">Click to see Chinese Intentional analysis</font></summary>我们输入的应该是字符串，方便操作并且保证数据范围。为了得到消去之后最大的值，我们只需要找到a[i]>a[i+1]的i并将之删除即可。这就是体现贪心的地方。但是我们还需要考虑一些特殊情况1. 数本身就是递增的，此时我们只需要输出前n位即可。2. 得到的答案字符串的前面有0，判断一下并消去即可。</details><p>Code:</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    string s;    int n;    while(cin&gt;&gt;s&gt;&gt;n)    {        int l=s.size();        while(n--)        {            for(int i=0;i&lt;l;i++)            {                if(s[i]&gt;s[i+1]||i==l-1)                {                    s.erase(i,1);                    break;                }            }        }        while(s[0]==&#39;0&#39;&amp;&amp;s[1])            s.erase(0,1);        cout&lt;&lt;s&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Greedy </tag>
            
            <tag> SDUTOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Dynamic programming</title>
      <link href="/2019/04/27/Basic-Dynamic-programming/"/>
      <url>/2019/04/27/Basic-Dynamic-programming/</url>
      
        <content type="html"><![CDATA[<center>堆石子</center><p>link: <a href="https://hpuoj.com/problem/135/" target="_blank" rel="noopener">堆石子</a><br>Description:<br>JQM开始玩堆石子的游戏。有 m 颗质量大小不同的石子，从最下面一层开始堆石子，最下面一层放置 n 颗石子，每层减少一颗石子，恰好到最上一层为 一颗 石子。现在从最下面一层开始每层石子中取出一颗石子（注意，为了方便取出，要求只能拿和已拿石子相邻的两颗石子中的一颗），求能取出的石子质量和最大为多少？</p><p>Input<br>石子总数 m(1≤m≤400)<br>接下来每行表示从最下面一层开始每层每个石子的质量 w(1≤w≤1e8)</p><p>Output<br>能取出的最大石子质量和</p><p>Examples<br>input<br>6<br>1 4 6<br>3 2<br>1<br>output<br>9<br>Note<br>   1<br>  2 3<br> 4 5 6<br>7 8 9 10<br>如果你拿了8，那么你就只能拿4或者5而不能拿6</p><p>Intentional analysis:<br>What we should is find the &quot;State transition equation&quot;.We know that the value of the optimal solution in the bottom row is his own, which is the critical condition.Another part of the state transition equation is that the value of the optimal solution is the maximum of the number above it and the number in the upper right corner, and then adds itself.Of course,we can solve this problem with DFS.Memory search is a perfect way to avoid TLE.<br>So,we can get the &quot;State transition equation&quot;:</p><pre><code>dp[i][j] = a[i][j]     if(i==n)dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]n represents the number of rows of triangles.a[i][j] represents the value of the i-th row and the j-th column in the triangle.dp[i][j] represents the value of the optimal solution for this position.</code></pre><details>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>这是一道DP的裸题，我们需要的就是推出递推公式就行了。首先我们知道若想得到当前位置的最优解，就需要知道它上一个位置的最优解，一开始可能会想到dfs，看一下数据范围，dfs的话肯定会超时，但是dfs也是可以做的，但是需要用到记忆化搜索。继续说回我们用DP做的方法，我们知道最下面那一行的最优解的值就是他自己，这就是临界条件，状态转移方程的另一部分就是这个数最优解的值就是它的上面的那个数和右上角的那个数的最大值加上自己本身。所以我们可以得到```dp[i][j] = a[i][j]     if(i==n)dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]n代表的是三角形的行数。a[i][j]代表的是三角形中的第i行第j列的值。dp[i][j]代表的就是这个位置的最优解的值。```</details><p>Code-dp:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=400;typedef long long ll;ll a[maxn][maxn];ll dp[maxn][maxn];int main(){    ll n,k=1;    cin&gt;&gt;n;    while(n)    {        n-=k;        k++;    }    k-=1;    for(ll i=k;i&gt;=1;i--)        for(ll j=1;j&lt;=i;j++)        cin&gt;&gt;a[i][j];    for(ll i=k;i&gt;=1;i--)    {        for(ll j=1;j&lt;=i;j++)            if(i==k)    dp[i][j]=a[i][j];            else dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j];    }    cout&lt;&lt;dp[1][1]&lt;&lt;endl;    return 0;}</code></pre><p>Code-dfs:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1000;ll a[maxn][maxn];ll dp[maxn][maxn];ll n,k=1;ll dfs(ll x,ll y){    if(dp[x][y])    return dp[x][y];    if(x==k) return dp[x][y]=a[x][y];    ll m = dfs(x+1,y);    ll n = dfs(x+1,y+1);    return dp[x][y]=max(m,n)+a[x][y];}int main(){    cin&gt;&gt;n;    while(n)    {        n-=k;        k++;    }    k-=1;    for(ll i=k;i&gt;=1;i--)        for(ll j=1;j&lt;=i;j++)        cin&gt;&gt;a[i][j];    cout&lt;&lt;dfs(1,1)&lt;&lt;endl;    return 0;}</code></pre><p>If you still confused with dp,just think about Fibonacci sequence.</p><pre><code>F[0]=1F[1]=1F[2]=2F[3]=3F[4]=5......F[n]=F[n-1]+F[n-2]</code></pre><p><code>F[n]=F[n-1]+F[n-2]</code> is Fibo&#39;s &quot;State transition equation&quot;.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> DFS </tag>
            
            <tag> DP </tag>
            
            <tag> HPUOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stone</title>
      <link href="/2019/04/26/Stone/"/>
      <url>/2019/04/26/Stone/</url>
      
        <content type="html"><![CDATA[<center>nowcoder-893-D Stone</center><p>link: <a href="https://ac.nowcoder.com/acm/contest/893/D" target="_blank" rel="noopener">Stone</a></p><p>Description:</p><p>有n堆石子排成一排，第i堆石子有ai个石子。<br>每次，你可以选择任意相邻的两堆石子进行合并，合并后的石子数量为两堆石子的和，消耗的体力等价于两堆石子中石子数少的那个。<br>请问，将所有的石子合并成一堆，你所消耗的体力最小是多少？<br>输入描述:<br>第一行是一个整数T(1≤T≤20)，表示样例的个数。<br>每个样例的第一行是一个整数(1≤n≤10000),表示石子堆的数量。<br>第二行是n个整数(1≤ai≤1e9)<br>输出描述:<br>每行输出一个样例的结果。<br>示例1<br>输入<br>2<br>2<br>1 2<br>1<br>1<br>输出<br>1<br>0<br>说明<br>巨大的输入，请使用C风格的输入。</p><p>Intentional analysis:</p><p>Because the order of the series is not changeable,so we can use the sum of each item in the series to subtract the largest item.It&#39;s the answer.</p><details>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>一开始看到这道题，我以为是贪心裸题，结果仔细一看，数列的顺序是不能变的。。。然后就没了思路。。。等到比赛结束之后看了大佬思路，恍然大悟。因为每次能合起来两堆石子，消耗的疲劳度是最小的那个，并且顺序还不能变，所以若想使最后的疲劳度最小，只需要让最大的那堆石头当成最后一组合起来的一个就行。因为最大的那个不管加上其他哪个数之后都会大于那个数。在一次合成中消耗掉这个最大的数并且使它不计算入疲劳度，就可以得到最小的疲劳度。</details><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[10005];int main(){    ll n,t;    scanf(&quot;%lld&quot;,&amp;n);    while(n--)    {        scanf(&quot;%lld&quot;,&amp;t);        ll sum=0;        for(ll i=0;i&lt;t;i++)            {scanf(&quot;%lld&quot;,&amp;a[i]);sum+=a[i];}        ll maxx=a[0];        for(ll i=1;i&lt;t;i++)            maxx=max(maxx,a[i]);        printf(&quot;%lld\n&quot;,sum-maxx);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nowcoder </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QAQ</title>
      <link href="/2019/04/25/QAQ/"/>
      <url>/2019/04/25/QAQ/</url>
      
        <content type="html"><![CDATA[<p>Yesterday participated in a practice session of nowcoder,Then I met a question similar to the previous one.</p><h3 id="nowcoder-847-A-QAQ"><a href="#nowcoder-847-A-QAQ" class="headerlink" title="nowcoder-847-A  QAQ"></a><center>nowcoder-847-A  QAQ</center></h3><p>link: <a href="https://ac.nowcoder.com/acm/contest/847/A" target="_blank" rel="noopener">QAQ</a></p><p>Descrption:</p><p>给定一个只包含大写字母的长度为N的字符串S,求S中不含相邻字符且长度为3的&quot;QAQ&quot;子序列个数。<br>即:<br>设字符串S的第i个字符为Si,求满足下列条件的<x,y,z>三元组个数。<br>1≤x,y,z≤N<br>x&lt;y−1<br>y&lt;z−1<br>Sx=&#39;Q&#39;,Sy=&#39;A&#39;,Sz=&#39;Q&#39;</x,y,z></p><p>输入描述:<br>输入仅一行一个字符串S,字符串的长度N满足(1≤N≤5000)。<br>N不会在输入中给出。<br>保证<br>S中只包含大写字母。<br>输出描述:<br>输出一行一个整数--满足条件的三元组个数。<br>示例1<br>输入<br>QQAQQ<br>输出<br>1<br>说明<br>满足条件的三元组只有一个:<br> <1,3,5><br>示例2<br>输入<br>QAQAQ<br>输出<br>0<br>示例3<br>输入<br>QQHAHAQQAQ<br>输出<br>10</1,3,5></p><p>Intentional analysis:</p><p>QAQ,let&#39;s look it carefully.Then we can find that the amount of &quot;QAQ&quot; is depends on the amount of &quot;A&quot;.So our task is find the position of &quot;A&quot;.<br>Attention: You can&#39;t choose neighboring char from the original string.</p><details>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>观察一下可以发现，QAQ的数量取决于A的数量。所以我们只需要找到A的数量，然后进行判断计算就行。注意：这道题要求的QAQ不能是在原字符串中相邻的字符。</details><p>For example:</p><pre><code>QAQAQ12345We can find &quot;QAQ&quot; at:1 2 31 2 51 4 53 4 5but all of these have neighboring char,so the answer of this example is &quot;0&quot;,not &quot;4&quot;.</code></pre><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;string s;long long ans;int main(){    cin&gt;&gt;s;    int l=s.size();    for(int i=0;i&lt;l;i++)    {        if(s[i]==&#39;A&#39;)        {            int a=0;            int b=0;            for(int j=i-2;j&gt;=0;j--)            {                if(s[j]==&#39;Q&#39;)                    a++;            }            for(int k=i+2;k&lt;l;k++)            {                if(s[k]==&#39;Q&#39;)                    b++;            }            ans+=a*b;        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><p>One more thing you should better focus on:<br>The answer is too big to be able to save a int type.I ffailed once because of this.</p><h3 id="A-similar-question"><a href="#A-similar-question" class="headerlink" title="A similar question:"></a>A similar question:</h3><p><center>CodeForces-894-A QAQ</center><br>link: <a href="https://codeforces.com/problemset/problem/894/A" target="_blank" rel="noopener">QAQ</a></p><p>Descripition:<br>&quot;QAQ&quot; is a word to denote an expression of crying. Imagine &quot;Q&quot; as eyes with tears and &quot;A&quot; as a mouth.</p><p>Now Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of &quot;QAQ&quot; in the string (Diamond is so cute!).</p><p>Bort wants to know how many subsequences &quot;QAQ&quot; are in the string Diamond has given. Note that the letters &quot;QAQ&quot; don&#39;t have to be consecutive, but the order of letters should be exact.</p><p>Input<br>The only line contains a string of length n (1 ≤ n ≤ 100). It&#39;s guaranteed that the string only contains uppercase English letters.</p><p>Output<br>Print a single integer — the number of subsequences &quot;QAQ&quot; in the string.</p><p>Examples<br>input<br>QAQAQYSYIOIWIN<br>output<br>4<br>input<br>QAQQQZZYNOIWIN<br>output<br>3<br>Note<br>In the first example there are 4 subsequences &quot;QAQ&quot;: &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;.</p><p>This is similar to the previois.The only thing different is choose a neighboring char is allowed here.So we just correct a number then we can solve this problem.</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;string s;long long ans;int main(){    cin&gt;&gt;s;    int l=s.size();    for(int i=0;i&lt;l;i++)    {        if(s[i]==&#39;A&#39;)        {            int a=0;            int b=0;            for(int j=i-2;j&gt;=0;j--)            {                if(s[j]==&#39;Q&#39;)                    a++;            }            for(int k=i+2;k&lt;l;k++)            {                if(s[k]==&#39;Q&#39;)                    b++;            }            ans+=a*b;        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><p>You can find the difference between these two codes which is better for you to understand this series of questions.</p><h3 id="The-most-exciting-thing-I-want-to-say-is"><a href="#The-most-exciting-thing-I-want-to-say-is" class="headerlink" title="The most exciting thing I want to say is"></a>The most exciting thing I want to say is</h3><ol><li>我中奖啦</li><li>I got the prize</li><li>Gané el premio.</li><li>Ek het die prys gewen.</li><li>Kam fituar çmimin.</li><li>ሽልማቱን አሸንፌያለሁ.</li><li>Ես հաղթել եմ մրցանակին:</li><li>Mükafatı qazandım.</li><li>Saria irabazi nuen.</li><li>Я выйграў латарэю сяброў<br>......</li></ol><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102528.gif" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102528.gif" class="img-shadow img-margin"></center></a><p>After nearly half a year of competition on the nowcoder.Participated in 18 games,I won the price at last.Congratulations!</p><p>Show off<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102619.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804102619.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nowcoder </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go back home</title>
      <link href="/2019/04/24/Go-back-home/"/>
      <url>/2019/04/24/Go-back-home/</url>
      
        <content type="html"><![CDATA[<p>五一四天假期，再加上省赛被卡下来所以莫得训练，回家！<br>一开始买的坐票，但是小姐姐觉得可能会有其他的事就改签了一次，因为改签的晚了，所以只剩下站票了。然而一开始我们并没有意识到站票的可怕。<br>候车的时候就发现，人奇多，，，我是2车厢的站票，小姐姐是4号车厢，我本来想着既然是站票那就不趁劲了，可是检票员并不是这样认为的，于是我从二车厢上去之后，又开始在车厢之间穿梭，挤啊挤，终于是挤到了小姐姐的地方，不过我去了好像让他们的空间更小了，太令人惭愧了（TAO。<br>下了车已经十二点了，正式进入了5-1，没地方去的我在街上乱晃，挺喜欢这种感觉的，虽然有点冷。我走在一条人烟稀少的路上，听着歌，跟着唱，显然我是不知道下一步该往哪里走的。最后我还是打了的，送我到了一个我认得的路，找到了一家24h营业的便利店坐了进来，买了杯热豆浆，开始学习并查集，可是这终究不是学习的环境，这个便利店坐的地方是在门口，透风所以冷而且还有蚊子。我疲了，现在准备离开这里，去找下一个容身之处。<br>2019.5.1   1:25</p><p>从家园出来之后，我准备去网吧坐着，毕竟不冷。在我去网吧的路上，途径我的初中，我就过去看看，看看也没啥变化，里面也不让进。学校这种东西，真的是在里面的时候想出出不来，现在在外面的时候想进进不去。转了转学校的大门，感慨颇深啊。我继续出发往网吧走。路上又看到了一家家园，这个家园显然要比昨天那个好，它的供人休息的地方是在店里面，而且还有个玻璃可以看到外面，当时我就喜欢上这个地方。进来买了个蛋挞就坐在那，还能充电，理想休息地点哇。唯一不足的就是找不到一个上厕所的地方。可是又不舍得离开这么舒服的一个地方，最后还是不行了我就问了一下售货员小姐姐，原来家园里面就有卫生间。从厕所出来感觉稍微有点冷，买了杯奶茶来喝，正好家园里面也有热水。售货员小姐姐问我咋没穿外套，会冷的吧。我说所以喝杯奶茶暖暖。拿着奶茶回到坐着的地方，已经两点多了，售货员小姐姐问我怎么还不回家，我跟她解释了一下。于是就又开始玩手机，她问我是不是没吃饭，要不要给我泡一碗泡面吃。我一开始以为是要诱导我消费，确实也不饿就拒绝了。过了一会她从柜台走过来，翻了一下休息区旁边的货柜，拿了个面包给我说吃个面包吧，我当然是拒绝的，但是她坚持要给我，我想着那就要了吧，当我准备去扫码付款的时候她说这是请我吃的，不要钱。瞬间没那么冷了，真的。我吃着面包，喝着奶茶，竟然还有了吃撑的感觉。大概三点左右的时候售货员小姐姐又过来把她的外套披给我说让我暖和暖和，我也说了好多谢谢。最后小说游戏电影电视剧都不想再碰的时候，我趴在桌上小憩了一会，四点五十左右我对售货员小姐姐说了声谢谢之后就离开了这家小店。</p><p>出来之后我本来的打算就是去高中看看，可是还是不让进，我能有什么办法(PU。在外面看了看，就走了。</p><p>回来的公交车上，十分瞌睡，最后还是到家了。从九点睡到一点，下午从三点又睡到六点，</p><p>本来计划着是4号回学校，可是又因为训练，唉，明天就得回去。忙啊。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prefix Sum Primes</title>
      <link href="/2019/04/22/Prefix%20Sum%20Primes/"/>
      <url>/2019/04/22/Prefix%20Sum%20Primes/</url>
      
        <content type="html"><![CDATA[<center>CodeForces-1149-A Prefix Sum Primes</center><p>Topic link:<a href="https://codeforces.com/problemset/problem/1149/A" target="_blank" rel="noopener">Prefix Sum Primes</a><br>Description:<br>We&#39;re giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2.</p><p>However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.</p><p>Can you win the prize? Hurry up, the bags are waiting!</p><p>Input<br>The first line of the input contains a single integer n (1≤n≤200000) — the number of number tiles in the bag. The following line contains n space-separated integers a1,a2,…,an (ai∈{1,2}) — the values written on the tiles.</p><p>Output<br>Output a permutation b1,b2,…,bn of the input sequence (a1,a2,…,an) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.</p><p>Examples<br>input<br>5<br>1 2 1 2 1<br>output<br>1 1 1 2 2<br>input<br>9<br>1 1 2 1 1 1 2 1 1<br>output<br>1 1 1 2 1 1 1 2 1<br>Note<br>The first solution produces the prefix sums 1,2,3,5,7 (four primes constructed), while the prefix sums in the second solution are 1,2,3,5,6,7,8,10,11 (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.</p><p>Intentional analysis:<br>To solve this problem,you&#39;d better know a rule——The difference between all adjacent prime numbers except 2, 3 is even.So what we should is just get the number of occurrences of 1 and 2,judge and print.There are three situations:</p><ul><li>1.The number of occurrences of 1 is 0.</li><li>2.The number of occurrences of 2 is 0.</li><li>3.Both 1 and 2 have appeared.</li></ul><p>Where does it reflect greed?<br>If the first two numbers are done,and you still have 2 ,just print it,and then print 1.</p><details>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>为了解决这个问题，有个规则你是必须要知道的——除了2，3之外的所有相邻的素数的差都是偶数。所以我们只需要知道给的数据中1，2出现几次就行了。这里总共有三种情况：一： 1没有出现过。二： 2没有出现过。三： 1，2都出现过。能体现出贪心的是哪里呢？就是当你处理完前两个质数2，3之后，如果你还有2，就把2先输出完，然后再输出剩下的1即可。</details><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int x,a=0,b=0,n;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;x;        if(x==1) a++;        else b++;    }    if(a==0)    {        while(b--)            cout&lt;&lt;&quot;2 &quot;;        cout&lt;&lt;endl;        return 0;    }    if(b==0)    {        while(a--)            cout&lt;&lt;&quot;1 &quot;;        cout&lt;&lt;endl;        return 0;    }    else    {        cout&lt;&lt;&quot;2 1 &quot;;        a-=1;        b-=1;        while(b--)            cout&lt;&lt;&quot;2 &quot;;        while(a--)            cout&lt;&lt;&quot;1 &quot;;        cout&lt;&lt;endl;        return 0;    }}</code></pre><p>There are many useful rules that I don’t know,still have to do more questions.</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> CodeForces </tag>
            
            <tag> Greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neko Performs Cat Furrier Transform</title>
      <link href="/2019/04/21/Neko%20Performs%20Cat%20Furrier%20Transform/"/>
      <url>/2019/04/21/Neko%20Performs%20Cat%20Furrier%20Transform/</url>
      
        <content type="html"><![CDATA[<center>CodeForces-1152-B Neko Performs Cat Furrier Transform</center><p>Topic link:<a href="https://codeforces.com/problemset/problem/1152/B" target="_blank" rel="noopener">Neko Performs Cat Furrier Transform</a><br>Description:<br>Cat Furrier Transform is a popular algorithm among cat programmers to create longcats. As one of the greatest cat programmers ever exist, Neko wants to utilize this algorithm to create the perfect longcat.</p><p>Assume that we have a cat with a number x. A perfect longcat is a cat with a number equal 2m−1 for some non-negative integer m. For example, the numbers 0, 1, 3, 7, 15 and so on are suitable for the perfect longcats.</p><p>In the Cat Furrier Transform, the following operations can be performed on x:</p><p>(Operation A): you select any non-negative integer n and replace x with x⊕(2n−1), with ⊕ being a bitwise XOR operator.<br>(Operation B): replace x with x+1.<br>The first applied operation must be of type A, the second of type B, the third of type A again, and so on. Formally, if we number operations from one in the order they are executed, then odd-numbered operations must be of type A and the even-numbered operations must be of type B.</p><p>Neko wants to produce perfect longcats at industrial scale, thus for each cat Neko only wants to perform at most 40 operations. Can you help Neko writing a transformation plan?</p><p>Note that it is not required to minimize the number of operations. You just need to use no more than 40 operations.</p><p>Input<br>The only line contains a single integer x (1≤x≤106).</p><p>Output<br>The first line should contain a single integer t (0≤t≤40) — the number of operations to apply.</p><p>Then for each odd-numbered operation print the corresponding number ni in it. That is, print ⌈t2⌉ integers ni (0≤ni≤30), denoting the replacement x with x⊕(2ni−1) in the corresponding step.</p><p>If there are multiple possible answers, you can print any of them. It is possible to show, that there is at least one answer in the constraints of this problem.</p><p>Examples<br>input<br>39<br>output<br>4<br>5 3<br>input<br>1<br>output<br>0<br>input<br>7<br>output<br>0<br>Note<br>In the first test, one of the transforms might be as follows: 39→56→57→62→63. Or more precisely:</p><p>Pick n=5. x is transformed into 39⊕31, or 56.<br>Increase x by 1, changing its value to 57.<br>Pick n=3. x is transformed into 57⊕7, or 62.<br>Increase x by 1, changing its value to 63=26−1.<br>In the second and third test, the number already satisfies the goal requirement.</p><p>There are some differences between the description on my blog and the real,so I put a real piture here.<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101908.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804101908.webp" class="img-shadow img-margin"></center></a></p><p>Intentional analysis:<br>The most important solution to this problem is to simulate.To solve this problem,you better use binary processing.If a number is equal to <code>pow(2,n)-1</code>,then its binary is 1 for each bit.So we only need to process the binary bits of the number to be processed.First, find the highest bit with a binary bit of 0.Then,Each of the next inversions.If the conditions are not met, add 1.This loops until the value that satisfies the condition appears.</p><p><details>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>这道题最重要的思想就是模拟，因为一个数如果是2的n次方减1，那么它的二进制位每一位都是1。因此这道题就可以对输入的数以二进制位的形式进行操作。首先找到最高位的0，然后对这一位以下的所有的二进制位与1进行异或，异或完判断是否满足条件，如果不满足就加一在进行判断，还不行的话就开始下一次循环，直到找到满足条件的数跳出循环即可。思想应该是很容易懂的，难得地方就是实现。一开始我想用bitset来做，但是没成功，还是老老实实的用数组做吧。</details><br>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    vector&lt;int&gt; v;    int B[30],n,ans=0,t,now=0;    cin&gt;&gt;n;    t=n;    while(t)    {        B[now++]=t%2;        t/=2;    }    int i=now-1;    for(;i&gt;=0;i--)    {        if(B[i]==0)        {            v.push_back(i+1);            bool flag=0;            for(int j=i;j&gt;=0;j--)            {                B[j]^=1;                if(B[j]==0&amp;&amp;j!=0)                    flag=1;            }            ans++;            if(flag==0)            {                if(B[0]==0)                {                    B[0]++;                    ans++;                }                i=-1;                break;            }            B[0]++;            ans++;            for(int k=0;k&lt;i;k++)            {                if(B[k]&gt;1)                {                    B[k]=0;                    B[k+1]++;                }                else                    break;            }        }        if(i==-1)        break;    }    cout&lt;&lt;ans&lt;&lt;endl;    for(int j=0;j&lt;v.size();j++)    {        cout&lt;&lt;v[j]&lt;&lt;&quot; &quot;;        if(j==v.size()-1)            puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> CodeForces </tag>
            
            <tag> Simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Long Number</title>
      <link href="/2019/04/20/Number/"/>
      <url>/2019/04/20/Number/</url>
      
        <content type="html"><![CDATA[<center>CodeForces-1157-B Long Number</center><p>Topic link:<a href="https://codeforces.com/problemset/problem/1157/B" target="_blank" rel="noopener">Long Number</a><br>Description:<br>You are given a long decimal number a consisting of n digits from 1 to 9. You also have a function f that maps every digit from 1 to 9 to some (possibly the same) digit from 1 to 9.</p><p>You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in a, and replace each digit x from this segment with f(x). For example, if a=1337, f(1)=1, f(3)=5, f(7)=3, and you choose the segment consisting of three rightmost digits, you get 1553 as the result.</p><p>What is the maximum possible number you can obtain applying this operation no more than once?</p><p>Input<br>The first line contains one integer n (1≤n≤2e5) — the number of digits in a.</p><p>The second line contains a string of n characters, denoting the number a. Each character is a decimal digit from 1 to 9.</p><p>The third line contains exactly 9 integers f(1), f(2), ..., f(9) (1≤f(i)≤9).</p><p>Output<br>Print the maximum number you can get after applying the operation described in the statement no more than once.</p><p>Examples<br>input<br>4<br>1337<br>1 2 5 4 6 6 3 1 9<br>output<br>1557<br>input<br>5<br>11111<br>9 8 7 6 5 4 3 2 1<br>output<br>99999<br>input<br>2<br>33<br>1 1 1 1 1 1 1 1 1<br>output<br>33<br>Intentional analysis:<br>Through reading this questions,we can see that this question is a greedy type of problem.Each number will correspond to another number,and if the corresponding number is greater than this number,we need to use it instead of this number,and as long as such a number appears continuously,we can always change it,but we can only change it once,and To find the maximum number after the change,you only need to find a series of consecutive changeable changes from the front and then output.</p><details>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>这道题就是每一个数都对应着一个数，题目要求更换之后取得最大值，可是只能更换一次，每次更换可以更换任一个数但是必须是连续的。这时就体现出贪心的思想了，要想这个数变得更大，在这个数的越高的位置数就得越大，所以只需要从前往后看，只要发现对应的数比本身大就开始更换直到对应的数小于本身，就停止更换。</details><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n;string s;char x;    cin&gt;&gt;n&gt;&gt;s;    map&lt;int,char&gt; ma;    for(int i=1;i&lt;=9;i++)    {        cin&gt;&gt;x;        ma[i]=x;    }    int flag;    char mid;    for(int i=0;i&lt;s.size();i++)    {        if(s[i]&lt;ma[s[i]-&#39;0&#39;])        {            flag=i;            break;        }    }    for(int i=0;i&lt;flag;i++)    {        cout&lt;&lt;s[i];    }    bool flag2=1;    for(int i=flag;i&lt;s.size();i++)    {        if(s[i]&gt;ma[s[i]-&#39;0&#39;])            flag2=0;        if(flag2)            cout&lt;&lt;ma[s[i]-&#39;0&#39;];        else            cout&lt;&lt;s[i];    }    cout&lt;&lt;endl;    return 0;}</code></pre><p>I didn&#39;t understand the meaning of this question at first, which led to WA several times and wasted my time.</p><font color="red">Now the result of hack has not come out yet, if my code was hacked.I will find the bug and correct it as soon as possible!(2019.4.27 1:03)</font><p><br></p><font color="green">Accepted(2019.4.27 22:52)</font>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> STL </tag>
            
            <tag> CodeForces </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-bitset</title>
      <link href="/2019/04/19/STL-bitset/"/>
      <url>/2019/04/19/STL-bitset/</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction-to-bitset-personal"><a href="#Introduction-to-bitset-personal" class="headerlink" title="Introduction to bitset-personal"></a>Introduction to bitset-personal</h3><p>I can&#39;t find a accurate explanation online.So there is my understanding of it.<br>Bitset is a STL which is easy to treat a number as a binary.</p><h3 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h3><p>It is included by <code>include&lt;bitset&gt;</code><br>If you want to define a bitset,the code is as follows</p><pre><code>bitset&lt;num&gt; n;//num must be defined as an integer literal constant or an integer type const object initialized with a constant value.</code></pre><p>If so initialized, each bit is 0.<br>Of course you can also define it like this</p><pre><code>int a;bitset&lt;num&gt; n(a);</code></pre><p>now,the bitset n is the binary form of a.And you even can use this like a array.<br>Such as</p><pre><code>#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main(){    int a;    cin&gt;&gt;a;    bitset&lt;4&gt; b(a);    cout&lt;&lt;b&lt;&lt;endl;    cout&lt;&lt;b[0]&lt;&lt;endl&lt;&lt;b[1]&lt;&lt;endl&lt;&lt;b[2]&lt;&lt;endl&lt;&lt;b[3]&lt;&lt;endl;    return 0;}Input:13 -5Ouput:1101101110111101</code></pre><p><font color="red">As can be seen from these examples, when the bit position in the bitset is operated, it is reversed.</font><br>Such as:</p><pre><code>int n = 16;bitset&lt;64&gt; b(n);b[0]=0b[1]=0b[2]=0b[3]=0b[4]=1</code></pre><p>From the above example we can see that the negative number will directly become the complement form under the action of bitset.This has advantages and disadvantages.This has advantages and disadvantages, because some places just let you represent the binary form, no need to complement.If you meet a situtation like this,just take a judge,all numbers are processed as positive numbers, if they are negative, then add a negative sign.I&#39;d like to paste a example here.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>Source: <a href="https://hpuoj.com/problem/48/" target="_blank" rel="noopener">简单的二进制</a><br>Description：<br>计算机只能识别0和1,使用的是二进制，而在日常生活中人们使用的是十进制，”正如亚里士多德早就指出的那样，今天十进制的广泛采用，只不过是我们绝大多数人生来具有10个手指头这个解剖学事实的结果。</p><p>在计算机领域中，补码是一个重要的概念，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</p><p>学习了计算机导论后，相信大家都明白了原码、反码和补码的区别，并能快速地将一个十进制整数的补码写出。今天我们将问题进行简化：给出一个十进制的整数N，请写出N在64位二进制补码表示下，一共有多少个1。</p><p>Input<br>多组输入，每一行有一个整数N（保证N在int64范围内）</p><p>Output<br>输出N在二进制补码下1的个数，每组输出占一行</p><p>Examples<br>input<br>10<br>15<br>output<br>2<br>4<br>Note<br>正整数的补码是其二进制表示，与原码相同</p><p>求负整数的补码，将其原码除符号位外的所有位取反后加一</p><p>Problem solving：<br>We can see this problem need the complement when the number is negative.So the bitset is so comfortable for this.</p><p>Code:</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    long long n;    while(scanf(&quot;%lld&quot;,&amp;n)!=EOF)    {        bitset&lt;64&gt; b(n);        cout&lt;&lt;b.count()&lt;&lt;endl;    }    return 0;}</code></pre><p>If you write this, the code will be very simple.The specific function functions will be discussed below.</p><h3 id="Many-functions"><a href="#Many-functions" class="headerlink" title="Many functions"></a>Many functions</h3><p>Almost all STL have lots of functions,bitset is no exception.<br>I don&#39;t have the ability, and I don&#39;t have the energy to list them all, so I will list what I like and what I find useful.</p><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>Define a bitset first:<br>bitset<64> b;</64></p><div class="table-container"><table><thead><tr><th>function</th><th>Features</th></tr></thead><tbody><tr><td><a href="#jump">b.any()</a></td><td>Is there a binary bit with a value of 1 in b?</td></tr><tr><td><a href="#jump">b.none()</a></td><td>Is there no binary bit with a value of 1 in b?</td></tr><tr><td><a href="#jump">b.count()</a></td><td>The number of bits in b with a value of 1</td></tr><tr><td><a href="#jump1">b[pos]</a></td><td>Access the binary bit at pos in b</td></tr><tr><td><a href="#jump2">b.test(pos)</a></td><td>Whether the binary bit in pos is 1 in b？</td></tr><tr><td><a href="#jump3">b.set()</a></td><td>Set all binary bits in b to 1</td></tr><tr><td><a href="#jump3">b.set(pos)</a></td><td>Put the binary position in b at pos as 1</td></tr><tr><td><a href="#jump4">b.reset()</a></td><td>Set all binary bits in b to 0</td></tr><tr><td><a href="#jump4">b.reset(pos)</a></td><td>Put the binary position in b at pos to 0</td></tr><tr><td><a href="#jump5">b.flip()</a></td><td>All binary bits in b are inverted bit by bit</td></tr><tr><td><a href="#jump5">b.flip(pos)</a></td><td>Invert the binary bit at b in pos</td></tr><tr><td><a href="#jump6">b.to_string()</a></td><td>Convert the contents of the bitset to string</td></tr><tr><td><a href="#jump7">b.to_ulong()</a></td><td>Convert the contents of the bitset to unsigned long</td></tr></tbody></table></div><p>Next I will help you understand the usage of these functions with some examples.</p><h4 id="b-any-and-b-none-and-b-count"><a href="#b-any-and-b-none-and-b-count" class="headerlink" title="b.any() and b.none() and b.count()"></a><span id="jump">b.any() and b.none() and b.count()</span></h4><p>b.any(): Is there a binary bit with a value of 1 in b?</p><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n=5,m=0;// n = 0101, m = 0    bitset&lt;8&gt; b1(n);    bitset&lt;8&gt; b2(m);    cout&lt;&lt;b1.none()&lt;&lt;&quot; &quot;&lt;&lt;b2.none();}Operation result:1 0</code></pre><p>So you can see that the return value of b.any() is the bool type.</p><p>b.none()：Is there no binary bit with a value of 1 in b?</p><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n=5,m=0;// n = 0101, m = 0    bitset&lt;8&gt; b1(n);    bitset&lt;8&gt; b2(m);    cout&lt;&lt;endl&lt;&lt;b1.none()&lt;&lt;&quot; &quot;&lt;&lt;b2.none();}Operation result:0 1</code></pre><p>So you can see that the return value of b.none() also is the bool type.</p><p>b.count(): The number of bits in b with a value of 1</p><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n=15,m=16;// n = 1111, m = 10000    bitset&lt;8&gt; b1(n);    bitset&lt;8&gt; b2(m);    cout&lt;&lt;b1.count()&lt;&lt;&quot; &quot;&lt;&lt;b2.count();}Operation result:4 1</code></pre><p>So the function of b.count() is to return the number of 1 in the binary.Just like the example above</p><h4 id="b-pos"><a href="#b-pos" class="headerlink" title="b[pos]"></a><span id="jump1">b[pos]</span></h4><p>b[pos]: Access the binary bit at pos in b<br>I started the function&#39;s introduction at the beginning of this blog, you can look up.</p><h4 id="b-test-pos"><a href="#b-test-pos" class="headerlink" title="b.test(pos)"></a><span id="jump2">b.test(pos)</span></h4><p>b.test(pos): Whether the binary bit in pos is 1 in b？</p><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n=15,m=16;// n = 1111, m = 10000    bitset&lt;8&gt; b1(n);    bitset&lt;8&gt; b2(m);    cout&lt;&lt;b1.test(1)&lt;&lt;&quot; &quot;&lt;&lt;b2.test(4)&lt;&lt;&quot; &quot;&lt;&lt;b2.test(1);}Operation result:1 1 0</code></pre><p>So you can see that the return value of b.test(pos)  is the bool type,too.</p><h4 id="b-set-and-b-set-pos"><a href="#b-set-and-b-set-pos" class="headerlink" title="b.set() and b.set(pos)"></a><span id="jump3">b.set() and b.set(pos)<span></span></span></h4><p>b.set(): Set all binary bits in b to 1</p><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n = 16;    bitset&lt;8&gt; b(n);    cout&lt;&lt;b&lt;&lt;endl;    b.set();    cout&lt;&lt;b;}Operation result:0001000011111111</code></pre><p>b.set(pos): Put the binary position in b at pos as 1</p><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n = 16;    bitset&lt;8&gt; b(n);    cout&lt;&lt;b&lt;&lt;endl;    b.set(0);    cout&lt;&lt;b;}Operation result:0001000000010001</code></pre><h4 id="b-reset-and-b-reset-pos"><a href="#b-reset-and-b-reset-pos" class="headerlink" title="b.reset() and b.reset(pos)"></a><span id="jump4">b.reset() and b.reset(pos)</span></h4><p>b.reset(): Set all binary bits in b to 0<br>b.reset(pos): Put the binary position in b at pos to 0<br>These two functions are very similar to the two above, so I won’t go into details.</p><h4 id="b-flip-and-b-flip-pos"><a href="#b-flip-and-b-flip-pos" class="headerlink" title="b.flip() and b.flip(pos)"></a><span id="jump5">b.flip() and b.flip(pos)</span></h4><p>b.flip(): All binary bits in b are inverted bit by bit</p><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n = 16;    bitset&lt;8&gt; b(n);    cout&lt;&lt;b&lt;&lt;endl;    b.flip();    cout&lt;&lt;b;}Operation result:0001000011101111</code></pre><p>b.flip(pos): Invert the binary bit at b in pos<br>Basically the same as above, no longer repeat</p><h4 id="b-to-string"><a href="#b-to-string" class="headerlink" title="b.to_string()"></a><span id="jump6">b.to_string()</span></h4><p>b.to_string(): Convert the contents of the bitset to string</p><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n = 16;    bitset&lt;8&gt; b(n);    string s;    s=b.to_string();    cout&lt;&lt;s&lt;&lt;endl;}Operation result:00010000</code></pre><h4 id="b-to-ulong"><a href="#b-to-ulong" class="headerlink" title="b.to_ulong()"></a><span id="jump7">b.to_ulong()</span></h4><pre><code>#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main(){    int n = 16;    bitset&lt;5&gt; b(n);    b.flip();    long a;    cout&lt;&lt;b&lt;&lt;endl;    a=b.to_ulong();    cout&lt;&lt;a&lt;&lt;endl;}Operation result:0111115</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>White-book-example</title>
      <link href="/2019/04/16/White-book-example/"/>
      <url>/2019/04/16/White-book-example/</url>
      
        <content type="html"><![CDATA[<center>部分和问题</center><p>给定一组数，判断是否可以从中取出若干数，是他们的和恰好为一个数。<br>Example:<br>input<br>4 13<br>2 3 4 7<br>ouput<br>Yes</p><p>每个数都会有两个状态，加上或者不加上，这组样例中有四个数，每个数两个状态，也就是说最后的加起来的结果会有2的4次方(16)种。</p><p>Codes</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,a[10000];bool dfs(int i,int sum){    if(i==n)    {//      puts(&quot;mmp&quot;);        return sum==k;    }       if(dfs(i+1,sum))    {//      puts(&quot;a&quot;);          return 1;    }    if(dfs(i+1,sum+a[i]))    { //     puts(&quot;b&quot;);        return 1;       }   }int main(){    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)    {        cin&gt;&gt;a[i];    }    if(dfs(0,0)) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);    return 0;}</code></pre><p>只看代码会很难理解，一重一重的递归，但这还只是最简单的一种。为了更好的让自己理解，我将这个样例的所有情况都列了出来。</p><pre><code>DFS(0,0)    DFS(1,0)        DFS(2,0)            DFS(3,0)                DFS(4,0) return 0                      DFS(4,7) return 0            DFS(3,4)                DFS(4,4) return 0                DFS(4,11) return 0        DFS(2,3)            DFS(3,3)                DFS(4,3) return 0                DFS(4,10) return 0            DFS(3,7)                DFS(4,7) return 0                DFS(4,14) return 0    DFS(1,2)        DFS(2,2)            DFS(3,2)                DFS(4,2) return 0                DFS(4,9) return 0            DFS(3,6)                DFS(4,6) return 0                DFS(4,13) return 0        DFS(2,5)            DFS(3,5)                DFS(4,5) return 0                DFS(4,12) return 0            DFS(3,9)                DFS(4,9) return 0                DFS(4,16) return 0</code></pre><p>我又将这16种情况，用图的方式表示了出来</p><pre><code>                                    0                                2       0                            5   2       3   0                    9   5   6   2       7   3   4   0    16  9   12  5   13  6   9   2       14  7   10  3   11  4   7   0</code></pre><a href="https://i.loli.net/2019/04/25/5cc120987c2f5.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://i.loli.net/2019/04/25/5cc120987c2f5.webp" class="img-shadow img-margin"></center></a><p>这时我发现程序跟画出来的是一模一样的。</p><p>可是还是不很理解，于是我运行起来程序，并且在每次递归中加入了可以看到的元素，输出a，b或者mmp啊什么的。一起来看看效果<br>input:<br>4 13<br>2 3 4 7<br><a href="https://i.loli.net/2019/04/25/5cc12159489e2.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://i.loli.net/2019/04/25/5cc12159489e2.webp" class="img-shadow img-margin"></center></a><br>mmp个数数出来是12个，a,b出现的顺序是b，b，a，b</p><p>input:<br>4 0<br>2 3 4 7<br><a href="https://i.loli.net/2019/04/25/5cc12192e1a1c.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://i.loli.net/2019/04/25/5cc12192e1a1c.webp" class="img-shadow img-margin"></center></a><br>mmp个数数出来是1个，a,b出现的顺序是a，a，a，a</p><p>mmp代表的个数就是出现sum==k的时候前面进行的递归的次数，a代表的是第i位的数状态是不加，b代表的是第i位的数状态是加</p><p>也就这样了，DFS慢慢来，这样跑程序我觉得会加深理解啊哈🎈。</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复读机</title>
      <link href="/2019/04/16/nowcoder-699-B/"/>
      <url>/2019/04/16/nowcoder-699-B/</url>
      
        <content type="html"><![CDATA[<center>南华大学第十五届ACM程序设计竞赛(重现赛） B 复读机</center><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/699/B" target="_blank" rel="noopener">复读机</a><br>题目描述：</p><p>在某华大学里有一个无聊的群组，群内的所有成员都是复读机，他们疯狂复读着别人的消息。然而复读机们在群内也是有阵营的，一个阵营的复读机会根据心情选择是否复读同一个阵营的成员的消息，但绝对不会去复读其他阵营的消息。</p><p>群内有n个人（标号1-n号）。现在群内聊天记录中一共有m条消息。请根据这些消息，判断出如果群内第i号成员（1&lt;=i&lt;=n）发一条十分有趣的消息，在同一阵营的成员都会去复读这条消息情况下，那么这条消息会被复读几次？</p><p>如果无法判断i号成员和j号成员是否为同一阵营，则视为不同阵营。</p><p>输入描述:<br>输入包括m+1行。第一行包括两个整数n,m；其后的m行为当前的聊天记录，每行包括一个数字i和一个字符串s（表示i发了一条消息）。（保证1&lt;=i&lt;=n，m&lt;=100000，消息的字符串总长不超过100000）<br>输出描述:<br>输出一行，包括n个数字。第i个数字表示第i号成员的有趣消息会被复读几次（1&lt;=i&lt;=n）。数字与数字之间用一个空格分隔。<br>示例1<br>输入<br>复制<br>3 5<br>1 a<br>2 a<br>1 b<br>2 c<br>3 c<br>输出<br>复制<br>2 2 2<br>说明<br>对于样例1： 由聊天记录的前两行可以得出2号和1号为同一阵营，由最后两行可得3号和2号为同一阵营，所以三者为同一阵营，他们三个发送的消息会被复读2次，故输出为2 2 2；<br>示例2<br>输入<br>复制<br>3 3<br>1 a<br>2 b<br>3 c<br>输出<br>复制<br>0 0 0<br>说明<br>对于样例2：1，2，3号无法判断是否为同一阵营，视为不同阵营。<br>备注:<br>对于复读的概念：</p><p>若聊天记录为</p><p>1 a</p><p>2 a</p><p>3 a</p><p>属于2，3号复读了1号的消息。</p><p>若聊天记录为</p><p>1 a</p><p>2 b</p><p>3 a</p><p>不构成任何复读，1的‘a‘和3的‘a’均属于自己原创消息。</p><p>题意分析：<br>具体并查集的思想我也解释不清，可以参考这篇博客：<br><a href="https://boctorio.com/2019/03/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/" target="_blank" rel="noopener">https://boctorio.com/2019/03/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</a><br>这道题就是当你检测到相邻的两次输入的字符串是相等的就需要把这两个字符串的所对应的前面的数字看成是一组的。最后输出的时候，就输出和它同组的数目减一就行了（因为要除去它自己）。<br>解题思路还是很简单的，实现起来的话用并查集就行了。</p><p>代码实现</p><pre><code>#include&lt;iostream&gt;using namespace std;const int maxn=100010;struct name{    int num;    string sym;}a[maxn];int pre[maxn];int sum[maxn];void init(int n){    for(int i=1;i&lt;=n;i++)        pre[i]=i;}int find(int x){    return pre[x]!=x?pre[x]=find(pre[x]):x;}void Union(int x,int y){    x=find(x);    y=find(y);    if(x&lt;y)        pre[y]=x;    else        pre[x]=y;}int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    init(n);    cin&gt;&gt;a[0].num&gt;&gt;a[0].sym;    for(int i=1;i&lt;m;i++)    {        cin&gt;&gt;a[i].num&gt;&gt;a[i].sym;        if(a[i].sym==a[i-1].sym)            Union(a[i].num,a[i-1].num);    }    for(int i=1;i&lt;=n;i++)    {        find(i);        sum[pre[i]]++;    }    for(int i=1;i&lt;=n;i++)    {        if(i!=1)            cout&lt;&lt;&quot; &quot;;        cout&lt;&lt;sum[pre[i]]-1;    }    cout&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> nowcoder </tag>
            
            <tag> union-find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The experience of building blog</title>
      <link href="/2019/04/15/A-big-change/"/>
      <url>/2019/04/15/A-big-change/</url>
      
        <content type="html"><![CDATA[<p>To study English,and make my blog become large and luxurious,i have changed the main language of my blog from Chinese to English.Hope my English and programming&#39;s ablity can upgrade together.</p><h3 id="some-changes"><a href="#some-changes" class="headerlink" title="some changes"></a>some changes</h3><p>I will correct the tags and categories tomorrow,though it will be too troublesome.</p><p>I have already changed tags and categories.</p><p>2019.4.22 6:34</p><p>What next?<br>“About” page!    </p><p>Carry out! in 2019.4.22. 7:29</p><p>The comment system Valine is Chinese now,i can&#39;t solve this,but i will finish this in the future.</p><p>Carry out in 2019.4.22 10:20</p><h3 id="How-to-put-a-post-to-the-top"><a href="#How-to-put-a-post-to-the-top" class="headerlink" title="How to put a post to the top?"></a>How to put a post to the top?</h3><p>At first,i installed the plugin to achieve this,and something wrong happened.The top flag is there, but there is no function to achieve the top.So isearched this online.Finally,i still don&#39;t known why,but i solve this problem through other method.</p><h4 id="Implemented-by-modifying-the-file"><a href="#Implemented-by-modifying-the-file" class="headerlink" title="Implemented by modifying the file"></a>Implemented by modifying the file</h4><p>file path:</p><pre><code>Ur blog name/node_modules/hexo-generator-index/lib/generator.js</code></pre><p>Add the following codes in the file</p><pre><code>posts.data = posts.data.sort(function(a, b) {    if(a.top &amp;&amp; b.top) { // Both articles have definitions on top        if(a.top == b.top) return b.date - a.date; // If the top value is the same, it will be sorted according to the article date.        else return b.top - a.top; // Otherwise,it willed be sorted according the value of top.    }    else if(a.top &amp;&amp; !b.top) { // The following is only one article top definition, then there will be top in front（这里用异或操作居然不行233）        return -1;    }    else if(!a.top &amp;&amp; b.top) {        return 1;    }    else return b.date - a.date; // Did not define the descending order according to the article date});</code></pre><p>At first,I didn&#39;t know much about js and didn&#39;t know where to insert it, so I failed several times.So if you are experiencing the same situation as me,you can directly copy these following codes and paste in your file.<br>Note: just cover it all.</p><pre><code>&#39;use strict&#39;;var pagination = require(&#39;hexo-pagination&#39;);module.exports = function(locals){  var config = this.config;  var posts = locals.posts;    posts.data = posts.data.sort(function(a, b) {        if(a.top &amp;&amp; b.top) {            if(a.top == b.top) return b.date - a.date;            else return b.top - a.top;        }        else if(a.top &amp;&amp; !b.top) {            return -1;        }        else if(!a.top &amp;&amp; b.top) {            return 1;        }        else return b.date - a.date;    });  var paginationDir = config.pagination_dir || &#39;page&#39;;  return pagination(&#39;&#39;, posts, {    perPage: config.index_generator.per_page,    layout: [&#39;index&#39;, &#39;archive&#39;],    format: paginationDir + &#39;/%d/&#39;,    data: {      __index: true    }  });};</code></pre><h4 id="How-to-display-the-flag-of-the-top"><a href="#How-to-display-the-flag-of-the-top" class="headerlink" title="How to display the flag of the top"></a>How to display the flag of the top</h4><p>This is easy.You still need to modify some files to achieve this features.<br>file path:</p><pre><code>Ur blog name/themes/next/layout/_macro/post.swig</code></pre><p>First,find the place of<code>&lt;div class=&quot;post-meta&quot;&gt;</code>.<br>Second,insert these following codes</p><pre><code>{% if post.top %}    <i class="fa fa-thumb-tack"></i>//You can choose and replace the icon you want in https://www.fontawesome.com.cn/.    <font color="green">Topping</font>//You can change the color and specific content of the top logo in this.    <span class="post-meta-divider">|</span>{% endif %}</code></pre><p>Of course,if you are not sure where to insert it,just compare with the code below.</p><pre><code>        &lt;div class=&quot;post-meta&quot;&gt;          &lt;span class=&quot;post-time&quot;&gt;            {% if post.top %}              <i class="fa fa-thumb-tack"></i>              <font color="7D26CD">Topping</font>              <span class="post-meta-divider">|</span>            {% endif %}            {% set date_diff = date(post.date) != date(post.updated) %}            {% set time_diff = time(post.date) != time(post.updated) %}            {% set datetime_diff = date_diff or time_diff %}</code></pre><p>Rendering<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095009.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095009.webp" class="img-shadow img-margin"></center></a><br>Reference article: <a href="https://blog.csdn.net/weixin_42556146/article/details/80836875" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42556146/article/details/80836875</a></p><p align="right">The introduction about the top is here.</p><h3 id="A-really-big-change"><a href="#A-really-big-change" class="headerlink" title="A really big change"></a>A really big change</h3><p>Great change, like changing the blog&#39;s blood<br>Reference article: <a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a></p><h3 id="Add-article-image-summary"><a href="#Add-article-image-summary" class="headerlink" title="Add article image summary"></a>Add article image summary</h3><blockquote><p>The reason of why use this</p><blockquote><p>First of all, the abstract of the article refers to the part of the content that each article displays on the page, which is the content of the previous article. Since it will be displayed on the page, adding an image to the article summary for each article will make the page look beautiful.</p></blockquote></blockquote><p>Rendering<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095032.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095032.webp" class="img-shadow img-margin"></center></a><br>First,Edit this file</p><pre><code>Urblog name/themes/next/_config.yml</code></pre><p>Change into</p><pre><code>excerpt_description: falseauto_excerpt:  enable: false</code></pre><p>Second,add these fowlling codes into this file</p><pre><code>Urblog Urblog name/themes/next/layout/_macro/post.swig</code></pre><p>codes</p><pre><code>        {% if post.image %}        <div class="out-img-topic">          <img src="{{" post.image }} class="img-topic">        </div>        {% endif %}</code></pre><p>If you change it correctly, this file will look like this.</p><pre><code>      {% if is_index %}        {% if post.description and theme.excerpt_description %}          {{ post.description }}          <!--noindex-->          <div class="post-button text-center">            <a class="btn" href="{{ url_for(post.path) }}">              {{ __('post.read_more') }} &raquo;            </a>          </div>          <!--/noindex-->        {% elif post.excerpt  %}          {{ post.excerpt }}+          +        {% if post.image %}+        <div class="out-img-topic">+          <img src="{{" post.image }} class="img-topic">+        </div>+        {% endif %}+                    &lt;!--noindex--&gt;          &lt;div class=&quot;post-button text-center&quot;&gt;            &lt;a class=&quot;btn&quot; href=&quot;{{ url_for(post.path) }}{% if theme.scroll_to_more %}#{{ __('post.more') }}{% endif %}&quot; rel=&quot;contents&quot;&gt;              {{ __('post.read_more') }} &amp;raquo;            &lt;/a&gt;          &lt;/div&gt;          &lt;!--/noindex--&gt;</code></pre><p>Third,add these following codes into this file</p><pre><code>Urblog name/themes/next/source/css/_custom/custom.styl</code></pre><p>codes</p><pre><code>//图片外部的容器方框.out-img-topic {  display: block;  max-height:300px;  margin-bottom: 24px;  overflow: hidden;}//图片img.img-topic {  display: block ;  margin-left: .7em;  margin-right: .7em;  padding: 0;  float: right;  clear: right;}</code></pre><p>Now,you have already finish this.<br>Note<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095053.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095053.webp" class="img-shadow img-margin"></center></a><br>add this <code>image: url/the picture&#39;s path</code>.</p><p align="right">The introduction about the image summary is here.</p><h3 id="A-Little-Summary"><a href="#A-Little-Summary" class="headerlink" title="A Little Summary"></a>A Little Summary</h3><p>　　Today is my birthday.And I successfully set my blog very beautiful.Everything is fine!</p><p align="right">2019.4.23</p><h3 id="Local-search"><a href="#Local-search" class="headerlink" title="Local search"></a>Local search</h3><p>Some unknown bug was happened on the local search,so I have to remove this.</p><p align="right">2019.4.24 22:35</p><p>Local search is fine now.</p><p align="right">2019.6.13 10:50</p><h3 id="Replaced-the-new-domain-name"><a href="#Replaced-the-new-domain-name" class="headerlink" title="Replaced the new domain name"></a>Replaced the new domain name</h3><p>Today, I changed the domain name for my blog. Although it cost a lot of money, it seems that it is really high.<br>But what&#39;s a little bad is that my visitor volume and pageviews are zero, and it&#39;s very uncomfortable.</p><p align="right">2019.4.25 23:55</p><h3 id="About-the-optimization-of-domestic-access-speed"><a href="#About-the-optimization-of-domestic-access-speed" class="headerlink" title="About the optimization of domestic access speed"></a>About the optimization of domestic access speed</h3><p><del>I put a copy of my blog on gitee again. Domestic visitors should see that this access speed should satisfy you.<br>New home&#39;s name.</del></p><p align="right">~~~2019.4.25 20:32~~~</p><h3 id="Add-Chinese-Intentional-analysis"><a href="#Add-Chinese-Intentional-analysis" class="headerlink" title="Add Chinese Intentional analysis"></a>Add Chinese Intentional analysis</h3><p>Because the visitors to my blog are still domestic, some of the meanings written in English may not be clear, so I added a Chinese meaning analysis to some blogs. The specific operation is as follows.<br>In fact, it is a syntax of markdown.</p><pre><code>&lt;details&gt;&lt;summary&gt;Description&lt;/summary&gt;//Hidden&lt;/details&gt;</code></pre><p>Rendering:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095111.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095111.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095125.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095125.webp" class="img-shadow img-margin"></center></a></p><h3 id="Summer-is-comming-come-here-and-enjoy-the-cool-snow"><a href="#Summer-is-comming-come-here-and-enjoy-the-cool-snow" class="headerlink" title="Summer is comming,come here and enjoy the cool snow."></a>Summer is comming,come here and enjoy the cool snow.</h3><p>Reference article: <a href="https://blog.csdn.net/stormdony/article/details/86001618" target="_blank" rel="noopener">https://blog.csdn.net/stormdony/article/details/86001618</a></p><p>Add a file name is <code>snow.js</code> into <code>\themes\next\source\js\src</code></p><p>Edit the contents of <code>snow.js</code> as</p><p>Choose one:</p><pre><code>/*样式一*/(function($){  $.fn.snow = function(options){  var $flake = $(&#39;&lt;div id=&quot;snowbox&quot; /&gt;&#39;).css({&#39;position&#39;: &#39;absolute&#39;,&#39;z-index&#39;:&#39;9999&#39;, &#39;top&#39;: &#39;-50px&#39;}).html(&#39;&amp;#10052;&#39;),  documentHeight  = $(document).height(),  documentWidth = $(document).width(),  defaults = {    minSize   : 10,    maxSize   : 20,    newOn   : 1000,    flakeColor  : &quot;#AFDAEF&quot; /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */  },  options = $.extend({}, defaults, options);  var interval= setInterval( function(){  var startPositionLeft = Math.random() * documentWidth - 100,  startOpacity = 0.5 + Math.random(),  sizeFlake = options.minSize + Math.random() * options.maxSize,  endPositionTop = documentHeight - 200,  endPositionLeft = startPositionLeft - 500 + Math.random() * 500,  durationFall = documentHeight * 10 + Math.random() * 5000;  $flake.clone().appendTo(&#39;body&#39;).css({    left: startPositionLeft,    opacity: startOpacity,    &#39;font-size&#39;: sizeFlake,    color: options.flakeColor  }).animate({    top: endPositionTop,    left: endPositionLeft,    opacity: 0.2  },durationFall,&#39;linear&#39;,function(){    $(this).remove()  });  }, options.newOn);    };})(jQuery);$(function(){    $.fn.snow({      minSize: 5, /* 定义雪花最小尺寸 */      maxSize: 50,/* 定义雪花最大尺寸 */      newOn: 300  /* 定义密集程度，数字越小越密集 */    });});</code></pre><p>Choose two:</p><pre><code>/*样式二*//* 控制下雪 */function snowFall(snow) {    /* 可配置属性 */    snow = snow || {};    this.maxFlake = snow.maxFlake || 200;   /* 最多片数 */    this.flakeSize = snow.flakeSize || 10;  /* 雪花形状 */    this.fallSpeed = snow.fallSpeed || 1;   /* 坠落速度 */}/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.msRequestAnimationFrame ||    window.oRequestAnimationFrame ||    function(callback) { setTimeout(callback, 1000 / 60); };cancelAnimationFrame = window.cancelAnimationFrame ||    window.mozCancelAnimationFrame ||    window.webkitCancelAnimationFrame ||    window.msCancelAnimationFrame ||  window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function(){    /* 创建画布 */    snowCanvas.apply(this);    /* 创建雪花形状 */    createFlakes.apply(this);    /* 画雪 */    drawSnow.apply(this)}/* 创建画布 */function snowCanvas() {    /* 添加Dom结点 */    var snowcanvas = document.createElement(&quot;canvas&quot;);    snowcanvas.id = &quot;snowfall&quot;;    snowcanvas.width = window.innerWidth;    snowcanvas.height = document.body.clientHeight;    snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;);    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas);    this.canvas = snowcanvas;    this.ctx = snowcanvas.getContext(&quot;2d&quot;);    /* 窗口大小改变的处理 */    window.onresize = function() {        snowcanvas.width = window.innerWidth;        /* snowcanvas.height = window.innerHeight */    }}/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) {    this.x = Math.floor(Math.random() * canvasWidth);   /* x坐标 */    this.y = Math.floor(Math.random() * canvasHeight);  /* y坐标 */    this.size = Math.random() * flakeSize + 2;          /* 形状 */    this.maxSize = flakeSize;                           /* 最大形状 */    this.speed = Math.random() * 1 + fallSpeed;         /* 坠落速度 */    this.fallSpeed = fallSpeed;                         /* 坠落速度 */    this.velY = this.speed;                             /* Y方向速度 */    this.velX = 0;                                      /* X方向速度 */    this.stepSize = Math.random() / 30;                 /* 步长 */    this.step = 0                                       /* 步数 */}flakeMove.prototype.update = function() {    var x = this.x,        y = this.y;    /* 左右摆动(余弦) */    this.velX *= 0.98;    if (this.velY &lt;= this.speed) {        this.velY = this.speed    }    this.velX += Math.cos(this.step += .05) * this.stepSize;    this.y += this.velY;    this.x += this.velX;    /* 飞出边界的处理 */    if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) {        this.reset(canvas.width, canvas.height)    }};/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) {    this.x = Math.floor(Math.random() * width);    this.y = 0;    this.size = Math.random() * this.maxSize + 2;    this.speed = Math.random() * 1 + this.fallSpeed;    this.velY = this.speed;    this.velX = 0;};// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) {    var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);    snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;);  /* 此处是雪花颜色，默认是白色 */    snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); /* 若要改为其他颜色，请自行查 */    snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;);    /* 找16进制的RGB 颜色代码。 */    ctx.save();    ctx.fillStyle = snowFlake;    ctx.beginPath();    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);    ctx.fill();    ctx.restore();};/* 创建雪花-定义形状 */function createFlakes() {    var maxFlake = this.maxFlake,        flakes = this.flakes = [],        canvas = this.canvas;    for (var i = 0; i &lt; maxFlake; i++) {        flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed))    }}/* 画雪 */function drawSnow() {    var maxFlake = this.maxFlake,        flakes = this.flakes;    ctx = this.ctx, canvas = this.canvas, that = this;    /* 清空雪花 */    ctx.clearRect(0, 0, canvas.width, canvas.height);    for (var e = 0; e &lt; maxFlake; e++) {        flakes[e].update();        flakes[e].render(ctx);    }    /*  一帧一帧的画 */    this.loop = requestAnimationFrame(function() {        drawSnow.apply(that);    });}/* 调用及控制方法 */var snow = new snowFall({maxFlake:60});snow.start();</code></pre><p>Then add these follwing contents in <code>\themes\next\layout\_layout.swig</code></p><pre><code>&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;/script&gt;</code></pre><p>To avoid the effects of mobile access, you can add the following instead of the one above.</p><pre><code>&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var windowWidth = $(window).width();  if (windowWidth &gt; 480) {    document.write(&#39;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;\/script&gt;&#39;);  }&lt;/script&gt;</code></pre><p>Rendering:</p><p>Choose one:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095148.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095148.webp" class="img-shadow img-margin"></center></a></p><p>Choose two:<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095204.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804095204.webp" class="img-shadow img-margin"></center></a></p><p>Snowflakes only appear on the computer side is not the effect I want.But I still do not want to affect the reading of the mobile terminal.So I try to add a else on the basic of the contents above.Just like:</p><pre><code>&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var windowWidth = $(window).width();  if (windowWidth &gt; 480) {    document.write(&#39;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;\/script&gt;&#39;);  }  else    document.write(&#39;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow_point.js&quot;&gt;&lt;\/script&gt;&#39;);&lt;/script&gt;</code></pre><p>And make the Choose two become the file <code>snow_point.js</code>,and then reduce the number of snowflakes.The effect achieved now is enough to satisfy me.</p><h3 id="CalendarCloud"><a href="#CalendarCloud" class="headerlink" title="CalendarCloud"></a>CalendarCloud</h3><p>I had add a calendarcloud into my blog successfully.But there is a bug:if some posts are in a same day,you can just come in one of them.<br>How can I solve this problem,absolutly I can&#39;t.<br>But you can click the month number so you can view a html which is full of post title which deploy in this month.</p><h3 id="The-Album-Page"><a href="#The-Album-Page" class="headerlink" title="The Album Page"></a>The Album Page</h3><p>I have to admit that the access speed of this page is too slow, it has affected the experience of my blog, so I decided to temporarily remove this page, and then re-open this page after I find a perfect method.</p><h3 id="The-Email-alert-service"><a href="#The-Email-alert-service" class="headerlink" title="The Email alert service"></a>The Email alert service</h3><p><a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a><br>Follow this step by step, I have successfully configured it, are you sure not to comment here?</p><h3 id="How-to-solve-the-problem-that-the-symbol——-39-is-too-wide"><a href="#How-to-solve-the-problem-that-the-symbol——-39-is-too-wide" class="headerlink" title="How to solve the problem that the symbol——&#39; is too wide"></a>How to solve the problem that the symbol——<code>&#39;</code> is too wide</h3><p>Add these follwing codes int the <code>config.yml</code> in your hexo root directory.</p><pre><code>marked:  gfm: true  pedantic: false  sanitize: false  tables: true  breaks: true  smartLists: true  smartypants: false</code></pre><h3 id="Add-random-quotes"><a href="#Add-random-quotes" class="headerlink" title="Add random quotes"></a>Add random quotes</h3><p>Preview:</p><script language="JavaScript">  <!-- Hide  var a = Math.random() + ""          //产生一个随机数  var rand1 = a.charAt(5)             //的到这个数的第五个字符(实际还是从0~9的数字)  quotes = new Array              //创建消息数组  quotes[1] = '<center><--你不知道我有多想因为你而有底气说出舔狗舔到最后应有尽有--></center>'               //这里分配十句随机出现的文本  quotes[2] = '<center><--人生就像一杯茶，不会苦一辈子，但总会苦一阵子--></center>'  quotes[3] = '<center><--浮天水送无穷树，带雨云埋一半山--></center>'  quotes[4] = '<center><--有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了；有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了--></center>'  quotes[5] = '<center><--哭过喊过便会停止哭泣--></center>'  quotes[6] = '<center><--人非圣贤，孰能无过？过而能改，善莫大焉--></center>'  quotes[7] = '<center><--今日，吾爱，我们融为一体--></center>'  quotes[8] = '<center><--人类的智慧就如同孔雀的羽毛。极尽炫耀，只是为了吸引异性--></center>'  quotes[9] = '<center><--不管什么时候，能够改变世界的人都是一心追逐梦想的人。--></center>'  quotes[0] = '<center><--人类文明从仰望星空那一刻起，就已经距离揭示宇宙奥秘仅有一步之遥了。--></center>'  var quote = quotes[rand1]   //由随机数选择一句话  //-->  </script>  <script language="JavaScript">  <!-- Hide  document.write( quote )     //将上面选择的话写进页面  // -->  </script>  <p><center>Main code:</center></p><pre><code>&lt;script language=&quot;JavaScript&quot;&gt;  &lt;!-- Hide  var a = Math.random() + &quot;&quot;          //Generate a random numbervar rand1 = a.charAt(5)             //Get the fifth character of this number (actually from 0 to 9)  quotes = new Array              //Create an array of messagesquotes[1] = &#39;&lt;center&gt;&lt;--你不知道我有多想因为你而有底气说出舔狗舔到最后应有尽有--&gt;&lt;/center&gt;&#39;               //Assign ten randomly appearing texts herequotes[2] = &#39;&lt;center&gt;&lt;--人生就像一杯茶，不会苦一辈子，但总会苦一阵子--&gt;&lt;/center&gt;&#39;  quotes[3] = &#39;&lt;center&gt;&lt;--浮天水送无穷树，带雨云埋一半山--&gt;&lt;/center&gt;&#39;  quotes[4] = &#39;&lt;center&gt;&lt;--有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了；有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了--&gt;&lt;/center&gt;&#39;  quotes[5] = &#39;&lt;center&gt;&lt;--哭过喊过便会停止哭泣--&gt;&lt;/center&gt;&#39;  quotes[6] = &#39;&lt;center&gt;&lt;--人非圣贤，孰能无过？过而能改，善莫大焉--&gt;&lt;/center&gt;&#39;  quotes[7] = &#39;&lt;center&gt;&lt;--今日，吾爱，我们融为一体--&gt;&lt;/center&gt;&#39;  quotes[8] = &#39;&lt;center&gt;&lt;--人类的智慧就如同孔雀的羽毛。极尽炫耀，只是为了吸引异性--&gt;&lt;/center&gt;&#39;  quotes[9] = &#39;&lt;center&gt;&lt;--不管什么时候，能够改变世界的人都是一心追逐梦想的人。--&gt;&lt;/center&gt;&#39;  quotes[0] = &#39;&lt;center&gt;&lt;--人类文明从仰望星空那一刻起，就已经距离揭示宇宙奥秘仅有一步之遥了。--&gt;&lt;/center&gt;&#39;  var quote = quotes[rand1]   //Choose a sentence from a random number//--&gt;  &lt;/script&gt;  &lt;script language=&quot;JavaScript&quot;&gt;  &lt;!-- Hide  document.write( quote )     //Write the words selected above into the page// --&gt;  &lt;/script&gt;</code></pre><p>And there has some other way to achieve this effect.You can search it if you are interested in.</p><p>一言<br>Code:</p><pre><code>&lt;p id=&quot;hitokoto&quot;&gt;:D 获取中...&lt;/p&gt;&lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt;</code></pre><h3 id="Add-countdown"><a href="#Add-countdown" class="headerlink" title="Add countdown"></a>Add countdown</h3><p>Code:</p><pre><code>&lt;DIV id=&quot;CountMsg&quot; class=&quot;HotDate&quot;&gt;&lt;span id=&quot;td&quot;&gt;00天&lt;/span&gt;&lt;/DIV&gt;&lt;script type=&quot;text/javascript&quot;&gt;function getRTime(){var EndTime= new Date(&#39;2020/10/23 10:00:00&#39;); //截止时间var NowTime = new Date();var t =EndTime.getTime() - NowTime.getTime();var d=Math.floor(t/1000/60/60/24);var h=Math.floor(t/1000/60/60%24);var m=Math.floor(t/1000/60%60);var s=Math.floor(t/1000%60);document.getElementById(&quot;td&quot;).innerHTML = &quot;距离一切结束还有&quot;+d+ &quot;天&quot;;document.getElementById(&quot;th&quot;).innerHTML = h+&quot;时&quot;;document.getElementById(&quot;tm&quot;).innerHTML = m+&quot;分&quot;;document.getElementById(&quot;ts&quot;).innerHTML = s+&quot;秒&quot;;}setInterval(getRTime,1000);&lt;/script&gt;</code></pre><h3 id="Add-a-guide-page-and-a-new-about-page"><a href="#Add-a-guide-page-and-a-new-about-page" class="headerlink" title="Add a guide page and a new about page."></a>Add a guide page and a new about page.</h3><p>These days I spend all my free time on this,and now it&#39;s OK.<br>Welcome to give me your advices.</p><p>说来惭愧，只记得一个女生的生日，却连家人的都记不住。<br>爸 八月初四<br>妈 十一月初九<br>姐 二月初一</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小y的序列</title>
      <link href="/2019/04/14/nowcoder-634-A/"/>
      <url>/2019/04/14/nowcoder-634-A/</url>
      
        <content type="html"><![CDATA[<center>牛客练习赛44 A 小y的序列</center><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/634/A" target="_blank" rel="noopener">小y的序列</a><br>题目描述：<br>小y有一块长度为n的布匹。颜色全部为0。他要给这个布匹染色。他总共有m种染料。小y认为一种染料用多次是不和谐的。所以每种染料会被用刚好一次。也就是说小y要给这块布匹染m次色。第i次会把Li<br>到Ri这个区间染成颜色i。现在给出最终布匹每段的颜色。请你输出一种染色方案。数据保证有解<br>输入描述:<br>输入共两行。<br>第一行两个个正整数n,m，表示布匹的长度和染料的数量<br>第二行n个用空格隔开的正整数，第i个数字ai表示第i个布匹的颜色。<br>输出描述:<br>输出m行。<br>第i行包含两个正整数<br>Li,Ri,表示第i次染色的区间。<br>示例1<br>输入<br>3 3<br>1 2 3<br>输出<br>1 3<br>2 3<br>3 3</p><p>备注:<br>1≤n,m≤1e5<br>0≤ai≤m<br>1≤Li≤Ri≤n</p><p>题意分析:<br>其实这道题就是让你找一个数第一次出现和最后一次出现的地方，然后输出就行。这里我用到了map，但是为什么会WA呢，因为题目中要求的是每种颜色都要用到，但是如果有一种颜色在最后的结果中没有出现并且不做处理的话，输出出来的结果就会有某几种颜色没有使用到，而题目又保证数据有解，所以我们只需要特判一下就行了。<br>代码实现</p><pre><code>#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;const int maxn=1e5+7;int a[maxn];int main(){    map&lt;int,int&gt; ma;    map&lt;int,int&gt; ma2;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i];        if(!ma[a[i]])            ma[a[i]]=i;        ma2[a[i]]=i;    }    for(int i=1;i&lt;=m;i++)    {        if(ma[i]==0)    cout&lt;&lt;ma[m]&lt;&lt;&quot; &quot;&lt;&lt;ma2[m]&lt;&lt;endl;        else cout&lt;&lt;ma[i]&lt;&lt;&quot; &quot;&lt;&lt;ma2[i]&lt;&lt;endl;    }    return 0;}</code></pre><p>一开始WA了好几次，最后才意识到需要有一个特判。<br>每天也就做做水题维持一下生活这样子了。😢</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> nowcoder </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活不止眼前的苟且，还有诗和远方的田野</title>
      <link href="/2019/04/13/life-only/"/>
      <url>/2019/04/13/life-only/</url>
      
        <content type="html"><![CDATA[<p>　　首先说一下大学生活吧，确实没有高中时候期待的那样美好。一点都不舒服，每天忙的要死，又有很多听不懂还学不会的东西，确实没有幻想中的那么美好，毕竟还是要奋斗的，死于安乐啊。<br>　　然后说一下关于协会的事吧，早在刚来学校前就知道了这个协会，一开始也是被公费旅游给吸引的妥妥的。可是很现实的就是有实力才能出去比赛，出去公费旅游。运气也是不错，来来回回出去了好几次。可是五月份那个驻马店的省赛去不了了诶，贼难受，不过还是因为自己菜，如果我也很厉害还是可以去。可惜没如果。。。而且最近真的是不知道怎么提示，复杂一点的算法就看不懂了很难受，也就一直水水cf上面简单的思维题，给自己一个没有退步的假象，实际上真的是越来越菜。还是加油吧，争取多出去玩几次。<br>　　然后说一下sublime，这个玩意是真的好用，就是配置成c/c++的IDE的话好难。。。前前后后搞了好几次，就在昨天晚上终于是搞好了，还通过下载插件实现了sublime中编辑markdown并实时预览的功能(快捷键：ALT+m)，真好用。还很漂亮。这里提一下，用sublime下载插件如果会出错，建议用手机的4G网络开热点进行下载，具体是什么原因可以网上看，我也解释不清。<br>还有就是google上的momomentum插件每次显示的壁纸都贼漂亮，一番查找终于是找到了图片的位置，有一种直接在网站上可以下载的方法可是我不会，但是可以在本地文件夹找到，文件路径为</p><pre><code>C:\Users\11204\AppData\Local\Google\Chrome\User Data\Default\Extensions\laookkfknpbbblfpciffpaejjkokdgca\1.8.3_0(版本号)\backgrounds</code></pre>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Expedition</title>
      <link href="/2019/04/12/Expedition/"/>
      <url>/2019/04/12/Expedition/</url>
      
        <content type="html"><![CDATA[<center>poj 2431 Expedition</center><p>题目链接：<a href="https://poj.org/problem?id=2431" target="_blank" rel="noopener">poj 2431 Expedition</a><br>题目描述：<br>A group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortunately managed to run over a rock and puncture the truck&#39;s fuel tank. The truck now leaks one unit of fuel every unit of distance it travels.</p><p>To repair the truck, the cows need to drive to the nearest town (no more than 1,000,000 units distant) down a long, winding road. On this road, between the town and the current location of the truck, there are N (1 &lt;= N &lt;= 10,000) fuel stops where the cows can stop to acquire additional fuel (1..100 units at each stop).</p><p>The jungle is a dangerous place for humans and is especially dangerous for cows. Therefore, the cows want to make the minimum possible number of stops for fuel on the way to the town. Fortunately, the capacity of the fuel tank on their truck is so large that there is effectively no limit to the amount of fuel it can hold. The truck is currently L units away from the town and has P units of fuel (1 &lt;= P &lt;= 1,000,000).</p><p>Determine the minimum number of stops needed to reach the town, or if the cows cannot reach the town at all.<br>Input</p><p>Line 1: A single integer, N</p><p>Lines 2..N+1: Each line contains two space-separated integers describing a fuel stop: The first integer is the distance from the town to the stop; the second is the amount of fuel available at that stop.</p><p>Line N+2: Two space-separated integers, L and P<br>Output</p><p>Line 1: A single integer giving the minimum number of fuel stops necessary to reach the town. If it is not possible to reach the town, output -1.<br>Sample Input</p><p>4<br>4 4<br>5 2<br>11 5<br>15 10<br>25 10<br>Sample Output</p><p>2<br>Hint</p><p>INPUT DETAILS:</p><p>The truck is 25 units away from the town; the truck has 10 units of fuel. Along the road, there are 4 fuel stops at distances 4, 5, 11, and 15 from the town (so these are initially at distances 21, 20, 14, and 10 from the truck). These fuel stops can supply up to 4, 2, 5, and 10 units of fuel, respectively.</p><p>OUTPUT DETAILS:</p><p>Drive 10 units, stop to acquire 10 more units of fuel, drive 4 more units, stop to acquire 5 more units of fuel, then drive to the town.<br>题意分析：<br>你需要驾驶一辆卡车行驶L单位距离。最开始时，卡车上有P单位的汽油。卡车每开1单位距离需要消耗1单位的汽油。如果在途中车上的汽油耗尽，卡车就无法继续前行，因而无法到达终点。在途中一共有N个加油站。给出每个加油站到终点的距离，以及这个加油站可以给卡车最多加多少汽油，并且卡车燃料箱的容量是没有限制的。如果卡车不能到达终点输出<code>-1</code>，否则输出最少停留，即需要加油的次数。</p><p>解题思路就是让卡车一直走下去，直至燃料箱中剩余为0的时候，看是不是经过了加油站，并且对那些加油站可以加的油的量进行判断，实现这一步，就可以用到优先队列。并且此时我们要给卡车加最多能加的油（体现贪心的地方）。我在这里用了结构体以及结构体的排序。<br>代码实现</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int l,p,pos=0,ans=0,re;//re代表油箱中剩的油，pos代表现在所在的位置priority_queue&lt;int&gt; q;struct oil{    int a,b;}s[1000005];bool cmp(oil x,oil y){    return x.a&lt;y.a;}int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)        cin&gt;&gt;s[i].a&gt;&gt;s[i].b;    cin&gt;&gt;l&gt;&gt;p;    for(int i=0;i&lt;n;i++)        s[i].a=l-s[i].a;    sort(s,s+n,cmp);    s[n].a=l;    s[n].b=0;    n++;    re=p;    for(int i=0;i&lt;n;i++)    {        int d=s[i].a-pos;        while(re-d&lt;0)//这个while代表的是此时油箱中剩的油的量够不够走到下一个位置。        {            if(q.empty())//队列为空代表已经没有可以加油的地方了，也就是到不了终点了。            {                cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;                return 0;            }            re+=q.top();            q.pop();            ans++;        }        re-=d;        pos=s[i].a;        q.push(s[i].b);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> STL </tag>
            
            <tag> poj </tag>
            
            <tag> Greedy </tag>
            
            <tag> Priority queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gourmet Cat</title>
      <link href="/2019/04/11/Gourmet%20Cat/"/>
      <url>/2019/04/11/Gourmet%20Cat/</url>
      
        <content type="html"><![CDATA[<center>1154C  Gourmet Cat</center><p>cf传送门：<a href="https://codeforces.com/problemset/problem/1154/C" target="_blank" rel="noopener">Gourmet Cat</a><br>vj传送门：<a href="https://cn.vjudge.net/problem/CodeForces-1154C" target="_blank" rel="noopener">Gourmet Cat</a><br>题目描述<br>Polycarp has a cat and his cat is a real gourmet! Dependent on a day of the week he eats certain type of food:</p><p>on Mondays, Thursdays and Sundays he eats fish food;<br>on Tuesdays and Saturdays he eats rabbit stew;<br>on other days of week he eats chicken stake.<br>Polycarp plans to go on a trip and already packed his backpack. His backpack contains:</p><p>a daily rations of fish food;<br>b daily rations of rabbit stew;<br>c daily rations of chicken stakes.<br>Polycarp has to choose such day of the week to start his trip that his cat can eat without additional food purchases as long as possible. Print the maximum number of days the cat can eat in a trip without additional food purchases, if Polycarp chooses the day of the week to start his trip optimally.</p><p>Input<br>The first line of the input contains three positive integers a, b and c (1≤a,b,c≤7⋅1e8) — the number of daily rations of fish food, rabbit stew and chicken stakes in Polycarps backpack correspondingly.</p><p>Output<br>Print the maximum number of days the cat can eat in a trip without additional food purchases, if Polycarp chooses the day of the week to start his trip optimally.</p><p>Examples<br>input<br>2 1 1<br>output<br>4<br>input<br>3 2 2<br>output<br>7<br>input<br>1 100 1<br>output<br>3<br>input<br>30 20 10<br>output<br>39<br>Note<br>In the first example the best day for start of the trip is Sunday. In this case, during Sunday and Monday the cat will eat fish food, during Tuesday — rabbit stew and during Wednesday — chicken stake. So, after four days of the trip all food will be eaten.</p><p>In the second example Polycarp can start his trip in any day of the week. In any case there are food supplies only for one week in Polycarps backpack.</p><p>In the third example Polycarp can start his trip in any day, excluding Wednesday, Saturday and Sunday. In this case, the cat will eat three different dishes in three days. Nevertheless that after three days of a trip there will be 99 portions of rabbit stew in a backpack, can cannot eat anything in fourth day of a trip.<br>题意分析：<br>这道题大概的意思就是给定一个序列<br><code>abcacba abcacba......</code><br>然后给定a，b，c的个数，求能得到的最大序列的长度。<br>观察可以发现3个a2个b2个c可以当成一组看待，然后将a，b，c通过这个原则进行缩小。缩小之后在进行判断，从第一个a开始最长的序列是多长，从第二个b开始最长序列是多长，从第三个c开始最长序列是多长，从第四个a开始最长的序列是多长。。。。。。用代码实现这部分功能就是</p><pre><code>int ans=0,s=0;    for(int i=1;i&lt;8;i++)    {        int j=i,s=0;        int A=a,B=b,C=c;        while(A&gt;=0&amp;&amp;B&gt;=0&amp;&amp;C&gt;=0)        {            if(j%7==1||j%7==4||j%7==0)    --A;            else if(j%7==3||j%7==5)    --C;            else --B;            j++;            s++;        }        ans=max(ans,s-1);    }</code></pre><p>每次计算出的s都需要减1，因为当你退出while循环的时候，a，b，c中会有一个值为-1，相当于多计算了一个字符，所以需要减一。如果不懂的话，建议手动模拟一下while循环中的内容，会有助于理解的。</p><p>这道题的代码实现</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int a,b,c;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;    int x;    x=min(a/3,min(b/2,c/2));    a-=x*3;    b-=x*2;    c-=x*2;    int ans=0,s=0;    for(int i=1;i&lt;8;i++)    {        int j=i,s=0;        int A=a,B=b,C=c;        while(A&gt;=0&amp;&amp;B&gt;=0&amp;&amp;C&gt;=0)        {            if(j%7==1||j%7==4||j%7==0)    --A;            else if(j%7==3||j%7==5)    --C;            else --B;            j++;            s++;        }        ans=max(ans,s-1);    }    cout&lt;&lt;ans+7*x&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>产生冠军</title>
      <link href="/2019/04/10/hdu-champion/"/>
      <url>/2019/04/10/hdu-champion/</url>
      
        <content type="html"><![CDATA[<p><center>产生冠军</center><br>题目描述：<br>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br>球赛的规则如下：<br>如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br>如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br>根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。</p><p>Input<br>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。</p><p>Output<br>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。</p><p>Sample Input<br>3<br>Alice Bob<br>Smith John<br>Alice Smith<br>5<br>a c<br>c d<br>d e<br>b e<br>a d<br>0</p><p>Sample Output<br>Yes<br>No</p><p>题意分析：刚开似乎看到这道题以为是并查集（虽然我也不会。但是经过仔细的分析可以发现，如果冠军是确定存在的，那么这个冠军肯定是没有输过的，所以可以使用c++STL中的set。将所有人和输过的人分开存进set，在比较两个set的size，如果所有人比输过的人多1，则说明冠军是存在的。<br>代码实现</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,a;    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)    {        set&lt;string&gt; x;        set&lt;string&gt; y;        string p,q;        while(n--)        {            cin&gt;&gt;p&gt;&gt;q;            x.insert(p);            x.insert(q);            y.insert(q);        }        if(x.size()-y.size()==1)            puts(&quot;Yes&quot;);        else            puts(&quot;No&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> HDU </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>咕咕的计数题 II</title>
      <link href="/2019/04/09/CCPC-silver/"/>
      <url>/2019/04/09/CCPC-silver/</url>
      
        <content type="html"><![CDATA[<p><center>咕咕的计数题 II</center><br>题目描述<br>咕咕最近在学习初等数论，并且对下取整函数产生了极大的兴趣。下取整函数是指一个函数，自变量为 一个实数，因变量为一个整数，这个整数恰好是小于或等于自变量的最大的整数，通常记做 ⌊x⌋。例如， ⌊2.5⌋ = 2,⌊2⌋ = 2,⌊−2.5⌋ = −3。<br> 咕咕发现，给定一个 a，并不是所有的自然数 n 都存在一个正整数 i 使得 ⌊n/i⌋ = a。那么，如果给定 l,r，咕咕好奇在区间 [l,r] 中有多少个正整数能使这个等式有正整数解 i 呢？<br> 那么，聪明的你，你能告诉咕咕吗？<br>输入<br>第一行有一个整数 T(1 ≤ T ≤ 1e6)，表示数据组数。接下来有 T 行，每行有三个数 a,l,r(1 ≤ a ≤ 1e18,1 ≤ l ≤ r ≤ 1e18)，表示一组询问。<br>输出<br>输出 T 行，对每组询问，输出一个整数表示答案。<br>样例输入<br>4<br>5 7 10<br>7 39 42<br>1000 1000 1000<br>27 100 1000<br>样例输出<br>1<br>2<br>1<br>617<br>提示<br>数据范围<br>当 n = 39,a = 7 时，能找到 i = 5 使得 ⌊39 /5 ⌋ = 7。<br>题意分析<br>这道题就是给你一个区间和一个数a，让你求区间内有几个数跟任意数整除之后可以得到a，通过看数据范围可以发现这道题的输入量巨大，所以应该是会可以找到一个规律。并且不能使用cin和cout。<br>找到的规律AND式子<br>假定a为7，l为1，r为70，区间内满足条件的值有一下几组</p><pre><code>a = 7 ,l = 1 ,r = 70714 1521 22 2328 29 30 3135 36 37 38 3942 43 44 45 46 4749 50 51 52 53 54 5556 57 58 59 60 61 62 6364 65 66 67 68 69 70 7172 73 74 75 76 77 78 7980</code></pre><p>仔细观察以及在写出来的过程中会发现满足整除出现a的数肯定是在(a*i,a*i+(i-1))内,i=1,2,3......并且一旦超过了a的平方之后，任意一个数都可以整除之后出现a。<br>规律已经找到了，可是该怎么实现呢，我们会发现，在小于a的平方之前，每次出现的满足条件的数的个数是<code>1,2,3,4,5,6......</code>这样递增的，所以我们让这个数对a整除，对整除出来的数进行从1加到它本身的求和，然后减去有可能不满足的个数，表达不满足的个数，我们看上面的列出来的数，会发现，如果这个数对a取余小于这个数对a整除，就满足条件，所以就可以判断了。写成式子就是</p><pre><code>Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0)Sum为自定义的从1加到本身的函数，可以直接用一个公式代替，这样方便理解</code></pre><p>然后就可以求出左区间以内满足的个数x，右区间以内满足的个数y，y-x就可以求出[x,l)之间的满足条件的个数，但是这种方法并没有对r进行判断，所以我们要再对r进行一次判断，如果r也满足，直接答案加一就行了。<br>分三种情况考虑</p><ol><li>左区间l大于a的平方，此时所需要输出的答案就是<code>r-l</code>。</li><li>左区间l小于a的平方，但右区间r大于a的平方，此时需要把区间分成两段，一段是(a*a,r),一段是(l,a*a-1)。大于a的平方的那一段的区间长度，加上小于a的平方的那一段中满足上面总结的规律的数的个数即答案。</li><li>右区间小于a的平方，此时就可以直接在(l,r)内去找满足条件的数的个数输出就行。</li></ol><p>代码实现</p><pre><code>#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll Sum(ll x){    if(x%2==0)  return x/2*(1+x);    return x*(1+x)/2;}int main(){    int t;    ll a,l,r;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        ll ans=0,x,y;        scanf(&quot;%lld %lld %lld&quot;,&amp;a,&amp;l,&amp;r);        if(sqrt(l)&gt;=a)        {            ans=r-l+1;        }        else if(sqrt(r)&gt;=a)        {            ans=r-a*a+1;            r=a*a-1;            x=Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0);            y=Sum(r/a)-(r%a&lt;r/a?(r/a-r%a):0);            if(r%a&lt;r/a)                y++;            ans+=y-x;        }        else        {            x=Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0);            y=Sum(r/a)-(r%a&lt;r/a?(r/a-r%a):0);            if(r%a&lt;r/a)                y++;            ans=y-x;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><p>这里有一个坑，就是分情况讨论的时候l，r跟a的平方比较的时候要对l，r开平方之后跟a比较，第一次我们交的与a的平方比较，WA了，怎么都找不到bug，最后还是机灵的队友说了一下会不会平方之后爆long long，改了一下交了还真过了。。。这数据卡的东西真多。一定要注意！！！</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Childhood dream</title>
      <link href="/2019/04/08/Childhood-dream/"/>
      <url>/2019/04/08/Childhood-dream/</url>
      
        <content type="html"><![CDATA[<p>Childhood dream<br><a href="https://acm.zzuli.edu.cn/contest.php?cid=1383" target="_blank" rel="noopener">比赛链接</a><br>题目链接:<a href="https://acm.zzuli.edu.cn/problem.php?id=2526" target="_blank" rel="noopener">Childhood dream</a><br>题目描述：<br>你童年时期就有一个梦想，想要加入 ACM(Association of Calculation and Magic)，今天，这个机会终于 来了。<br>但是 ACM 只想要哪些天赋异禀的人, 比如像 tourist，他们给了你一道题来检测你是否足够机智。<br>猜一个长度为 m 数字串，总共有 n 个提示串，解释如下：<br> 8640 0A2B<br>A 前面的数字说明与答案相比，有多少个位置上的数字是相同的。 B 前面的数字说明与答案相比，有多 少个数字是相同的，但是位置不一样。<br> 0 A 就表示给出的串没有任何位置和答案是相同的。 2 B 就表示给出的串中有两个数字和答案相同，但 是位置不一样。<br>所以，对于上面那个提示串 6457 是一个合理的答案，但是 1234 并不是。<br>现在给你 N(N&lt;=100) 个提示串（如上所示），你需要去找到一个数字串来符合每一个提示串的要求。<br>提示串中的每个数字都是不同的，即一个串中不会存在相同的数字。<br>你能解决这个问题并加入 ACM 吗？<br>输入<br>第一行两个数字，n(n&lt;=100) 和 m(m&lt;=9）, 提示串的数量以及目标字符串的长度。<br>然后是 n 行，每行的格式如下：<br>s x y<br>s 是提示串，x 是 A 前的数字，y 是 B 前的数字，等同于：<br>s xAyB<br>输出<br>一行，目标串。<br>数据保证答案唯一。<br>样例输入<br>6 4<br>5164 3 0<br>5174 3 0<br>5194 3 0<br>5124 3 0<br>5134 3 0<br>5104 3 0<br>样例输出<br>5184<br>题意分析<br>这道题的意思就是猜一个数，数的位数是确定的，然后会进行猜数，会给出两个数，第一个数代表位置相等且大小相等的个数，第二个数代表的是数相等但位置不等的数，通过这几次猜测，让你输出对应的满足条件的答案。因为答案最大的长度才10所以可以直接全排，全排之后对每次猜测就行A跟B的计算，然后跟输入进行比较，最后根据比较的结果得出答案，题目保证答案唯一。这样想这道题还是很水的。。。<br>代码实现</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;string s[105];int a[105],b[105];int A[10]={0,1,2,3,4,5,6,7,8,9};int main(){    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)        cin&gt;&gt;s[i]&gt;&gt;a[i]&gt;&gt;b[i];    do    {        bool flag=0;        int x,y;        for(int i=0;i&lt;n;i++)        {            x=y=0;            for(int j=0;j&lt;m;j++)            {                if(A[j]==s[i][j]-&#39;0&#39;)                {                    x++;                }            }            for(int j=0;j&lt;m;j++)                for(int k=0;k&lt;m;k++)                {                    if(j!=k&amp;&amp;A[j]==s[i][k]-&#39;0&#39;)                        y++;                    }            if(x!=a[i]||y!=b[i])            {                flag=1;                break;            }        }        if(!flag)        {            for(int i=0;i&lt;m;i++)            {                cout&lt;&lt;A[i];            }            cout&lt;&lt;endl;            break;        }    }while(next_permutation(A,A+10));    return 0;}</code></pre><p>全排之后取前m位进行判断就行。<br>虽说题有点‘水’，但要是让我自己做出来显然还是不可以的，加油吧！</p><p>附上学霸学长修改了的我的TLE的代码，我又学到了好多东西🎈</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a[10]={0,1,2,3,4,5,6,7,8,9};struct guess{    string S;    int A,B;}gue[100];int n,m,x,y;bool check(){    int k,l;    for(int i=0;i&lt;n;i++)    {        k=l=0;        for(int j=0;j&lt;m;j++)        {            if(a[j]==gue[i].S[j]-&#39;0&#39;)                k++;        }        for(int k=0;k&lt;m;k++)            for(int j=0;j&lt;m;j++)            {                if(k==j)                    continue;                if(a[k]==gue[i].S[j]-&#39;0&#39;)                    l++;            }        if(k!=gue[i].A||l!=gue[i].B)            return 0;    }    return 1;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)        cin&gt;&gt;gue[i].S&gt;&gt;gue[i].A&gt;&gt;gue[i].B;    do    {        if(check())        {            for(int i=0;i&lt;m;i++)                cout&lt;&lt;a[i];            cout&lt;&lt;endl;            break;        }    }while(next_permutation(a,a+10));    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现大数加法</title>
      <link href="/2019/04/06/add-bn/"/>
      <url>/2019/04/06/add-bn/</url>
      
        <content type="html"><![CDATA[<p>具体思想其实就是模拟，加法就是按位相加，再考虑一下低位过来的进位就可以了。说起来简单但是实现起来就不是那么回事了。之前刚开始了解的是用数组存，好像还很麻烦，这些天突然看到一个用了string类型以及string类型有关的函数来解决这个问题的，感觉不错。先上代码</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,a,b;    a=b=0;    cin&gt;&gt;n;    while(n--)    {        string s1,s2,s(10000,&#39;0&#39;);        cin&gt;&gt;s1&gt;&gt;s2;        cout&lt;&lt;(b++?&quot;\n&quot;:&quot;&quot;);        reverse(s1.begin(),s1.end());        reverse(s2.begin(),s2.end());        for(int i=0;i&lt;s1.size();i++)        {            s[i]=s1[i];        }        int temp=0;        for(int i=0;i&lt;s2.size();i++)        {            temp+=s[i]+s2[i]-&#39;0&#39;-&#39;0&#39;;            s[i]=temp%10+&#39;0&#39;;            temp/=10;        }        s[s2.size()]=s[s2.size()]+temp;        reverse(s.begin(),s.end());        reverse(s1.begin(),s1.end());        reverse(s2.begin(),s2.end());        cout&lt;&lt;&quot;Case &quot;&lt;&lt;b&lt;&lt;&#39;:&#39;&lt;&lt;endl;        cout&lt;&lt;s1&lt;&lt;&quot; + &quot;&lt;&lt;s2&lt;&lt;&quot; = &quot;&lt;&lt;s.substr(s.find_first_not_of(&#39;0&#39;))&lt;&lt;endl;    }    return 0;}</code></pre><p>这是<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank" rel="noopener">HDU1002</a>的AC代码。其中有很多是格式控制符，跟大数相加无关，所需要理解的其实就是这一步</p><pre><code>       for(int i=0;i&lt;s2.size();i++)        {            temp+=s[i]+s2[i]-&#39;0&#39;-&#39;0&#39;;            s[i]=temp%10+&#39;0&#39;;            temp/=10;        }</code></pre><p>temp所表示的数就是进位。<br>另外这里面还用到<code>s.substr()，s.find_first_not_of()</code>函数。因为在定义结果字符串s的时候定义成了全是0的一个字符串。s.substr()用来输出子串，s.find_first_not_of()用来找到第一个不是0的字符的位置来生成子串。<br>这样写还是很简洁的，也比较好理解。</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asia区域制</title>
      <link href="/2019/04/05/Asiaqyz/"/>
      <url>/2019/04/05/Asiaqyz/</url>
      
        <content type="html"><![CDATA[<p>Asia区域制<br>题目链接：<a href="https://hpuoj.com/contest/16/problem/B/" target="_blank" rel="noopener">Asia区域制</a><br>题目描述<br>二进制数据是用 0 和 1 两个数码来表示的数.它的基数为 2 ，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现.<br>十六进制（简写为hex或下标 16 ）在数学中是一种逢 16 进 1 的进位制.一般用数字 0 到 9 和字母 A 到 F（或 a ~ f ）表示，其中: a ~ f 表示 10 ~ 15 ，这些称作十六进制数字.<br>请将给定的二进制数转为十六进制数，英文字母使用小写形式.</p><p>输入<br>第一行一个正整数 T， 代表有 T 组测试数据. (1≤T≤10).<br>接下来 T 行，每行输入一串只包含 0 和 1 的字符串（无前导 0），字符串长度：1≤length≤106.</p><p>输出<br>对于每组测试样例，输出转化后的十六进制数并单独占一行.</p><p>样例<br>input<br>2<br>1<br>10<br>output<br>1<br>2<br>题意分析<br>就是将输入的一个二进制数转换成十六进制，但是需要注意的是这里给的二进制的数很大很大，就算用unsigned long long也存不下，所以只能使用字符串处理了。二进制转换成十六进制可以每四位转换成一个十进制数，最后全部转化完的结果就是十六进制的表现形式。具体看代码实现<br>代码实现</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    string s;    int n;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;s;        stack&lt;char&gt; sta;        stack&lt;int&gt; sta0;        for(int i=0;i&lt;s.size();i++)        {            sta.push(s[i]);        }        while(!sta.empty())        {            int flag=0,k=1,s=0;            while(flag&lt;4)            {                int m=sta.top()-&#39;0&#39;;                sta.pop();                s+=m*k;                k*=2;                flag++;                if(sta.empty())                    break;            }            sta0.push(s);        }        while(!sta0.empty())        {            printf(&quot;%0x&quot;,sta0.top());            sta0.pop();        }        cout&lt;&lt;endl;    }    return 0;}</code></pre><p>这里用到一个小技巧，c语言的printf的格式控制符里面有控制八进制(%o)十六进制(%0x)的控制符（具体更多的用法可以自行百度）可以直接使用。说到控制符就很气，请接着往下看。<br>我与这题的恩恩怨怨<br>校赛前还专门复习了一下进制转换，一开始没仔细看以为是道水题，直接WA了两发。看到数据范围才醒悟过来。<br>跟某大佬交流时听说python写这道题贼简单，正好我也在学习python，然后就试着用python写了这道题</p><pre><code class="lang-python">for i in range(int(input())):    print(hex(int(input(), 2))[2:])</code></pre><p>毫无人性啊有没有😭python的大数。。。用python就有一种作弊的既视感。好好学习！！！</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hangman Judge</title>
      <link href="/2019/04/05/Hangman%20Judge/"/>
      <url>/2019/04/05/Hangman%20Judge/</url>
      
        <content type="html"><![CDATA[<p>UVA 489 - Hangman Judge<br>原题链接：<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=0&amp;problem=430&amp;mosmsg=Submission+received+with+ID+23109097" target="_blank" rel="noopener">Hangman Judge</a><br>原题链接：<a href="https://cn.vjudge.net/problem/UVA-489" target="_blank" rel="noopener">Hangman Judge----vj</a></p><p><font color="red">ATTENTION</font> ：我与书上的方法不一样。并且因为我很菜，用的方法会很笨，有什么想指点的请在评论区留言，勿喷👌。<br>题目描述<br>In “Hangman Judge,” you are to write a program that judges a series of Hangman games. For each<br>game, the answer to the puzzle is given as well as the guesses. Rules are the same as the classic game<br>of hangman, and are given as follows:<br>1.The contestant tries to solve to puzzle by guessing one letter at a time.<br>2.Every time a guess is correct, all the characters in the word that match the guess will be “turnedover.” For example, if your guess is ‘o’ and the word is “book”, then both ‘o’s in the solution willbe counted as“solved”.<br>3.Every time a wrong guess is made, a stroke will be added to the drawing of a hangman, whichneeds 7 strokes to complete. Each unique wrong guess only counts against the contestant once.</p><pre><code>______|  ||  O| /|\|  || / \ __|_|  |______|_________|</code></pre><p>4.If the drawing of the hangman is completed before the contestant has successfully guessed all thecharacters of the word, the contestant loses.<br>5.If the contestant has guessed all the characters of the word before the drawing is complete, thecontestant wins the game.<br>6.If the contestant does not guess enough letters to either win or lose, the contestant chickens out.Your task as the “Hangman Judge” is to determine, for each game, whether the contestant wins,loses, or fails to finish a game.<br>Input<br>Your program will be given a series of inputs regarding the status of a game. All input will be in lowercase. The first line of each section will contain a number to indicate which round of the game is beingplayed; the next line will be the solution to the puzzle; the last line is a sequence of the guesses made by the contestant. A round number of ‘-1’ would indicate the end of all games (and input).<br>Output<br>The output of your program is to indicate which round of the game the contestant is currently playing as well as the result of the game. There are three possible results:<br>You win.<br>You lose.<br>You chickened out.</p><p>Sample Input<br>1<br>cheese<br>chese<br>2<br>cheese<br>abcdefg<br>3<br>cheese<br>abcdefgij<br>-1<br>Sample Output<br>Round 1<br>You win.<br>Round 2<br>You chickened out.<br>Round 3<br>You lose.</p><p>题意分析：计算机想一个单词让你猜，你每次可以猜一个字母，如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一副“侩子手”画上填上一笔。这幅画一共需要7笔就能完成，因此你最多只能错6次。注意，猜一个已经猜过的字母也算错。（以上内容来自——算法竞赛入门经典第二版  刘汝佳编）。<br>题目中输入的第一个字符串就是计算机想的单词，第二个字符串就是你猜的所有字符，这道题书上和我在网上看的好多用的是用一个数组标记每个字母出现的次数，但是我不会用，于是用了map来实现。这题我WA了好几次，其实大致上的实现方式是差不多的，就是会有很多细节需要考虑。<br>题目中的输出有三种情况<br>You win.       即在错误7次一下成功猜出了所有第一个字符串中的字符。<br>You chickened out.        即虽然错误次数没有超过7，但是并没有猜出来所有的第一个字符串中的字符。<br>You lose.        即全部猜对之前错误次数大于等于7了。<br>我的解题思路：首先将第一个字符串中的所有元素用map标记value为1，然后开始询问第二个字符串中的元素，如果这个元素（即字符）的map值为一，就说明它在第一个字符串中存在，反之就说明这是一次错误的猜测，此时需要对错误的次数加一方便以后的判断。需要注意的是因为在判断的过程中如果错误的次数已经到达了7次，后面的就不需要再进行判断了，因为此时已经Lose了。还有就是每一个错误的字符最多错一次，解释一下就是如果<code>s</code>不是第一个字符串中的元素，尽管你在第二个字符串中出现了几个<code>s</code>,都还只是猜错了一次。还有一些具体的细节我们在代码里进行解释。<br>代码实现</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n;    string x,y;    while(cin&gt;&gt;n&amp;&amp;n!=-1)//题目要求n为-1时退出程序    {        map&lt;char,int&gt; ma;//用来标记第一个字符串中出现的字符        map&lt;char,int&gt; ma1;//用来判断是否需要对错误次数进行累加        getchar();        cin&gt;&gt;x&gt;&gt;y;        int p=0;        for(int i=0;i&lt;x.size();i++)        {                ma[x[i]]=1;//把第一个字符串中出现的字符全部存进map并标记为1        }        for(int i=0;i&lt;y.size();i++)        {            if(ma[y[i]])//如果ma[y[i]]不为0，即说明这个元素在第一个字符串中            {                ma[y[i]]=0;//对最后的判断第一个字符串有没有被猜完做准备                ma1[y[i]]=1;//因为这是一个正确的字符，所以标记为1，在接下来的判断中将其跳过            }            else if(!ma1[y[i]])//如果ma1[y[i]]为0，说明这个字符是错误且只出现了一次的，此时需要对错误次数加一            {                p++;                ma1[y[i]]=1;//将y[i]标记为1，再遇见y[i]的时候，错误次数不变            }            if(p&gt;=7)                break;//错误的次数已经到达了7次，直接跳出循环        }        int flag=1;        map&lt;char,int&gt;::iterator it;//定义一个迭代器，用来遍历map中的每一个元素        for(it=ma.begin();it!=ma.end();it++)        {            if(it-&gt;second)//如果存在一个it-&gt;second不为0，即说明没有猜完            {                flag=0;                break;            }        }        printf(&quot;Round %d\n&quot;,n);//这个很坑，一开始就没注意到，注意看题目的输出格式！！！        if(flag)//flag为1说明在7次错误以内已经猜对了所有字符，所以输出You win.            puts(&quot;You win.&quot;);        else//否则对错误次数进行判定，这个里面挺好懂的，就不做详细解释了        {            if(p&lt;7)                puts(&quot;You chickened out.&quot;);            else                puts(&quot;You lose.&quot;);        }    }    return 0;}</code></pre><p>至此这道题就告一段落了，再次说明一下，这种方法肯定是比较麻烦的那种，我知道😭<br>但是这是我能想起来的可以解决的方法了，以后好好了解一下数组在这方面的应用。<br>有什么想吐槽的就来吧，我听着<br><a href="https://imgsrc.baidu.com/forum/pic/item/39b3a61ea8d3fd1ffbf6a61c3e4e251f94ca5fd5.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://imgsrc.baidu.com/forum/pic/item/39b3a61ea8d3fd1ffbf6a61c3e4e251f94ca5fd5.webp" class="img-shadow img-margin"></center></a></p><p>书上的方法</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100int left,chance;char s[maxn],s2[maxn];int win,lose;void guess(char ch){    int bad=1;    for(int i=0;i&lt;strlen(s);i++)    if(s[i]==ch)    {        left--;        s[i]=&#39; &#39;;        bad=0;    }    if(bad)   --chance;    if(!chance)  lose=1;    if(!left)  win=1;}int main(){    int rnd;    while(scanf(&quot;%d%s%s&quot;,&amp;rnd,s,s2)==3&amp;&amp;rnd!=-1)    {        printf(&quot;Round %d\n&quot;,rnd);        win=lose=0;        left=strlen(s);        chance=7;        for(int i=0;i&lt;strlen(s2);i++)        {            guess(s2[i]);            if(win||lose)            break;        }        if(win)        printf(&quot;You win.\n&quot;);        else if(lose)        printf(&quot;You lose.\n&quot;);        else        printf(&quot;You chickened out.\n&quot;);    }    return 0;}</code></pre><p>书上的方法还是很直接的，直接看就可以看懂了😘</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> UVA </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩形面积并</title>
      <link href="/2019/04/04/hpu%20C16%20H/"/>
      <url>/2019/04/04/hpu%20C16%20H/</url>
      
        <content type="html"><![CDATA[<p>校赛原题：<a href="https://hpuoj.com/contest/16/problem/H/" target="_blank" rel="noopener">Mo的面积</a><br>学长博客：<a href="https://boctorio.com/2019/03/22/%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF%E5%B9%B6/" target="_blank" rel="noopener">矩形面积并</a><br>题目描述<br>Mo的老师给了他两个矩形，让他求两个矩形的面积并。Mo很忙没时间解决这种小case，请你帮他解决。</p><p>输入<br>输入两行，每行四个整数 x,y,x1,y1 。(x,y) 是矩形左下角，(x1,y1) 是矩形的右上角. (0≤x,y,x1,y1≤1000)。</p><p>输出<br>输出一个整数表示二个矩形的面积并。</p><p>样例<br>input<br>0 1 2 3<br>1 0 3 2<br>output<br>7<br>学长的代码(求两个矩形相交部分的面积)</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;double a[10];int main(){    double l,r,u,d;    for(int i=1;i&lt;=8;i++){        scanf(&quot;%lf&quot;,&amp;a[i]);    }    l=max( min(a[1],a[3]) , min(a[5],a[7]) );    r=min( max(a[1],a[3]) , max(a[5],a[7]) );    d=max( min(a[2],a[4]) , min(a[6],a[8]) );    u=min( max(a[2],a[4]) , max(a[6],a[8]) );    if( r - l &lt;= 0 || u - d &lt;= 0 ) printf(&quot;0.00\n&quot;);    else printf(&quot;%.2lf\n&quot;,(r-l)*(u-d));    return 0;}</code></pre><p>校赛原题代码(在学长的代码的基础上稍加改动就行)</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a[10];int main(){    int l,r,u,d,s,s1;    for(int i=1;i&lt;=8;i++){        scanf(&quot;%d&quot;,&amp;a[i]);    }    l=max( min(a[1],a[3]) , min(a[5],a[7]) );    r=min( max(a[1],a[3]) , max(a[5],a[7]) );    d=max( min(a[2],a[4]) , min(a[6],a[8]) );    u=min( max(a[2],a[4]) , max(a[6],a[8]) );    if( r - l &lt;= 0 || u - d &lt;= 0 ) s1=0;    else s1=(r-l)*(u-d);    s=(a[4]-a[2])*(a[3]-a[1])+(a[8]-a[6])*(a[7]-a[5]);    cout&lt;&lt;s-s1&lt;&lt;endl;    return 0;}</code></pre><p>！！！！！！！！！！<font color="red">一定要记住补题</font>！！！！！！！！！！！！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彩虹瓶</title>
      <link href="/2019/04/03/pta%20stack/"/>
      <url>/2019/04/03/pta%20stack/</url>
      
        <content type="html"><![CDATA[<p><center> PTA L2-032 彩虹瓶 </center><br>原题链接：(<a href="https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858889" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858889</a>)</p><p>题目描述</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804103255.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804103255.webp" class="img-shadow img-margin"></center></a><p>彩虹瓶的制作过程（并不）是这样的：先把一大批空瓶铺放在装填场地上，然后按照一定的顺序将每种颜色的小球均匀撒到这批瓶子里。</p><p>假设彩虹瓶里要按顺序装 N 种颜色的小球（不妨将顺序就编号为 1 到 N）。现在工厂里有每种颜色的小球各一箱，工人需要一箱一箱地将小球从工厂里搬到装填场地。如果搬来的这箱小球正好是可以装填的颜色，就直接拆箱装填；如果不是，就把箱子先码放在一个临时货架上，码放的方法就是一箱一箱堆上去。当一种颜色装填完以后，先看看货架顶端的一箱是不是下一个要装填的颜色，如果是就取下来装填，否则去工厂里再搬一箱过来。</p><p>如果工厂里发货的顺序比较好，工人就可以顺利地完成装填。例如要按顺序装填 7 种颜色，工厂按照 7、6、1、3、2、5、4 这个顺序发货，则工人先拿到 7、6 两种不能装填的颜色，将其按照 7 在下、6 在上的顺序堆在货架上；拿到 1 时可以直接装填；拿到 3 时又得临时码放在 6 号颜色箱上；拿到 2 时可以直接装填；随后从货架顶取下 3 进行装填；然后拿到 5，临时码放到 6 上面；最后取了 4 号颜色直接装填；剩下的工作就是顺序从货架上取下 5、6、7 依次装填。</p><p>但如果工厂按照 3、1、5、4、2、6、7 这个顺序发货，工人就必须要愤怒地折腾货架了，因为装填完 2 号颜色以后，不把货架上的多个箱子搬下来就拿不到 3 号箱，就不可能顺利完成任务。</p><p>另外，货架的容量有限，如果要堆积的货物超过容量，工人也没办法顺利完成任务。例如工厂按照 7、6、5、4、3、2、1 这个顺序发货，如果货架够高，能码放 6 只箱子，那还是可以顺利完工的；但如果货架只能码放 5 只箱子，工人就又要愤怒了……</p><p>本题就请你判断一下，工厂的发货顺序能否让工人顺利完成任务。</p><p>输入格式：<br>输入首先在第一行给出 3 个正整数，分别是彩虹瓶的颜色数量 N（1&lt;N≤10<br>​3<br>​​ ）、临时货架的容量 M（&lt;N）、以及需要判断的发货顺序的数量 K。</p><p>随后 K 行，每行给出 N 个数字，是 1 到N 的一个排列，对应工厂的发货顺序。</p><p>一行中的数字都以空格分隔。</p><p>输出格式：<br>对每个发货顺序，如果工人可以愉快完工，就在一行中输出 YES；否则输出 NO。</p><p>输入样例：<br>7 5 3<br>7 6 1 3 2 5 4<br>3 1 5 4 2 6 7<br>7 6 5 4 3 2 1<br>输出样例：<br>YES<br>NO<br>NO<br>我与这道题的恩恩怨怨：<br>第一次看到这道题的时候，是很懵的，描述太长感觉看不懂不想看。看了榜单发现好多人做出来了，回头仔细一看，发现这就是一道栈的题。用一个栈就可以解决，虽然发现了方法，可是由于菜还是没做出来，补题补题。补题时候发现我的思路又总是出问题，在学长的帮助下，还是成功的过了这道题。<br>题意分析：这道题跟pta上之前一道题，几乎是原题，题目是出栈序列的合理性(想找的自己翻吧，我没找到🌚)。我们不管输入的是什么都先让它入栈然后对栈顶的元素进行判断，并且将符合条件的pop出栈。具体看代码<br>代码实现</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,m,k,a;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    while(k--)    {        int k=1;        bool flag=0;        stack&lt;int&gt; sta;        for(int i=0;i&lt;n;i++)        {            cin&gt;&gt;a;            sta.push(a);            if(sta.size()&gt;m+1)                flag=1;            while(!sta.empty())            {                if(sta.top()==k)                {                    sta.pop();                    k++;//k就是用来模拟此时应放的序号，如果有对应的就对k加1，模拟的就是这个放过了，准备放下一个。                }                else                    break;            }        }        if(!flag&amp;&amp;k==n+1)            puts(&quot;YES&quot;);        else            puts(&quot;NO&quot;);    }    return 0;}</code></pre><p>Ps：<code>if(sta.size()&gt;m+1)</code>是因为题目中要求的有货架最多存放的数量，即栈的最大容量。可为什么是m+1而不是m呢，这个我也纠结了好久。因为我们放进去之后接下来就要对它进行判断，所以在实际的过程中它是不用放在货架（入栈）上的，所以是m+1。还是不明白的话，建议手动模拟一下，这道题就会理解的更加透彻。<br>Warning：栈空的时候千万不要用.top()。。。不要用，不要用，不要用。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归实现十进制与二进制的转换</title>
      <link href="/2019/04/02/tentobin/"/>
      <url>/2019/04/02/tentobin/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6" target="_blank" rel="noopener">二进制</a>：二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。计算机中的二进制则是一个非常微小的开关，用“开”来表示1，“关”来表示0。<br>20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，因为数字计算机只能识别和处理由‘0’.‘1’符号串组成的代码。其运算模式正是二进制。19世纪爱尔兰逻辑学家乔治布尔对逻辑命题的思考过程转化为对符号&quot;0&#39;&#39;.&#39;&#39;1&#39;&#39;的某种代数演算，二进制是逢2进位的进位制。0、1是基本算符。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。<br>转换二进制我们用的都是余数短除法，就是要转换的数对二取余，然后除以二，直到这个数为0，再将余数倒序排列即可。不懂的话请看图示：<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804103413.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804103413.webp" class="img-shadow img-margin"></center></a><br>这里的倒序输出，我们想到的就是用数组或者栈来实现，这也是等很大众化的一种方式。我要介绍的这种方法采用的是递归，其实本质都是一样的，且不分优劣，这样写只单纯为了加深对递归的理解！</p><pre><code>void Binary(int x){    if(x==0)            return ;    Binary(x/2);    cout&lt;&lt;x%2;    return ;}</code></pre><p>这部分就是代码的核心。<br>我们手动执行一下就知道这种使用递归实现的巧妙之处了。</p><pre><code>当x=10时：此时x不为0，所以会执行Binary(x/2)x/2=5此时x不为0，所以会执行Binary(x/2)x/2=2此时x不为0，所以会执行Binary(x/2)x/2=1此时x不为0，所以会执行Binary(x/2)x/2=0此时x为0，所以会返回至上一次递归，而上一次递归中的x为1，所以输出x%2就是1，然后遇见return，返回上一次递归。上一次递归中x为2。所以输出x%2就是0，然后遇见return，返回上一次递归。上一次递归中x为5。所以输出x%2就是1，然后遇见return，返回上一次递归。上一次递归中x为10。所以输出x%2就是10，然后遇见return，返回上一次递归。上一次递归中x为1。此时这一次整体的递归就已经结束了，输出是1010，就是10的二进制形式。</code></pre><p>这里比较难理解的就是每一次新的递归开始的时候，上一次的执行会“保留现场”。然后每一次递归结束后就返回上一层递归。注意：<code>x==0时return</code>这个判断条件必须存在，不然递归不会结束。<br>完整代码</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;void Binary(int x){    if(x==0)            return ;    Binary(x/2);    cout&lt;&lt;x%2;    return ;}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n))    {        if(n==0)        {            puts(&quot;0&quot;);            continue;        }        Binary(n);        cout&lt;&lt;endl;    }    return 0;}</code></pre><p>这样的话会发现如果输入的数是负数会出现错误，只需要小小的改正一下就行</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;void Binary(int x){    if(x==0)            return ;    Binary(x/2);    cout&lt;&lt;abs(x%2);    return ;}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n))    {        if(n==0)        {            puts(&quot;0&quot;);            continue;        }        if(n&lt;0)            cout&lt;&lt;&#39;-&#39;;        Binary(n);        cout&lt;&lt;endl;    }    return 0;}</code></pre><p>这样就实现了任意整数转化成二进制的功能啦</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长对称子串</title>
      <link href="/2019/04/01/Maxhw/"/>
      <url>/2019/04/01/Maxhw/</url>
      
        <content type="html"><![CDATA[<h3 id="PTA-L2-008-最长对称子串"><a href="#PTA-L2-008-最长对称子串" class="headerlink" title="PTA L2-008 最长对称子串"></a><center>PTA L2-008 最长对称子串</center></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定<code>Is PAT&amp;TAP symmetric?</code>，最长对称子串为<code>s PAT&amp;TAP s</code>，于是你应该输出11。</p><p>输入格式：<br>输入在一行中给出长度不超过1000的非空字符串。</p><p>输出格式：<br>在一行中输出最长对称子串的长度。</p><pre><code>输入样例：Is PAT&amp;TAP symmetric?输出样例：11</code></pre><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>第一眼看到这道题是没有什么思路的，但是回头发现很多人a了这题，我又仔细的思考了很久，想到一种方法，让字符串与翻转之后的它进行比较，如果出现相等的就继续比较，同时对ans加一直到下一个不相同的出现为止。再将ans与最大值比较存储后归零。但是TLE了。不过有好的pta也是给了我21分（总分25。回来之后又想了想，查了一下资料，发现一种更好用的方法。参考文章：<a href="https://blog.csdn.net/king_cannon_fodder/article/details/75893967" target="_blank" rel="noopener">CSDN——职业炮灰</a><br>具体思路就是遍历字符串的每一个字符，每次循环中都对这个字符两边的字符进行判断，出现不一样的就退出内层循环。<br>这里面分有两种情况，一种是最长回文串的长度是奇数，一种是偶数。其实大体上是一样的。具体可以看代码</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    string s;    getline(cin,s);    int l=s.size(),len=0;    for(int i=0;i&lt;l;i++)    {        for(int j=0;i-j&gt;=0&amp;&amp;i+j&lt;l;j++)        {            if(s[i-j]!=s[i+j])                break;            len=2*j+1&gt;len?2*j+1:len;        }        for(int j=0;i-j&gt;=0&amp;&amp;i+j&lt;l;j++)        {            if(s[i-j]!=s[i+j+1])                break;            len=(2*j+2)&gt;len?(2*j+2):len;        }    }    cout&lt;&lt;len&lt;&lt;endl;    return 0;}</code></pre><h4 id="总结以及向对自己说的话"><a href="#总结以及向对自己说的话" class="headerlink" title="总结以及向对自己说的话"></a>总结以及向对自己说的话</h4><p>昨晚的天体训练赛垫底了。。。好多基础算法也都还不会，不能再沉迷于水题了，要学习。学习。学习！</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十届蓝桥杯</title>
      <link href="/2019/03/31/10th%20lq/"/>
      <url>/2019/03/31/10th%20lq/</url>
      
        <content type="html"><![CDATA[<p>原题：<a href="https://pan.baidu.com/s/1wof54ubWv5C6NlkcO8PwFA" target="_blank" rel="noopener">PDF版</a>提取码：xc2k<br><a href="https://pan.baidu.com/s/1bpRcQo_J0rfQXZTZjdwceA" target="_blank" rel="noopener">WORD版</a>提取码：w4go<br>早上要六点半在教学楼门口集合一起做大巴去赛点——河南科技学院。因为是周日，大早上的起来没几个人，校园里空荡荡的。准备好后就出发了，这个大巴的座非常舒服，去的路上风景也很好，心里既有害怕又有期待，第一次出去打比赛。</p><p>风景大好，去的路上我们也都聊得很开心。到了学校看到河南科技学院的大门还是比较震撼的，很高的门。并没有想象中的人山人海的感觉。机房里面气氛也很轻松。到了十一点多，负责人给我们发“午饭”。。。没人一根火腿，两个面包，一瓶水（水还没给我发，可能是因为我太菜，水都某的喝。这份300快的午餐还是很“丰盛”的嘛。比赛期间就一直听负责人说能提交的赶紧提交，有的电脑已经中了病毒。。。比赛完下午一点，本来好像是要直接走的，可是因为有些同学的电脑中了病毒，要进行延时，所以我们获得了差不多一个小时的活动时间。中间还叫上了一个本校的小姐姐给我们拍了合影嘻嘻。于是转了转学校周围吃了点饭，就出发回来了。<br>挺充实的一天，再说一下题目吧。可能是连题都没看太懂，总觉得有点简单，基本上都能写出来，但是超时应该还是会有的。等以后真题可以看到了，就在这里补题就完事了。<br>上面那三张照片是真好看，不过这肯定跟拍照的人没关系，肯定没有，没有（疯狂暗示。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于搭好了</title>
      <link href="/2019/03/30/finish/"/>
      <url>/2019/03/30/finish/</url>
      
        <content type="html"><![CDATA[<p>从寒假知道可以自己搭建博客以来，就一直在百度谷歌相关的东西。刚开始看到域名注册，虚拟主机一类什么高深的东西，显然不适合我这个小白。然后就看到了github——很强大的一个网站，具体是什么作用我也不很清楚，但是用这个可以搭建一个自己的博客网站，并且是不收费的。一直搜索，又安装了各种各样的软件，结果当然是失败了。结果就是，启动：绝地求生。。。<br>寒假开学之后，空余时间又看到了个人博客，很是羡慕别人，于是自己也想搭一个。于是我又开始了漫长的搜索，网上的好多教程大多数我都是看不懂的。。。毕竟电子竞技，菜是原罪。为此我还专门跑到学校图书馆找了一本书《GitHub入门到实践》，然后用自己的智商生生地把它读成了《Github从入门到放弃》。已经花费了这么多时间，自然是很不甘心的，我还是死磕着，鬼知道我经历了什么。“安装，卸载，安装，卸载。。。。。。”还有昨天晚上git下载模板用了四十分钟下载了2％，直到寝室熄灯下载还不到10％，气的我直接关掉了电脑。今天一上午的课都没好好听，一有时间就用手机搜索github搭博客的教程。中午回到寝室吃了饭就继续死磕，午休时间过去了，我下午没有课，室友有课，我一个人在寝室不停的找方法，找教程。<br>“功夫不负有心人”，我成功了。但是我的博客的搭建却更多归功于我的一个学长学霸（手动@亦往沧劫:stuck_out_tongue_winking_eye:，就这样），我自己实在折腾不出来了，就去找学长求助。最终在学长和学长博客的帮助下，我才搭好了。万分感谢！<br>最后还是总结一下我搭好博客的过程吧，防止今后再想搭却不会的情况，如果可能的话，也尽量帮一下想搭博客却不知道怎么做的小小白吧。我的系统是<code>windows</code>的。<br>总结教程大部分的内容来自我的学霸学长<br>他的搭建博客教程传送门:<a href="https://blog.todest.cn/post/hexo-next%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">https://blog.todest.cn/post/hexo-next%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</a></p><p>下面我来用我的语言和我的想法以及我在搭建过程中出现的问题总结一下<br>=<br>1.首先当然是需要注册一个<code>github</code>的账号（传送门：<a href="https://github.com/" target="_blank" rel="noopener">github</a>），这个注册我觉得不用详细的说，会用电脑的应改就会注册。注册好之后创建一个新的仓库，创建的时候<code>repositort name</code>必须保持格式<code>&lt;username&gt;.github.io</code>（username就是你的<code>github</code>账号的名字）。<br>2 .创建成功之后，先不要管这里了。去下载<code>git</code>（传送门：<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>），<code>Node.js</code>（传送门：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>），安装的时候好多勾勾怎么选我也不是很清楚，咳咳咳，不过相信我，这不是很重要:sweat_smile::sweat_smile::sweat_smile:。<br>3.该安装的东西都安装后，就该要配置SSH（传送门：<a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">SSH</a>）了。打开<code>git bash</code>，在弹出来的框框里输入</p><pre><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;        # 连续回车</code></pre><p>邮件地址就是你注册github时候用到的邮箱。连续回车一定要有哦:grin:。然后将<code>&quot;C:\Users\你的用户名\.ssh\id_rsa.pub&quot;</code>的内容复制下来，<code>打开GitHub设置-&gt;SSH and GPG keys-&gt;New SSH key</code>（注意这里的设置是整个网站的设置，不是仓库里面的那个设置！！！），粘贴到此处确定。继续向框框内输入</p><pre><code>ssh -T git@github.com</code></pre><p>以测试SSH是否配置好，如果看到<code>You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>,就说明配置好了。<br>4.接下来需要安装<code>hexo</code>，讲道理代码应该输入在<code>git bash</code>的框框里，可是我在安装的时候可能是因为有些勾勾没选所以在<code>git bash</code>中无法使用此命令,但是在cmd命令中可以正常使用。</p><pre><code>npm install hexo-cli -g</code></pre><p>这个命令是用来安装hexo的。安装好之后要初始化</p><pre><code>hexo init Blog</code></pre><p>这里的<code>Blog</code>是自己可以随意命名的，对应的会是在你的电脑中生成的文件夹的名称。初始化完成后，安装hexo扩展</p><pre><code>cd Blog         #进入Blog文件夹npm install hexo-deployer-git --savenpm install</code></pre><p>把上面的代码输入命令行，等到下载完就可以下一步了。<br>5.本地调试。</p><pre><code>hexo cleanhexo g                        # 生成  此条和后一条可简写为 hexo s -g（g是generate的缩写）hexo s                        # 预览（s是start的缩写）</code></pre><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a> 即可看到内容。<br>6.上传到GitHub pages。</p><pre><code>hexo cleanhexo g                        # 此条和后一条可简写为 hexo d -ghexo d                        #（d是deploy的缩写）</code></pre><p>等这些都完成得时候，你的博客也就基本上搭建完了，你可以自己去访问自己的博客了。当然我这里提到的只有最基础的搭建，具体还有更多的知识，我也在慢慢学习，并且愿意用博客记录这段历程。毕竟这是第一次博客，可能食用体验较差，望见谅。</p><p>   用女神纪念<br>-<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551260436887&amp;di=f57673ec3539ca0742091a807ac2ffef&amp;imgtype=0&amp;src=https%3A%2F%2Fwx4.sinaimg.cn%2Flarge%2Fa1ba8744ly1fo7wy0d0ofj21hc0u041m.webp" alt="别看了，这是我女神"></p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河南理工大学18级算法协会招新赛(第二场)非官方题解</title>
      <link href="/2019/03/30/zx2/"/>
      <url>/2019/03/30/zx2/</url>
      
        <content type="html"><![CDATA[<p>我校oj：<a href="https://hpuoj.com/" target="_blank" rel="noopener">HPUOJ</a><br>本场招新赛：<a href="https://hpuoj.com/contest/15/" target="_blank" rel="noopener">河南理工大学18级算法协会招新赛(第二场)</a></p><h3 id="A-wzy学长温暖的签到题"><a href="#A-wzy学长温暖的签到题" class="headerlink" title="A. wzy学长温暖的签到题"></a>A. wzy学长温暖的签到题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 1.0 秒</p><p>内存限制: 256 MB</p><p>每位ACMer（JBer）都是从a+b开始的！<br>作为本场比赛的良心出题人，怎么能忘记出a+b这么经典的题目呢？<br>请作为ACMer的你来尝试解决它吧！</p><p>输入<br>单组输入<br>每行输入两个实数a，b（用空格隔开）</p><p>输出<br>输出a+b的结果（结果保留两位小数）</p><p>样例<br>input<br>1 1<br>output<br>2.00<br>input<br>1.555 1.001<br>output<br>2.56<br>提示<br>0≤a,b≤100<br>请使用double定义变量，并使用%lf输入和输出</p><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>这道题确实没有什么难得，简单的a+b，很多人也都a了，提示写的明明白白(wzy学长是真的可爱</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;stdio.h&gt;int main(){    double a,b;    scanf(&quot;%lf %lf&quot;,&amp;a,&amp;b);    printf(&quot;%.2lf\n&quot;,a+b);    return 0;}</code></pre><h3 id="B-分糖果"><a href="#B-分糖果" class="headerlink" title="B. 分糖果"></a>B. 分糖果</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>Codancer 现在有n颗糖果，现在他要把这n颗糖果全部分给两个小朋友Dicer和thelittleboy,已知第i颗糖果能够使小朋友的开心值增加i,为了不让两个小朋友争吵，他必须使两个小朋友最终的开心值的差值最小化，现在Codancer很头疼，请你快来帮帮他吧QAQ。</p><p>输入<br>单组输入<br>输入一个数n,代表codancer的糖的数量。<br>(1≤n≤1000000000)</p><p>输出<br>输出两个小朋友的开心值的最小差值</p><p>样例<br>input<br>3<br>output<br>0<br>input<br>1<br>output<br>1</p><h4 id="题意分析-1"><a href="#题意分析-1" class="headerlink" title="题意分析"></a>题意分析</h4><p>输入一个数n，题意就是把从1-n个数分成两组让他们的和的差最小。这道题我看到第一感觉就是找规律，其实规律无非也就哪几种。这道题我们可以列出来几个情况求出来答案来找规律<br>1 2 3 4 5 6 7 8</p><pre><code>糖果数量  分配方案    最小差值1         1    0        12         1    2        13         1，2     3       04         1，4     2.3     05         1，2，5    3，4    16         1，2，3，5    4，6   17         1，2，5，6    3，4，7    08         4,6,8    1,2,3,5,7    0</code></pre><p>现在看起来规律就很明显了，1，1，0，0，1，1，0，0......<br>在找规律的过程中我发现从1到n的和如果是偶数，最小差值就是0，如果是奇数，最小差值就是1.于是我直接定义了一个求和函数后判断奇偶，直接T了。。。其实可以发现1100是四个一组出现的，直接n对4求余判断余数就好了。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;stdio.h&gt;int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    if(n%4==0||n%4==3)    puts(&quot;0&quot;);    else    puts(&quot;1&quot;);    return 0;}</code></pre><p>有些题掌握了规律实现起来就会很简单。<br>(什么时候codancer能给我们发糖吃呢</p><h3 id="C-中位数"><a href="#C-中位数" class="headerlink" title="C. 中位数"></a>C. 中位数</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>给出一个1−n的排列，统计该排列有多少个长度为奇数的连续子序列的中位数是k。中位数是指把所有元素从小到大排列后，位于中间的数。<br>接下来一行n个数代表这个排列。</p><p>输入<br>单组输入<br>一行两个数n,k代表排列的长度以及中位数。(1≤n≤100000,1≤k≤n)</p><p>输出<br>输出满足条件的区间个数。</p><p>样例<br>input<br>7 4<br>5 7 2 4 3 1 6<br>output<br>4<br>提示<br>样例解释：满足条件的区间为{4}, {7,2,4}, {5,7,2,4,3}和{5,7,2,4,3,1,6}。</p><h4 id="题意分析-2"><a href="#题意分析-2" class="headerlink" title="题意分析"></a>题意分析</h4><p>这道题刚看见以为是很简单的一道题，WA了几次之后才发现并不简单。最后好像也没几个人做出来这道题。学长讲的时候也没听懂。。咳咳，确实挺难。这两天为了更好的帮(ceng)助(re)大(du)家，这几天也是一直在搞这道题。不断地查阅资料，现在也差不多是搞懂了，快点来帮(ceng)助(re)大(du)家。<br>参考于：<a href="https://www.luogu.org/problemnew/solution/P1627" target="_blank" rel="noopener">洛谷P1627题解</a><br>中位数说明这个区间内大于他的数的数量与小于他的数的数量相等。且这个题中符合题意的区间顺序是必须与输入一样的，不能更改。<br>先找到中位数的位置标记一下，然后输入的同时对每一个数进行判断，大于中位数的标记为1，小于中位数的标记为-1。然后从中位数的左边开始第一次循环，对标记求和，如果有和为0的情况（即大于中位数的数的数量与小于中位数的数量相等），即说明这是一个符合题意的区间。接着对右边开始第二次循环，与第一次循环相等的步骤，但是要多一步，就是要考虑中位数位于区间中间（不是两端）的情况。具体可以在代码中解释。最后得到的答案还要加一，因为中位数自己一个区间也是可以的。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a[100050],flag[100050],f[200050];const int key=100000;int main(){    int n,k,bj,s,ans;    cin&gt;&gt;n&gt;&gt;k;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i];        if(a[i]==k)        bj=i;        else if(a[i]&gt;k)        flag[i]=1;        else     flag[i]=-1;    }//进行标记    s=ans=0;    for(int i=bj-1;i&gt;=1;i--)    {        s+=flag[i];        f[s+key]++;//用一个f数组来记录s为为-1，0，1时候的个数        if(s==0)    ans++;    }    s=0;    for(int i=bj+1;i&lt;=n;i++)    {        s+=flag[i];        if(s==0)    ans++;        ans+=f[-s+key];//中位数在区间中的情况。    }    ans+=1;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><p>咳咳，可以对着样例和代码自己跑一遍可以加深一下理解。</p><h3 id="D-打麻将"><a href="#D-打麻将" class="headerlink" title="D. 打麻将"></a>D. 打麻将</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>打麻将实在是太有趣了，不知道大家过年的时候有没有打麻将呢？</p><p>我是十分喜欢打麻将的，但是因为我不够聪明，所以我经常会诈胡(不具备胡牌的条件而胡牌)，因此我希望你能帮我判断一下我当前的手牌是否符合胡牌的条件。</p><p>为了简化这个问题，我们规定胡牌的条件如下：</p><p>你必须有且仅能有一个对子(即两张相同的牌)。<br>除了那个对子之外，其他的都是刻子(3张相同的牌)。(刻子的数量可以为0)<br>我们用两个字符表示一张麻将：</p><p>B，T, W 分别表示牌的种类为 筒子，条子，万子 。(可能你不知道这是什么意思，不过没有关系，你只需要知道这三种类型的牌是互不相同的。)<br>数字1~9表示牌上的数字。<br>另外用HZ，FC，BB，EE，WW，SS，NN 来分别表示除了 筒子，条子，万子 以外的 红中，发财，白板，东风，西风，南风，北风 。<br>对于两种牌来说，只要表示它们的两个字符中第一个字符或第二个字符任意一个不同，那么它们就是不同的牌，每种牌最多只有四张。(例如：B1 和 B2，B1 和 T1,HZ 和 FC 都是不同的。)<br>输入<br>第一行是一个数字T，表示你需要判断的次数。(1 \leq T \leq 10000)<br>接下来2*T行，前一行是一个数字 n 是你的手牌数，2≤n≤14，接下来一行有 n 对字符，每一对字符代表你的一张手牌。<br>保证不会有未知的牌型，不会有任何一种牌出现超过四次，但是你的手牌数因为某种原因可能会是正常出牌不能出现的个数。<br>输出<br>如果可以胡牌请输出 YES，否则输出 NO 。</p><p>样例<br>input<br>3<br>14<br>B1 B1 B1 T1 T1 T1 W1 W1 W1 HZ HZ HZ WW WW<br>2<br>BB BB<br>7<br>BB BB B1 B1 B1 B2 B2<br>output<br>YES<br>YES<br>NO</p><h4 id="题意分析-3"><a href="#题意分析-3" class="headerlink" title="题意分析"></a>题意分析</h4><p>题面看起来很长，但是我们需要学会如何找到有用的信息。这道题我们需要知道的就是我们手中的牌只能有一种是出现了两次，别的牌出现的只能是三次。思路一清晰实现起来就会简单点了。这道题如果按我的方法的话希望大家补一下相关的知识：基础容器之map以及c++中的string(用char数组应该也是可以的，但是string会方便一些)类型。更详细的解释我会加在代码里。</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    string s[15];    int n,a;    cin&gt;&gt;n;    map&lt;string,int&gt; ma;    while(n--)    {        ma.clear();//因为是多组输入，所以每次开始时都需要将map清空，避免干扰到下一次的判断。        int flag=1;        cin&gt;&gt;a;        for(int i=0;i&lt;a;i++)        {            cin&gt;&gt;s[i];            ma[s[i]]++;        }        map&lt;string,int&gt;::iterator it;        for(it=ma.begin();it!=ma.end();it++)        {            if(it-&gt;second==1||it-&gt;second==4)            {                flag=0;                break;            }//如果有出现一次的或者出现四次的，肯定不能胡牌。            if(it-&gt;second==2)                flag++;//判断出现两次的牌的数量。        }        if(flag==2)//因为flag定义时的赋值是1，所以如果现在的值是2则说明出项两次的牌（字符串）只有一个，符合条件，可以胡牌。否则就不能胡牌。        puts(&quot;YES&quot;);        else        puts(&quot;NO&quot;);    }    return 0;}</code></pre><p>(咳咳，我还是个麻将“高手”呢，</p><h3 id="E-假票"><a href="#E-假票" class="headerlink" title="E. 假票"></a>E. 假票</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>春天到了，万物复苏，乍暖还寒。H城为了庆祝春天的到来，将要举办一场盛大的舞会。</p><p>由于舞会非常的盛大，H城许多的居民都想参加舞会，但是舞厅大小有限，只能容纳n个人，为了防止到时候位置不够，人太拥挤，H城城主决定在舞会开始前进行售票。城主规定，每个人只能买一张票，每张票都会有其固定的编号（1~n）。但是有一个人，由于没抢到票，居然制造了一张与真票一模一样的假票！城主知道这个消息后，当然不能允许这种行为，因此就派出他最信任的大臣你去找出制造假票的人。</p><p>输入<br>多组输入，处理到文件结束</p><p>第一行两个数n,m (1&lt;=n&lt;=10000,0&lt;=m&lt;=n+1)，表示总共售出n张票，编号为 1 ~ n，m表示舞会当天到场的人数（注意：由于有些人可能当天有事来不了，这种情况下你可能找不到制造假票的人）。</p><p>接下来一行m个数a1,a2,.....,am，表示检票口收到的所有票的编号。</p><p>输出<br>如果能找到假票，则输出假票编号，否则输出-1。</p><p>样例<br>input<br>5 6<br>3 1 4 2 3 5<br>5 3<br>1 2 4<br>output<br>3<br>-1</p><h4 id="题意分析-4"><a href="#题意分析-4" class="headerlink" title="题意分析"></a>题意分析</h4><p>这个题还是比较容易读懂的，就是让你输出一组数中出现了两次的数。我一开始用的是先排序然后判断每一项与它后面那一项是否相等来判断是否有出现两次的，如果有，就将这个数输出，没有就输出<code>-1</code>，但是不知道为什么会WA，于是又改用了map，还好最后过了。</p><h4 id="补题"><a href="#补题" class="headerlink" title="补题"></a>补题</h4><p>排序的那种方法也是可以的，只不过因为是多组输入，因为第一次的输入票的数量如果比第二次输入的多，此时就可能会存在数组中还依然存在着一些上一组的数据，导致结果错误。参考我之前的错误代码发现其中判断是否相等的时候多循环了一次——最后一次，这就会导致WA了。改一下就行了。代码请看下面。（感谢学长哈）</p><p>这题我跟小伙伴讨论之后发现用set也是可以的，比较前后的和的大小即可，有兴趣的可以自己实现一下。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a[10050];int main(){    map&lt;int,int&gt; ma;    int n,m,b;    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        bool flag=1;        ma.clear();        while(m--)        {            cin&gt;&gt;b;            ma[b]++;        }        map&lt;int,int&gt;::iterator it;        for(it=ma.begin();it!=ma.end();it++)        {            if(it-&gt;second==2)            {                cout&lt;&lt;it-&gt;first&lt;&lt;endl;                flag=0;                break;            }        }        if(flag)        cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;    }    return 0;}#include&lt;bits/stdc++.h&gt;using namespace std;int a[10050];int main(){    int n,m;    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        int ans=-1;        for(int i=0;i&lt;m;i++)        {            cin&gt;&gt;a[i];        }        sort(a,a+m);        for(int i=0;i&lt;m-1;i++)        {            if(a[i]==a[i+1])            {                ans=a[i];                break;            }        }        if(ans!=-1)        cout&lt;&lt;ans&lt;&lt;endl;        else        puts(&quot;-1&quot;);    }    return 0;}</code></pre><h3 id="F-字符串博弈"><a href="#F-字符串博弈" class="headerlink" title="F. 字符串博弈"></a>F. 字符串博弈</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>一天Codancer和Todest玩游戏。现在有一个由大写字母组成的字符串s，Codancer和Todest轮流进行一下操作：<br>如果存在i使得s[i]=s[i+1],就可以把这两个字符从s中删除。比如原本s为ABBA,现在可以把BB删除，此时s就变为AA。<br>如果一方不能再执行此操作时，该方即为败者。现在Codancer先手，判断Codancer能否获胜。</p><p>输入<br>单组输入<br>输入字符串s。1≤|s|≤10000</p><p>输出<br>如果Codancer能够获胜输出”YES”,否则输出”NO”。(不加引号)。</p><p>样例<br>input<br>ABBA<br>output<br>NO</p><h4 id="题意分析-5"><a href="#题意分析-5" class="headerlink" title="题意分析"></a>题意分析</h4><p>我对这道题的理解就是将字符串中相邻且相同的两个字母消掉，消到不能再消，统计消除的次数就是能进行的回合数，再对回合数的奇偶进行判断就可以了。但是消除的实现还是用栈（不会的可以补一下知识，这个我的博客中也有相关的文章不过是偏实用性（就是只讲了几种函数的用法）的）比较轻松。关于栈的传送门：<a href="https://drew233.github.io/2019/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Uncle_drew最帅</a></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char s[10005];int main(){    stack&lt;char&gt; sta;    cin&gt;&gt;s;    int a=0;    for(int i=0;i&lt;strlen(s);i++)    {        if(i&gt;0)        {            if(sta.top()==s[i])            {                sta.pop();                a++;                continue;            }        }        sta.push(s[i]);    }    if(a%2==0)    puts(&quot;NO&quot;);    else    puts(&quot;YES&quot;);}</code></pre><p>(Todest很帅的，小学妹们抓住机会，ε=ε=ε=┏(゜ロ゜;)┛</p><h3 id="G-小w的过路费-暂无"><a href="#G-小w的过路费-暂无" class="headerlink" title="G. 小w的过路费(暂无)"></a>G. 小w的过路费(暂无)</h3><h3 id="H-超级简单的斐波那契数列"><a href="#H-超级简单的斐波那契数列" class="headerlink" title="H. 超级简单的斐波那契数列"></a>H. 超级简单的斐波那契数列</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 1.0 秒</p><p>内存限制: 256 MB</p><p>众所周知，斐波那契数列又称黄金分割数列，由数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入</p><p>斐波那契的通项公式为：</p><a href="https://www.kupan123.com/upload/1552350228x2063928140.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://www.kupan123.com/upload/1552350228x2063928140.webp" class="img-shadow img-margin"></center></a><p>计算斐波那契的第n项是一件容易的事，但是如果给出第n项的斐波那契数num，你能反推出n吗？</p><p>试一试吧！</p><p>输入<br>第一行一个整数T (0≤T≤100)，表示测试组数。<br>之后的T行，每行一个斐波那契数num (num≠0,1)</p><p>输出<br>对于每个测试数据，输出一行表示数num是斐波那契数列的第几项</p><p>样例<br>input<br>2<br>2<br>5<br>output<br>3<br>5<br>提示<br>保证num在斐波那契数列的前200000项中</p><h4 id="题意分析-6"><a href="#题意分析-6" class="headerlink" title="题意分析"></a>题意分析</h4><p>一开始我看错题，以为是数列的最大值不超过200000.。。。直接交了3次，WA了3次。。。所以说看题还是很重要的。我们昨天也都听学长说了，斐波(肥波)那契数列第50项已经爆了unsigned long long了。所以我们直接存是不现实的，这时候就需要存储的时候对其取模然后存储，并且用map存储一下每个值对应的斐波(肥波)那契数列的项数。因为输入的数会很大，所以我们需要用到字符串输入，然后用到一个很XX的东西——对字符串表示的大数取模。</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p>对用字符串输入的大数取模(感谢学长！</p><pre><code>        cin&gt;&gt;s;        ll ans,num;        ll l=strlen(s);        num=0;        for(ll i=0;i&lt;l;i++)        {            num=num*10+s[i]-&#39;0&#39;;            num%=maxx;        }//num就是这个大数取模之后的结果。</code></pre><pre><code>//这道题比赛的时候我是没写出来的，赛后补题。学会了大数取模屁颠屁颠的跑去交题#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx=1e9+7;typedef long long ll;ll f[200050];char s[100000];int main(){    map&lt;ll,ll&gt; ma;    f[0]=0;    f[1]=1;    for(ll i=2;i&lt;200001;i++)    {        f[i]=(f[i-1]+f[i-2])%maxx;        ma[f[i]]=i;    }//对斐波(肥波)那契数列进行取模存储    ll n;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;s;        ll ans,num;        num=0;        for(ll i=0;i&lt;strlen(s);i++)        {            num=num*10+s[i]-&#39;0&#39;;            num%=maxx;        }        cout&lt;&lt;ma[num]&lt;&lt;endl;            }    return 0;}//然后TLE了。。。观察一下(hao jiu)代码会发现我在大数取模的for循环里面每次都对s的长度重新求一次，这样是很耗费时间的，自然会tle，改一下就好#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx=1e9+7;typedef long long ll;ll f[200050];char s[100000];int main(){    ios::sync_with_stdio(false);    map&lt;ll,ll&gt; ma;    f[0]=0;    f[1]=1;    for(ll i=2;i&lt;200001;i++)    {        f[i]=(f[i-1]+f[i-2])%maxx;        ma[f[i]]=i;    }    ll n;    cin&gt;&gt;n;    while(n--)    {        cin&gt;&gt;s;        ll ans,num,l;        l=strlen(s);//先把长度求出来，用的时候直接用        num=0;        for(ll i=0;i&lt;l;i++)        {            num=num*10+s[i]-&#39;0&#39;;            num%=maxx;        }        cout&lt;&lt;ma[num]&lt;&lt;endl;            }    return 0;}取模的部分也可以这样写        for(ll i=0;i&lt;s.length();i++)        {            num=num*10+s[i]-&#39;0&#39;;            num%=maxx;        }</code></pre><h3 id="I-斐波那契（非递归）"><a href="#I-斐波那契（非递归）" class="headerlink" title="I. 斐波那契（非递归）"></a>I. 斐波那契（非递归）</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>请输出斐波那契的第n项</p><p>输入<br>多组输入处理到文件结束，每组输入一个数n。1≤n≤10000</p><p>输出<br>输出第n个斐波那契数对109+7取模的结果</p><p>样例<br>input<br>3<br>4<br>output<br>2<br>3</p><h4 id="题意分析-7"><a href="#题意分析-7" class="headerlink" title="题意分析"></a>题意分析</h4><p>简单的斐波(肥波)那契数列问题，与J题差不多，不过加了取模。直接代码就行了。</p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn=1e9+7;ll f[10005];int main(){    f[0]=0;    f[1]=1;    for(int i=2;i&lt;10001;i++)    {        f[i]=f[i-1]+f[i-2];        f[i]=f[i]%maxn;    }//打表    int a;    while(~scanf(&quot;%d&quot;,&amp;a))    {        cout&lt;&lt;f[a]&lt;&lt;endl;    }    return 0;}</code></pre><h3 id="J-斐波那契数列"><a href="#J-斐波那契数列" class="headerlink" title="J. 斐波那契数列"></a>J. 斐波那契数列</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>请输出斐波那契的第n项</p><p>输入<br>单组输入<br>每组输入一个数n。0≤n≤10</p><p>输出<br>输出斐波那契数列的第n项</p><p>样例<br>input<br>0<br>output<br>0<br>input<br>1<br>output<br>1</p><h4 id="题意分析-8"><a href="#题意分析-8" class="headerlink" title="题意分析"></a>题意分析</h4><p>妥妥的签到</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;stdio.h&gt;int a[15];int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    a[0]=0;    a[1]=1;    for(int i=2;i&lt;=10;i++)    {        a[i]=a[i-1]+a[i-2];    }//打表    printf(&quot;%d\n&quot;,a[n]);    return 0;}</code></pre><p>咳咳，写这个“题解”，我是为了帮助同学，没有骗访问量没有没有。有不懂的可以直接qq我或者网页右下角有一个可以实时联系我的小框框你们可以直接跟我聊天，看见就会回复的，有什么不同的想法和思路可以在评论区发表一下意见，毕竟不是官方题解，考虑的可能不周全莫名其妙的a题，集思广益。</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Useful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不翻墙使用谷歌搜索的方法</title>
      <link href="/2019/03/28/google-search/"/>
      <url>/2019/03/28/google-search/</url>
      
        <content type="html"><![CDATA[<p>我用的软件</p><p>emm，神奇的是这个好像又可以直接添加插件了。。。<br>一个小哥哥(@Faye)如是说:打开谷歌浏览器，点击右上角的三个点，进入菜单。找到更多工具选项，扩展程序就在那里面。点击进入页面后后，在右上角有一个开发者模式，点击打开。再把下载的CRX格式的插件文件用鼠标拉到扩展程序的页面，再在弹出的窗口中点击“添加扩展程序”，插件就安装上去了(๑•̀ㅂ•́)و✧(这颜文字用的，想撩他的联系我</p><p>不行的话就往下看吧。</p><ul><li>Google Chrome(这个大家可以去直接搜索会有可以下载的)</li><li><a href="https://pan.baidu.com/s/1iaWRmiOSBAFDN5JYroHY8w" target="_blank" rel="noopener">插件伴侣</a> 提取码：dmom</li><li><a href="https://pan.baidu.com/s/151m9AgSXF70X57PFbruBpg" target="_blank" rel="noopener">谷歌访问助手</a>的插件  提取码：virl<br>应该是每个浏览器都会有相应的插件，有需要的请自己去找，我在这里只提供chrome的相关软件。<br>为什么需要插件伴侣：谷歌浏览器自Chrome67版本以后，我们从第三方下载站，自己下载插件文件，然后拖放到浏览器安装。这种方式，已经被谷歌官方禁止了！<a href="https://thyrsi.com/t6/677/1551967787x2890191853.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551967787x2890191853.webp" class="img-shadow img-margin"></center></a>点击打开之后，会出现以下的界面<a href="https://thyrsi.com/t6/677/1551967833x2890191853.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551967833x2890191853.webp" class="img-shadow img-margin"></center></a>点击选择插件，找到自己下载的访问助手的插件<a href="https://thyrsi.com/t6/677/1551967925x2890191853.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551967925x2890191853.webp" class="img-shadow img-margin"></center></a>开始安装<a href="https://thyrsi.com/t6/677/1551968008x2890191853.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551968008x2890191853.webp" class="img-shadow img-margin"></center></a>注意下面会有一个isearch插件默认是安装的，不想要的话可以把勾点掉。安装的时候是需要退出浏览器的<a href="https://thyrsi.com/t6/677/1551968113x2890191853.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551968113x2890191853.webp" class="img-shadow img-margin"></center></a>然后点击安装就成功了<a href="https://thyrsi.com/t6/677/1551968172x2890191655.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551968172x2890191655.webp" class="img-shadow img-margin"></center></a>下面就是打开你的google浏览器，按照提示一步一步走下去就行，因为我之前已经安装过了，下面这些简单的步骤就不再赘述了。<br>安装成功的效果<a href="https://thyrsi.com/t6/677/1551968354x2728278668.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551968354x2728278668.webp" class="img-shadow img-margin"></center></a><a href="https://thyrsi.com/t6/677/1551968347x2728278668.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551968347x2728278668.webp" class="img-shadow img-margin"></center></a><a href="https://thyrsi.com/t6/677/1551968360x2728278668.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/677/1551968360x2728278668.webp" class="img-shadow img-margin"></center></a>如果安装步骤出现问题或者不知道该怎么做，我分享的压缩包里有一个pdf文件里面有比较详细的内容，可以参考一下。<br>至此，你就可以愉快的使用谷歌搜索了，还有G-mail之类的都慢慢的探索吧，并且可以添加更多的插件来提高你的体验感。<br>以上这种方法在pc端可以实现。</li></ul><p>另外，<a href="https://www.hlhmf.com/" target="_blank" rel="noopener">https://www.hlhmf.com/</a><br>谷歌镜像，可以直接使用谷歌搜索，手机电脑均可用。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德鲁大叔观后感</title>
      <link href="/2019/03/27/movie-drew/"/>
      <url>/2019/03/27/movie-drew/</url>
      
        <content type="html"><![CDATA[<p><center>德鲁大叔</center><br>　　第一次听说德鲁大叔这个词是某可乐的广告，刚刚沉迷于篮球的我，在网上把几部广告都看完了。讲的是我欧文和NBA的球星换上老人妆去街球场扮猪吃老虎的故事。广告毕竟是短的，但是还是能体现出欧文的骚气的哈哈。<a id="more"></a><br>　　然后经听说了欧文拍摄了这部电影，还是很期待的，但是网上各种消息说内地是不会上映的，两分钟的宣传片不知道看了多少遍。应该是上年的十月份左右吧，这部电影上映了，果然内地没有，在网上各种找资源啊，一开始还没有，过了一两个月，慢慢的找到了资源，刚找到的那天我第一次在学校熬夜了，熬夜看完了这部电影，怎么会有这么好看的电影，这是我的第一感觉，满满的都是震撼，我都不知道该怎么去描述。通过一场球赛映射出慢慢的人生道理，让我对欧文的崇拜愈发加深。那一晚我截下了好多精彩照片，但是由于特殊原因丢失了，但是德鲁大叔这部电影在我的手机和电脑上都有存着。用痴迷来形容我是很贴切的，一有时间就看那部电影，现在我还能回忆起来那部电影从开头到结尾的每一帧画面，每一句经典的台词。上学期英语老师组织电影配音，我毫不犹豫地选择了这部电影，哈哈毕竟喜欢。<br>　　最振奋人心的就是又过了一段时间，有消息说要在内地上映了，我没去看首映，不想自己一个人去看的。可是第二天我没忍住还是去看了，但我买了两张票，我幻想着她就在我身边跟我一起看。整个放映厅除了我没别人了，真的感觉的不值，真正有意义的电影没人看。<br>　　这部电影讲的就是一个因为年少时一次失误的篮球少年从打球到教练并且赌上自己的一切想要获得洛克公园的冠军的故事，但是他的死对头夺走了他的球队还有他的女友。他开始到处去寻找组建自己新的球队，却到处碰壁，接着他遇见了德鲁大叔，在整部电影里如神一般的存在，德鲁大叔带着他一起找回当年的队友，准备拿回当年因为特殊原因失去的冠军，中间历经很多磨练，最后由篮球少年的一次绝杀夺得了冠军正好与他年少时的失误有了一个对比。剧情虽然简单，甚至有点狗血，但我觉得只要是我们打球的人都会感动，眼酸。成长就行一场球赛，总会有许多的磕磕绊绊，但是我们能做的只有克服它，迎难而上。<br>　　其实关于这部电影感触这么深还是因为篮球吧，高二开始接触篮球，现在已经三年了，时间虽然不长，但是它的魅力早就深深的吸引住了我，甚至不再允许我有其他的爱好了，因为时间都想给它。晚上不吃饭去打球，中午不睡觉去打球，逃课打球，不开心时打球，高兴时打球，它能治愈你所有的负面状态，每次都仿佛打不完，打完球回到教室趴在座位上睡一觉，这种日子已经一去不复返了。<br>　　有句话很对：无篮球不兄弟，因为篮球我结识了我最好的兄弟，也认识了很多有趣的人。可能你们本不认识，但在球场上一起打一次球就会很熟了。我喜欢篮球，感谢它带给我的一切。</p><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804103315.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804103315.webp" class="img-shadow img-margin"></center></a><p>我喜欢的台词</p><ul><li>It&#39;s like a perfectly orchestrated symphony.</li><li><p>打篮球就像演奏一首精心编排的交响乐</p></li><li><p>And what&#39;s in it for you?</p></li><li>Love,yongblood.Only love.</li><li>那你是为了什么打篮球？</li><li><p>热爱，小伙子，只有热爱。</p></li><li><p>It&#39;s getting to be about that time,ain&#39;t it?</p></li><li><p>是时候展现真正的技术了 不是吗？</p></li><li><p>There&#39;s a fine line between confidence and arrogance.</p></li><li><p>自信与自大 界限分明</p></li><li><p>This game is all mental.All mental.</p></li><li><p>篮球运动关乎精神状态 精神状态</p></li><li><p>Hand down,man down</p></li><li><p>真是手起刀落</p></li><li><p>Once a shooter,always a shooter.</p></li><li><p>一朝为投手 终身是投手</p></li><li><p>You don&#39;t stop playing &#39;couse you get old.You get old &#39;cause you stop playing.</p></li><li><p>你不是因为老了才不打球，而是你决定不打球的那一刻，你才是真的老了。</p></li><li><p>Nothing a few Ws can&#39;t fix.</p></li><li><p>没有什么是赢点球解决不了的</p></li><li><p>Play the game the right way,it fixs everything.</p></li><li><p>用最恰当的方式打一场比赛 会修复一切</p></li><li><p>What&#39;s there not to love?</p></li><li><p>篮球有让人不爱上的理由吗</p></li><li><p>Basketball&#39;s the most reliable thing in the world.Don&#39;t complain,don&#39;t ask any questions.You bounce it,comes right back up.</p></li><li>篮球是世界上最可靠的东西 不要抱怨 也不要问任何问题 你运球 然后它弹回你手里</li></ul><p>唯她，篮球与兄弟不可辜负。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Even Substrings</title>
      <link href="/2019/03/26/Even%20Substrings/"/>
      <url>/2019/03/26/Even%20Substrings/</url>
      
        <content type="html"><![CDATA[<h3 id="1139-A-Even-Substrings"><a href="#1139-A-Even-Substrings" class="headerlink" title="1139 A Even Substrings"></a><center>1139 A Even Substrings</center></h3><p>cf传送门：<a href="https://codeforces.com/problemset/problem/1139/A" target="_blank" rel="noopener">Even Substrings</a><br>vj传送门：<a href="https://cn.vjudge.net/problem/CodeForces-1139A" target="_blank" rel="noopener">Even Substrings</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>You are given a string s=s1s2…sn of length n, which only contains digits 1, 2, ..., 9.</p><p>A substring s[l…r] of s is a string slsl+1sl+2…sr. A substring s[l…r] of s is called even if the number represented by it is even.</p><p>Find the number of even substrings of s. Note, that even if some substrings are equal as strings, but have different l and r, they are counted as different substrings.</p><p>Input<br>The first line contains an integer n (1≤n≤65000) — the length of the string s.</p><p>The second line contains a string s of length n. The string s consists only of digits 1, 2, ..., 9.</p><p>Output<br>Print the number of even substrings of s.</p><p>Examples<br>Input<br>4<br>1234<br>Output<br>6<br>Input<br>4<br>2244<br>Output<br>10<br>Note<br>In the first example, the [l,r] pairs corresponding to even substrings are:</p><p>s[1…2]<br>s[2…2]<br>s[1…4]<br>s[2…4]<br>s[3…4]<br>s[4…4]<br>In the second example, all 10 substrings of s are even substrings. Note, that while substrings s[1…1] and s[2…2] both define the substring &quot;2&quot;, they are still counted as different substrings.</p><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>这道题说实话直接看我真的看不懂，然后我借助翻译，，，发现还是看不懂。经过一段时间的挣扎和猜题意终于是看懂了这道题。<br>这道题就是输入一个字符串，让我们判断它的子串中<code>偶数</code>的个数，偶数指的就是把子串看成是整形的偶数。字符串的长度最大时65000，所以两重for是肯定不能用的，这时候就显现出了思维的重要性。如果这个字符串表示的数是偶数，那么它的最后一位一定是2或2的倍数。根据这一点就可以判断了。具体看代码</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    int n;    string s,l;    cin&gt;&gt;n&gt;&gt;s;    int ans=0;    for(int i=0;i&lt;n;i++)    {        if((s[i]-&#39;0&#39;)%2==0)            ans+=(i+1);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Thinking </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Game 23</title>
      <link href="/2019/03/26/Game%2023/"/>
      <url>/2019/03/26/Game%2023/</url>
      
        <content type="html"><![CDATA[<h3 id="1141A-Game-23"><a href="#1141A-Game-23" class="headerlink" title="1141A Game 23"></a><center>1141A Game 23</center></h3><p>cf传送门：<a href="https://codeforces.com/problemset/problem/1141/A" target="_blank" rel="noopener">Game 23</a><br>vj传送门：<a href="https://cn.vjudge.net/problem/CodeForces-1141A" target="_blank" rel="noopener">Game 23</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><center>A. Game 23</center><br>Polycarp plays &quot;Game 23&quot;. Initially he has a number n and his goal is to transform it to m. In one move, he can multiply n by 2 or multiply n by 3. He can perform any number of moves.</p><p>Print the number of moves needed to transform n to m. Print -1 if it is impossible to do so.</p><p>It is easy to prove that any way to transform n to m contains the same number of moves (i.e. number of moves doesn&#39;t depend on the way of transformation).</p><p>Input<br>The only line of the input contains two integers n and m (1≤n≤m≤5⋅108).</p><p>Output<br>Print the number of moves to transform n to m, or -1 if there is no solution.</p><p>Examples<br>Input<br>120 51840<br>Output<br>7<br>Input<br>42 42<br>Output<br>0<br>Input<br>48 72<br>Output<br>-1<br>Note<br>In the first example, the possible sequence of moves is: 120→240→720→1440→4320→12960→25920→51840. The are 7 steps in total.</p><p>In the second example, no moves are needed. Thus, the answer is 0.</p><p>In the third example, it is impossible to transform 48 to 72.</p><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>因为是全英文的题面，我选择了先看样例，又看到了提示，因为紧张加小激动我把题意理解错了。。。以为是个水题（对大佬是真水题吧）。题目要求就是输入两个数，问你从第一个数变成第二个数需要几步，变化的方法是乘以2或者乘以3，如果可以，输出步数，不可以的话就输出“-1”，听学长说是质因子分解，可是我不会（哈哈哈哈，以后会了再来试试。经过我跟小伙伴的一波探讨发现可以用第二个数对第一个数先求余，如果余数不为0，直接输出“-1”。余数如果为0，就对两数的商进行处理，除以三能除尽就一直除直到除不尽，再判断，如果除以二能除尽就一直除直到除不尽，每循环一次次数加一，最后都除不尽的时候需要在进行一次判断了看现在的商是不是1，如果不是则说明变化的过程中只有二和三是不够的，所以需要输出“-1”，反之输出次数即可。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll n,m,k,a,b;    cin&gt;&gt;n&gt;&gt;m;    if(m%n!=0)        cout&lt;&lt;&quot;-1&quot;;    ll s=0;    if(m%n==0)    {        k=m/n;        while(k%3==0)        {            k/=3;            s++;        }        while(k%2==0)        {            k/=2;            s++;        }        if(k!=1)        {            cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;            return 0;        }        cout&lt;&lt;s;    }    cout&lt;&lt;endl;    return 0; }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Thinking </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD和LCM</title>
      <link href="/2019/03/26/GCD%E5%92%8CLCM/"/>
      <url>/2019/03/26/GCD%E5%92%8CLCM/</url>
      
        <content type="html"><![CDATA[<h2 id="GCD-最大公约数"><a href="#GCD-最大公约数" class="headerlink" title="GCD(最大公约数)"></a><center>GCD(最大公约数)</center></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>　　<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B8" target="_blank" rel="noopener">gcd</a>,最大公因数（英语：highest common factor，hcf）也称最大公约数（英语：greatest common divisor，gcd）是数学词汇，指能够整除多个整数的最大正整数。而多个整数不能都为零。</p><h3 id="c-c-语言实现求GCD"><a href="#c-c-语言实现求GCD" class="headerlink" title="c/c++语言实现求GCD"></a>c/c++语言实现求GCD</h3><p>　　求两个整数最大公约数主要的方法有：</p><ul><li>穷举法</li><li>素因数分解</li><li>短除法</li><li>辗转相除法<br>　　这里我们主要用辗转相除法(又称欧几里得算法)求最大公因数。<br><a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95" target="_blank" rel="noopener">辗转相除法</a>：用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。<br>具体代码实现</li></ul><pre><code>int gcd(int x,int y){    if(y==0)        return x;    else        return gcd(y,x%y);}//这种方法可以用到三目运算符来简化代码int gcd(int x.int y){    return y==0?x:gcd(y,x%y);}</code></pre><p>上面这种写法用到了递归，还有就是不用递归的写法</p><pre><code>int gcd(int x,int y){    int z;    while(y!=0)    {        z=x%y;        x=y;        y=z;    }    return x;}</code></pre><p>上面两种写法本质上是一样的，就是辗转相除法.</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><center>HDUOJ 2504</center><br>题目描述<br>又见GCD<br>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p><p>有三个正整数a,b,c(a,b,c是三个大于0小于1e6的数)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。</p><p>Input<br>第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。</p><p>Output<br>输出对应的c，每组测试数据占一行。</p><p>Sample Input<br>2<br>6 2<br>12 4<br>Sample Output<br>4<br>8<br>题目分析<br>这是一道简单的考察最大公约数的问题。给定两个数a,b求满足<code>gcd(a,c)=b</code>的最小的c的值且c不等于b。数据范围在1e6以内，并且c是b的倍数，所以可以每次给b加c，每次判断是不是答案即可。即</p><pre><code>c=2*b;    //因为b是a,c的最大公约数，所以c肯定是大于等于b的。又因为题目中了b不等于c，所以给c定初值为2*b。while(gcd(a,c)!=b)    b+=c;    //c是b的倍数，所以可以每次给b加c</code></pre><p>完整代码实现</p><pre><code>#include&lt;stdio.h&gt;int gcd(int x,int y){    if(y==0) return x;    return gcd(y,x%y);}int main(){    int a,b,n;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);        int c=2*b;        while(gcd(a,c)!=b)        c+=b;        printf(&quot;%d\n&quot;,c);    }    return 0;}</code></pre><p>在vj上提交运行的结果</p><a href="https://thyrsi.com/t6/676/1551749214x2728278668.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551749214x2728278668.webp" class="img-shadow img-margin"></center></a><h2 id="LCM-最小公倍数"><a href="#LCM-最小公倍数" class="headerlink" title="LCM(最小公倍数)"></a><center>LCM(最小公倍数)</center></h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B8" target="_blank" rel="noopener">LCM</a>,两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。</p><h3 id="c-c-实现求LCM"><a href="#c-c-实现求LCM" class="headerlink" title="c/c++实现求LCM"></a>c/c++实现求LCM</h3><p>n个数的最小公倍数就等于这n个数乘积的绝对值除以这n个数的最大公约数。即<code>lcm(a,b)=a*b/gcd(a,b)</code>。换句话说就是，如果n个数以及这n个数的最大公约数已知，就能求出这n个数的最小公倍数。<br>具体代码实现</p><pre><code>int gcd(int x,int y){    return y==0?x:gcd(y,x%y);}int lcm(int x,int y){    return x*y/gcd(x,y);}</code></pre><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p><center>蓝桥杯历届试题 核桃的数量</center><br>题目描述<br>历届试题 核桃的数量<br>时间限制：1.0s   内存限制：256.0MB</p><p>问题描述<br>小张是软件项目经理，他带领3个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是：</p><ol><li>各组的核桃数量必须相同</li><li>各组内必须能平分核桃（当然是不能打碎的）</li><li>尽量提供满足1,2条件的最小数量（节约闹革命嘛）</li></ol><p>输入格式<br>输入包含三个正整数a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c是三个小于30的数）<br>输出格式<br>输出一个正整数，表示每袋核桃的数量。<br>样例输入1<br>2 4 5<br>样例输出1<br>20<br>样例输入2<br>3 1 1<br>样例输出2<br>3<br>题目分析 经过看题的过程可以发现这只是一个让求三个数的最小公倍数的水题，直接写就行。<br>具体代码实现</p><pre><code>#include&lt;stdio.h&gt;int gcd(int x,int y){    return y==0?x:gcd(y,x%y);}int lcm(int x,int y){    return x*y/gcd(x,y);}int main(){    int a,b,c;    scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);    printf(&quot;%d\n&quot;,lcm(lcm(a,b),c));    return 0;}</code></pre><p>在蓝桥评测系统上提交运行的结果</p><a href="https://thyrsi.com/t6/676/1551749245x2728278668.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551749245x2728278668.webp" class="img-shadow img-margin"></center></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于最大公约数以及最小公倍数的东西先总结到这里，以后再有拓展的话会继续添加。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo背景的更换</title>
      <link href="/2019/03/26/Hexo-bgchange/"/>
      <url>/2019/03/26/Hexo-bgchange/</url>
      
        <content type="html"><![CDATA[<p>首先我选择换一个背景，因为简单（手动滑稽）。<br>我通过我经过换背景的<del>愉快</del>艰辛历程总结一下换背景的一些经验。<br>找到自己喜欢的图片，把它放进文件<code>myblog\themes\next\source\images</code>(博客主题中的文件夹)<br>然后去找到<code>myblog\themes\next\source\css\_custom</code>中的<code>custom.styl</code><br>在里面填入代码</p><pre><code>body{    background:url(https://cdn.jsdelivr.net/gh/drew233/cdn/(你选择要作为背景的图片).webp);    background-size:cover;    background-repeat:no-repeat;    background-attachment:fixed;    background-position:center;}</code></pre><p>然后重新载入一次就可以看到自己的背景了。浅色背景还好，如果背景颜色较深，需要更改透明度什么的，我继续学习！！！</p><a href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1551336624317&di=87485d465f2c9a25e1401b102f9cfb71&imgtype=0&src=https%3A%2F%2Fplayhard.me%2Fwp-content%2Fuploads%2F2015%2F07%2F170.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1551336624317&di=87485d465f2c9a25e1401b102f9cfb71&imgtype=0&src=https%3A%2F%2Fplayhard.me%2Fwp-content%2Fuploads%2F2015%2F07%2F170.webp" class="img-shadow img-margin"></center></a>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map的应用之Summarize to the Power of Two</title>
      <link href="/2019/03/26/Summarize-to-the-Power-of-Two/"/>
      <url>/2019/03/26/Summarize-to-the-Power-of-Two/</url>
      
        <content type="html"><![CDATA[<h2 id="CodeForces-1005C-Summarize-to-the-Power-of-Two"><a href="#CodeForces-1005C-Summarize-to-the-Power-of-Two" class="headerlink" title="CodeForces - 1005C   Summarize to the Power of Two"></a>CodeForces - 1005C   Summarize to the Power of Two</h2><p>cf原题传送门:<a href="https://codeforces.com/problemset/problem/1005/C" target="_blank" rel="noopener">cf真好玩</a><br>vjudge传送门:<a href="https://cn.vjudge.net/problem/CodeForces-1005C" target="_blank" rel="noopener">cf真好玩</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>A sequence a1,a2,…,an is called good if, for each element ai, there exists an element aj (i≠j) such that ai+aj is a power of two (that is, 2d for some non-negative integer d).</p><p>For example, the following sequences are good:</p><p>[5,3,11] (for example, for a1=5 we can choose a2=3. Note that their sum is a power of two. Similarly, such an element can be found for a2 and a3),<br>[1,1,1,1023],<br>[7,39,89,25,89],<br>[].<br>Note that, by definition, an empty sequence (with a length of 0) is good.</p><p>For example, the following sequences are not good:</p><p>[16] (for a1=16, it is impossible to find another element aj such that their sum is a power of two),<br>[4,16] (for a1=4, it is impossible to find another element aj such that their sum is a power of two),<br>[1,3,2,8,8,8] (for a3=2, it is impossible to find another element aj such that their sum is a power of two).<br>You are given a sequence a1,a2,…,an. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.</p><p>Input<br>The first line contains the integer n (1≤n≤120000) — the length of the given sequence.</p><p>The second line contains the sequence of integers a1,a2,…,an (1≤ai≤109).</p><p>Output<br>Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all n elements, make it empty, and thus get a good sequence.</p><p>Examples<br>Input<br>6<br>4 7 1 5 4 9<br>Output<br>1<br>Input<br>5<br>1 2 3 4 5<br>Output<br>2<br>Input<br>1<br>16<br>Output<br>1<br>Input<br>4<br>1 1 1 1023<br>Output<br>0<br>Note<br>In the first example, it is enough to delete one element a4=5. The remaining elements form the sequence [4,7,1,4,9], which is good.</p><h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>啊，熟悉的全英文题面，虽然看起来有点吃力但还是要看的，不记得了之前在哪里听到过这样一句话，做程序员，不能排斥英语，你要学会去适应。也把这句话送给和我一样的小白白们。<br>其实仔细看看还是可以懂个大概的，然后就可以看样例猜题意了。这道题的意思是给你一组数，每个数都可以和另外任意一个数（不包括他自己）进行求和，如果求和之后是2的N次方，这个数就可以存在在这个数列中。如果有一个数，和其他任意一个数相加都不是2的N次方，这个数就不符合要求，题目中要求输出的就是不符合条件的数字的个数（可以为0）。我一开始想着暴力判断再慢慢优化，然后发现我的优化能力不是很强（😭逃。然后想到了map。用2的N次方减去每一个数，判断差是否存在。具体看代码实现。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[200000];int main(){    map&lt;ll,ll&gt; ma;    ll n,i,k,ans=0;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    {        cin&gt;&gt;a[i];        ma[a[i]]++;//对a[i]出现的次数进行计数    }    for(int i=0;i&lt;n;i++)    {        ll er=1,g=0,j=0;        for(int j=0;j&lt;31;j++)        {            if(ma[er-a[i]]!=0)//ma[er-a[i]]不为零说明差值在数列中存在            {                if(er-a[i]==a[i])//如果差值为它自己，就需要接着判断                {                    if(ma[a[i]]&gt;1)                        g++;                }                else    g++;            }            er*=2;//er就是2的N次方        }        if(g==0)    ans++;//g为0则说明差值不存在或者差值与a[i]相等且a[i]只出现一次，即a[i]不是符合条件的数。    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>随着慢慢的刷题，发现这些容器，函数什么的都贼好用，解决问题的时候应该多往这方面想一想。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>祝某凡生日快乐</title>
      <link href="/2019/03/26/bir%20hap/"/>
      <url>/2019/03/26/bir%20hap/</url>
      
        <content type="html"><![CDATA[<p>今天我姐某凡生日快乐，22了，永远18！(手动滑稽，祝她生日快乐。记住了今天！！！<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804080954.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20190804080954.webp" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德鲁大叔学编程搭建基本完成</title>
      <link href="/2019/03/26/drew-finish/"/>
      <url>/2019/03/26/drew-finish/</url>
      
        <content type="html"><![CDATA[<p>经过了将近十天时间的折腾，各种各样的查阅资料，各种<del>骚扰</del>麻烦学长，终于是差不多像样了。这期间花费了大量时间，作业都不写了，有点太丧心病狂。结果还是不错的，哈哈。<br>　　一些还没解决但是还在想解决办法(没什么大问题)的待办项</p><ul><li>[x] 把离家出走的DaoVoice小图标找回来(昨天应该是DaoVoice哪里出了一些问题，今天它自己回来了)</li><li>[] 添加收款码可以预览的功能</li><li>[x] 让谷歌收录我的网站！！！</li><li>[x] 实现彩色标签<br>主要遇到的问题基本上是由next主题的版本引起的，这个还是比较忧伤的，教程中的next版本跟我的不一样，好多东西要摸索着来。<br>重点就是站点配置文件以及主题配置文件应该好好看看，很有帮助。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学程序作业</title>
      <link href="/2019/03/26/li%20san/"/>
      <url>/2019/03/26/li%20san/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章作业"><a href="#第一章作业" class="headerlink" title="第一章作业"></a><center>第一章作业</center></h2><h3 id="能够输入五个连接词符号"><a href="#能够输入五个连接词符号" class="headerlink" title="能够输入五个连接词符号"></a>能够输入五个连接词符号</h3><p>据说这些个符号也可以在各种输入法的表情符号里找到，那样时会很方便哈！下面我来总结一下我发现的方法</p><pre><code>∧ 合取 unicode十六进制：2227∨ 析取 unicode十六进制：2228¬ 非 unicode十六进制：00AC(不区分大小写) Ascii十进制： 172</code></pre><p>以上三种符号均可以在进入WPS后点击菜单栏的插入--符号--其他符号选项中进行添加，自己找这些符号也可以在弹出的框框里面选择编码以及对应的值直接搜索到。</p><a href="https://thyrsi.com/t6/676/1551782952x1822611383.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551782952x1822611383.webp" class="img-shadow img-margin"></center></a><a href="https://thyrsi.com/t6/676/1551782997x1822611383.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551782997x1822611383.webp" class="img-shadow img-margin"></center></a><a href="https://thyrsi.com/t6/676/1551783012x1822611383.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551783012x1822611383.webp" class="img-shadow img-margin"></center></a><a href="https://thyrsi.com/t6/676/1551783026x1822611383.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551783026x1822611383.webp" class="img-shadow img-margin"></center></a><pre><code>↔ 等价→ 蕴涵</code></pre><p>以上两种符号可以在插入--公式--插入新公式中找到。</p><a href="https://thyrsi.com/t6/676/1551783056x1822611383.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551783056x1822611383.webp" class="img-shadow img-margin"></center></a><a href="https://thyrsi.com/t6/676/1551783071x1822611383.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551783071x1822611383.webp" class="img-shadow img-margin"></center></a><a href="https://thyrsi.com/t6/676/1551783096x1822611209.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551783096x1822611209.webp" class="img-shadow img-margin"></center></a><a href="https://thyrsi.com/t6/676/1551783118x1822611209.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://thyrsi.com/t6/676/1551783118x1822611209.webp" class="img-shadow img-margin"></center></a><p>示例是在word里面进行的，经我测试ppt中操作是一样的，但是在excel中插入新公式我也不知道为什么不能点，可以直接从word/ppt复制粘贴。</p><h3 id="判断是否为合式公式"><a href="#判断是否为合式公式" class="headerlink" title="判断是否为合式公式"></a>判断是否为合式公式</h3><p>　　这个问题有好多方法，递归，栈，数什么高深的东西，但显然我这种小小白是绝对做不出来的，当然只能用暴力的方法了，咳咳，那谁不是曾经说过吗，暴力出奇迹。python还不是很熟悉，我先用c++来实现。<br>　　我的方法是遍历字符串中的每一个字符，通过对不同情况的分析，进行分类处理。<br>　　我们来看看这个问题，要判断是否为合式公式，那我们首先应该了解一下何为合式公式。<br>　　<a href="https://zh.wikipedia.org/wiki/%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F#%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E4%B8%AD%E7%9A%84%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">合式公式</a>：将命题变项用联结词和圆括号按照一定的逻辑关系联结起来的符号串称为合式公式。<br>　　由于这几个符号的输入比较麻烦，我们这里做一下简单的替换<br>  <code>&amp; 合取  | 析取  ! 非  - 蕴含  =  等价</code><br>例如<code>p&amp;q   !p    !(p&amp;q)&amp;s|r</code>均为合式公式，而<code>qwp   q&amp;&amp;d</code>等均不是合式公式。<br>代码实现(具体分情况请参考注释)</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char s[100000];int main(){    bool flag;    scanf(&quot;%s&quot;,s);    flag=1;//定义一个布尔类型的变量，初始赋值为1，代表是合式公式，每种条件下的判断中若发现不是合式公式，就改变flag的值为0，代表不是合式公式。    if(s[0]==&#39;)&#39;||s[0]==&#39;&amp;&#39;||s[0]==&#39;-&#39;||s[0]==&#39;=&#39;||s[0]==&#39;|&#39;)//若第一个字符就是联结词或者右括号，显然不是合式公式。    {        puts(&quot;Not well formed!&quot;);        return 0;    }    for(int i=0;i&lt;strlen(s);i++)//这里的这种情况判断的是如果有两个字母（即原子命题）在一起，显然也不是合式公式。    {        if(s[i]&gt;=65&amp;&amp;s[i]&lt;=90||s[i]&gt;=97&amp;&amp;s[i]&lt;=122)        {            if(s[i+1]&gt;=65&amp;&amp;s[i+1]&lt;=90||s[i+1]&gt;=97&amp;&amp;s[i+1]&lt;=122)            {                puts(&quot;Not well formed!&quot;);                return 0;            }        }    }    for(int i=1;i&lt;strlen(s);i++)//这里的这种情况判断的是如果有两个联结词（不包括非）在一起，显然也不是合式公式。    {        if(s[i]==&#39;&amp;&#39;||s[i]==&#39;|&#39;||s[i]==&#39;-&#39;||s[i]==&#39;=&#39;)        {            if(s[i+1]==&#39;&amp;&#39;||s[i+1]==&#39;|&#39;||s[i+1]==&#39;-&#39;||s[i+1]==&#39;=&#39;||s[i-1]==&#39;&amp;&#39;||s[i-1]==&#39;|&#39;||s[i-1]==&#39;-&#39;||s[i-1]==&#39;=&#39;)            {                flag=0;                break;            }        }        else if(s[i]==&#39;!&#39;)//如果非后面加的是联结词，显然也不是合式公式。        {            if(s[i+1]==&#39;&amp;&#39;||s[i+1]==&#39;|&#39;||s[i+1]==&#39;-&#39;||s[i+1]==&#39;=&#39;)            {                flag=0;                break;            }            if(s[i+1]==&#39;!&#39;||s[i-1]==&#39;!&#39;)//如果几个非连在一起可以看成是一个。                break;            else if(s[i+1]&gt;122||s[i+1]&lt;65)            {                flag=0;                break;            }            else if(s[i+1]&gt;90&amp;&amp;s[i+1]&lt;97)//此处判断的是非后面是否加的是原子命题。            {                flag=0;                break;            }        }    }    stack&lt;char&gt; sta;//设定一个栈用来检测左右括号的匹配性。    for(int i=0;i&lt;strlen(s);i++)    {        if(s[i]==&#39;)&#39;&amp;&amp;sta.empty())//如果是右括号且此时栈空（说明此右括号的前面没有与之配的左括号，所以不是合式公式）。        {            flag=0;            break;        }        if(s[i]==&#39;(&#39;)//如果是左括号就入栈。        {            sta.push(s[i]);        }        if(s[i]==&#39;)&#39;&amp;&amp;!sta.empty())//如果是右括号，且栈不空就将栈顶的左括号除去。        {            sta.pop();        }    }    if(!sta.empty())//如果字符串循环完毕且栈中还有元素，说明有左括号不存在与之对应的右括号，即不为合式公式。    flag=0;    if(flag)     puts(&quot;Well formed&quot;);    else     puts(&quot;Not well informed&quot;);    return 0;}</code></pre><h3 id="求合式公式的层次"><a href="#求合式公式的层次" class="headerlink" title="求合式公式的层次"></a>求合式公式的层次</h3><h3 id="给出任意命题公式的成真赋值"><a href="#给出任意命题公式的成真赋值" class="headerlink" title="给出任意命题公式的成真赋值"></a>给出任意命题公式的成真赋值</h3><h3 id="给出任意命题公式的成假赋值"><a href="#给出任意命题公式的成假赋值" class="headerlink" title="给出任意命题公式的成假赋值"></a>给出任意命题公式的成假赋值</h3><h3 id="判断任一命题公式的公式类型"><a href="#判断任一命题公式的公式类型" class="headerlink" title="判断任一命题公式的公式类型"></a>判断任一命题公式的公式类型</h3>]]></content>
      
      
      <categories>
          
          <category> Discrete mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> python </tag>
            
            <tag> Discrete mathematics </tag>
            
            <tag> WPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础dfs之Lake Counting</title>
      <link href="/2019/03/26/poj-2386/"/>
      <url>/2019/03/26/poj-2386/</url>
      
        <content type="html"><![CDATA[<h2 id="POJ-2386-Lake-Counting"><a href="#POJ-2386-Lake-Counting" class="headerlink" title="POJ 2386 Lake Counting"></a><center>POJ 2386 Lake Counting</center></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><center>Lake Counting</center><br>Time Limit: 1000MS        Memory Limit: 65536K</p><p>Due to recent rains, water has pooled in various places in Farmer John&#39;s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (&#39;W&#39;) or dry land (&#39;.&#39;). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.</p><p>Given a diagram of Farmer John&#39;s field, determine how many ponds he has.<br>Input</p><ul><li><p>Line 1: Two space-separated integers: N and M</p></li><li><p>Lines 2..N+1: M characters per line representing one row of Farmer John&#39;s field. Each character is either &#39;W&#39; or &#39;.&#39;. The characters do not have spaces between them.<br>Output</p></li><li><p>Line 1: The number of ponds in Farmer John&#39;s field.<br>Sample Input</p><pre><code>10 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W.Sample Output3</code></pre><p>Hint</p></li></ul><p>OUTPUT DETAILS:</p><p>There are three ponds: one in the upper left, one in the lower left,and one along the right side.</p><h3 id="大意分析，题目中让我们求“水洼”的个数，W表示有水，-表示无水，有水的周围八个方向内有水都算成是一个水洼。样例中的三个水洼可以加强对题意的理解。因为需要对每一个状态进行查询，所以这里我们需要用到dfs。"><a href="#大意分析，题目中让我们求“水洼”的个数，W表示有水，-表示无水，有水的周围八个方向内有水都算成是一个水洼。样例中的三个水洼可以加强对题意的理解。因为需要对每一个状态进行查询，所以这里我们需要用到dfs。" class="headerlink" title="大意分析，题目中让我们求“水洼”的个数，W表示有水，.表示无水，有水的周围八个方向内有水都算成是一个水洼。样例中的三个水洼可以加强对题意的理解。因为需要对每一个状态进行查询，所以这里我们需要用到dfs。"></a>大意分析，题目中让我们求“水洼”的个数，<code>W</code>表示有水，<code>.</code>表示无水，有水的周围八个方向内有水都算成是一个水洼。样例中的三个水洼可以加强对题意的理解。因为需要对每一个状态进行查询，所以这里我们需要用到dfs。</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;char p[105][105];int d[8][2]={0,1, 0,-1, 1,0, -1,0, 1,1, 1,-1, -1,1, -1,-1};//方向变量的定义，周围八个方向。int m,n,sum;void dfs(int x,int y){    if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m)//判断每次进行递归的时候x和y是否还在合理的范围内，否则直接退出当前循环。    {        if(p[x][y]==&#39;W&#39;)        {            p[x][y]=&#39;.&#39;;//把查询到的W(有水)变成.(无水)。            for(int i=0;i&lt;8;i++)                dfs(x+d[i][0],y+d[i][1]);//对每个有水地方的八个方向进行dfs，用来向下一步递归        }    }}int main(){    sum=0;    cin&gt;&gt;n&gt;&gt;m;    getchar();    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;m;j++)        {            cin&gt;&gt;p[i][j];//存图        }        getchar();    }    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;m;j++)        {            if(p[i][j]==&#39;W&#39;)//从0，0开始，查询到W就开始dfs。            {                dfs(i,j);                sum++;//每次dfs完回来之后，及说明与i，j相邻的水地没有了，所以水洼的数量加一            }        }    }    cout&lt;&lt;sum&lt;&lt;endl;    return 0;}</code></pre><p>参考白书之后，发现如果是八个方向的话，可以不用方向向量而是使用两层循环</p><pre><code>for(int i=-1;i&lt;=1;i++)    for(int j=1;j&lt;=1;j++)    {        int nx=x+i;        int ny=y+j;        ……        dfs(nx,ny);    }</code></pre><p>这个就看个人喜好了。</p><p>我的个人喜好？<br><a href="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1552090479&di=32a91fd313233bf5e29b126f18fdad4c&src=https://5b0988e595225.cdn.sohucs.comhttps://cdn.jsdelivr.net/gh/drew233/cdn/20171027/670b199bf6944e98af0685af253cc01b.jpeg" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1552090479&di=32a91fd313233bf5e29b126f18fdad4c&src=https://5b0988e595225.cdn.sohucs.comhttps://cdn.jsdelivr.net/gh/drew233/cdn/20171027/670b199bf6944e98af0685af253cc01b.jpeg" class="img-shadow img-margin"></center></a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除字符串中的子串</title>
      <link href="/2019/03/26/pta-erase/"/>
      <url>/2019/03/26/pta-erase/</url>
      
        <content type="html"><![CDATA[<h3 id="PTA7-29-删除字符串中的子串"><a href="#PTA7-29-删除字符串中的子串" class="headerlink" title="PTA7-29 删除字符串中的子串"></a><center>PTA7-29 删除字符串中的子串</center></h3><p>题目链接：<a href="https://pintia.cn/problem-sets/14/problems/809" target="_blank" rel="noopener">删除字符串中的子串</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。</p><p>输入格式：<br>输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。</p><p>输出格式：<br>在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。</p><p>输入样例：<br>Tomcat is a male ccatat<br>cat<br>输出样例：<br>Tom is a male</p><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>这道题还是比较容易懂的，就是输入两个字符串S1，S2，将S1中出现的S2全部删掉即可，需要注意的是有可能删掉一个S2之后会出现一个新的S2（如样例），此时就需要再删除一次。因为输入是有空格的，所以不能直接cin。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    string a,b;    getline(cin,a);    getline(cin,b);    while(a.find(b,0)!=-1)    {        int p=a.find(b,0);        a.erase(p,b.size());    }    cout&lt;&lt;a&lt;&lt;endl;    return 0;}</code></pre><h3 id="知识（补）"><a href="#知识（补）" class="headerlink" title="知识（补）"></a>知识（补）</h3><p>不搜这道题都不知道string类型中也有这么多方便好用的函数，特此把这些常用的函数在我的博客总结一下，方便自己记忆。</p><ul><li>原帖链接：<a href="https://www.zybuluo.com/RabbitHu/note/658924" target="_blank" rel="noopener">十个你一定会用到的 C++ string 函数</a></li></ul><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>将字符串2赋值给字符串1：</p><ol><li>字符串1 = 字符串2;</li><li>字符串1.assign(字符串2);<pre><code>string s1=&quot;Drew&quot;,s2;s2=s1;cout&lt;&lt;s2&lt;&lt;&quot; &quot;;s2=&quot;is handsome&quot;;s1.assign(s2);cout&lt;&lt;s1;//运行结果：Drew is handsome</code></pre>将字符串2从第m个字符开始的n个字符赋值给字符串1：<br>字符串1.assign(字符串2, m, n);<pre><code>string s1=&quot;Uncle &quot;,s2=&quot;drew&quot;;s1.assign(s2,1,3);cout&lt;&lt;s1&lt;&lt;endl;cout&lt;&lt;s2;//运行结果：rew//         drew</code></pre></li></ol><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><p>返回字符串长度：</p><ol><li>字符串1.length();</li><li>字符串1.size();<pre><code>string s1=&quot;Uncle&quot;,s2=&quot;drew&quot;;cout&lt;&lt;s1.length()&lt;&lt;&quot; &quot;&lt;&lt;s2.size();//运行结果：5 4</code></pre></li></ol><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><code>&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;</code>均可以用于字符串比较。<br>这个不需要例子了。直接比较就可以</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>在字符串1中从第m个字符开始查找字符串2，返回第一次出现的首字母位置，失败时返回-1：<br>字符串1.find(字符串2, m);</p><pre><code>string s1=&quot;Uncle_drew!Uncle_drew!Uncle_drew!&quot;,s2=&quot;drew&quot;;int pos=-1;while(1){    pos = s1.find(s2,pos+1);    if(pos==-1) break;    cout&lt;&lt;pos&lt;&lt;&quot; &quot;;}//运行结果：6 17 28</code></pre><p>在字符串1中从第m个字符开始从后向前查找字符串2，返回第一次出现的首字母位置，失败时返回-1：<br>字符串1.rfind(字符串2, m);</p><pre><code>string s1=&quot;Uncle_drew!Uncle_drew!Uncle_drew!&quot;,s2=&quot;drew&quot;;int pos=s1.size();while(pos){    pos = s1.rfind(s2,pos-1);    if(pos&lt;0) break;    cout&lt;&lt;pos&lt;&lt;&quot; &quot;;}//运行结果：28 17 6</code></pre><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>将字符串2接到字符串1尾部：</p><ol><li>字符串1.append(字符串2); //字符不可</li><li>字符串1 += 字符串2; //字符亦可<pre><code>string s1=&quot;Uncle_&quot;,s2=&quot;drew is handsome&quot;;string s3=s1,s4=s2;s1.append(s2);cout&lt;&lt;s1&lt;&lt;&quot;\t&quot;;s3+=s4;cout&lt;&lt;s3;//运行结果：Uncle_drew is handsome  Uncle_drew is handsome</code></pre></li></ol><p>将字符串2从第m个字符开始的n个字符接到字符串1尾部：<br>字符串1.append(字符串2, m, n);</p><pre><code>string s1=&quot;Uncle&quot;,s2=&quot;drew is handsome&quot;;s1.append(s2,4,15);cout&lt;&lt;s1;//运行结果：Uncle is handsome</code></pre><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><p>字符串1.swap(字符串2);</p><pre><code>string s2=&quot;Uncle &quot;,s1=&quot;drew is handsome&quot;;s1.swap(s2);cout&lt;&lt;s1&lt;&lt;&quot;\t&quot;&lt;&lt;s2;//运行结果：Uncle   drew is handsome</code></pre><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>返回字符串1从第m个字符开始的n个字符所组成的子串：<br>字符串1.substr(m, n);</p><pre><code>string s1=&quot;Uncle &quot;,s2=&quot;drew is handsome&quot;;string s3,s4;s3=s1+s2;s4=s3.substr(6,20);cout&lt;&lt;s3&lt;&lt;&quot;的一个子串：    &quot;&lt;&lt;s4;//运行结果：Uncle drew is handsome的一个子串：    drew is handsome</code></pre><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>在字符串1中删除从m开始的n个字符，然后在m处插入串s2<br>字符串1.replace(m, n, s2);</p><pre><code>string s1=&quot;Uncle &quot;,s2=&quot;drew is not handsome&quot;;string s3=&quot;so&quot;,s4=&quot;not&quot;;int pos=s2.find(s4);s2.replace(pos,s4.size(),s3);cout&lt;&lt;s2;//运行结果：drew is so handsome</code></pre><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>在字符串1的第m个字符处插入字符串2：<br>字符串1.insert(m, 字符串2);</p><pre><code>string s1=&quot;Uncle &quot;,s2=&quot;drew is handsome&quot;;string s3=&quot;so &quot;;s2.insert(s2.find(&quot;handsome&quot;,0),s3);cout&lt;&lt;s2;//运行结果：drew is so handsome</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>从字符串1的第m个字符开始，删除n个字符：<br>字符串1.erase(m, n);</p><pre><code>string s1=&quot;Uncle &quot;,s2=&quot;drew is not handsome&quot;;s2.erase(s2.find(&quot;not&quot;),4);cout&lt;&lt;s2;//运行结果：drew is handsome</code></pre><p>c语言中的string.h中也有许多对字符数组操作的函数，先记着吧。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记</title>
      <link href="/2019/03/26/pythonStudy/"/>
      <url>/2019/03/26/pythonStudy/</url>
      
        <content type="html"><![CDATA[<p>推荐大家去<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a> 廖雪峰的官方网站学习，我是在本网站的基础上进行的学习以及自己的总结。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>python中的运算符有些跟c是不同的。<br>python中有两种除法</p><pre><code class="lang-python">/      这个除法计算的结果是浮点数，即使两个整数恰好整除，结果也是浮点数；&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 9 / 33.0//     这个是整除，不会四舍五入的&gt;&gt;&gt; 10 // 33&gt;&gt;&gt; 10 / 120.8333333333333334&gt;&gt;&gt; 10 // 120</code></pre><h2 id="各种函数"><a href="#各种函数" class="headerlink" title="各种函数"></a>各种函数</h2><p><code>ord()</code>获取字符的整数表示<br><code>chr()</code>把编码转换为对应的字符</p><pre><code class="lang-python">&gt;&gt;&gt; ord(&quot;崔&quot;)23828&gt;&gt;&gt; ord(&quot;美&quot;)32654&gt;&gt;&gt; ord(&quot;美&quot;)32654&gt;&gt;&gt; chr(23828)&#39;崔&#39;&gt;&gt;&gt; chr(32654)&#39;美&#39;&gt;&gt;&gt; chr(32654)&#39;美&#39;</code></pre><h2 id="python的格式化"><a href="#python的格式化" class="headerlink" title="python的格式化"></a>python的格式化</h2><p>python中的格式化方式跟c语言是一致的，用<code>%</code>实现。</p><pre><code>%d    整数%f    浮点数%s    字符串%x    十六进制整数&gt;&gt;&gt; &#39;Hello, %s&#39; % &#39;world&#39;&#39;Hello, world&#39;&gt;&gt;&gt; &#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000)&#39;Hi, Michael, you have $1000000.&#39;# 具体看来跟c还是有些出入的，注意一下</code></pre><p>还有一种格式化输出的方式即format函数，这个我们上学期学过，我就不再总结了。</p><h2 id="列表——list"><a href="#列表——list" class="headerlink" title="列表——list"></a>列表——list</h2><p>list是一种有序的集合，可以随时添加和删除其中的元素。</p><pre><code class="lang-python">&gt;&gt;&gt; girllist = [&quot;崔美美&quot;,&quot;侍皮皮&quot;,&quot;顾六六&quot;]&gt;&gt;&gt; girllist[&#39;崔美美&#39;, &#39;侍皮皮&#39;, &#39;顾六六&#39;]&gt;&gt;&gt; len(girllist)3&gt;&gt;&gt; girllist[0]&#39;崔美美&#39;&gt;&gt;&gt; girllist[-1]&#39;顾六六&#39;&gt;&gt;&gt; girllist[1]&#39;侍皮皮&#39;</code></pre><p>可以用append函数向列表尾部增加新元素</p><pre><code class="lang-python">&gt;&gt;&gt; girllist.append(&quot;jimila&quot;)&gt;&gt;&gt; girllist[3]&#39;jimila&#39;</code></pre><p>还可以用insert函数把元素插入到指定的位置</p><pre><code class="lang-python">&gt;&gt;&gt; girllist[&#39;崔美美&#39;, &#39;侍皮皮&#39;, &#39;顾六六&#39;, &#39;jimila&#39;]&gt;&gt;&gt; girllist.insert(2,&quot;drew&quot;)&gt;&gt;&gt; girllist[&#39;崔美美&#39;, &#39;侍皮皮&#39;, &#39;drew&#39;, &#39;顾六六&#39;, &#39;jimila&#39;]</code></pre><p>pop函数可以直接删除列表末尾的元素</p><pre><code class="lang-python">&gt;&gt;&gt; girllist[&#39;崔美美&#39;, &#39;侍皮皮&#39;, &#39;drew&#39;, &#39;顾六六&#39;, &#39;jimila&#39;]&gt;&gt;&gt; girllist.pop()&#39;jimila&#39;&gt;&gt;&gt; girllist[&#39;崔美美&#39;, &#39;侍皮皮&#39;, &#39;drew&#39;, &#39;顾六六&#39;]</code></pre><p>也可以用pop(i)删除指定位置的元素</p><pre><code class="lang-python">&gt;&gt;&gt; girllist[&#39;崔美美&#39;, &#39;侍皮皮&#39;, &#39;drew&#39;, &#39;顾六六&#39;]&gt;&gt;&gt; girllist.pop(2)&#39;drew&#39;&gt;&gt;&gt; girllist[&#39;崔美美&#39;, &#39;侍皮皮&#39;, &#39;顾六六&#39;]</code></pre><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置</p><pre><code class="lang-python">&gt;&gt;&gt; girllist[&#39;崔美美&#39;, &#39;侍皮皮&#39;, &#39;顾六六&#39;]&gt;&gt;&gt; girllist[0] = &quot;悦美美&quot;&gt;&gt;&gt; girllist[&#39;悦美美&#39;, &#39;侍皮皮&#39;, &#39;顾六六&#39;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记</title>
      <link href="/2019/03/26/study-note/"/>
      <url>/2019/03/26/study-note/</url>
      
        <content type="html"><![CDATA[<h2 id="第一次训练"><a href="#第一次训练" class="headerlink" title="第一次训练"></a><center>第一次训练</center></h2><p>第一次训练主要讲了一下基础的东西。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">时间复杂度</a><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3></li><li>栈和队列<ul><li><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">栈</a>    First in last out(FILO)<ul><li>1.栈的头文件 <code>#include&lt;stack&gt;</code></li><li>2.栈的定义 stack&lt;变量类型(int,char...)&gt; s(栈的名字可以自定义)</li><li>3.常用函数<ul><li><code>s.pop()</code>  删掉栈顶的元素     </li><li><code>s.top()</code> 返回值为栈顶元素的值</li><li><code>s.push()</code> 向栈中输入新的元素</li></ul></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">队列</a>  First in first out(FIFO)<ul><li>1.队列的头文件<code>#include&lt;queue&gt;</code></li><li>2.队列的定义 queue&lt;变量类型(int,char...)&gt; q(队列的名字可以自定义)</li><li>3常用函数<ul><li><code>q.pop()</code>  删掉队列最前面的元素     </li><li><code>q.front()</code> 返回值为栈顶元素的值</li><li><code>q.push()</code> 在队尾压入新元素</li><li><code>q.back()</code> 返回值为队列最后一个元素<h3 id="栈和队列的通用函数"><a href="#栈和队列的通用函数" class="headerlink" title="栈和队列的通用函数"></a>栈和队列的通用函数</h3></li></ul></li><li>栈和队列的通用函数<ul><li><code>q/s.empty()</code> 如果栈(队列)为空返回true，否则返回false</li><li><code>q/s.size()</code>返回栈(队列)中元素的个数</li></ul></li></ul></li></ul></li></ul><h3 id="sort排序-默认为升序"><a href="#sort排序-默认为升序" class="headerlink" title="sort排序(默认为升序)"></a>sort排序(默认为升序)</h3><pre><code>    #include&lt;bits/stdc++.h&gt;  //sort的头文件为algorithm,此处的头文件为万能头文件    using namespace std;    int main()    {        int n,a[100];        cin&gt;&gt;n;        for(int i=0;i&lt;n;i++)        cin&gt;&gt;a[i];        sort(a,a+n);        for(int i=0;i&lt;n;i++)        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;        puts(&quot;&quot;);        return 0;    }</code></pre><p>若想更改成降序排列，需要添加一个自定义函数</p><pre><code>    #include&lt;bits/stdc++.h&gt;    using namespace std;    bool cmp(int a,int b) //变成降序    {        return a&gt;b;    }    int main()    {        int n,a[100];        cin&gt;&gt;n;        for(int i=0;i&lt;n;i++)        cin&gt;&gt;a[i];        sort(a,a+n,cmp);        for(int i=0;i&lt;n;i++)        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;        puts(&quot;&quot;);        return 0;    }</code></pre><p align="right">2018-11-30</p><h2 id="第二次训练"><a href="#第二次训练" class="headerlink" title="第二次训练"></a><center>第二次训练</center></h2><p>第二次训练主要讲了<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二分查找，二分答案</a>等。</p><h3 id="二分法的使用条件"><a href="#二分法的使用条件" class="headerlink" title="二分法的使用条件"></a>二分法的使用条件</h3><ul><li>答案区间上下限确定，即最终答案在哪个范围是容易知道的。</li><li>检验某值是否可行是个简单活，即给你个值，你能很容易的判断是不是符合题目要求。</li><li>可行解满足区间单调性，即若x是可行解，则在答案区间内x+1（也可能是x-1）也可行。<h3 id="几个关于二分查找的函数"><a href="#几个关于二分查找的函数" class="headerlink" title="几个关于二分查找的函数"></a>几个关于二分查找的函数</h3>因为二分查找的显著优越性，c++的<algorithm>库中封装了几个于二分查找有关的函数。<pre><code>1.lower_bound(起始地址，结束地址，要查找的数值) 返回的是大于或等于val的第一个元素位置。2.upper_bound(起始地址，结束地址，要查找的数值) 返回的是大于val的第一个元素位置。3.binary_search(起始地址，结束地址，要查找的数值) 返回的是是否存在这么一个数，是一个bool值。</code></pre><h2 id="第三次训练"><a href="#第三次训练" class="headerlink" title="第三次训练"></a><center>第三次训练</center></h2>第三次训练我们讲了一些特殊容器<a href="https://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93" target="_blank" rel="noopener">(STL)</a>的用法.(stl内容太复杂了,我就先不总结了，以后补上）</algorithm></li></ul><h2 id="快速幂-自学"><a href="#快速幂-自学" class="headerlink" title="快速幂(自学)"></a><center>快速幂(自学)</center></h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    int poww(int a,int b){    int ans=1,base=a;    while(b!=0){        if(b&amp;1!=0)//判断每次循环a的奇偶        　　ans*=base;        base*=base;        b&gt;&gt;=1;//去除b的二进制数中的最后一位　 }    return ans;}</code></pre><p>快速幂的时间复杂度：  O(log₂N)</p><a href="https://www.segahome.comhttps://cdn.jsdelivr.net/gh/drew233/cdn/collect_article/26397/14951630786311.webp" data-fancybox="images" data-caption="sakura" target="_blank" rel="noopener"><center><img src="https://www.segahome.comhttps://cdn.jsdelivr.net/gh/drew233/cdn/collect_article/26397/14951630786311.webp" class="img-shadow img-margin"></center></a>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> c/c++ </tag>
            
            <tag> Tutorial </tag>
            
            <tag> Useful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符的妙用</title>
      <link href="/2019/03/01/funoperator/"/>
      <url>/2019/03/01/funoperator/</url>
      
        <content type="html"><![CDATA[<h2 id="位逻辑运算符——异或"><a href="#位逻辑运算符——异或" class="headerlink" title="位逻辑运算符——异或(^)"></a>位逻辑运算符——异或(^)</h2><p>异或指的是参与运算的两个值，如果两个相应位(二进制形式下，按位运算)相同，则结果为0，否则为1。<br>我们先测试一下^的计算功能</p><pre><code>#include&lt;stdio.h&gt;int main(){    int a,b;    while(~scanf(&quot;%d %d&quot;,&amp;a,&amp;b))    {        printf(&quot;%d\n&quot;,a^b);    }    return 0;}input:0 00 11 01 1output:0110</code></pre><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><center>HPUOJ 18级新生周赛第四场 A. 阴与阳</center><br>题目描述<br>阴与阳<br>单测试点时限: 1.0 秒</p><p>内存限制: 256 MB</p><p>“龟，象也；筮，数也。物生而后有象，象而后有滋，滋而后有数。” ——《左传·僖公十五年》</p><p>数，从诞生开始，就被赋予了特殊的意义。</p><p>从古希腊起，奇数就比偶数更招人喜爱。公元前6世纪的希腊哲学家毕达哥拉斯说，奇数阳刚（代表男性），偶数阴柔（代表女性）。他说，奇数拒绝被一分为二，说明它强大；偶数能被平分，说明它很脆弱。</p><p>在《周易》中，奇数代表阳爻，偶数代表阴爻。阳反而阴顺，故奇数刚而偶数柔。</p><p>而在当今素粒子领域的现象，似乎也认证了他们的见解：奇数的粒子的运动比偶数的粒子激烈。</p><p>现在定义阴数和阳数的概念：在一个无序序列中，出现次数为奇数次的数为阴数，出现次数为偶数次的数为阳数</p><p>输入<br>第一行输入一个奇数N (1≤N≤107+1)</p><p>第二行输入N个整数x (0≤x≤109)</p><p>输入数据有多组，输入到文件结束</p><p>保证每组输入数据一定有且仅有一个阴数</p><p>输出<br>输出每组数据中的唯一的阴数<br>样例<br>input</p><pre><code>51 5 5 1 331 1 2</code></pre><p>output</p><pre><code>32</code></pre><p>提示<br>本题输入输出量比较大，请尽量使用快速的OI方法。<br>题意分析<br>题目描述很多，但是我们需要的就是读取里面有用的信息供自己使用。题目中说出现次数为奇数次的数为阴数，出现次数为偶数次的数为阳数，并且保证每组数据有且只有一个阴数，也就是说把两个相同的数两两消去，最后剩下的数就是阴数，不好理解的话可以想象一下扑克牌中的抽老鳖游戏，最后剩下的那个数没有与它配对的就是老鳖，也就是这里的阴数。并且看到题目中的数据范围，直接暴力显然是不行的，这里就要用到我们的^了。<br>代码实现<br>首先我们来看一下多个数依次异或之后的结果</p><pre><code>#include&lt;stdio.h&gt;int main(){    int t,a,b;    scanf(&quot;%d %d&quot;,&amp;t,&amp;a);    t-=1;    while(t--)    {        scanf(&quot;%d&quot;,&amp;b);        a=a^b;    }    printf(&quot;%d\n&quot;,a);    return 0;}input:51 1 2 2 351 1 2 2 231 3 1output:323</code></pre><p>从这里你应该就可以看出异或的去重性，其实仔细想一下就很容易想到每两个相同的数异或之后为0，而0与任意一个数异或之后等于那个数，所以最后出现的数就是只出现过1+2n(奇数次)的数了。到了这里应该也可以发现，上面的代码加上多组输入就已经是本题的答案了，做简单的更改就可以了。</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ios::sync_with_stdio(false);//使流的输入输出速度与C的输入输出持平    ll n,x,ans;    while(cin&gt;&gt;n)    {        ans=0;        while(n--)        {            cin&gt;&gt;x;            ans^=x;           }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><p>之前的ac代码蜜汁TLE了，但是用上ios::sync_with_stdio(false)与cin和cout可以过，scanf和printf却过不了。<br>ios::sync_with_stdio(false)：iostream默认是与stdio关联在一起的，以使两者同步，因此消耗了iostream不少性能，设置为false后，不再同步了，iostream的性能提高了很多倍。而cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几。本段话摘选自(<a href="https://blog.csdn.net/deepseazbw/article/details/76672177" target="_blank" rel="noopener">https://blog.csdn.net/deepseazbw/article/details/76672177</a>)</p><h2 id="位逻辑运算符————与-amp-移位运算符————右移运算符-gt-gt-实现快速幂"><a href="#位逻辑运算符————与-amp-移位运算符————右移运算符-gt-gt-实现快速幂" class="headerlink" title="位逻辑运算符————与(&amp;) 移位运算符————右移运算符(&gt;&gt;)实现快速幂"></a>位逻辑运算符————与(&amp;) 移位运算符————右移运算符(&gt;&gt;)实现快速幂</h2><p><code>&amp;</code>运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数<br><code>&gt;&gt;</code>右移运算符，具体的用法书上和网站上总结的都有很多。快速幂也用到了这个运算符。<br>具体实现请参考在下的<a href="https://drew233.github.io/2019/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">学习笔记</a>中的快速幂实现。</p><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p><center>HDUOJ 1905 Pseudoprime numbers</center><br>题目描述<br>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p><p>Problem Description<br>Fermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, a^p == a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)<br>Given 2 &lt; p ≤ 1,000,000,000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime.</p><p>Input<br>Input contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a.</p><p>Output<br>For each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;.</p><p>Sample Input<br>3 2<br>10 3<br>341 2<br>341 3<br>1105 2<br>1105 3<br>0 0</p><p>Sample Output<br>no<br>no<br>yes<br>no<br>yes<br>yes<br>题意分析<br>英文题面虽然不太好读懂，但是这道题的题意还是很清晰的。就是给出两个数p,a,如果p是素数输出no，否则判断a的p次方对p取模之后是不是等于a，如果不是a输出no。表面看是挺无脑的，但是看到数据范围会发现直接求n次方是不行的，绝对会超时，这时就要用到快速幂了。<br>代码实现</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll isok(ll x)//判断是否为素数{    if(x&lt;2)        return 0;    for(ll i=2;i&lt;=sqrt(x);i++)    {        if(x%i==0)        {            return 0;        }    }    return 1;}ll poww(ll x,ll y,ll z)//快速幂{    ll ans=1,base=x;    while(y!=0)    {        if(y&amp;1!=0)            ans=ans*base%z;        base=(base%z)*(base%z)%z;        y&gt;&gt;=1;    }    return ans;}int main(){    ll a,p;    while(cin&gt;&gt;p&gt;&gt;a)    {        if(p==0&amp;&amp;a==0)            break;        if(isok(p))            puts(&quot;no&quot;);        else        {            ll s=poww(a,p,p);            if(s%p==a)                puts(&quot;yes&quot;);            else                puts(&quot;no&quot;);        }    }    return 0;}</code></pre><p>除去快速幂，基本上可以算是一道水题了，看代码应该都是可以看懂的。</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> Useful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comment 测试专用</title>
      <link href="/2018/12/12/Hexo-Theme-Sakura/"/>
      <url>/2018/12/12/Hexo-Theme-Sakura/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
